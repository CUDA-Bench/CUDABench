{"id": 0, "task_name": "Post_Process_GL", "task_description": "Compute the Post_Process_GL kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint8", "shape": "(128, 128, 4)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants and Macros\n// ----------------------------------------------------------------------------\n// SMEM macro to index the shared memory array \"sdata\"\n// tilew = blockDim.x + 2*r. However, since the shared memory is 1D array of uchar4\n// and we treat it as 2D: sdata[ y * tilew + x ]\n// In the kernel, 'tilew' is passed as argument.\n#define SMEM(X, Y) sdata[(Y)*tilew + (X)]\n\n// ----------------------------------------------------------------------------\n// Texture Object\n// ----------------------------------------------------------------------------\n// We need to use a texture object for reading input as per kernel signature.\n// However, since we are writing a standalone app without OpenGL interop, \n// we will create a CUDA texture object from a CUDA array.\n\n// ----------------------------------------------------------------------------\n// Helper Device Functions (from typical NVIDIA samples context)\n// ----------------------------------------------------------------------------\n__device__ inline uchar4 getPixel(int x, int y, cudaTextureObject_t tex) {\n    // tex2D<uchar4>(tex, x, y) returns the pixel\n    // Since we use cudaReadModeElementType, we get uchar4 directly\n    return tex2D<uchar4>(tex, (float)x, (float)y);\n}\n\n__device__ inline unsigned int rgbToInt(float r, float g, float b) {\n    // Pack into ABGR or ARGB integer. \n    // The kernel comment says \"// ABGR\".\n    // Typically: (a << 24) | (b << 16) | (g << 8) | r\n    // Assuming alpha is 255\n    unsigned int ir = (unsigned int)min(255.0f, max(0.0f, r));\n    unsigned int ig = (unsigned int)min(255.0f, max(0.0f, g));\n    unsigned int ib = (unsigned int)min(255.0f, max(0.0f, b));\n    unsigned int ia = 255;\n    return (ia << 24) | (ib << 16) | (ig << 8) | ir;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void cudaProcess(unsigned int       *g_odata,\n                            int                 imgw,\n                            int                 imgh,\n                            int                 tilew,\n                            int                 r,\n                            float               threshold,\n                            float               highlight,\n                            cudaTextureObject_t inTex)\n{\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ uchar4 sdata[];\n\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n    int bw = blockDim.x;\n    int bh = blockDim.y;\n    int x  = blockIdx.x * bw + tx;\n    int y  = blockIdx.y * bh + ty;\n\n    // Check bounds for global read/write\n    // Although the tiling logic loads halo, we must be careful not to read \n    // outside image bounds if texture is not set to Clamp/Border. \n    // Texture hardware handles OOB if configured correctly.\n\n    // copy tile to shared memory\n    // center region\n    SMEM(r + tx, r + ty) = getPixel(x, y, inTex);\n\n    // borders\n    if (threadIdx.x < r) {\n        // left\n        SMEM(tx, r + ty) = getPixel(x - r, y, inTex);\n        // right\n        SMEM(r + bw + tx, r + ty) = getPixel(x + bw, y, inTex);\n    }\n\n    if (threadIdx.y < r) {\n        // top\n        SMEM(r + tx, ty) = getPixel(x, y - r, inTex);\n        // bottom\n        SMEM(r + tx, r + bh + ty) = getPixel(x, y + bh, inTex);\n    }\n\n    // load corners\n    if ((threadIdx.x < r) && (threadIdx.y < r)) {\n        // tl\n        SMEM(tx, ty) = getPixel(x - r, y - r, inTex);\n        // bl\n        SMEM(tx, r + bh + ty) = getPixel(x - r, y + bh, inTex);\n        // tr\n        SMEM(r + bw + tx, ty) = getPixel(x + bh, y - r, inTex);\n        // br\n        SMEM(r + bw + tx, r + bh + ty) = getPixel(x + bw, y + bh, inTex);\n    }\n\n    // wait for loads to complete\n    cg::sync(cta);\n\n    // perform convolution\n    float rsum    = 0.0f;\n    float gsum    = 0.0f;\n    float bsum    = 0.0f;\n    float samples = 0.0f;\n\n    for (int dy = -r; dy <= r; dy++) {\n        for (int dx = -r; dx <= r; dx++) {\n            uchar4 pixel = SMEM(r + tx + dx, r + ty + dy);\n\n            // only sum pixels within disc-shaped kernel\n            float l = (float)(dx * dx + dy * dy);\n\n            if (l <= (float)(r * r)) {\n                float fr = float(pixel.x);\n                float fg = float(pixel.y);\n                float fb = float(pixel.z);\n\n                // brighten highlights\n                float lum = (fr + fg + fb) / (255.0f * 3.0f);\n\n                if (lum > threshold) {\n                    fr *= highlight;\n                    fg *= highlight;\n                    fb *= highlight;\n                }\n\n                rsum += fr;\n                gsum += fg;\n                bsum += fb;\n                samples += 1.0f;\n            }\n        }\n    }\n\n    if (samples > 0.0f) {\n        rsum /= samples;\n        gsum /= samples;\n        bsum /= samples;\n    }\n\n    // ABGR\n    if (x < imgw && y < imgh) {\n        g_odata[y * imgw + x] = rgbToInt(rsum, gsum, bsum);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 128;\n    const int height = 128;\n    const int radius = 4;\n    const float threshold = 0.8f;\n    const float highlight = 2.0f;\n\n    size_t img_size_bytes = width * height * sizeof(uchar4);\n    size_t out_size_bytes = width * height * sizeof(unsigned int);\n\n    // Host alloc\n    uchar4* h_in = new uchar4[width * height];\n    unsigned int* h_out = new unsigned int[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size_bytes);\n\n    // CUDA Array for Texture\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc<uchar4>();\n    cudaArray* cuArray;\n    cudaMallocArray(&cuArray, &channelDesc, width, height);\n    cudaMemcpy2DToArray(cuArray, 0, 0, h_in, width * sizeof(uchar4), width * sizeof(uchar4), height, cudaMemcpyHostToDevice);\n\n\n    // Create Texture Object\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp; // Clamp to edge\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint; // Pixel exact access\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0; // Use integer coords [0, width)\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n    // Output Buffer\n    unsigned int* d_out;\n    cudaMalloc(&d_out, out_size_bytes);\n\n    // Kernel Launch Config\n    dim3 dimBlock(16, 16);\n    dim3 dimGrid((width + dimBlock.x - 1) / dimBlock.x, \n                 (height + dimBlock.y - 1) / dimBlock.y);\n\n    // Shared memory size calculation:\n    // Tile width includes the halo (radius) on both sides.\n    // tile_w = blockDim.x + 2 * r\n    // tile_h = blockDim.y + 2 * r\n    int tile_w = dimBlock.x + 2 * radius;\n    int tile_h = dimBlock.y + 2 * radius;\n    size_t shm_size = tile_w * tile_h * sizeof(uchar4);\n\n    cudaProcess<<<dimGrid, dimBlock, shm_size>>>(\n        d_out,\n        width,\n        height,\n        tile_w, // Passed as 'tilew' used in SMEM macro\n        radius,\n        threshold,\n        highlight,\n        texObj\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read back\n    cudaMemcpy(h_out, d_out, out_size_bytes, cudaMemcpyDeviceToHost);\n\n    // Write output\n    write_binary(\"data/output_img.bin\", h_out, out_size_bytes);\n\n    // Cleanup\n    cudaDestroyTextureObject(texObj);\n    cudaFreeArray(cuArray);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nfrom PIL import Image\n\n# Constants\nWIDTH = 128\nHEIGHT = 128\nRADIUS = 4\nTHRESHOLD = 0.8\nHIGHLIGHT = 2.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef process_cpu(img, radius, threshold, highlight):\n    h, w, c = img.shape\n    # Pad image to handle borders (Clamp/Replica padding)\n    padded = np.pad(img, ((radius, radius), (radius, radius), (0, 0)), mode='edge')\n    output = np.zeros((h, w), dtype=np.uint32)\n    \n    # Pre-calculate kernel mask (disc)\n    ky, kx = np.ogrid[-radius:radius+1, -radius:radius+1]\n    mask = kx**2 + ky**2 <= radius**2\n    \n    # Iterate over every pixel\n    # Note: Python loops are slow, but for 512x512 it's acceptable for verification generation\n    # Optimized using sliding windows would be better but complex to read.\n    # We will use simple loops for clarity matching the kernel.\n    \n    # Convert image to float for calculation\n    img_f = padded.astype(np.float32)\n    \n    # Pre-calculate highlight mask\n    # Luminance: (r+g+b)/(255*3)\n    lum = np.sum(img_f, axis=2) / (255.0 * 3.0)\n    is_highlight = lum > threshold\n    \n    # Apply highlight boost to the padded image copy\n    img_boosted = img_f.copy()\n    img_boosted[is_highlight] *= highlight\n    \n    for y in range(h):\n        for x in range(w):\n            # Extract window\n            # Window coords in padded image: y to y+2r+1, x to x+2r+1\n            window = img_boosted[y:y+2*radius+1, x:x+2*radius+1]\n            \n            # Apply disc mask\n            # Sum pixels where mask is true\n            pixels = window[mask]\n            \n            samples = pixels.shape[0]\n            if samples > 0:\n                avg = np.sum(pixels, axis=0) / samples\n            else:\n                avg = np.array([0, 0, 0])\n                \n            # Clamp and pack to int\n            # Kernel packs: ABGR (A=255)\n            # Input img is RGB. \n            r, g, b = np.clip(avg, 0, 255).astype(np.uint8)\n            \n            r = np.uint32(r)\n            g = np.uint32(g)\n            b = np.uint32(b)\n            a = np.uint32(255)\n            \n            # Pack: (A << 24) | (B << 16) | (G << 8) | R\n            packed = (a << 24) | (b << 16) | (g << 8) | r\n            output[y, x] = packed\n            \n    return output\n\n# Generate Random Image\n# Shape: (H, W, 4) uchar4, but we only use RGB for logic usually. \n# The kernel reads uchar4 but uses .x(r), .y(g), .z(b).\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n# Set alpha to 255 for consistency, though kernel ignores input alpha\nimg_data[:, :, 3] = 255\n\n# Compute Reference\n# Remove alpha for processing convenience as kernel calculates luminance from RGB\nimg_rgb = img_data[:, :, :3]\nref_out = process_cpu(img_rgb, RADIUS, THRESHOLD, HIGHLIGHT)\n\n# Save Data\nos.makedirs(\"data\", exist_ok=True)\nimg_data.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n    \n    # Unpack to compare channels individually\n    # Packed: (A << 24) | (B << 16) | (G << 8) | R\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    \n    # Calculate diffs\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Allow small difference due to float/accumulation precision differences\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 128\n    HEIGHT = 128\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Post_Process_GL kernel that processes an input image. The input is a 128x128 RGBA image stored as uint8 values. The kernel should apply a disc-shaped convolution filter with radius r=4 to each pixel. For pixels within the disc neighborhood, if their luminance (average of RGB channels) exceeds threshold=0.8, multiply their RGB values by highlight=2.0 before averaging. The output should be a flattened 16384-element array of uint32 values, each representing an ABGR-packed pixel (alpha=255) with processed RGB channels. Boundary handling should use clamp addressing, and shared memory should be used for efficient neighborhood access.", "level2_prompt": "Perform image processing where each output pixel is computed as the average of neighboring pixels within a disc of radius 4. Pixels with luminance above 0.8 have their RGB values doubled before contributing to the average. Convert the resulting RGB values to a packed ABGR uint32 format (alpha=255) for output.", "level3_prompt": "Compute the Post_Process_GL kernel on GPU using CUDA."}
{"id": 1, "task_name": "Post_Process_GL", "task_description": "Compute the Post_Process_GL kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint8", "shape": "(256, 256, 4)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants and Macros\n// ----------------------------------------------------------------------------\n// SMEM macro to index the shared memory array \"sdata\"\n// tilew = blockDim.x + 2*r. However, since the shared memory is 1D array of uchar4\n// and we treat it as 2D: sdata[ y * tilew + x ]\n// In the kernel, 'tilew' is passed as argument.\n#define SMEM(X, Y) sdata[(Y)*tilew + (X)]\n\n// ----------------------------------------------------------------------------\n// Texture Object\n// ----------------------------------------------------------------------------\n// We need to use a texture object for reading input as per kernel signature.\n// However, since we are writing a standalone app without OpenGL interop, \n// we will create a CUDA texture object from a CUDA array.\n\n// ----------------------------------------------------------------------------\n// Helper Device Functions (from typical NVIDIA samples context)\n// ----------------------------------------------------------------------------\n__device__ inline uchar4 getPixel(int x, int y, cudaTextureObject_t tex) {\n    // tex2D<uchar4>(tex, x, y) returns the pixel\n    // Since we use cudaReadModeElementType, we get uchar4 directly\n    return tex2D<uchar4>(tex, (float)x, (float)y);\n}\n\n__device__ inline unsigned int rgbToInt(float r, float g, float b) {\n    // Pack into ABGR or ARGB integer. \n    // The kernel comment says \"// ABGR\".\n    // Typically: (a << 24) | (b << 16) | (g << 8) | r\n    // Assuming alpha is 255\n    unsigned int ir = (unsigned int)min(255.0f, max(0.0f, r));\n    unsigned int ig = (unsigned int)min(255.0f, max(0.0f, g));\n    unsigned int ib = (unsigned int)min(255.0f, max(0.0f, b));\n    unsigned int ia = 255;\n    return (ia << 24) | (ib << 16) | (ig << 8) | ir;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void cudaProcess(unsigned int       *g_odata,\n                            int                 imgw,\n                            int                 imgh,\n                            int                 tilew,\n                            int                 r,\n                            float               threshold,\n                            float               highlight,\n                            cudaTextureObject_t inTex)\n{\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ uchar4 sdata[];\n\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n    int bw = blockDim.x;\n    int bh = blockDim.y;\n    int x  = blockIdx.x * bw + tx;\n    int y  = blockIdx.y * bh + ty;\n\n    // Check bounds for global read/write\n    // Although the tiling logic loads halo, we must be careful not to read \n    // outside image bounds if texture is not set to Clamp/Border. \n    // Texture hardware handles OOB if configured correctly.\n\n    // copy tile to shared memory\n    // center region\n    SMEM(r + tx, r + ty) = getPixel(x, y, inTex);\n\n    // borders\n    if (threadIdx.x < r) {\n        // left\n        SMEM(tx, r + ty) = getPixel(x - r, y, inTex);\n        // right\n        SMEM(r + bw + tx, r + ty) = getPixel(x + bw, y, inTex);\n    }\n\n    if (threadIdx.y < r) {\n        // top\n        SMEM(r + tx, ty) = getPixel(x, y - r, inTex);\n        // bottom\n        SMEM(r + tx, r + bh + ty) = getPixel(x, y + bh, inTex);\n    }\n\n    // load corners\n    if ((threadIdx.x < r) && (threadIdx.y < r)) {\n        // tl\n        SMEM(tx, ty) = getPixel(x - r, y - r, inTex);\n        // bl\n        SMEM(tx, r + bh + ty) = getPixel(x - r, y + bh, inTex);\n        // tr\n        SMEM(r + bw + tx, ty) = getPixel(x + bh, y - r, inTex);\n        // br\n        SMEM(r + bw + tx, r + bh + ty) = getPixel(x + bw, y + bh, inTex);\n    }\n\n    // wait for loads to complete\n    cg::sync(cta);\n\n    // perform convolution\n    float rsum    = 0.0f;\n    float gsum    = 0.0f;\n    float bsum    = 0.0f;\n    float samples = 0.0f;\n\n    for (int dy = -r; dy <= r; dy++) {\n        for (int dx = -r; dx <= r; dx++) {\n            uchar4 pixel = SMEM(r + tx + dx, r + ty + dy);\n\n            // only sum pixels within disc-shaped kernel\n            float l = (float)(dx * dx + dy * dy);\n\n            if (l <= (float)(r * r)) {\n                float fr = float(pixel.x);\n                float fg = float(pixel.y);\n                float fb = float(pixel.z);\n\n                // brighten highlights\n                float lum = (fr + fg + fb) / (255.0f * 3.0f);\n\n                if (lum > threshold) {\n                    fr *= highlight;\n                    fg *= highlight;\n                    fb *= highlight;\n                }\n\n                rsum += fr;\n                gsum += fg;\n                bsum += fb;\n                samples += 1.0f;\n            }\n        }\n    }\n\n    if (samples > 0.0f) {\n        rsum /= samples;\n        gsum /= samples;\n        bsum /= samples;\n    }\n\n    // ABGR\n    if (x < imgw && y < imgh) {\n        g_odata[y * imgw + x] = rgbToInt(rsum, gsum, bsum);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 256;\n    const int height = 256;\n    const int radius = 4;\n    const float threshold = 0.8f;\n    const float highlight = 2.0f;\n\n    size_t img_size_bytes = width * height * sizeof(uchar4);\n    size_t out_size_bytes = width * height * sizeof(unsigned int);\n\n    // Host alloc\n    uchar4* h_in = new uchar4[width * height];\n    unsigned int* h_out = new unsigned int[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size_bytes);\n\n    // CUDA Array for Texture\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc<uchar4>();\n    cudaArray* cuArray;\n    cudaMallocArray(&cuArray, &channelDesc, width, height);\n    cudaMemcpy2DToArray(cuArray, 0, 0, h_in, width * sizeof(uchar4), width * sizeof(uchar4), height, cudaMemcpyHostToDevice);\n\n    // Create Texture Object\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp; // Clamp to edge\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint; // Pixel exact access\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0; // Use integer coords [0, width)\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n    // Output Buffer\n    unsigned int* d_out;\n    cudaMalloc(&d_out, out_size_bytes);\n\n    // Kernel Launch Config\n    dim3 dimBlock(16, 16);\n    dim3 dimGrid((width + dimBlock.x - 1) / dimBlock.x, \n                 (height + dimBlock.y - 1) / dimBlock.y);\n\n    // Shared memory size calculation:\n    // Tile width includes the halo (radius) on both sides.\n    // tile_w = blockDim.x + 2 * r\n    // tile_h = blockDim.y + 2 * r\n    int tile_w = dimBlock.x + 2 * radius;\n    int tile_h = dimBlock.y + 2 * radius;\n    size_t shm_size = tile_w * tile_h * sizeof(uchar4);\n\n    cudaProcess<<<dimGrid, dimBlock, shm_size>>>(\n        d_out,\n        width,\n        height,\n        tile_w, // Passed as 'tilew' used in SMEM macro\n        radius,\n        threshold,\n        highlight,\n        texObj\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read back\n    cudaMemcpy(h_out, d_out, out_size_bytes, cudaMemcpyDeviceToHost);\n\n    // Write output\n    write_binary(\"data/output_img.bin\", h_out, out_size_bytes);\n\n    // Cleanup\n    cudaDestroyTextureObject(texObj);\n    cudaFreeArray(cuArray);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nfrom PIL import Image\n\n# Constants\nWIDTH = 256\nHEIGHT = 256\nRADIUS = 4\nTHRESHOLD = 0.8\nHIGHLIGHT = 2.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef process_cpu(img, radius, threshold, highlight):\n    h, w, c = img.shape\n    # Pad image to handle borders (Clamp/Replica padding)\n    padded = np.pad(img, ((radius, radius), (radius, radius), (0, 0)), mode='edge')\n    output = np.zeros((h, w), dtype=np.uint32)\n    \n    # Pre-calculate kernel mask (disc)\n    ky, kx = np.ogrid[-radius:radius+1, -radius:radius+1]\n    mask = kx**2 + ky**2 <= radius**2\n    \n    # Iterate over every pixel\n    # Note: Python loops are slow, but for 512x512 it's acceptable for verification generation\n    # Optimized using sliding windows would be better but complex to read.\n    # We will use simple loops for clarity matching the kernel.\n    \n    # Convert image to float for calculation\n    img_f = padded.astype(np.float32)\n    \n    # Pre-calculate highlight mask\n    # Luminance: (r+g+b)/(255*3)\n    lum = np.sum(img_f, axis=2) / (255.0 * 3.0)\n    is_highlight = lum > threshold\n    \n    # Apply highlight boost to the padded image copy\n    img_boosted = img_f.copy()\n    img_boosted[is_highlight] *= highlight\n    \n    for y in range(h):\n        for x in range(w):\n            # Extract window\n            # Window coords in padded image: y to y+2r+1, x to x+2r+1\n            window = img_boosted[y:y+2*radius+1, x:x+2*radius+1]\n            \n            # Apply disc mask\n            # Sum pixels where mask is true\n            pixels = window[mask]\n            \n            samples = pixels.shape[0]\n            if samples > 0:\n                avg = np.sum(pixels, axis=0) / samples\n            else:\n                avg = np.array([0, 0, 0])\n                \n            # Clamp and pack to int\n            # Kernel packs: ABGR (A=255)\n            # Input img is RGB. \n            r, g, b = np.clip(avg, 0, 255).astype(np.uint8)\n            \n            r = np.uint32(r)\n            g = np.uint32(g)\n            b = np.uint32(b)\n            a = np.uint32(255)\n            \n            # Pack: (A << 24) | (B << 16) | (G << 8) | R\n            packed = (a << 24) | (b << 16) | (g << 8) | r\n            output[y, x] = packed\n            \n    return output\n\n# Generate Random Image\n# Shape: (H, W, 4) uchar4, but we only use RGB for logic usually. \n# The kernel reads uchar4 but uses .x(r), .y(g), .z(b).\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n# Set alpha to 255 for consistency, though kernel ignores input alpha\nimg_data[:, :, 3] = 255\n\n# Compute Reference\n# Remove alpha for processing convenience as kernel calculates luminance from RGB\nimg_rgb = img_data[:, :, :3]\nref_out = process_cpu(img_rgb, RADIUS, THRESHOLD, HIGHLIGHT)\n\n# Save Data\nos.makedirs(\"data\", exist_ok=True)\nimg_data.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n    \n    # Unpack to compare channels individually\n    # Packed: (A << 24) | (B << 16) | (G << 8) | R\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    \n    # Calculate diffs\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Allow small difference due to float/accumulation precision differences\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 256\n    HEIGHT = 256\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Post_Process_GL kernel for GPU processing. The input is a 256×256 RGBA image with 4 channels (shape 256,256,4) of uint8 data type. The output must be a 256×256 image of uint32 values where each pixel is packed in ABGR format (alpha=255). The kernel must apply a disc-shaped convolution with a 4-pixel radius, processing only pixels within Euclidean distance ≤4 from the center. For pixels with luminance (average of RGB channels normalized to [0,1]) above 0.8, multiply RGB values by 2.0 before averaging. Handle image boundaries with clamping, and ensure shared memory optimization with halo loading for neighborhood access.", "level2_prompt": "For each output pixel, compute a weighted average over neighboring pixels within a Euclidean distance of 4 pixels. First, calculate luminance as (R+G+B)/(3×255). If luminance exceeds 0.8, scale the pixel's RGB values by 2.0. Then, average all qualifying pixels' RGB values within the disc-shaped neighborhood. Pack the result as a uint32 in ABGR format with alpha=255. Input is RGBA uint8, output is uint32.", "level3_prompt": "Compute the Post_Process_GL kernel: Transform input RGBA image to output image via disc convolution with highlight enhancement."}
{"id": 2, "task_name": "Post_Process_GL", "task_description": "Compute the Post_Process_GL kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint8", "shape": "(512, 512, 4)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants and Macros\n// ----------------------------------------------------------------------------\n// SMEM macro to index the shared memory array \"sdata\"\n// tilew = blockDim.x + 2*r. However, since the shared memory is 1D array of uchar4\n// and we treat it as 2D: sdata[ y * tilew + x ]\n// In the kernel, 'tilew' is passed as argument.\n#define SMEM(X, Y) sdata[(Y)*tilew + (X)]\n\n// ----------------------------------------------------------------------------\n// Texture Object\n// ----------------------------------------------------------------------------\n// We need to use a texture object for reading input as per kernel signature.\n// However, since we are writing a standalone app without OpenGL interop, \n// we will create a CUDA texture object from a CUDA array.\n\n// ----------------------------------------------------------------------------\n// Helper Device Functions (from typical NVIDIA samples context)\n// ----------------------------------------------------------------------------\n__device__ inline uchar4 getPixel(int x, int y, cudaTextureObject_t tex) {\n    // tex2D<uchar4>(tex, x, y) returns the pixel\n    // Since we use cudaReadModeElementType, we get uchar4 directly\n    return tex2D<uchar4>(tex, (float)x, (float)y);\n}\n\n__device__ inline unsigned int rgbToInt(float r, float g, float b) {\n    // Pack into ABGR or ARGB integer. \n    // The kernel comment says \"// ABGR\".\n    // Typically: (a << 24) | (b << 16) | (g << 8) | r\n    // Assuming alpha is 255\n    unsigned int ir = (unsigned int)min(255.0f, max(0.0f, r));\n    unsigned int ig = (unsigned int)min(255.0f, max(0.0f, g));\n    unsigned int ib = (unsigned int)min(255.0f, max(0.0f, b));\n    unsigned int ia = 255;\n    return (ia << 24) | (ib << 16) | (ig << 8) | ir;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void cudaProcess(unsigned int       *g_odata,\n                            int                 imgw,\n                            int                 imgh,\n                            int                 tilew,\n                            int                 r,\n                            float               threshold,\n                            float               highlight,\n                            cudaTextureObject_t inTex)\n{\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ uchar4 sdata[];\n\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n    int bw = blockDim.x;\n    int bh = blockDim.y;\n    int x  = blockIdx.x * bw + tx;\n    int y  = blockIdx.y * bh + ty;\n\n    // Check bounds for global read/write\n    // Although the tiling logic loads halo, we must be careful not to read \n    // outside image bounds if texture is not set to Clamp/Border. \n    // Texture hardware handles OOB if configured correctly.\n\n    // copy tile to shared memory\n    // center region\n    SMEM(r + tx, r + ty) = getPixel(x, y, inTex);\n\n    // borders\n    if (threadIdx.x < r) {\n        // left\n        SMEM(tx, r + ty) = getPixel(x - r, y, inTex);\n        // right\n        SMEM(r + bw + tx, r + ty) = getPixel(x + bw, y, inTex);\n    }\n\n    if (threadIdx.y < r) {\n        // top\n        SMEM(r + tx, ty) = getPixel(x, y - r, inTex);\n        // bottom\n        SMEM(r + tx, r + bh + ty) = getPixel(x, y + bh, inTex);\n    }\n\n    // load corners\n    if ((threadIdx.x < r) && (threadIdx.y < r)) {\n        // tl\n        SMEM(tx, ty) = getPixel(x - r, y - r, inTex);\n        // bl\n        SMEM(tx, r + bh + ty) = getPixel(x - r, y + bh, inTex);\n        // tr\n        SMEM(r + bw + tx, ty) = getPixel(x + bh, y - r, inTex);\n        // br\n        SMEM(r + bw + tx, r + bh + ty) = getPixel(x + bw, y + bh, inTex);\n    }\n\n    // wait for loads to complete\n    cg::sync(cta);\n\n    // perform convolution\n    float rsum    = 0.0f;\n    float gsum    = 0.0f;\n    float bsum    = 0.0f;\n    float samples = 0.0f;\n\n    for (int dy = -r; dy <= r; dy++) {\n        for (int dx = -r; dx <= r; dx++) {\n            uchar4 pixel = SMEM(r + tx + dx, r + ty + dy);\n\n            // only sum pixels within disc-shaped kernel\n            float l = (float)(dx * dx + dy * dy);\n\n            if (l <= (float)(r * r)) {\n                float fr = float(pixel.x);\n                float fg = float(pixel.y);\n                float fb = float(pixel.z);\n\n                // brighten highlights\n                float lum = (fr + fg + fb) / (255.0f * 3.0f);\n\n                if (lum > threshold) {\n                    fr *= highlight;\n                    fg *= highlight;\n                    fb *= highlight;\n                }\n\n                rsum += fr;\n                gsum += fg;\n                bsum += fb;\n                samples += 1.0f;\n            }\n        }\n    }\n\n    if (samples > 0.0f) {\n        rsum /= samples;\n        gsum /= samples;\n        bsum /= samples;\n    }\n\n    // ABGR\n    if (x < imgw && y < imgh) {\n        g_odata[y * imgw + x] = rgbToInt(rsum, gsum, bsum);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 512;\n    const int height = 512;\n    const int radius = 4;\n    const float threshold = 0.8f;\n    const float highlight = 2.0f;\n\n    size_t img_size_bytes = width * height * sizeof(uchar4);\n    size_t out_size_bytes = width * height * sizeof(unsigned int);\n\n    // Host alloc\n    uchar4* h_in = new uchar4[width * height];\n    unsigned int* h_out = new unsigned int[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size_bytes);\n\n    // CUDA Array for Texture\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc<uchar4>();\n    cudaArray* cuArray;\n    cudaMallocArray(&cuArray, &channelDesc, width, height);\n    cudaMemcpy2DToArray(cuArray, 0, 0, h_in, width * sizeof(uchar4), width * sizeof(uchar4), height, cudaMemcpyHostToDevice);\n\n    // Create Texture Object\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp; // Clamp to edge\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint; // Pixel exact access\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0; // Use integer coords [0, width)\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n    // Output Buffer\n    unsigned int* d_out;\n    cudaMalloc(&d_out, out_size_bytes);\n\n    // Kernel Launch Config\n    dim3 dimBlock(16, 16);\n    dim3 dimGrid((width + dimBlock.x - 1) / dimBlock.x, \n                 (height + dimBlock.y - 1) / dimBlock.y);\n\n    // Shared memory size calculation:\n    // Tile width includes the halo (radius) on both sides.\n    // tile_w = blockDim.x + 2 * r\n    // tile_h = blockDim.y + 2 * r\n    int tile_w = dimBlock.x + 2 * radius;\n    int tile_h = dimBlock.y + 2 * radius;\n    size_t shm_size = tile_w * tile_h * sizeof(uchar4);\n\n    cudaProcess<<<dimGrid, dimBlock, shm_size>>>(\n        d_out,\n        width,\n        height,\n        tile_w, // Passed as 'tilew' used in SMEM macro\n        radius,\n        threshold,\n        highlight,\n        texObj\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read back\n    cudaMemcpy(h_out, d_out, out_size_bytes, cudaMemcpyDeviceToHost);\n\n    // Write output\n    write_binary(\"data/output_img.bin\", h_out, out_size_bytes);\n\n    // Cleanup\n    cudaDestroyTextureObject(texObj);\n    cudaFreeArray(cuArray);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nfrom PIL import Image\n\n# Constants\nWIDTH = 512\nHEIGHT = 512\nRADIUS = 4\nTHRESHOLD = 0.8\nHIGHLIGHT = 2.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef process_cpu(img, radius, threshold, highlight):\n    h, w, c = img.shape\n    # Pad image to handle borders (Clamp/Replica padding)\n    padded = np.pad(img, ((radius, radius), (radius, radius), (0, 0)), mode='edge')\n    output = np.zeros((h, w), dtype=np.uint32)\n    \n    # Pre-calculate kernel mask (disc)\n    ky, kx = np.ogrid[-radius:radius+1, -radius:radius+1]\n    mask = kx**2 + ky**2 <= radius**2\n    \n    # Iterate over every pixel\n    # Note: Python loops are slow, but for 512x512 it's acceptable for verification generation\n    # Optimized using sliding windows would be better but complex to read.\n    # We will use simple loops for clarity matching the kernel.\n    \n    # Convert image to float for calculation\n    img_f = padded.astype(np.float32)\n    \n    # Pre-calculate highlight mask\n    # Luminance: (r+g+b)/(255*3)\n    lum = np.sum(img_f, axis=2) / (255.0 * 3.0)\n    is_highlight = lum > threshold\n    \n    # Apply highlight boost to the padded image copy\n    img_boosted = img_f.copy()\n    img_boosted[is_highlight] *= highlight\n    \n    for y in range(h):\n        for x in range(w):\n            # Extract window\n            # Window coords in padded image: y to y+2r+1, x to x+2r+1\n            window = img_boosted[y:y+2*radius+1, x:x+2*radius+1]\n            \n            # Apply disc mask\n            # Sum pixels where mask is true\n            pixels = window[mask]\n            \n            samples = pixels.shape[0]\n            if samples > 0:\n                avg = np.sum(pixels, axis=0) / samples\n            else:\n                avg = np.array([0, 0, 0])\n                \n            # Clamp and pack to int\n            # Kernel packs: ABGR (A=255)\n            # Input img is RGB. \n            r, g, b = np.clip(avg, 0, 255).astype(np.uint8)\n            \n            r = np.uint32(r)\n            g = np.uint32(g)\n            b = np.uint32(b)\n            a = np.uint32(255)\n            \n            # Pack: (A << 24) | (B << 16) | (G << 8) | R\n            packed = (a << 24) | (b << 16) | (g << 8) | r\n            output[y, x] = packed\n            \n    return output\n\n# Generate Random Image\n# Shape: (H, W, 4) uchar4, but we only use RGB for logic usually. \n# The kernel reads uchar4 but uses .x(r), .y(g), .z(b).\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n# Set alpha to 255 for consistency, though kernel ignores input alpha\nimg_data[:, :, 3] = 255\n\n# Compute Reference\n# Remove alpha for processing convenience as kernel calculates luminance from RGB\nimg_rgb = img_data[:, :, :3]\nref_out = process_cpu(img_rgb, RADIUS, THRESHOLD, HIGHLIGHT)\n\n# Save Data\nos.makedirs(\"data\", exist_ok=True)\nimg_data.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n    \n    # Unpack to compare channels individually\n    # Packed: (A << 24) | (B << 16) | (G << 8) | R\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    \n    # Calculate diffs\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Allow small difference due to float/accumulation precision differences\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 512\n    HEIGHT = 512\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Post_Process_GL. Implement a CUDA kernel that processes a 512x512 input image with 4 channels (RGBA) of type uint8. The kernel must apply a disc-shaped convolution with radius 4, where pixels within Euclidean distance ≤4 are included. For pixels with luminance (R+G+B)/(3×255) > 0.8, multiply RGB values by 2.0 before averaging. Compute the average RGB for valid pixels, clamp results to [0,255], and pack into uint32 output in ABGR format (alpha=255). Boundary handling must use clamping. Output is a flattened 262144-element uint32 tensor.", "level2_prompt": "Task: Post_Process_GL. For each pixel in a 512x512 input image: (1) Load a 9x9 window centered on the pixel with clamped boundaries. (2) For pixels in the window with distance ≤4 from center: if luminance > 0.8, scale RGB by 2.0. (3) Sum scaled RGB values and divide by valid pixel count. (4) Clamp averages to [0,255] and pack into uint32 as (255<<24)|(B<<16)|(G<<8)|R. Output is a 1D uint32 array.", "level3_prompt": "Apply disc convolution and highlight enhancement to an input image."}
{"id": 3, "task_name": "Post_Process_GL", "task_description": "Compute the Post_Process_GL kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint8", "shape": "(1024, 1024, 4)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants and Macros\n// ----------------------------------------------------------------------------\n// SMEM macro to index the shared memory array \"sdata\"\n// tilew = blockDim.x + 2*r. However, since the shared memory is 1D array of uchar4\n// and we treat it as 2D: sdata[ y * tilew + x ]\n// In the kernel, 'tilew' is passed as argument.\n#define SMEM(X, Y) sdata[(Y)*tilew + (X)]\n\n// ----------------------------------------------------------------------------\n// Texture Object\n// ----------------------------------------------------------------------------\n// We need to use a texture object for reading input as per kernel signature.\n// However, since we are writing a standalone app without OpenGL interop, \n// we will create a CUDA texture object from a CUDA array.\n\n// ----------------------------------------------------------------------------\n// Helper Device Functions (from typical NVIDIA samples context)\n// ----------------------------------------------------------------------------\n__device__ inline uchar4 getPixel(int x, int y, cudaTextureObject_t tex) {\n    // tex2D<uchar4>(tex, x, y) returns the pixel\n    // Since we use cudaReadModeElementType, we get uchar4 directly\n    return tex2D<uchar4>(tex, (float)x, (float)y);\n}\n\n__device__ inline unsigned int rgbToInt(float r, float g, float b) {\n    // Pack into ABGR or ARGB integer. \n    // The kernel comment says \"// ABGR\".\n    // Typically: (a << 24) | (b << 16) | (g << 8) | r\n    // Assuming alpha is 255\n    unsigned int ir = (unsigned int)min(255.0f, max(0.0f, r));\n    unsigned int ig = (unsigned int)min(255.0f, max(0.0f, g));\n    unsigned int ib = (unsigned int)min(255.0f, max(0.0f, b));\n    unsigned int ia = 255;\n    return (ia << 24) | (ib << 16) | (ig << 8) | ir;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void cudaProcess(unsigned int       *g_odata,\n                            int                 imgw,\n                            int                 imgh,\n                            int                 tilew,\n                            int                 r,\n                            float               threshold,\n                            float               highlight,\n                            cudaTextureObject_t inTex)\n{\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ uchar4 sdata[];\n\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n    int bw = blockDim.x;\n    int bh = blockDim.y;\n    int x  = blockIdx.x * bw + tx;\n    int y  = blockIdx.y * bh + ty;\n\n    // Check bounds for global read/write\n    // Although the tiling logic loads halo, we must be careful not to read \n    // outside image bounds if texture is not set to Clamp/Border. \n    // Texture hardware handles OOB if configured correctly.\n\n    // copy tile to shared memory\n    // center region\n    SMEM(r + tx, r + ty) = getPixel(x, y, inTex);\n\n    // borders\n    if (threadIdx.x < r) {\n        // left\n        SMEM(tx, r + ty) = getPixel(x - r, y, inTex);\n        // right\n        SMEM(r + bw + tx, r + ty) = getPixel(x + bw, y, inTex);\n    }\n\n    if (threadIdx.y < r) {\n        // top\n        SMEM(r + tx, ty) = getPixel(x, y - r, inTex);\n        // bottom\n        SMEM(r + tx, r + bh + ty) = getPixel(x, y + bh, inTex);\n    }\n\n    // load corners\n    if ((threadIdx.x < r) && (threadIdx.y < r)) {\n        // tl\n        SMEM(tx, ty) = getPixel(x - r, y - r, inTex);\n        // bl\n        SMEM(tx, r + bh + ty) = getPixel(x - r, y + bh, inTex);\n        // tr\n        SMEM(r + bw + tx, ty) = getPixel(x + bh, y - r, inTex);\n        // br\n        SMEM(r + bw + tx, r + bh + ty) = getPixel(x + bw, y + bh, inTex);\n    }\n\n    // wait for loads to complete\n    cg::sync(cta);\n\n    // perform convolution\n    float rsum    = 0.0f;\n    float gsum    = 0.0f;\n    float bsum    = 0.0f;\n    float samples = 0.0f;\n\n    for (int dy = -r; dy <= r; dy++) {\n        for (int dx = -r; dx <= r; dx++) {\n            uchar4 pixel = SMEM(r + tx + dx, r + ty + dy);\n\n            // only sum pixels within disc-shaped kernel\n            float l = (float)(dx * dx + dy * dy);\n\n            if (l <= (float)(r * r)) {\n                float fr = float(pixel.x);\n                float fg = float(pixel.y);\n                float fb = float(pixel.z);\n\n                // brighten highlights\n                float lum = (fr + fg + fb) / (255.0f * 3.0f);\n\n                if (lum > threshold) {\n                    fr *= highlight;\n                    fg *= highlight;\n                    fb *= highlight;\n                }\n\n                rsum += fr;\n                gsum += fg;\n                bsum += fb;\n                samples += 1.0f;\n            }\n        }\n    }\n\n    if (samples > 0.0f) {\n        rsum /= samples;\n        gsum /= samples;\n        bsum /= samples;\n    }\n\n    // ABGR\n    if (x < imgw && y < imgh) {\n        g_odata[y * imgw + x] = rgbToInt(rsum, gsum, bsum);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 1024;\n    const int height = 1024;\n    const int radius = 4;\n    const float threshold = 0.8f;\n    const float highlight = 2.0f;\n\n    size_t img_size_bytes = width * height * sizeof(uchar4);\n    size_t out_size_bytes = width * height * sizeof(unsigned int);\n\n    // Host alloc\n    uchar4* h_in = new uchar4[width * height];\n    unsigned int* h_out = new unsigned int[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size_bytes);\n\n    // CUDA Array for Texture\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc<uchar4>();\n    cudaArray* cuArray;\n    cudaMallocArray(&cuArray, &channelDesc, width, height);\n    cudaMemcpy2DToArray(cuArray, 0, 0, h_in, width * sizeof(uchar4), width * sizeof(uchar4), height, cudaMemcpyHostToDevice);\n\n    // Create Texture Object\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp; // Clamp to edge\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint; // Pixel exact access\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0; // Use integer coords [0, width)\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n    // Output Buffer\n    unsigned int* d_out;\n    cudaMalloc(&d_out, out_size_bytes);\n\n    // Kernel Launch Config\n    dim3 dimBlock(16, 16);\n    dim3 dimGrid((width + dimBlock.x - 1) / dimBlock.x, \n                 (height + dimBlock.y - 1) / dimBlock.y);\n\n    // Shared memory size calculation:\n    // Tile width includes the halo (radius) on both sides.\n    // tile_w = blockDim.x + 2 * r\n    // tile_h = blockDim.y + 2 * r\n    int tile_w = dimBlock.x + 2 * radius;\n    int tile_h = dimBlock.y + 2 * radius;\n    size_t shm_size = tile_w * tile_h * sizeof(uchar4);\n\n    cudaProcess<<<dimGrid, dimBlock, shm_size>>>(\n        d_out,\n        width,\n        height,\n        tile_w, // Passed as 'tilew' used in SMEM macro\n        radius,\n        threshold,\n        highlight,\n        texObj\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read back\n    cudaMemcpy(h_out, d_out, out_size_bytes, cudaMemcpyDeviceToHost);\n\n    // Write output\n    write_binary(\"data/output_img.bin\", h_out, out_size_bytes);\n\n    // Cleanup\n    cudaDestroyTextureObject(texObj);\n    cudaFreeArray(cuArray);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nfrom PIL import Image\n\n# Constants\nWIDTH = 1024\nHEIGHT = 1024\nRADIUS = 4\nTHRESHOLD = 0.8\nHIGHLIGHT = 2.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef process_cpu(img, radius, threshold, highlight):\n    h, w, c = img.shape\n    # Pad image to handle borders (Clamp/Replica padding)\n    padded = np.pad(img, ((radius, radius), (radius, radius), (0, 0)), mode='edge')\n    output = np.zeros((h, w), dtype=np.uint32)\n    \n    # Pre-calculate kernel mask (disc)\n    ky, kx = np.ogrid[-radius:radius+1, -radius:radius+1]\n    mask = kx**2 + ky**2 <= radius**2\n    \n    # Iterate over every pixel\n    # Note: Python loops are slow, but for 512x512 it's acceptable for verification generation\n    # Optimized using sliding windows would be better but complex to read.\n    # We will use simple loops for clarity matching the kernel.\n    \n    # Convert image to float for calculation\n    img_f = padded.astype(np.float32)\n    \n    # Pre-calculate highlight mask\n    # Luminance: (r+g+b)/(255*3)\n    lum = np.sum(img_f, axis=2) / (255.0 * 3.0)\n    is_highlight = lum > threshold\n    \n    # Apply highlight boost to the padded image copy\n    img_boosted = img_f.copy()\n    img_boosted[is_highlight] *= highlight\n    \n    for y in range(h):\n        for x in range(w):\n            # Extract window\n            # Window coords in padded image: y to y+2r+1, x to x+2r+1\n            window = img_boosted[y:y+2*radius+1, x:x+2*radius+1]\n            \n            # Apply disc mask\n            # Sum pixels where mask is true\n            pixels = window[mask]\n            \n            samples = pixels.shape[0]\n            if samples > 0:\n                avg = np.sum(pixels, axis=0) / samples\n            else:\n                avg = np.array([0, 0, 0])\n                \n            # Clamp and pack to int\n            # Kernel packs: ABGR (A=255)\n            # Input img is RGB. \n            r, g, b = np.clip(avg, 0, 255).astype(np.uint8)\n            \n            r = np.uint32(r)\n            g = np.uint32(g)\n            b = np.uint32(b)\n            a = np.uint32(255)\n            \n            # Pack: (A << 24) | (B << 16) | (G << 8) | R\n            packed = (a << 24) | (b << 16) | (g << 8) | r\n            output[y, x] = packed\n            \n    return output\n\n# Generate Random Image\n# Shape: (H, W, 4) uchar4, but we only use RGB for logic usually. \n# The kernel reads uchar4 but uses .x(r), .y(g), .z(b).\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n# Set alpha to 255 for consistency, though kernel ignores input alpha\nimg_data[:, :, 3] = 255\n\n# Compute Reference\n# Remove alpha for processing convenience as kernel calculates luminance from RGB\nimg_rgb = img_data[:, :, :3]\nref_out = process_cpu(img_rgb, RADIUS, THRESHOLD, HIGHLIGHT)\n\n# Save Data\nos.makedirs(\"data\", exist_ok=True)\nimg_data.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n    \n    # Unpack to compare channels individually\n    # Packed: (A << 24) | (B << 16) | (G << 8) | R\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    \n    # Calculate diffs\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Allow small difference due to float/accumulation precision differences\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 1024\n    HEIGHT = 1024\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Post_Process_GL. Given an input image of shape (1024, 1024, 4) with uint8 data type, compute an output image of shape (1024, 1024) with uint32 data type. For each pixel, apply a disc-shaped convolution with radius 4. For each neighboring pixel within the disc, if its luminance (average of RGB values) exceeds 0.8, multiply its RGB values by 2.0. Compute the average RGB values of all valid neighboring pixels within the disc and pack the result into a 32-bit ABGR format (alpha=255). Handle boundary pixels using clamping behavior. Ensure the output pixel values are clamped to [0,255].", "level2_prompt": "Task: Post_Process_GL. For each pixel in a 1024x1024 grid, gather all pixels within a disc of radius 4. For each neighbor in the disc, compute luminance (average RGB). If luminance exceeds 0.8, scale neighbor's RGB by 2.0. Average all scaled/unscaled RGB values in the disc, then pack the result into a 32-bit integer with alpha=255 (ABGR format).", "level3_prompt": "Apply a disc convolution with highlight boost to an input image."}
{"id": 4, "task_name": "Post_Process_GL", "task_description": "Compute the Post_Process_GL kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint8", "shape": "(2048, 2048, 4)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants and Macros\n// ----------------------------------------------------------------------------\n// SMEM macro to index the shared memory array \"sdata\"\n// tilew = blockDim.x + 2*r. However, since the shared memory is 1D array of uchar4\n// and we treat it as 2D: sdata[ y * tilew + x ]\n// In the kernel, 'tilew' is passed as argument.\n#define SMEM(X, Y) sdata[(Y)*tilew + (X)]\n\n// ----------------------------------------------------------------------------\n// Texture Object\n// ----------------------------------------------------------------------------\n// We need to use a texture object for reading input as per kernel signature.\n// However, since we are writing a standalone app without OpenGL interop, \n// we will create a CUDA texture object from a CUDA array.\n\n// ----------------------------------------------------------------------------\n// Helper Device Functions (from typical NVIDIA samples context)\n// ----------------------------------------------------------------------------\n__device__ inline uchar4 getPixel(int x, int y, cudaTextureObject_t tex) {\n    // tex2D<uchar4>(tex, x, y) returns the pixel\n    // Since we use cudaReadModeElementType, we get uchar4 directly\n    return tex2D<uchar4>(tex, (float)x, (float)y);\n}\n\n__device__ inline unsigned int rgbToInt(float r, float g, float b) {\n    // Pack into ABGR or ARGB integer. \n    // The kernel comment says \"// ABGR\".\n    // Typically: (a << 24) | (b << 16) | (g << 8) | r\n    // Assuming alpha is 255\n    unsigned int ir = (unsigned int)min(255.0f, max(0.0f, r));\n    unsigned int ig = (unsigned int)min(255.0f, max(0.0f, g));\n    unsigned int ib = (unsigned int)min(255.0f, max(0.0f, b));\n    unsigned int ia = 255;\n    return (ia << 24) | (ib << 16) | (ig << 8) | ir;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void cudaProcess(unsigned int       *g_odata,\n                            int                 imgw,\n                            int                 imgh,\n                            int                 tilew,\n                            int                 r,\n                            float               threshold,\n                            float               highlight,\n                            cudaTextureObject_t inTex)\n{\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ uchar4 sdata[];\n\n    int tx = threadIdx.x;\n    int ty = threadIdx.y;\n    int bw = blockDim.x;\n    int bh = blockDim.y;\n    int x  = blockIdx.x * bw + tx;\n    int y  = blockIdx.y * bh + ty;\n\n    // Check bounds for global read/write\n    // Although the tiling logic loads halo, we must be careful not to read \n    // outside image bounds if texture is not set to Clamp/Border. \n    // Texture hardware handles OOB if configured correctly.\n\n    // copy tile to shared memory\n    // center region\n    SMEM(r + tx, r + ty) = getPixel(x, y, inTex);\n\n    // borders\n    if (threadIdx.x < r) {\n        // left\n        SMEM(tx, r + ty) = getPixel(x - r, y, inTex);\n        // right\n        SMEM(r + bw + tx, r + ty) = getPixel(x + bw, y, inTex);\n    }\n\n    if (threadIdx.y < r) {\n        // top\n        SMEM(r + tx, ty) = getPixel(x, y - r, inTex);\n        // bottom\n        SMEM(r + tx, r + bh + ty) = getPixel(x, y + bh, inTex);\n    }\n\n    // load corners\n    if ((threadIdx.x < r) && (threadIdx.y < r)) {\n        // tl\n        SMEM(tx, ty) = getPixel(x - r, y - r, inTex);\n        // bl\n        SMEM(tx, r + bh + ty) = getPixel(x - r, y + bh, inTex);\n        // tr\n        SMEM(r + bw + tx, ty) = getPixel(x + bh, y - r, inTex);\n        // br\n        SMEM(r + bw + tx, r + bh + ty) = getPixel(x + bw, y + bh, inTex);\n    }\n\n    // wait for loads to complete\n    cg::sync(cta);\n\n    // perform convolution\n    float rsum    = 0.0f;\n    float gsum    = 0.0f;\n    float bsum    = 0.0f;\n    float samples = 0.0f;\n\n    for (int dy = -r; dy <= r; dy++) {\n        for (int dx = -r; dx <= r; dx++) {\n            uchar4 pixel = SMEM(r + tx + dx, r + ty + dy);\n\n            // only sum pixels within disc-shaped kernel\n            float l = (float)(dx * dx + dy * dy);\n\n            if (l <= (float)(r * r)) {\n                float fr = float(pixel.x);\n                float fg = float(pixel.y);\n                float fb = float(pixel.z);\n\n                // brighten highlights\n                float lum = (fr + fg + fb) / (255.0f * 3.0f);\n\n                if (lum > threshold) {\n                    fr *= highlight;\n                    fg *= highlight;\n                    fb *= highlight;\n                }\n\n                rsum += fr;\n                gsum += fg;\n                bsum += fb;\n                samples += 1.0f;\n            }\n        }\n    }\n\n    if (samples > 0.0f) {\n        rsum /= samples;\n        gsum /= samples;\n        bsum /= samples;\n    }\n\n    // ABGR\n    if (x < imgw && y < imgh) {\n        g_odata[y * imgw + x] = rgbToInt(rsum, gsum, bsum);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 2048;\n    const int height = 2048;\n    const int radius = 4;\n    const float threshold = 0.8f;\n    const float highlight = 2.0f;\n\n    size_t img_size_bytes = width * height * sizeof(uchar4);\n    size_t out_size_bytes = width * height * sizeof(unsigned int);\n\n    // Host alloc\n    uchar4* h_in = new uchar4[width * height];\n    unsigned int* h_out = new unsigned int[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size_bytes);\n\n    // CUDA Array for Texture\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc<uchar4>();\n    cudaArray* cuArray;\n    cudaMallocArray(&cuArray, &channelDesc, width, height);\n    cudaMemcpy2DToArray(cuArray, 0, 0, h_in, width * sizeof(uchar4), width * sizeof(uchar4), height, cudaMemcpyHostToDevice);\n\n    // Create Texture Object\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp; // Clamp to edge\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint; // Pixel exact access\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0; // Use integer coords [0, width)\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n    // Output Buffer\n    unsigned int* d_out;\n    cudaMalloc(&d_out, out_size_bytes);\n\n    // Kernel Launch Config\n    dim3 dimBlock(16, 16);\n    dim3 dimGrid((width + dimBlock.x - 1) / dimBlock.x, \n                 (height + dimBlock.y - 1) / dimBlock.y);\n\n    // Shared memory size calculation:\n    // Tile width includes the halo (radius) on both sides.\n    // tile_w = blockDim.x + 2 * r\n    // tile_h = blockDim.y + 2 * r\n    int tile_w = dimBlock.x + 2 * radius;\n    int tile_h = dimBlock.y + 2 * radius;\n    size_t shm_size = tile_w * tile_h * sizeof(uchar4);\n\n    cudaProcess<<<dimGrid, dimBlock, shm_size>>>(\n        d_out,\n        width,\n        height,\n        tile_w, // Passed as 'tilew' used in SMEM macro\n        radius,\n        threshold,\n        highlight,\n        texObj\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read back\n    cudaMemcpy(h_out, d_out, out_size_bytes, cudaMemcpyDeviceToHost);\n\n    // Write output\n    write_binary(\"data/output_img.bin\", h_out, out_size_bytes);\n\n    // Cleanup\n    cudaDestroyTextureObject(texObj);\n    cudaFreeArray(cuArray);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nfrom PIL import Image\n\n# Constants\nWIDTH = 2048\nHEIGHT = 2048\nRADIUS = 4\nTHRESHOLD = 0.8\nHIGHLIGHT = 2.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef process_cpu(img, radius, threshold, highlight):\n    h, w, c = img.shape\n    # Pad image to handle borders (Clamp/Replica padding)\n    padded = np.pad(img, ((radius, radius), (radius, radius), (0, 0)), mode='edge')\n    output = np.zeros((h, w), dtype=np.uint32)\n    \n    # Pre-calculate kernel mask (disc)\n    ky, kx = np.ogrid[-radius:radius+1, -radius:radius+1]\n    mask = kx**2 + ky**2 <= radius**2\n    \n    # Iterate over every pixel\n    # Note: Python loops are slow, but for 512x512 it's acceptable for verification generation\n    # Optimized using sliding windows would be better but complex to read.\n    # We will use simple loops for clarity matching the kernel.\n    \n    # Convert image to float for calculation\n    img_f = padded.astype(np.float32)\n    \n    # Pre-calculate highlight mask\n    # Luminance: (r+g+b)/(255*3)\n    lum = np.sum(img_f, axis=2) / (255.0 * 3.0)\n    is_highlight = lum > threshold\n    \n    # Apply highlight boost to the padded image copy\n    img_boosted = img_f.copy()\n    img_boosted[is_highlight] *= highlight\n    \n    for y in range(h):\n        for x in range(w):\n            # Extract window\n            # Window coords in padded image: y to y+2r+1, x to x+2r+1\n            window = img_boosted[y:y+2*radius+1, x:x+2*radius+1]\n            \n            # Apply disc mask\n            # Sum pixels where mask is true\n            pixels = window[mask]\n            \n            samples = pixels.shape[0]\n            if samples > 0:\n                avg = np.sum(pixels, axis=0) / samples\n            else:\n                avg = np.array([0, 0, 0])\n                \n            # Clamp and pack to int\n            # Kernel packs: ABGR (A=255)\n            # Input img is RGB. \n            r, g, b = np.clip(avg, 0, 255).astype(np.uint8)\n            \n            r = np.uint32(r)\n            g = np.uint32(g)\n            b = np.uint32(b)\n            a = np.uint32(255)\n            \n            # Pack: (A << 24) | (B << 16) | (G << 8) | R\n            packed = (a << 24) | (b << 16) | (g << 8) | r\n            output[y, x] = packed\n            \n    return output\n\n# Generate Random Image\n# Shape: (H, W, 4) uchar4, but we only use RGB for logic usually. \n# The kernel reads uchar4 but uses .x(r), .y(g), .z(b).\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n# Set alpha to 255 for consistency, though kernel ignores input alpha\nimg_data[:, :, 3] = 255\n\n# Compute Reference\n# Remove alpha for processing convenience as kernel calculates luminance from RGB\nimg_rgb = img_data[:, :, :3]\nref_out = process_cpu(img_rgb, RADIUS, THRESHOLD, HIGHLIGHT)\n\n# Save Data\nos.makedirs(\"data\", exist_ok=True)\nimg_data.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n    \n    # Unpack to compare channels individually\n    # Packed: (A << 24) | (B << 16) | (G << 8) | R\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    \n    # Calculate diffs\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Allow small difference due to float/accumulation precision differences\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 2048\n    HEIGHT = 2048\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Post_Process_GL kernel that processes a 2048x2048 RGBA input image (8-bit per channel) to produce a 2048x2048 output image (32-bit packed integers). For each output pixel, compute a disc-shaped convolution within radius 4 around the corresponding input pixel. For neighborhood pixels within the disc, brighten RGB components by factor 2.0 if their luminance (average of RGB values) exceeds 0.8, then compute the average RGB values across valid neighborhood pixels. Pack the resulting RGB values into a 32-bit integer in ABGR format (alpha=255) with clamped [0,255] values.", "level2_prompt": "Compute output image where each pixel is the average of input pixels within a circular neighborhood of radius 4. Apply highlight enhancement (2x multiplier) to neighborhood pixels with luminance >0.8 before averaging. Pack averaged RGB values into 32-bit ABGR integers.", "level3_prompt": "Compute the Post_Process_GL kernel on GPU using CUDA."}
{"id": 5, "task_name": "Recursive_Gaussian", "task_description": "Compute the Recursive_Gaussian kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint32", "shape": "(512, 512)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n// ----------------------------------------------------------------------------\n// Macros and Helpers\n// ----------------------------------------------------------------------------\n#define CLAMP_TO_EDGE 1\n\ntypedef unsigned int uint;\n\n// Helper to convert uint (RGBA 8-bit packed) to float4\n__device__ inline float4 rgbaIntToFloat(uint c) {\n    float4 rgba;\n    rgba.x = (float)(c & 0xff);\n    rgba.y = (float)((c >> 8) & 0xff);\n    rgba.z = (float)((c >> 16) & 0xff);\n    rgba.w = (float)((c >> 24) & 0xff);\n    return rgba;\n}\n\n// Helper to convert float4 to uint (RGBA 8-bit packed)\n__device__ inline uint rgbaFloatToInt(float4 rgba) {\n    rgba.x = __saturatef(rgba.x / 255.0f);\n    rgba.y = __saturatef(rgba.y / 255.0f);\n    rgba.z = __saturatef(rgba.z / 255.0f);\n    rgba.w = __saturatef(rgba.w / 255.0f);\n    return ((uint)(rgba.w * 255.0f) << 24) |\n           ((uint)(rgba.z * 255.0f) << 16) |\n           ((uint)(rgba.y * 255.0f) << 8) |\n           ((uint)(rgba.x * 255.0f));\n}\n\n// Overloaded arithmetic operators for float4\n__device__ inline float4 operator+(float4 a, float4 b) {\n    return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n}\n__device__ inline float4 operator-(float4 a, float4 b) {\n    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n}\n__device__ inline float4 operator*(float4 a, float s) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n__device__ inline float4 operator*(float s, float4 a) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void d_recursiveGaussian_rgba(uint *id,\n                                         uint *od,\n                                         int   w,\n                                         int   h,\n                                         float a0,\n                                         float a1,\n                                         float a2,\n                                         float a3,\n                                         float b1,\n                                         float b2,\n                                         float coefp,\n                                         float coefn)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (x >= w)\n        return;\n\n    id += x; // advance pointers to correct column\n    od += x;\n\n    // forward pass\n    float4 xp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous input\n    float4 yp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output\n    float4 yb = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output by 2\n#if CLAMP_TO_EDGE\n    xp = rgbaIntToFloat(*id);\n    yb = coefp * xp;\n    yp = yb;\n#endif\n\n    for (int y = 0; y < h; y++) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb;\n        *od       = rgbaFloatToInt(yc);\n        id += w;\n        od += w; // move to next row\n        xp = xc;\n        yb = yp;\n        yp = yc;\n    }\n\n    // reset pointers to point to last element in column\n    id -= w;\n    od -= w;\n\n    // reverse pass\n    // ensures response is symmetrical\n    float4 xn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 xa = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 yn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 ya = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n#if CLAMP_TO_EDGE\n    xn = xa = rgbaIntToFloat(*id);\n    yn      = coefn * xn;\n    ya      = yn;\n#endif\n\n    for (int y = h - 1; y >= 0; y--) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya;\n        xa        = xn;\n        xn        = xc;\n        ya        = yn;\n        yn        = yc;\n        // Combining forward and reverse passes\n        // We read the current forward result from *od, add reverse component, and store back\n        float4 forward_res = rgbaIntToFloat(*od);\n        *od       = rgbaFloatToInt(forward_res + yc);\n        id -= w;\n        od -= w; // move to previous row\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// Precompute coefficients for the recursive filter\nvoid computeCoefficients(float sigma, float* a0, float* a1, float* a2, float* a3,\n                         float* b1, float* b2, float* coefp, float* coefn) {\n    float alpha = 1.695f / sigma;\n    float ema = std::exp(-alpha);\n    float ema2 = std::exp(-2.0f * alpha);\n    *b1 = -2.0f * ema;\n    *b2 = ema2;\n    float k = (1.0f - ema) * (1.0f - ema) / (1.0f + 2.0f * alpha * ema - ema2);\n    *a0 = k;\n    *a1 = k * (alpha - 1.0f) * ema;\n    *a2 = k * (alpha + 1.0f) * ema;\n    *a3 = -k * ema2;\n    *coefp = (*a0 + *a1) / (1.0f + *b1 + *b2);\n    *coefn = (*a2 + *a3) / (1.0f + *b1 + *b2);\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 512;\n    const int height = 512;\n    const float sigma = 10.0f;\n\n    size_t img_size = width * height * sizeof(uint);\n\n    // Host alloc\n    uint* h_in = new uint[width * height];\n    uint* h_out = new uint[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size);\n\n    // Compute Filter Coefficients\n    float a0, a1, a2, a3, b1, b2, coefp, coefn;\n    computeCoefficients(sigma, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn);\n\n    // Device alloc\n    uint *d_in, *d_out;\n    cudaMalloc(&d_in, img_size);\n    cudaMalloc(&d_out, img_size);\n\n    cudaMemcpy(d_in, h_in, img_size, cudaMemcpyHostToDevice);\n\n    // Launch Config\n    // This kernel processes columns vertically.\n    // One thread per column.\n    int threads = 256;\n    int blocks = (width + threads - 1) / threads;\n\n    d_recursiveGaussian_rgba<<<blocks, threads>>>(\n        d_in,\n        d_out,\n        width,\n        height,\n        a0, a1, a2, a3, b1, b2, coefp, coefn\n    );\n\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_out, d_out, img_size, cudaMemcpyDeviceToHost);\n\n    // Write Output\n    write_binary(\"data/output_img.bin\", h_out, img_size);\n\n    // Cleanup\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\n# Constants\nWIDTH = 512\nHEIGHT = 512\nSIGMA = 10.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef compute_coefficients(sigma):\n    alpha = 1.695 / sigma\n    ema = math.exp(-alpha)\n    ema2 = math.exp(-2.0 * alpha)\n    b1 = -2.0 * ema\n    b2 = ema2\n    k = (1.0 - ema) * (1.0 - ema) / (1.0 + 2.0 * alpha * ema - ema2)\n    a0 = k\n    a1 = k * (alpha - 1.0) * ema\n    a2 = k * (alpha + 1.0) * ema\n    a3 = -k * ema2\n    coefp = (a0 + a1) / (1.0 + b1 + b2)\n    coefn = (a2 + a3) / (1.0 + b1 + b2)\n    return a0, a1, a2, a3, b1, b2, coefp, coefn\n\ndef recursive_gaussian_column(img, h, w, coeffs):\n    a0, a1, a2, a3, b1, b2, coefp, coefn = coeffs\n    \n    # We process each column independently.\n    # img is (H, W, 4)\n    # Output buffer\n    # Use float for precision during calc\n    result = np.zeros_like(img, dtype=np.float32)\n    \n    # Forward pass\n    # y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2]\n    \n    # Python loops are slow but explicit for matching kernel logic\n    # Vectorize across columns (W) for performance\n    \n    # Initialize buffers for W columns\n    xp = np.zeros((w, 4), dtype=np.float32) # x[i-1]\n    yp = np.zeros((w, 4), dtype=np.float32) # y[i-1]\n    yb = np.zeros((w, 4), dtype=np.float32) # y[i-2]\n    \n    # Initial condition (CLAMP_TO_EDGE)\n    # xp = x[0]\n    # yb = coefp * xp\n    # yp = yb\n    xp = img[0].astype(np.float32)\n    yb = coefp * xp\n    yp = yb\n    \n    forward_res = np.zeros_like(img, dtype=np.float32)\n    \n    for y in range(h):\n        xc = img[y].astype(np.float32)\n        yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb\n        forward_res[y] = yc\n        \n        xp = xc\n        yb = yp\n        yp = yc\n\n    # Reverse pass\n    # Result is sum of forward and reverse\n    # Reverse filter:\n    # y[i] = a2*x[i+1] + a3*x[i+2] - b1*y[i+1] - b2*y[i+2]\n    # Implemented as backward iteration\n    \n    xn = np.zeros((w, 4), dtype=np.float32) # x[i+1]\n    xa = np.zeros((w, 4), dtype=np.float32) # x[i+2]\n    yn = np.zeros((w, 4), dtype=np.float32) # y[i+1]\n    ya = np.zeros((w, 4), dtype=np.float32) # y[i+2]\n    \n    # Initial condition (CLAMP_TO_EDGE) at y = h-1\n    # xn = xa = x[h-1]\n    # yn = coefn * xn\n    # ya = yn\n    xn = img[h-1].astype(np.float32)\n    xa = xn\n    yn = coefn * xn\n    ya = yn\n    \n    for y in range(h-1, -1, -1):\n        xc = img[y].astype(np.float32)\n        yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya\n        \n        xa = xn\n        xn = xc\n        ya = yn\n        yn = yc\n        \n        # Combine\n        # Kernel: *od = rgbaFloatToInt(forward + yc)\n        result[y] = forward_res[y] + yc\n\n    return result\n\n# Generate Random Data\n# Shape (H, W, 4) for RGBA\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n\n# Pack for binary file\n# (R, G, B, A) -> uint32\npacked_img = (img_data[:,:,3].astype(np.uint32) << 24) | \\\n             (img_data[:,:,2].astype(np.uint32) << 16) | \\\n             (img_data[:,:,1].astype(np.uint32) << 8)  | \\\n             (img_data[:,:,0].astype(np.uint32))\n\n# Compute Reference\ncoeffs = compute_coefficients(SIGMA)\nref_float = recursive_gaussian_column(img_data, HEIGHT, WIDTH, coeffs)\n\n# Convert reference back to packed uint32\nref_float = np.clip(ref_float, 0.0, 255.0)\nref_out = (ref_float[:,:,3].astype(np.uint32) << 24) | \\\n          (ref_float[:,:,2].astype(np.uint32) << 16) | \\\n          (ref_float[:,:,1].astype(np.uint32) << 8)  | \\\n          (ref_float[:,:,0].astype(np.uint32))\n\n# Save\nos.makedirs(\"data\", exist_ok=True)\npacked_img.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    # Unpack\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    out_a = (output >> 24) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    ref_a = (reference >> 24) & 0xFF\n    \n    # Diff\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    diff_a = np.abs(out_a.astype(np.int16) - ref_a.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b), np.max(diff_a))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Typically 1 or 2 due to rounding differences in float->int conversion\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 512\n    HEIGHT = 512\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    # Using tolerance=2 to account for precision differences in the recursive accumulation\n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT, tolerance=2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a Recursive Gaussian filter kernel. The input is a 512x512 image where each pixel is a 32-bit unsigned integer representing RGBA channels. The output must be a 512x512 image with the same data type. The kernel must process each image column independently, applying a recursive filter with forward and reverse passes. Boundary conditions clamp to edge pixels. The filter uses precomputed coefficients (a0, a1, a2, a3, b1, b2, coefp, coefn) derived from Gaussian sigma. Final pixel values combine both passes.", "level2_prompt": "Apply a recursive Gaussian filter column-wise. For each column: First, compute a forward pass: y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2], starting from the top with clamped edge conditions. Then compute a reverse pass: y_rev[i] = a2*x[i+1] + a3*x[i+2] - b1*y_rev[i+1] - b2*y_rev[i+2], starting from the bottom with clamped edge conditions. Sum the forward and reverse results for the final output.", "level3_prompt": "Compute the Recursive Gaussian kernel on GPU using CUDA."}
{"id": 6, "task_name": "Recursive_Gaussian", "task_description": "Compute the Recursive_Gaussian kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint32", "shape": "(1024, 1024)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n// ----------------------------------------------------------------------------\n// Macros and Helpers\n// ----------------------------------------------------------------------------\n#define CLAMP_TO_EDGE 1\n\ntypedef unsigned int uint;\n\n// Helper to convert uint (RGBA 8-bit packed) to float4\n__device__ inline float4 rgbaIntToFloat(uint c) {\n    float4 rgba;\n    rgba.x = (float)(c & 0xff);\n    rgba.y = (float)((c >> 8) & 0xff);\n    rgba.z = (float)((c >> 16) & 0xff);\n    rgba.w = (float)((c >> 24) & 0xff);\n    return rgba;\n}\n\n// Helper to convert float4 to uint (RGBA 8-bit packed)\n__device__ inline uint rgbaFloatToInt(float4 rgba) {\n    rgba.x = __saturatef(rgba.x / 255.0f);\n    rgba.y = __saturatef(rgba.y / 255.0f);\n    rgba.z = __saturatef(rgba.z / 255.0f);\n    rgba.w = __saturatef(rgba.w / 255.0f);\n    return ((uint)(rgba.w * 255.0f) << 24) |\n           ((uint)(rgba.z * 255.0f) << 16) |\n           ((uint)(rgba.y * 255.0f) << 8) |\n           ((uint)(rgba.x * 255.0f));\n}\n\n// Overloaded arithmetic operators for float4\n__device__ inline float4 operator+(float4 a, float4 b) {\n    return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n}\n__device__ inline float4 operator-(float4 a, float4 b) {\n    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n}\n__device__ inline float4 operator*(float4 a, float s) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n__device__ inline float4 operator*(float s, float4 a) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void d_recursiveGaussian_rgba(uint *id,\n                                         uint *od,\n                                         int   w,\n                                         int   h,\n                                         float a0,\n                                         float a1,\n                                         float a2,\n                                         float a3,\n                                         float b1,\n                                         float b2,\n                                         float coefp,\n                                         float coefn)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (x >= w)\n        return;\n\n    id += x; // advance pointers to correct column\n    od += x;\n\n    // forward pass\n    float4 xp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous input\n    float4 yp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output\n    float4 yb = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output by 2\n#if CLAMP_TO_EDGE\n    xp = rgbaIntToFloat(*id);\n    yb = coefp * xp;\n    yp = yb;\n#endif\n\n    for (int y = 0; y < h; y++) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb;\n        *od       = rgbaFloatToInt(yc);\n        id += w;\n        od += w; // move to next row\n        xp = xc;\n        yb = yp;\n        yp = yc;\n    }\n\n    // reset pointers to point to last element in column\n    id -= w;\n    od -= w;\n\n    // reverse pass\n    // ensures response is symmetrical\n    float4 xn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 xa = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 yn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 ya = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n#if CLAMP_TO_EDGE\n    xn = xa = rgbaIntToFloat(*id);\n    yn      = coefn * xn;\n    ya      = yn;\n#endif\n\n    for (int y = h - 1; y >= 0; y--) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya;\n        xa        = xn;\n        xn        = xc;\n        ya        = yn;\n        yn        = yc;\n        // Combining forward and reverse passes\n        // We read the current forward result from *od, add reverse component, and store back\n        float4 forward_res = rgbaIntToFloat(*od);\n        *od       = rgbaFloatToInt(forward_res + yc);\n        id -= w;\n        od -= w; // move to previous row\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// Precompute coefficients for the recursive filter\nvoid computeCoefficients(float sigma, float* a0, float* a1, float* a2, float* a3,\n                         float* b1, float* b2, float* coefp, float* coefn) {\n    float alpha = 1.695f / sigma;\n    float ema = std::exp(-alpha);\n    float ema2 = std::exp(-2.0f * alpha);\n    *b1 = -2.0f * ema;\n    *b2 = ema2;\n    float k = (1.0f - ema) * (1.0f - ema) / (1.0f + 2.0f * alpha * ema - ema2);\n    *a0 = k;\n    *a1 = k * (alpha - 1.0f) * ema;\n    *a2 = k * (alpha + 1.0f) * ema;\n    *a3 = -k * ema2;\n    *coefp = (*a0 + *a1) / (1.0f + *b1 + *b2);\n    *coefn = (*a2 + *a3) / (1.0f + *b1 + *b2);\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 1024;\n    const int height = 1024;\n    const float sigma = 10.0f;\n\n    size_t img_size = width * height * sizeof(uint);\n\n    // Host alloc\n    uint* h_in = new uint[width * height];\n    uint* h_out = new uint[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size);\n\n    // Compute Filter Coefficients\n    float a0, a1, a2, a3, b1, b2, coefp, coefn;\n    computeCoefficients(sigma, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn);\n\n    // Device alloc\n    uint *d_in, *d_out;\n    cudaMalloc(&d_in, img_size);\n    cudaMalloc(&d_out, img_size);\n\n    cudaMemcpy(d_in, h_in, img_size, cudaMemcpyHostToDevice);\n\n    // Launch Config\n    // This kernel processes columns vertically.\n    // One thread per column.\n    int threads = 256;\n    int blocks = (width + threads - 1) / threads;\n\n    d_recursiveGaussian_rgba<<<blocks, threads>>>(\n        d_in,\n        d_out,\n        width,\n        height,\n        a0, a1, a2, a3, b1, b2, coefp, coefn\n    );\n\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_out, d_out, img_size, cudaMemcpyDeviceToHost);\n\n    // Write Output\n    write_binary(\"data/output_img.bin\", h_out, img_size);\n\n    // Cleanup\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\n# Constants\nWIDTH = 1024\nHEIGHT = 1024\nSIGMA = 10.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef compute_coefficients(sigma):\n    alpha = 1.695 / sigma\n    ema = math.exp(-alpha)\n    ema2 = math.exp(-2.0 * alpha)\n    b1 = -2.0 * ema\n    b2 = ema2\n    k = (1.0 - ema) * (1.0 - ema) / (1.0 + 2.0 * alpha * ema - ema2)\n    a0 = k\n    a1 = k * (alpha - 1.0) * ema\n    a2 = k * (alpha + 1.0) * ema\n    a3 = -k * ema2\n    coefp = (a0 + a1) / (1.0 + b1 + b2)\n    coefn = (a2 + a3) / (1.0 + b1 + b2)\n    return a0, a1, a2, a3, b1, b2, coefp, coefn\n\ndef recursive_gaussian_column(img, h, w, coeffs):\n    a0, a1, a2, a3, b1, b2, coefp, coefn = coeffs\n    \n    # We process each column independently.\n    # img is (H, W, 4)\n    # Output buffer\n    # Use float for precision during calc\n    result = np.zeros_like(img, dtype=np.float32)\n    \n    # Forward pass\n    # y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2]\n    \n    # Python loops are slow but explicit for matching kernel logic\n    # Vectorize across columns (W) for performance\n    \n    # Initialize buffers for W columns\n    xp = np.zeros((w, 4), dtype=np.float32) # x[i-1]\n    yp = np.zeros((w, 4), dtype=np.float32) # y[i-1]\n    yb = np.zeros((w, 4), dtype=np.float32) # y[i-2]\n    \n    # Initial condition (CLAMP_TO_EDGE)\n    # xp = x[0]\n    # yb = coefp * xp\n    # yp = yb\n    xp = img[0].astype(np.float32)\n    yb = coefp * xp\n    yp = yb\n    \n    forward_res = np.zeros_like(img, dtype=np.float32)\n    \n    for y in range(h):\n        xc = img[y].astype(np.float32)\n        yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb\n        forward_res[y] = yc\n        \n        xp = xc\n        yb = yp\n        yp = yc\n\n    # Reverse pass\n    # Result is sum of forward and reverse\n    # Reverse filter:\n    # y[i] = a2*x[i+1] + a3*x[i+2] - b1*y[i+1] - b2*y[i+2]\n    # Implemented as backward iteration\n    \n    xn = np.zeros((w, 4), dtype=np.float32) # x[i+1]\n    xa = np.zeros((w, 4), dtype=np.float32) # x[i+2]\n    yn = np.zeros((w, 4), dtype=np.float32) # y[i+1]\n    ya = np.zeros((w, 4), dtype=np.float32) # y[i+2]\n    \n    # Initial condition (CLAMP_TO_EDGE) at y = h-1\n    # xn = xa = x[h-1]\n    # yn = coefn * xn\n    # ya = yn\n    xn = img[h-1].astype(np.float32)\n    xa = xn\n    yn = coefn * xn\n    ya = yn\n    \n    for y in range(h-1, -1, -1):\n        xc = img[y].astype(np.float32)\n        yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya\n        \n        xa = xn\n        xn = xc\n        ya = yn\n        yn = yc\n        \n        # Combine\n        # Kernel: *od = rgbaFloatToInt(forward + yc)\n        result[y] = forward_res[y] + yc\n\n    return result\n\n# Generate Random Data\n# Shape (H, W, 4) for RGBA\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n\n# Pack for binary file\n# (R, G, B, A) -> uint32\npacked_img = (img_data[:,:,3].astype(np.uint32) << 24) | \\\n             (img_data[:,:,2].astype(np.uint32) << 16) | \\\n             (img_data[:,:,1].astype(np.uint32) << 8)  | \\\n             (img_data[:,:,0].astype(np.uint32))\n\n# Compute Reference\ncoeffs = compute_coefficients(SIGMA)\nref_float = recursive_gaussian_column(img_data, HEIGHT, WIDTH, coeffs)\n\n# Convert reference back to packed uint32\nref_float = np.clip(ref_float, 0.0, 255.0)\nref_out = (ref_float[:,:,3].astype(np.uint32) << 24) | \\\n          (ref_float[:,:,2].astype(np.uint32) << 16) | \\\n          (ref_float[:,:,1].astype(np.uint32) << 8)  | \\\n          (ref_float[:,:,0].astype(np.uint32))\n\n# Save\nos.makedirs(\"data\", exist_ok=True)\npacked_img.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    # Unpack\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    out_a = (output >> 24) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    ref_a = (reference >> 24) & 0xFF\n    \n    # Diff\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    diff_a = np.abs(out_a.astype(np.int16) - ref_a.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b), np.max(diff_a))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Typically 1 or 2 due to rounding differences in float->int conversion\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 1024\n    HEIGHT = 1024\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    # Using tolerance=2 to account for precision differences in the recursive accumulation\n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT, tolerance=2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a recursive Gaussian filter kernel for image processing. The input is a 1024x1024 image where each pixel is stored as a 32-bit unsigned integer representing RGBA values (8 bits per channel). The output should be a filtered image of the same dimensions and data type. The kernel must process each image column independently using a two-pass approach: a forward pass from top to bottom and a reverse pass from bottom to top. Boundary conditions must clamp to the edge pixels. Filter coefficients (a0, a1, a2, a3, b1, b2, coefp, coefn) are provided as parameters.", "level2_prompt": "Apply a recursive Gaussian filter column-wise to an image. For each column, compute a forward pass where each output pixel depends on current and previous inputs/outputs using recurrence relations, then compute a reverse pass where each output pixel depends on subsequent inputs/outputs. Combine results from both passes to produce the final filtered image.", "level3_prompt": "Compute the Recursive Gaussian kernel on an input image."}
{"id": 7, "task_name": "Recursive_Gaussian", "task_description": "Compute the Recursive_Gaussian kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint32", "shape": "(2048, 2048)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n// ----------------------------------------------------------------------------\n// Macros and Helpers\n// ----------------------------------------------------------------------------\n#define CLAMP_TO_EDGE 1\n\ntypedef unsigned int uint;\n\n// Helper to convert uint (RGBA 8-bit packed) to float4\n__device__ inline float4 rgbaIntToFloat(uint c) {\n    float4 rgba;\n    rgba.x = (float)(c & 0xff);\n    rgba.y = (float)((c >> 8) & 0xff);\n    rgba.z = (float)((c >> 16) & 0xff);\n    rgba.w = (float)((c >> 24) & 0xff);\n    return rgba;\n}\n\n// Helper to convert float4 to uint (RGBA 8-bit packed)\n__device__ inline uint rgbaFloatToInt(float4 rgba) {\n    rgba.x = __saturatef(rgba.x / 255.0f);\n    rgba.y = __saturatef(rgba.y / 255.0f);\n    rgba.z = __saturatef(rgba.z / 255.0f);\n    rgba.w = __saturatef(rgba.w / 255.0f);\n    return ((uint)(rgba.w * 255.0f) << 24) |\n           ((uint)(rgba.z * 255.0f) << 16) |\n           ((uint)(rgba.y * 255.0f) << 8) |\n           ((uint)(rgba.x * 255.0f));\n}\n\n// Overloaded arithmetic operators for float4\n__device__ inline float4 operator+(float4 a, float4 b) {\n    return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n}\n__device__ inline float4 operator-(float4 a, float4 b) {\n    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n}\n__device__ inline float4 operator*(float4 a, float s) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n__device__ inline float4 operator*(float s, float4 a) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void d_recursiveGaussian_rgba(uint *id,\n                                         uint *od,\n                                         int   w,\n                                         int   h,\n                                         float a0,\n                                         float a1,\n                                         float a2,\n                                         float a3,\n                                         float b1,\n                                         float b2,\n                                         float coefp,\n                                         float coefn)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (x >= w)\n        return;\n\n    id += x; // advance pointers to correct column\n    od += x;\n\n    // forward pass\n    float4 xp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous input\n    float4 yp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output\n    float4 yb = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output by 2\n#if CLAMP_TO_EDGE\n    xp = rgbaIntToFloat(*id);\n    yb = coefp * xp;\n    yp = yb;\n#endif\n\n    for (int y = 0; y < h; y++) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb;\n        *od       = rgbaFloatToInt(yc);\n        id += w;\n        od += w; // move to next row\n        xp = xc;\n        yb = yp;\n        yp = yc;\n    }\n\n    // reset pointers to point to last element in column\n    id -= w;\n    od -= w;\n\n    // reverse pass\n    // ensures response is symmetrical\n    float4 xn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 xa = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 yn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 ya = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n#if CLAMP_TO_EDGE\n    xn = xa = rgbaIntToFloat(*id);\n    yn      = coefn * xn;\n    ya      = yn;\n#endif\n\n    for (int y = h - 1; y >= 0; y--) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya;\n        xa        = xn;\n        xn        = xc;\n        ya        = yn;\n        yn        = yc;\n        // Combining forward and reverse passes\n        // We read the current forward result from *od, add reverse component, and store back\n        float4 forward_res = rgbaIntToFloat(*od);\n        *od       = rgbaFloatToInt(forward_res + yc);\n        id -= w;\n        od -= w; // move to previous row\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// Precompute coefficients for the recursive filter\nvoid computeCoefficients(float sigma, float* a0, float* a1, float* a2, float* a3,\n                         float* b1, float* b2, float* coefp, float* coefn) {\n    float alpha = 1.695f / sigma;\n    float ema = std::exp(-alpha);\n    float ema2 = std::exp(-2.0f * alpha);\n    *b1 = -2.0f * ema;\n    *b2 = ema2;\n    float k = (1.0f - ema) * (1.0f - ema) / (1.0f + 2.0f * alpha * ema - ema2);\n    *a0 = k;\n    *a1 = k * (alpha - 1.0f) * ema;\n    *a2 = k * (alpha + 1.0f) * ema;\n    *a3 = -k * ema2;\n    *coefp = (*a0 + *a1) / (1.0f + *b1 + *b2);\n    *coefn = (*a2 + *a3) / (1.0f + *b1 + *b2);\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 2048;\n    const int height = 2048;\n    const float sigma = 10.0f;\n\n    size_t img_size = width * height * sizeof(uint);\n\n    // Host alloc\n    uint* h_in = new uint[width * height];\n    uint* h_out = new uint[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size);\n\n    // Compute Filter Coefficients\n    float a0, a1, a2, a3, b1, b2, coefp, coefn;\n    computeCoefficients(sigma, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn);\n\n    // Device alloc\n    uint *d_in, *d_out;\n    cudaMalloc(&d_in, img_size);\n    cudaMalloc(&d_out, img_size);\n\n    cudaMemcpy(d_in, h_in, img_size, cudaMemcpyHostToDevice);\n\n    // Launch Config\n    // This kernel processes columns vertically.\n    // One thread per column.\n    int threads = 256;\n    int blocks = (width + threads - 1) / threads;\n\n    d_recursiveGaussian_rgba<<<blocks, threads>>>(\n        d_in,\n        d_out,\n        width,\n        height,\n        a0, a1, a2, a3, b1, b2, coefp, coefn\n    );\n\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_out, d_out, img_size, cudaMemcpyDeviceToHost);\n\n    // Write Output\n    write_binary(\"data/output_img.bin\", h_out, img_size);\n\n    // Cleanup\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\n# Constants\nWIDTH = 2048\nHEIGHT = 2048\nSIGMA = 10.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef compute_coefficients(sigma):\n    alpha = 1.695 / sigma\n    ema = math.exp(-alpha)\n    ema2 = math.exp(-2.0 * alpha)\n    b1 = -2.0 * ema\n    b2 = ema2\n    k = (1.0 - ema) * (1.0 - ema) / (1.0 + 2.0 * alpha * ema - ema2)\n    a0 = k\n    a1 = k * (alpha - 1.0) * ema\n    a2 = k * (alpha + 1.0) * ema\n    a3 = -k * ema2\n    coefp = (a0 + a1) / (1.0 + b1 + b2)\n    coefn = (a2 + a3) / (1.0 + b1 + b2)\n    return a0, a1, a2, a3, b1, b2, coefp, coefn\n\ndef recursive_gaussian_column(img, h, w, coeffs):\n    a0, a1, a2, a3, b1, b2, coefp, coefn = coeffs\n    \n    # We process each column independently.\n    # img is (H, W, 4)\n    # Output buffer\n    # Use float for precision during calc\n    result = np.zeros_like(img, dtype=np.float32)\n    \n    # Forward pass\n    # y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2]\n    \n    # Python loops are slow but explicit for matching kernel logic\n    # Vectorize across columns (W) for performance\n    \n    # Initialize buffers for W columns\n    xp = np.zeros((w, 4), dtype=np.float32) # x[i-1]\n    yp = np.zeros((w, 4), dtype=np.float32) # y[i-1]\n    yb = np.zeros((w, 4), dtype=np.float32) # y[i-2]\n    \n    # Initial condition (CLAMP_TO_EDGE)\n    # xp = x[0]\n    # yb = coefp * xp\n    # yp = yb\n    xp = img[0].astype(np.float32)\n    yb = coefp * xp\n    yp = yb\n    \n    forward_res = np.zeros_like(img, dtype=np.float32)\n    \n    for y in range(h):\n        xc = img[y].astype(np.float32)\n        yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb\n        forward_res[y] = yc\n        \n        xp = xc\n        yb = yp\n        yp = yc\n\n    # Reverse pass\n    # Result is sum of forward and reverse\n    # Reverse filter:\n    # y[i] = a2*x[i+1] + a3*x[i+2] - b1*y[i+1] - b2*y[i+2]\n    # Implemented as backward iteration\n    \n    xn = np.zeros((w, 4), dtype=np.float32) # x[i+1]\n    xa = np.zeros((w, 4), dtype=np.float32) # x[i+2]\n    yn = np.zeros((w, 4), dtype=np.float32) # y[i+1]\n    ya = np.zeros((w, 4), dtype=np.float32) # y[i+2]\n    \n    # Initial condition (CLAMP_TO_EDGE) at y = h-1\n    # xn = xa = x[h-1]\n    # yn = coefn * xn\n    # ya = yn\n    xn = img[h-1].astype(np.float32)\n    xa = xn\n    yn = coefn * xn\n    ya = yn\n    \n    for y in range(h-1, -1, -1):\n        xc = img[y].astype(np.float32)\n        yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya\n        \n        xa = xn\n        xn = xc\n        ya = yn\n        yn = yc\n        \n        # Combine\n        # Kernel: *od = rgbaFloatToInt(forward + yc)\n        result[y] = forward_res[y] + yc\n\n    return result\n\n# Generate Random Data\n# Shape (H, W, 4) for RGBA\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n\n# Pack for binary file\n# (R, G, B, A) -> uint32\npacked_img = (img_data[:,:,3].astype(np.uint32) << 24) | \\\n             (img_data[:,:,2].astype(np.uint32) << 16) | \\\n             (img_data[:,:,1].astype(np.uint32) << 8)  | \\\n             (img_data[:,:,0].astype(np.uint32))\n\n# Compute Reference\ncoeffs = compute_coefficients(SIGMA)\nref_float = recursive_gaussian_column(img_data, HEIGHT, WIDTH, coeffs)\n\n# Convert reference back to packed uint32\nref_float = np.clip(ref_float, 0.0, 255.0)\nref_out = (ref_float[:,:,3].astype(np.uint32) << 24) | \\\n          (ref_float[:,:,2].astype(np.uint32) << 16) | \\\n          (ref_float[:,:,1].astype(np.uint32) << 8)  | \\\n          (ref_float[:,:,0].astype(np.uint32))\n\n# Save\nos.makedirs(\"data\", exist_ok=True)\npacked_img.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    # Unpack\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    out_a = (output >> 24) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    ref_a = (reference >> 24) & 0xFF\n    \n    # Diff\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    diff_a = np.abs(out_a.astype(np.int16) - ref_a.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b), np.max(diff_a))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Typically 1 or 2 due to rounding differences in float->int conversion\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 2048\n    HEIGHT = 2048\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    # Using tolerance=2 to account for precision differences in the recursive accumulation\n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT, tolerance=2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named Recursive_Gaussian that applies a recursive Gaussian filter to an input image. The input is a 2048x2048 2D tensor of uint32 values representing RGBA pixels (8 bits per channel). The output is a filtered image of the same shape and data type. The kernel must process each column independently with one thread per column, implement both forward and reverse passes for symmetry, clamp to edge at boundaries, convert RGBA values between uint32 and float4 for processing, and use precomputed filter coefficients.", "level2_prompt": "The Recursive_Gaussian task involves applying a recursive Gaussian filter to image columns. Each thread processes one column vertically. The algorithm consists of a forward pass (top-to-bottom) using the recurrence relation y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2], and a reverse pass (bottom-to-top) using y[i] = a2*x[i+1] + a3*x[i+2] - b1*y[i+1] - b2*y[i+2]. The final output combines both passes. Boundary conditions clamp to edge values.", "level3_prompt": "Compute the Recursive_Gaussian kernel on GPU using CUDA."}
{"id": 8, "task_name": "Recursive_Gaussian", "task_description": "Compute the Recursive_Gaussian kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint32", "shape": "(4096, 4096)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n// ----------------------------------------------------------------------------\n// Macros and Helpers\n// ----------------------------------------------------------------------------\n#define CLAMP_TO_EDGE 1\n\ntypedef unsigned int uint;\n\n// Helper to convert uint (RGBA 8-bit packed) to float4\n__device__ inline float4 rgbaIntToFloat(uint c) {\n    float4 rgba;\n    rgba.x = (float)(c & 0xff);\n    rgba.y = (float)((c >> 8) & 0xff);\n    rgba.z = (float)((c >> 16) & 0xff);\n    rgba.w = (float)((c >> 24) & 0xff);\n    return rgba;\n}\n\n// Helper to convert float4 to uint (RGBA 8-bit packed)\n__device__ inline uint rgbaFloatToInt(float4 rgba) {\n    rgba.x = __saturatef(rgba.x / 255.0f);\n    rgba.y = __saturatef(rgba.y / 255.0f);\n    rgba.z = __saturatef(rgba.z / 255.0f);\n    rgba.w = __saturatef(rgba.w / 255.0f);\n    return ((uint)(rgba.w * 255.0f) << 24) |\n           ((uint)(rgba.z * 255.0f) << 16) |\n           ((uint)(rgba.y * 255.0f) << 8) |\n           ((uint)(rgba.x * 255.0f));\n}\n\n// Overloaded arithmetic operators for float4\n__device__ inline float4 operator+(float4 a, float4 b) {\n    return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n}\n__device__ inline float4 operator-(float4 a, float4 b) {\n    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n}\n__device__ inline float4 operator*(float4 a, float s) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n__device__ inline float4 operator*(float s, float4 a) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void d_recursiveGaussian_rgba(uint *id,\n                                         uint *od,\n                                         int   w,\n                                         int   h,\n                                         float a0,\n                                         float a1,\n                                         float a2,\n                                         float a3,\n                                         float b1,\n                                         float b2,\n                                         float coefp,\n                                         float coefn)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (x >= w)\n        return;\n\n    id += x; // advance pointers to correct column\n    od += x;\n\n    // forward pass\n    float4 xp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous input\n    float4 yp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output\n    float4 yb = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output by 2\n#if CLAMP_TO_EDGE\n    xp = rgbaIntToFloat(*id);\n    yb = coefp * xp;\n    yp = yb;\n#endif\n\n    for (int y = 0; y < h; y++) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb;\n        *od       = rgbaFloatToInt(yc);\n        id += w;\n        od += w; // move to next row\n        xp = xc;\n        yb = yp;\n        yp = yc;\n    }\n\n    // reset pointers to point to last element in column\n    id -= w;\n    od -= w;\n\n    // reverse pass\n    // ensures response is symmetrical\n    float4 xn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 xa = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 yn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 ya = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n#if CLAMP_TO_EDGE\n    xn = xa = rgbaIntToFloat(*id);\n    yn      = coefn * xn;\n    ya      = yn;\n#endif\n\n    for (int y = h - 1; y >= 0; y--) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya;\n        xa        = xn;\n        xn        = xc;\n        ya        = yn;\n        yn        = yc;\n        // Combining forward and reverse passes\n        // We read the current forward result from *od, add reverse component, and store back\n        float4 forward_res = rgbaIntToFloat(*od);\n        *od       = rgbaFloatToInt(forward_res + yc);\n        id -= w;\n        od -= w; // move to previous row\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// Precompute coefficients for the recursive filter\nvoid computeCoefficients(float sigma, float* a0, float* a1, float* a2, float* a3,\n                         float* b1, float* b2, float* coefp, float* coefn) {\n    float alpha = 1.695f / sigma;\n    float ema = std::exp(-alpha);\n    float ema2 = std::exp(-2.0f * alpha);\n    *b1 = -2.0f * ema;\n    *b2 = ema2;\n    float k = (1.0f - ema) * (1.0f - ema) / (1.0f + 2.0f * alpha * ema - ema2);\n    *a0 = k;\n    *a1 = k * (alpha - 1.0f) * ema;\n    *a2 = k * (alpha + 1.0f) * ema;\n    *a3 = -k * ema2;\n    *coefp = (*a0 + *a1) / (1.0f + *b1 + *b2);\n    *coefn = (*a2 + *a3) / (1.0f + *b1 + *b2);\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 4096;\n    const int height = 4096;\n    const float sigma = 10.0f;\n\n    size_t img_size = width * height * sizeof(uint);\n\n    // Host alloc\n    uint* h_in = new uint[width * height];\n    uint* h_out = new uint[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size);\n\n    // Compute Filter Coefficients\n    float a0, a1, a2, a3, b1, b2, coefp, coefn;\n    computeCoefficients(sigma, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn);\n\n    // Device alloc\n    uint *d_in, *d_out;\n    cudaMalloc(&d_in, img_size);\n    cudaMalloc(&d_out, img_size);\n\n    cudaMemcpy(d_in, h_in, img_size, cudaMemcpyHostToDevice);\n\n    // Launch Config\n    // This kernel processes columns vertically.\n    // One thread per column.\n    int threads = 256;\n    int blocks = (width + threads - 1) / threads;\n\n    d_recursiveGaussian_rgba<<<blocks, threads>>>(\n        d_in,\n        d_out,\n        width,\n        height,\n        a0, a1, a2, a3, b1, b2, coefp, coefn\n    );\n\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_out, d_out, img_size, cudaMemcpyDeviceToHost);\n\n    // Write Output\n    write_binary(\"data/output_img.bin\", h_out, img_size);\n\n    // Cleanup\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\n# Constants\nWIDTH = 4096\nHEIGHT = 4096\nSIGMA = 10.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef compute_coefficients(sigma):\n    alpha = 1.695 / sigma\n    ema = math.exp(-alpha)\n    ema2 = math.exp(-2.0 * alpha)\n    b1 = -2.0 * ema\n    b2 = ema2\n    k = (1.0 - ema) * (1.0 - ema) / (1.0 + 2.0 * alpha * ema - ema2)\n    a0 = k\n    a1 = k * (alpha - 1.0) * ema\n    a2 = k * (alpha + 1.0) * ema\n    a3 = -k * ema2\n    coefp = (a0 + a1) / (1.0 + b1 + b2)\n    coefn = (a2 + a3) / (1.0 + b1 + b2)\n    return a0, a1, a2, a3, b1, b2, coefp, coefn\n\ndef recursive_gaussian_column(img, h, w, coeffs):\n    a0, a1, a2, a3, b1, b2, coefp, coefn = coeffs\n    \n    # We process each column independently.\n    # img is (H, W, 4)\n    # Output buffer\n    # Use float for precision during calc\n    result = np.zeros_like(img, dtype=np.float32)\n    \n    # Forward pass\n    # y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2]\n    \n    # Python loops are slow but explicit for matching kernel logic\n    # Vectorize across columns (W) for performance\n    \n    # Initialize buffers for W columns\n    xp = np.zeros((w, 4), dtype=np.float32) # x[i-1]\n    yp = np.zeros((w, 4), dtype=np.float32) # y[i-1]\n    yb = np.zeros((w, 4), dtype=np.float32) # y[i-2]\n    \n    # Initial condition (CLAMP_TO_EDGE)\n    # xp = x[0]\n    # yb = coefp * xp\n    # yp = yb\n    xp = img[0].astype(np.float32)\n    yb = coefp * xp\n    yp = yb\n    \n    forward_res = np.zeros_like(img, dtype=np.float32)\n    \n    for y in range(h):\n        xc = img[y].astype(np.float32)\n        yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb\n        forward_res[y] = yc\n        \n        xp = xc\n        yb = yp\n        yp = yc\n\n    # Reverse pass\n    # Result is sum of forward and reverse\n    # Reverse filter:\n    # y[i] = a2*x[i+1] + a3*x[i+2] - b1*y[i+1] - b2*y[i+2]\n    # Implemented as backward iteration\n    \n    xn = np.zeros((w, 4), dtype=np.float32) # x[i+1]\n    xa = np.zeros((w, 4), dtype=np.float32) # x[i+2]\n    yn = np.zeros((w, 4), dtype=np.float32) # y[i+1]\n    ya = np.zeros((w, 4), dtype=np.float32) # y[i+2]\n    \n    # Initial condition (CLAMP_TO_EDGE) at y = h-1\n    # xn = xa = x[h-1]\n    # yn = coefn * xn\n    # ya = yn\n    xn = img[h-1].astype(np.float32)\n    xa = xn\n    yn = coefn * xn\n    ya = yn\n    \n    for y in range(h-1, -1, -1):\n        xc = img[y].astype(np.float32)\n        yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya\n        \n        xa = xn\n        xn = xc\n        ya = yn\n        yn = yc\n        \n        # Combine\n        # Kernel: *od = rgbaFloatToInt(forward + yc)\n        result[y] = forward_res[y] + yc\n\n    return result\n\n# Generate Random Data\n# Shape (H, W, 4) for RGBA\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n\n# Pack for binary file\n# (R, G, B, A) -> uint32\npacked_img = (img_data[:,:,3].astype(np.uint32) << 24) | \\\n             (img_data[:,:,2].astype(np.uint32) << 16) | \\\n             (img_data[:,:,1].astype(np.uint32) << 8)  | \\\n             (img_data[:,:,0].astype(np.uint32))\n\n# Compute Reference\ncoeffs = compute_coefficients(SIGMA)\nref_float = recursive_gaussian_column(img_data, HEIGHT, WIDTH, coeffs)\n\n# Convert reference back to packed uint32\nref_float = np.clip(ref_float, 0.0, 255.0)\nref_out = (ref_float[:,:,3].astype(np.uint32) << 24) | \\\n          (ref_float[:,:,2].astype(np.uint32) << 16) | \\\n          (ref_float[:,:,1].astype(np.uint32) << 8)  | \\\n          (ref_float[:,:,0].astype(np.uint32))\n\n# Save\nos.makedirs(\"data\", exist_ok=True)\npacked_img.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    # Unpack\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    out_a = (output >> 24) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    ref_a = (reference >> 24) & 0xFF\n    \n    # Diff\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    diff_a = np.abs(out_a.astype(np.int16) - ref_a.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b), np.max(diff_a))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Typically 1 or 2 due to rounding differences in float->int conversion\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 4096\n    HEIGHT = 4096\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    # Using tolerance=2 to account for precision differences in the recursive accumulation\n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT, tolerance=2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a Recursive_Gaussian filter for image processing. The input is a 4096x4096 image where each pixel is stored as a uint32 representing RGBA channels (8 bits per channel). The output should be a flattened 16777216-element uint32 array of filtered pixel data. The kernel must independently process each image column using a two-pass approach: a forward pass (top to bottom) and reverse pass (bottom to top) with clamp-to-edge boundary conditions. Filter coefficients (a0-a3, b1-b2, coefp, coefn) are precomputed parameters. Pixel data must be converted between uint32 and floating-point representations during processing, and the final output combines results from both passes.", "level2_prompt": "Apply a recursive Gaussian filter to image columns. For each column, perform a forward pass computing filtered values using recurrence relations with previous inputs/outputs, then a reverse pass with symmetrical processing. Combine results from both passes. The filter uses precomputed coefficients and clamp-to-edge boundary conditions at column ends.", "level3_prompt": "Compute a recursive Gaussian filter on an image using GPU acceleration."}
{"id": 9, "task_name": "Recursive_Gaussian", "task_description": "Compute the Recursive_Gaussian kernel on GPU using CUDA.", "inputs": [{"name": "input_img", "dtype": "uint32", "shape": "(8192, 8192)"}], "outputs": [{"name": "output_img", "dtype": "uint32", "shape": "(67108864,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n// ----------------------------------------------------------------------------\n// Macros and Helpers\n// ----------------------------------------------------------------------------\n#define CLAMP_TO_EDGE 1\n\ntypedef unsigned int uint;\n\n// Helper to convert uint (RGBA 8-bit packed) to float4\n__device__ inline float4 rgbaIntToFloat(uint c) {\n    float4 rgba;\n    rgba.x = (float)(c & 0xff);\n    rgba.y = (float)((c >> 8) & 0xff);\n    rgba.z = (float)((c >> 16) & 0xff);\n    rgba.w = (float)((c >> 24) & 0xff);\n    return rgba;\n}\n\n// Helper to convert float4 to uint (RGBA 8-bit packed)\n__device__ inline uint rgbaFloatToInt(float4 rgba) {\n    rgba.x = __saturatef(rgba.x / 255.0f);\n    rgba.y = __saturatef(rgba.y / 255.0f);\n    rgba.z = __saturatef(rgba.z / 255.0f);\n    rgba.w = __saturatef(rgba.w / 255.0f);\n    return ((uint)(rgba.w * 255.0f) << 24) |\n           ((uint)(rgba.z * 255.0f) << 16) |\n           ((uint)(rgba.y * 255.0f) << 8) |\n           ((uint)(rgba.x * 255.0f));\n}\n\n// Overloaded arithmetic operators for float4\n__device__ inline float4 operator+(float4 a, float4 b) {\n    return make_float4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n}\n__device__ inline float4 operator-(float4 a, float4 b) {\n    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n}\n__device__ inline float4 operator*(float4 a, float s) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n__device__ inline float4 operator*(float s, float4 a) {\n    return make_float4(a.x * s, a.y * s, a.z * s, a.w * s);\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void d_recursiveGaussian_rgba(uint *id,\n                                         uint *od,\n                                         int   w,\n                                         int   h,\n                                         float a0,\n                                         float a1,\n                                         float a2,\n                                         float a3,\n                                         float b1,\n                                         float b2,\n                                         float coefp,\n                                         float coefn)\n{\n    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (x >= w)\n        return;\n\n    id += x; // advance pointers to correct column\n    od += x;\n\n    // forward pass\n    float4 xp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous input\n    float4 yp = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output\n    float4 yb = make_float4(0.0f, 0.0f, 0.0f, 0.0f); // previous output by 2\n#if CLAMP_TO_EDGE\n    xp = rgbaIntToFloat(*id);\n    yb = coefp * xp;\n    yp = yb;\n#endif\n\n    for (int y = 0; y < h; y++) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb;\n        *od       = rgbaFloatToInt(yc);\n        id += w;\n        od += w; // move to next row\n        xp = xc;\n        yb = yp;\n        yp = yc;\n    }\n\n    // reset pointers to point to last element in column\n    id -= w;\n    od -= w;\n\n    // reverse pass\n    // ensures response is symmetrical\n    float4 xn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 xa = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 yn = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n    float4 ya = make_float4(0.0f, 0.0f, 0.0f, 0.0f);\n#if CLAMP_TO_EDGE\n    xn = xa = rgbaIntToFloat(*id);\n    yn      = coefn * xn;\n    ya      = yn;\n#endif\n\n    for (int y = h - 1; y >= 0; y--) {\n        float4 xc = rgbaIntToFloat(*id);\n        float4 yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya;\n        xa        = xn;\n        xn        = xc;\n        ya        = yn;\n        yn        = yc;\n        // Combining forward and reverse passes\n        // We read the current forward result from *od, add reverse component, and store back\n        float4 forward_res = rgbaIntToFloat(*od);\n        *od       = rgbaFloatToInt(forward_res + yc);\n        id -= w;\n        od -= w; // move to previous row\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\n// Precompute coefficients for the recursive filter\nvoid computeCoefficients(float sigma, float* a0, float* a1, float* a2, float* a3,\n                         float* b1, float* b2, float* coefp, float* coefn) {\n    float alpha = 1.695f / sigma;\n    float ema = std::exp(-alpha);\n    float ema2 = std::exp(-2.0f * alpha);\n    *b1 = -2.0f * ema;\n    *b2 = ema2;\n    float k = (1.0f - ema) * (1.0f - ema) / (1.0f + 2.0f * alpha * ema - ema2);\n    *a0 = k;\n    *a1 = k * (alpha - 1.0f) * ema;\n    *a2 = k * (alpha + 1.0f) * ema;\n    *a3 = -k * ema2;\n    *coefp = (*a0 + *a1) / (1.0f + *b1 + *b2);\n    *coefn = (*a2 + *a3) / (1.0f + *b1 + *b2);\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    const int width = 8192;\n    const int height = 8192;\n    const float sigma = 10.0f;\n\n    size_t img_size = width * height * sizeof(uint);\n\n    // Host alloc\n    uint* h_in = new uint[width * height];\n    uint* h_out = new uint[width * height];\n\n    // Read Input\n    read_binary(\"data/input_img.bin\", h_in, img_size);\n\n    // Compute Filter Coefficients\n    float a0, a1, a2, a3, b1, b2, coefp, coefn;\n    computeCoefficients(sigma, &a0, &a1, &a2, &a3, &b1, &b2, &coefp, &coefn);\n\n    // Device alloc\n    uint *d_in, *d_out;\n    cudaMalloc(&d_in, img_size);\n    cudaMalloc(&d_out, img_size);\n\n    cudaMemcpy(d_in, h_in, img_size, cudaMemcpyHostToDevice);\n\n    // Launch Config\n    // This kernel processes columns vertically.\n    // One thread per column.\n    int threads = 256;\n    int blocks = (width + threads - 1) / threads;\n\n    d_recursiveGaussian_rgba<<<blocks, threads>>>(\n        d_in,\n        d_out,\n        width,\n        height,\n        a0, a1, a2, a3, b1, b2, coefp, coefn\n    );\n\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_out, d_out, img_size, cudaMemcpyDeviceToHost);\n\n    // Write Output\n    write_binary(\"data/output_img.bin\", h_out, img_size);\n\n    // Cleanup\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_in;\n    delete[] h_out;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\n# Constants\nWIDTH = 8192\nHEIGHT = 8192\nSIGMA = 10.0\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef compute_coefficients(sigma):\n    alpha = 1.695 / sigma\n    ema = math.exp(-alpha)\n    ema2 = math.exp(-2.0 * alpha)\n    b1 = -2.0 * ema\n    b2 = ema2\n    k = (1.0 - ema) * (1.0 - ema) / (1.0 + 2.0 * alpha * ema - ema2)\n    a0 = k\n    a1 = k * (alpha - 1.0) * ema\n    a2 = k * (alpha + 1.0) * ema\n    a3 = -k * ema2\n    coefp = (a0 + a1) / (1.0 + b1 + b2)\n    coefn = (a2 + a3) / (1.0 + b1 + b2)\n    return a0, a1, a2, a3, b1, b2, coefp, coefn\n\ndef recursive_gaussian_column(img, h, w, coeffs):\n    a0, a1, a2, a3, b1, b2, coefp, coefn = coeffs\n    \n    # We process each column independently.\n    # img is (H, W, 4)\n    # Output buffer\n    # Use float for precision during calc\n    result = np.zeros_like(img, dtype=np.float32)\n    \n    # Forward pass\n    # y[i] = a0*x[i] + a1*x[i-1] - b1*y[i-1] - b2*y[i-2]\n    \n    # Python loops are slow but explicit for matching kernel logic\n    # Vectorize across columns (W) for performance\n    \n    # Initialize buffers for W columns\n    xp = np.zeros((w, 4), dtype=np.float32) # x[i-1]\n    yp = np.zeros((w, 4), dtype=np.float32) # y[i-1]\n    yb = np.zeros((w, 4), dtype=np.float32) # y[i-2]\n    \n    # Initial condition (CLAMP_TO_EDGE)\n    # xp = x[0]\n    # yb = coefp * xp\n    # yp = yb\n    xp = img[0].astype(np.float32)\n    yb = coefp * xp\n    yp = yb\n    \n    forward_res = np.zeros_like(img, dtype=np.float32)\n    \n    for y in range(h):\n        xc = img[y].astype(np.float32)\n        yc = a0 * xc + a1 * xp - b1 * yp - b2 * yb\n        forward_res[y] = yc\n        \n        xp = xc\n        yb = yp\n        yp = yc\n\n    # Reverse pass\n    # Result is sum of forward and reverse\n    # Reverse filter:\n    # y[i] = a2*x[i+1] + a3*x[i+2] - b1*y[i+1] - b2*y[i+2]\n    # Implemented as backward iteration\n    \n    xn = np.zeros((w, 4), dtype=np.float32) # x[i+1]\n    xa = np.zeros((w, 4), dtype=np.float32) # x[i+2]\n    yn = np.zeros((w, 4), dtype=np.float32) # y[i+1]\n    ya = np.zeros((w, 4), dtype=np.float32) # y[i+2]\n    \n    # Initial condition (CLAMP_TO_EDGE) at y = h-1\n    # xn = xa = x[h-1]\n    # yn = coefn * xn\n    # ya = yn\n    xn = img[h-1].astype(np.float32)\n    xa = xn\n    yn = coefn * xn\n    ya = yn\n    \n    for y in range(h-1, -1, -1):\n        xc = img[y].astype(np.float32)\n        yc = a2 * xn + a3 * xa - b1 * yn - b2 * ya\n        \n        xa = xn\n        xn = xc\n        ya = yn\n        yn = yc\n        \n        # Combine\n        # Kernel: *od = rgbaFloatToInt(forward + yc)\n        result[y] = forward_res[y] + yc\n\n    return result\n\n# Generate Random Data\n# Shape (H, W, 4) for RGBA\nimg_data = np.random.randint(0, 256, (HEIGHT, WIDTH, 4), dtype=np.uint8)\n\n# Pack for binary file\n# (R, G, B, A) -> uint32\npacked_img = (img_data[:,:,3].astype(np.uint32) << 24) | \\\n             (img_data[:,:,2].astype(np.uint32) << 16) | \\\n             (img_data[:,:,1].astype(np.uint32) << 8)  | \\\n             (img_data[:,:,0].astype(np.uint32))\n\n# Compute Reference\ncoeffs = compute_coefficients(SIGMA)\nref_float = recursive_gaussian_column(img_data, HEIGHT, WIDTH, coeffs)\n\n# Convert reference back to packed uint32\nref_float = np.clip(ref_float, 0.0, 255.0)\nref_out = (ref_float[:,:,3].astype(np.uint32) << 24) | \\\n          (ref_float[:,:,2].astype(np.uint32) << 16) | \\\n          (ref_float[:,:,1].astype(np.uint32) << 8)  | \\\n          (ref_float[:,:,0].astype(np.uint32))\n\n# Save\nos.makedirs(\"data\", exist_ok=True)\npacked_img.tofile(\"data/input_img.bin\")\nref_out.tofile(\"data/ref_img.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary_uint32(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files: {output_file} or {ref_file}\")\n        return False\n    \n    output = read_binary_uint32(output_file, size)\n    reference = read_binary_uint32(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    # Unpack\n    out_r = (output >> 0) & 0xFF\n    out_g = (output >> 8) & 0xFF\n    out_b = (output >> 16) & 0xFF\n    out_a = (output >> 24) & 0xFF\n    \n    ref_r = (reference >> 0) & 0xFF\n    ref_g = (reference >> 8) & 0xFF\n    ref_b = (reference >> 16) & 0xFF\n    ref_a = (reference >> 24) & 0xFF\n    \n    # Diff\n    diff_r = np.abs(out_r.astype(np.int16) - ref_r.astype(np.int16))\n    diff_g = np.abs(out_g.astype(np.int16) - ref_g.astype(np.int16))\n    diff_b = np.abs(out_b.astype(np.int16) - ref_b.astype(np.int16))\n    diff_a = np.abs(out_a.astype(np.int16) - ref_a.astype(np.int16))\n    \n    max_diff = max(np.max(diff_r), np.max(diff_g), np.max(diff_b), np.max(diff_a))\n    # print(f\"Max Channel Diff: {max_diff}\")\n    \n    # Typically 1 or 2 due to rounding differences in float->int conversion\n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    WIDTH = 8192\n    HEIGHT = 8192\n    \n    out_file = \"data/output_img.bin\"\n    ref_file = \"data/ref_img.bin\"\n    \n    # Using tolerance=2 to account for precision differences in the recursive accumulation\n    if compare_outputs(out_file, ref_file, WIDTH * HEIGHT, tolerance=2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Recursive_Gaussian. Implement a CUDA kernel that applies a recursive Gaussian filter to an input image. The input is a tensor named 'input_img' with data type uint32 and shape (8192, 8192), where each element represents a packed RGBA value (red, green, blue, alpha channels in 8 bits each). The output is a tensor named 'output_img' with the same data type and a flattened shape of (67108864,), equivalent to the input size. The kernel must process each column independently, performing a forward pass from top to bottom and a reverse pass from bottom to top for symmetry, summing the results. Boundary conditions should clamp to the edge pixels, and the filter uses precomputed coefficients (a0, a1, a2, a3, b1, b2, coefp, coefn) derived from a sigma value.", "level2_prompt": "Recursive_Gaussian: Apply a vertical recursive Gaussian filter to each column of an image. For each column, compute the output in a forward direction using the current input, previous input, and previous outputs with given coefficients, then compute in reverse direction and add it to the forward result. Handle edge clamping by using the boundary pixel values for initial conditions.", "level3_prompt": "Compute a recursive Gaussian filter on an image using CUDA."}
{"id": 10, "task_name": "ReLU_Activation_Fuction", "task_description": "Compute the ReLU_Activation_Fuction kernel on GPU using CUDA.", "inputs": [{"name": "relu_input", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "relu_out", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 20;\n\n__global__ void relu_kernel(const float* input, float* output, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < size) {\n        float val = input[idx];\n        output[idx] = val > 0.0f ? val : 0.0f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input  = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    std::string input_file = \"data/relu_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    relu_kernel<<<blocks, threads>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/relu_out.bin\";\n    write_binary(out_file, h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 20\n\nx = (np.random.randn(N) * 5).astype(np.float32)\ny = np.maximum(0, x).astype(np.float32)\n\nx.tofile(\"data/relu_input.bin\")\ny.tofile(\"data/relu_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 20\n    out_file = \"data/relu_out.bin\"\n    ref_file = \"data/relu_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the ReLU activation function kernel. The kernel should take a one-dimensional float32 input tensor of size 1048576 and produce a float32 output tensor of the same size. For each element in the input, if the value is greater than zero, output the same value; otherwise, output zero. The computation must be performed element-wise independently.", "level2_prompt": "Compute the ReLU activation function for each element in a float32 array of size 1048576. The ReLU function outputs the input value if it is positive and zero otherwise.", "level3_prompt": "Compute the ReLU activation function on a GPU using CUDA."}
{"id": 11, "task_name": "ReLU_Activation_Fuction", "task_description": "Compute the ReLU_Activation_Fuction kernel on GPU using CUDA.", "inputs": [{"name": "relu_input", "dtype": "float32", "shape": "(4194304,)"}], "outputs": [{"name": "relu_out", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 22;\n\n__global__ void relu_kernel(const float* input, float* output, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < size) {\n        float val = input[idx];\n        output[idx] = val > 0.0f ? val : 0.0f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input  = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    std::string input_file = \"data/relu_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    relu_kernel<<<blocks, threads>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/relu_out.bin\";\n    write_binary(out_file, h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 22\n\nx = (np.random.randn(N) * 5).astype(np.float32)\ny = np.maximum(0, x).astype(np.float32)\n\nx.tofile(\"data/relu_input.bin\")\ny.tofile(\"data/relu_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 22\n    out_file = \"data/relu_out.bin\"\n    ref_file = \"data/relu_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the ReLU Activation Function kernel. The kernel should process a one-dimensional input tensor of 4,194,304 single-precision floating-point numbers. For each element in the input tensor, the kernel must output the element's value if positive, or zero otherwise. The output tensor must have identical shape and data type as the input. The kernel must preserve the element-wise correspondence between input and output tensors.", "level2_prompt": "Compute the ReLU activation function element-wise. Given an input vector of single-precision floats, apply the function f(x) = max(0, x) to each element independently. Output a new vector with identical dimensions where each element represents the rectified value of its corresponding input.", "level3_prompt": "Compute the ReLU_Activation_Fuction kernel on GPU using CUDA."}
{"id": 12, "task_name": "ReLU_Activation_Fuction", "task_description": "Compute the ReLU_Activation_Fuction kernel on GPU using CUDA.", "inputs": [{"name": "relu_input", "dtype": "float32", "shape": "(16777216,)"}], "outputs": [{"name": "relu_out", "dtype": "float32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 24;\n\n__global__ void relu_kernel(const float* input, float* output, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < size) {\n        float val = input[idx];\n        output[idx] = val > 0.0f ? val : 0.0f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input  = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    std::string input_file = \"data/relu_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    relu_kernel<<<blocks, threads>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/relu_out.bin\";\n    write_binary(out_file, h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 24\n\nx = (np.random.randn(N) * 5).astype(np.float32)\ny = np.maximum(0, x).astype(np.float32)\n\nx.tofile(\"data/relu_input.bin\")\ny.tofile(\"data/relu_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 24\n    out_file = \"data/relu_out.bin\"\n    ref_file = \"data/relu_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "ReLU Activation Function: Compute the Rectified Linear Unit (ReLU) activation function. The input is a 1-dimensional tensor with 16,777,216 float32 elements. The output must be a tensor of the same shape and data type. For each element, if the input value is positive, output the same value; otherwise, output zero. The operation must be performed element-wise without altering adjacent elements.", "level2_prompt": "ReLU Activation Function: For each element in the input array, compute the output element as the maximum of zero and the input element value.", "level3_prompt": "Compute the ReLU activation function on GPU using CUDA."}
{"id": 13, "task_name": "ReLU_Activation_Fuction", "task_description": "Compute the ReLU_Activation_Fuction kernel on GPU using CUDA.", "inputs": [{"name": "relu_input", "dtype": "float32", "shape": "(67108864,)"}], "outputs": [{"name": "relu_out", "dtype": "float32", "shape": "(67108864,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 26;\n\n__global__ void relu_kernel(const float* input, float* output, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < size) {\n        float val = input[idx];\n        output[idx] = val > 0.0f ? val : 0.0f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input  = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    std::string input_file = \"data/relu_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    relu_kernel<<<blocks, threads>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/relu_out.bin\";\n    write_binary(out_file, h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 26\n\nx = (np.random.randn(N) * 5).astype(np.float32)\ny = np.maximum(0, x).astype(np.float32)\n\nx.tofile(\"data/relu_input.bin\")\ny.tofile(\"data/relu_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 26\n    out_file = \"data/relu_out.bin\"\n    ref_file = \"data/relu_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the ReLU_Activation_Fuction kernel. The kernel applies the ReLU activation function element-wise to an input tensor. The input tensor is a 1-dimensional array of 67,108,864 float32 values named 'relu_input'. For each element, if the value is greater than 0, output the original value; otherwise, output 0. The output tensor 'relu_out' must be a float32 array of the same shape. The kernel must process all 67,108,864 elements without modifying the input.", "level2_prompt": "Implement the ReLU_Activation_Fuction kernel. Perform an element-wise ReLU operation on a 1D float32 array. For each element x, output max(0, x). The input size is fixed at 67,108,864 elements.", "level3_prompt": "Compute the ReLU activation function on a GPU for a large float32 array."}
{"id": 14, "task_name": "ReLU_Activation_Fuction", "task_description": "Compute the ReLU_Activation_Fuction kernel on GPU using CUDA.", "inputs": [{"name": "relu_input", "dtype": "float32", "shape": "(268435456,)"}], "outputs": [{"name": "relu_out", "dtype": "float32", "shape": "(268435456,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 28;\n\n__global__ void relu_kernel(const float* input, float* output, int size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < size) {\n        float val = input[idx];\n        output[idx] = val > 0.0f ? val : 0.0f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input  = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    std::string input_file = \"data/relu_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    relu_kernel<<<blocks, threads>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/relu_out.bin\";\n    write_binary(out_file, h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 28\n\nx = (np.random.randn(N) * 5).astype(np.float32)\ny = np.maximum(0, x).astype(np.float32)\n\nx.tofile(\"data/relu_input.bin\")\ny.tofile(\"data/relu_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 28\n    out_file = \"data/relu_out.bin\"\n    ref_file = \"data/relu_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the ReLU activation function. The input is a 1D tensor of float32 values with 268435456 elements. The output must be a 1D tensor of the same shape and data type. For each element, if the input value is greater than zero, output the same value; otherwise, output zero. The kernel must process all elements independently.", "level2_prompt": "Compute the ReLU activation function element-wise. For each value in the input array, output the value if it is positive, otherwise output zero.", "level3_prompt": "Compute the ReLU activation function on a GPU using CUDA."}
{"id": 15, "task_name": "Top-K_Selection", "task_description": "Compute the Top-K_Selection kernel on GPU using CUDA.", "inputs": [{"name": "topk_input", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "topk_out", "dtype": "float32", "shape": "(32,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 10;\nconst int K = 32;\n\n__global__ void topk_selection_kernel(const float* input, float* output, int k, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < k; ++i) output[i] = input[i];\n\n        for (int i = 1; i < k; ++i) {\n            float key = output[i];\n            int j = i - 1;\n            while (j >= 0 && output[j] < key) {\n                output[j + 1] = output[j];\n                --j;\n            }\n            output[j + 1] = key;\n        }\n\n        for (int i = k; i < n; ++i) {\n            float val = input[i];\n            if (val > output[k - 1]) {\n                int j = k - 2;\n                while (j >= 0 && output[j] < val) {\n                    output[j + 1] = output[j];\n                    --j;\n                }\n                output[j + 1] = val;\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n    size_t output_bytes = K * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    read_binary(\"data/topk_input.bin\", h_input, N);\n\n    float* d_input;\n    float* d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    topk_selection_kernel<<<1, 32>>>(d_input, d_output, K, N);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/topk_out.bin\", h_output, K);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 10\nK = 32\n\ndata = np.random.rand(N).astype(np.float32)\ntopk_ref = np.sort(data)[-K:][::-1].astype(np.float32)\n\ndata.tofile(\"data/topk_input.bin\")\ntopk_ref.tofile(\"data/topk_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    K = 32\n\n    out_file = \"data/topk_out.bin\"\n    ref_file = \"data/topk_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, K):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Top-K_Selection. Given an input tensor 'topk_input' of 1024 floating-point numbers, the kernel must compute an output tensor 'topk_out' of 32 floating-point numbers. The output must contain the 32 largest values from the input, sorted in descending order (from largest to smallest). The kernel must respect the constraint that the output is exactly the top 32 values and in the correct order.", "level2_prompt": "Task: Top-K_Selection. The kernel must select the 32 largest elements from an input array of 1024 numbers and sort these selected values in descending order.", "level3_prompt": "Select the top 32 values from an input array and output them in descending order."}
{"id": 16, "task_name": "Top-K_Selection", "task_description": "Compute the Top-K_Selection kernel on GPU using CUDA.", "inputs": [{"name": "topk_input", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "topk_out", "dtype": "float32", "shape": "(64,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 12;\nconst int K = 64;\n\n__global__ void topk_selection_kernel(const float* input, float* output, int k, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < k; ++i) output[i] = input[i];\n\n        for (int i = 1; i < k; ++i) {\n            float key = output[i];\n            int j = i - 1;\n            while (j >= 0 && output[j] < key) {\n                output[j + 1] = output[j];\n                --j;\n            }\n            output[j + 1] = key;\n        }\n\n        for (int i = k; i < n; ++i) {\n            float val = input[i];\n            if (val > output[k - 1]) {\n                int j = k - 2;\n                while (j >= 0 && output[j] < val) {\n                    output[j + 1] = output[j];\n                    --j;\n                }\n                output[j + 1] = val;\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n    size_t output_bytes = K * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    read_binary(\"data/topk_input.bin\", h_input, N);\n\n    float* d_input;\n    float* d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    topk_selection_kernel<<<1, 32>>>(d_input, d_output, K, N);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/topk_out.bin\", h_output, K);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 12\nK = 64\n\ndata = np.random.rand(N).astype(np.float32)\ntopk_ref = np.sort(data)[-K:][::-1].astype(np.float32)\n\ndata.tofile(\"data/topk_input.bin\")\ntopk_ref.tofile(\"data/topk_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    K = 64\n\n    out_file = \"data/topk_out.bin\"\n    ref_file = \"data/topk_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, K):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Top-K_Selection. Given an input tensor named 'topk_input' of shape (4096,) and data type float32, the kernel must compute an output tensor named 'topk_out' of shape (64,) and data type float32. The output must contain the top 64 largest values from the input, sorted in descending order (from largest to smallest). The kernel must correctly handle the entire input array of 4096 elements to produce the output.", "level2_prompt": "Task: Top-K_Selection. The algorithm finds the K (K=64) largest values in an array of N (N=4096) elements. It maintains a sorted list of the top K elements. Initially, the first K elements are taken and sorted in descending order. Then, for each remaining element, if it is greater than the smallest element in the current top K, it is inserted into the sorted list at the correct position to maintain descending order, and the smallest element (now the last) is removed to keep the list size at K.", "level3_prompt": "Compute the Top-K_Selection kernel on GPU using CUDA."}
{"id": 17, "task_name": "Top-K_Selection", "task_description": "Compute the Top-K_Selection kernel on GPU using CUDA.", "inputs": [{"name": "topk_input", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "topk_out", "dtype": "float32", "shape": "(128,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 14;\nconst int K = 128;\n\n__global__ void topk_selection_kernel(const float* input, float* output, int k, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < k; ++i) output[i] = input[i];\n\n        for (int i = 1; i < k; ++i) {\n            float key = output[i];\n            int j = i - 1;\n            while (j >= 0 && output[j] < key) {\n                output[j + 1] = output[j];\n                --j;\n            }\n            output[j + 1] = key;\n        }\n\n        for (int i = k; i < n; ++i) {\n            float val = input[i];\n            if (val > output[k - 1]) {\n                int j = k - 2;\n                while (j >= 0 && output[j] < val) {\n                    output[j + 1] = output[j];\n                    --j;\n                }\n                output[j + 1] = val;\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n    size_t output_bytes = K * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    read_binary(\"data/topk_input.bin\", h_input, N);\n\n    float* d_input;\n    float* d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    topk_selection_kernel<<<1, 32>>>(d_input, d_output, K, N);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/topk_out.bin\", h_output, K);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 14\nK = 128\n\ndata = np.random.rand(N).astype(np.float32)\ntopk_ref = np.sort(data)[-K:][::-1].astype(np.float32)\n\ndata.tofile(\"data/topk_input.bin\")\ntopk_ref.tofile(\"data/topk_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    K = 128\n\n    out_file = \"data/topk_out.bin\"\n    ref_file = \"data/topk_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, K):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Top-K Selection kernel. Given an input tensor of 16384 float32 values, compute the top 128 largest values. The output must be a tensor of 128 float32 values sorted in descending order. The kernel must correctly identify the largest elements and maintain them in sorted order throughout processing.", "level2_prompt": "Perform Top-K Selection to find the 128 largest elements from a 16384-element array. Initialize output with the first 128 input elements, sort them in descending order, then scan remaining elements. For each subsequent element larger than the smallest in the current top-k, insert it into the sorted output while maintaining descending order.", "level3_prompt": "Compute the top-k selection kernel to identify the 128 largest elements from a 16384-element float32 array and output them in descending order."}
{"id": 18, "task_name": "Top-K_Selection", "task_description": "Compute the Top-K_Selection kernel on GPU using CUDA.", "inputs": [{"name": "topk_input", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "topk_out", "dtype": "float32", "shape": "(256,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 16;\nconst int K = 256;\n\n__global__ void topk_selection_kernel(const float* input, float* output, int k, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < k; ++i) output[i] = input[i];\n\n        for (int i = 1; i < k; ++i) {\n            float key = output[i];\n            int j = i - 1;\n            while (j >= 0 && output[j] < key) {\n                output[j + 1] = output[j];\n                --j;\n            }\n            output[j + 1] = key;\n        }\n\n        for (int i = k; i < n; ++i) {\n            float val = input[i];\n            if (val > output[k - 1]) {\n                int j = k - 2;\n                while (j >= 0 && output[j] < val) {\n                    output[j + 1] = output[j];\n                    --j;\n                }\n                output[j + 1] = val;\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n    size_t output_bytes = K * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    read_binary(\"data/topk_input.bin\", h_input, N);\n\n    float* d_input;\n    float* d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    topk_selection_kernel<<<1, 32>>>(d_input, d_output, K, N);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/topk_out.bin\", h_output, K);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 16\nK = 256\n\ndata = np.random.rand(N).astype(np.float32)\ntopk_ref = np.sort(data)[-K:][::-1].astype(np.float32)\n\ndata.tofile(\"data/topk_input.bin\")\ntopk_ref.tofile(\"data/topk_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    K = 256\n\n    out_file = \"data/topk_out.bin\"\n    ref_file = \"data/topk_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, K):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Top-K_Selection. The kernel must select the top 256 largest values from an input array of 65536 float32 numbers and output them in descending order (largest first). The input is a 1D tensor of shape (65536,) with dtype float32. The output must be a 1D tensor of shape (256,) with dtype float32, containing exactly the 256 largest values sorted in descending order. The kernel must maintain this sorted order throughout insertion and ensure no extraneous values are included.", "level2_prompt": "Task: Top-K_Selection. Given an array of 65536 floating-point numbers, select the 256 largest values and arrange them in descending order. Initialize by copying the first 256 elements into the output and sorting them in descending order. For each subsequent element, compare it against the smallest value in the current output. If larger, insert it into the sorted output at the correct position while shifting elements and discarding the smallest value to maintain exactly 256 elements.", "level3_prompt": "Top-K selection of the largest K values in descending order."}
{"id": 19, "task_name": "Top-K_Selection", "task_description": "Compute the Top-K_Selection kernel on GPU using CUDA.", "inputs": [{"name": "topk_input", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "topk_out", "dtype": "float32", "shape": "(512,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 18;\nconst int K = 512;\n\n__global__ void topk_selection_kernel(const float* input, float* output, int k, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < k; ++i) output[i] = input[i];\n\n        for (int i = 1; i < k; ++i) {\n            float key = output[i];\n            int j = i - 1;\n            while (j >= 0 && output[j] < key) {\n                output[j + 1] = output[j];\n                --j;\n            }\n            output[j + 1] = key;\n        }\n\n        for (int i = k; i < n; ++i) {\n            float val = input[i];\n            if (val > output[k - 1]) {\n                int j = k - 2;\n                while (j >= 0 && output[j] < val) {\n                    output[j + 1] = output[j];\n                    --j;\n                }\n                output[j + 1] = val;\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n    size_t output_bytes = K * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    read_binary(\"data/topk_input.bin\", h_input, N);\n\n    float* d_input;\n    float* d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    topk_selection_kernel<<<1, 32>>>(d_input, d_output, K, N);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/topk_out.bin\", h_output, K);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 18\nK = 512\n\ndata = np.random.rand(N).astype(np.float32)\ntopk_ref = np.sort(data)[-K:][::-1].astype(np.float32)\n\ndata.tofile(\"data/topk_input.bin\")\ntopk_ref.tofile(\"data/topk_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    K = 512\n\n    out_file = \"data/topk_out.bin\"\n    ref_file = \"data/topk_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, K):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Top-K Selection. Compute the top-k elements from a one-dimensional input tensor of 262144 float32 values. The kernel must output a one-dimensional tensor of 512 float32 values containing the largest elements from the input, sorted in descending order (largest first). The kernel should process the entire input array and maintain a sorted list of the current top-k elements, updating it whenever a larger element is encountered. Constraints include fixed input size (262144) and output size (512), with output values sorted descending.", "level2_prompt": "Task: Top-K Selection. The algorithm selects the k largest elements from an input array. It initializes by copying the first k elements into the output and sorting them descending. For each subsequent element in the input, if it is larger than the smallest element in the current top-k, it is inserted into the sorted output at the correct position while preserving descending order, displacing the smallest element.", "level3_prompt": "Select the top-k elements from an input array."}
{"id": 20, "task_name": "Sorting", "task_description": "Compute the Sorting kernel on GPU using CUDA.", "inputs": [{"name": "sort_input", "dtype": "float32", "shape": "(512,)"}], "outputs": [{"name": "sort_out", "dtype": "float32", "shape": "(512,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 9;   // 512\n\n__global__ void sort_kernel(float* data, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = 0; j < n - i - 1; ++j) {\n                if (data[j] > data[j + 1]) {\n                    float tmp = data[j];\n                    data[j] = data[j + 1];\n                    data[j + 1] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    read_binary(\"data/sort_input.bin\", h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    sort_kernel<<<1, 1>>>(d_data, N);\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/sort_out.bin\", h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nN = 1 << 9   # 512\n\ndata = (np.random.rand(N) * 2000).astype(np.float32)\nsorted_data = np.sort(data).astype(np.float32)\n\ndata.tofile(\"data/sort_input.bin\")\nsorted_data.tofile(\"data/sort_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 9\n\n    out_file = \"data/sort_out.bin\"\n    ref_file = \"data/sort_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel to sort an array of 512 single-precision floating-point numbers in ascending order. The input is a one-dimensional tensor of shape (512,) containing unsorted float32 values. The output must be a tensor of identical shape and data type with elements sorted from smallest to largest. The kernel must produce results that exactly match a reference sorted array when validated.", "level2_prompt": "Create a GPU kernel that sorts a 512-element float32 array in non-decreasing order. The algorithm must rearrange the input elements such that each output element is less than or equal to its successor.", "level3_prompt": "Sort an array of 512 floating-point numbers."}
{"id": 21, "task_name": "Sorting", "task_description": "Compute the Sorting kernel on GPU using CUDA.", "inputs": [{"name": "sort_input", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "sort_out", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 10;\n\n__global__ void sort_kernel(float* data, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = 0; j < n - i - 1; ++j) {\n                if (data[j] > data[j + 1]) {\n                    float tmp = data[j];\n                    data[j] = data[j + 1];\n                    data[j + 1] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    read_binary(\"data/sort_input.bin\", h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    sort_kernel<<<1, 1>>>(d_data, N);\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/sort_out.bin\", h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nN = 1 << 10\n\ndata = (np.random.rand(N) * 2000).astype(np.float32)\nsorted_data = np.sort(data).astype(np.float32)\n\ndata.tofile(\"data/sort_input.bin\")\nsorted_data.tofile(\"data/sort_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 10\n\n    out_file = \"data/sort_out.bin\"\n    ref_file = \"data/sort_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Sorting. Sort an array of 1024 floating-point numbers in ascending order. The input is a 1D tensor of 1024 float32 values. The output must be a 1D tensor of 1024 float32 values containing the same elements as the input but sorted in non-decreasing order. The algorithm must correctly sort any input array of the specified size.", "level2_prompt": "Task: Sorting. Rearrange the elements of the input array of 1024 float32 numbers so that the array is sorted in non-decreasing order (each element is less than or equal to the next element).", "level3_prompt": "Compute the Sorting kernel on GPU using CUDA."}
{"id": 22, "task_name": "Sorting", "task_description": "Compute the Sorting kernel on GPU using CUDA.", "inputs": [{"name": "sort_input", "dtype": "float32", "shape": "(2048,)"}], "outputs": [{"name": "sort_out", "dtype": "float32", "shape": "(2048,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 11;\n\n__global__ void sort_kernel(float* data, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = 0; j < n - i - 1; ++j) {\n                if (data[j] > data[j + 1]) {\n                    float tmp = data[j];\n                    data[j] = data[j + 1];\n                    data[j + 1] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    read_binary(\"data/sort_input.bin\", h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    sort_kernel<<<1, 1>>>(d_data, N);\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/sort_out.bin\", h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nN = 1 << 11\n\ndata = (np.random.rand(N) * 2000).astype(np.float32)\nsorted_data = np.sort(data).astype(np.float32)\n\ndata.tofile(\"data/sort_input.bin\")\nsorted_data.tofile(\"data/sort_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 11\n\n    out_file = \"data/sort_out.bin\"\n    ref_file = \"data/sort_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Sorting\nDescription: Sort an input array of 2048 floating point numbers in ascending order.\nInput: A 1D tensor named 'sort_input' with shape (2048,) and data type float32.\nOutput: A 1D tensor named 'sort_out' with shape (2048,) and data type float32, containing the sorted elements of the input array in ascending order.\nConstraints: The output must be the sorted version of the input array and must match the reference sorted array within a tolerance of 1e-5.", "level2_prompt": "Task: Sorting\nDescription: Rearrange the elements of the input array of 2048 floats so that for every index i from 0 to 2046, the element at index i is less than or equal to the element at index i+1.", "level3_prompt": "Sort an array of 2048 floating point numbers in ascending order."}
{"id": 23, "task_name": "Sorting", "task_description": "Compute the Sorting kernel on GPU using CUDA.", "inputs": [{"name": "sort_input", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "sort_out", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 12;\n\n__global__ void sort_kernel(float* data, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = 0; j < n - i - 1; ++j) {\n                if (data[j] > data[j + 1]) {\n                    float tmp = data[j];\n                    data[j] = data[j + 1];\n                    data[j + 1] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    read_binary(\"data/sort_input.bin\", h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    sort_kernel<<<1, 1>>>(d_data, N);\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/sort_out.bin\", h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nN = 1 << 12\n\ndata = (np.random.rand(N) * 2000).astype(np.float32)\nsorted_data = np.sort(data).astype(np.float32)\n\ndata.tofile(\"data/sort_input.bin\")\nsorted_data.tofile(\"data/sort_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 12\n\n    out_file = \"data/sort_out.bin\"\n    ref_file = \"data/sort_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Sorting' that sorts an input array of 4096 single-precision floating-point numbers in ascending order. The input tensor 'sort_input' is a 1D array of shape (4096,) with float32 data type. The output tensor 'sort_out' must be a sorted version of the input array with the same shape and data type, where each element is less than or equal to the next element. The kernel must produce results that exactly match a reference sorted array within a tolerance of 1e-5.", "level2_prompt": "Implement a CUDA kernel for sorting where given an array of 4096 floating-point numbers, the kernel rearranges elements such that each subsequent element is greater than or equal to the previous one, producing a non-decreasing sequence.", "level3_prompt": "Sort an array of 4096 floating-point numbers in ascending order."}
{"id": 24, "task_name": "Sorting", "task_description": "Compute the Sorting kernel on GPU using CUDA.", "inputs": [{"name": "sort_input", "dtype": "float32", "shape": "(8192,)"}], "outputs": [{"name": "sort_out", "dtype": "float32", "shape": "(8192,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 13;\n\n__global__ void sort_kernel(float* data, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        for (int i = 0; i < n - 1; ++i) {\n            for (int j = 0; j < n - i - 1; ++j) {\n                if (data[j] > data[j + 1]) {\n                    float tmp = data[j];\n                    data[j] = data[j + 1];\n                    data[j + 1] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    read_binary(\"data/sort_input.bin\", h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    sort_kernel<<<1, 1>>>(d_data, N);\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/sort_out.bin\", h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nN = 1 << 13\n\ndata = (np.random.rand(N) * 2000).astype(np.float32)\nsorted_data = np.sort(data).astype(np.float32)\n\ndata.tofile(\"data/sort_input.bin\")\nsorted_data.tofile(\"data/sort_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 13\n\n    out_file = \"data/sort_out.bin\"\n    ref_file = \"data/sort_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel to sort an array of 8192 floating-point numbers in ascending order. The input is a 1D tensor of float32 values with shape (8192,). The output must be a 1D tensor of float32 values with the same shape, containing the sorted elements in non-decreasing order. The kernel must produce results that exactly match a reference sorted array.", "level2_prompt": "Sort an array of 8192 elements in ascending order. The kernel should rearrange the input values such that each element is less than or equal to the next element in the output array.", "level3_prompt": "Sort an array of floating point numbers in ascending order."}
{"id": 25, "task_name": "Matrix_Copy", "task_description": "Compute the Matrix_Copy kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 10;  // 1024\n\n__global__ void matrix_copy_kernel(const float* A, float* B, int width) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < width && col < width) {\n        int idx = row * width + col;\n        B[idx] = A[idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t num_elements = static_cast<size_t>(N) * N;\n    size_t size_bytes = num_elements * sizeof(float);\n\n    float* h_A = (float*)malloc(size_bytes);\n    float* h_B = (float*)malloc(size_bytes);\n\n    read_binary(\"data/matrix_input.bin\", h_A, num_elements);\n\n    float *d_A, *d_B;\n    cudaMalloc(&d_A, size_bytes);\n    cudaMalloc(&d_B, size_bytes);\n\n    cudaMemcpy(d_A, h_A, size_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((N + threads.x - 1) / threads.x,\n                (N + threads.y - 1) / threads.y);\n\n    matrix_copy_kernel<<<blocks, threads>>>(d_A, d_B, N);\n    cudaMemcpy(h_B, d_B, size_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matrix_out.bin\", h_B, num_elements);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 10  # 1024\n\nmatrix = np.random.rand(N, N).astype(np.float32)\n\nmatrix.tofile(\"data/matrix_input.bin\")\nmatrix.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 10\n    size = N * N\n\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Matrix_Copy that copies a 1024x1024 matrix of single-precision floating-point numbers. The input tensor 'matrix_input' has shape (1024, 1024) and dtype float32. The output tensor 'matrix_out' must have identical shape and dtype. The kernel must copy each element from the input to the output at the same position. The implementation must handle exactly 1024x1024 elements.", "level2_prompt": "Perform a matrix copy operation where each element in a 1024x1024 input matrix is transferred to the corresponding position in an output matrix of identical dimensions.", "level3_prompt": "Compute the Matrix_Copy kernel on GPU using CUDA."}
{"id": 26, "task_name": "Matrix_Copy", "task_description": "Compute the Matrix_Copy kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 11;\n\n__global__ void matrix_copy_kernel(const float* A, float* B, int width) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < width && col < width) {\n        int idx = row * width + col;\n        B[idx] = A[idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t num_elements = static_cast<size_t>(N) * N;\n    size_t size_bytes = num_elements * sizeof(float);\n\n    float* h_A = (float*)malloc(size_bytes);\n    float* h_B = (float*)malloc(size_bytes);\n\n    read_binary(\"data/matrix_input.bin\", h_A, num_elements);\n\n    float *d_A, *d_B;\n    cudaMalloc(&d_A, size_bytes);\n    cudaMalloc(&d_B, size_bytes);\n\n    cudaMemcpy(d_A, h_A, size_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((N + threads.x - 1) / threads.x,\n                (N + threads.y - 1) / threads.y);\n\n    matrix_copy_kernel<<<blocks, threads>>>(d_A, d_B, N);\n    cudaMemcpy(h_B, d_B, size_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matrix_out.bin\", h_B, num_elements);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 11\n\nmatrix = np.random.rand(N, N).astype(np.float32)\n\nmatrix.tofile(\"data/matrix_input.bin\")\nmatrix.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 11\n    size = N * N\n\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Matrix_Copy that copies a 2048x2048 input matrix of single-precision floating-point numbers to an output matrix. The input and output matrices must have identical dimensions and data types. Each element in the input matrix must be exactly replicated in the corresponding position of the output matrix with no modifications or transformations.", "level2_prompt": "The Matrix_Copy task requires copying every element from a 2048x2048 input matrix to an identically sized output matrix. For each element at row i and column j, the value is transferred without modification.", "level3_prompt": "Compute the Matrix_Copy kernel on GPU using CUDA."}
{"id": 27, "task_name": "Matrix_Copy", "task_description": "Compute the Matrix_Copy kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(4096, 4096)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(4096, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 12;\n\n__global__ void matrix_copy_kernel(const float* A, float* B, int width) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < width && col < width) {\n        int idx = row * width + col;\n        B[idx] = A[idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t num_elements = static_cast<size_t>(N) * N;\n    size_t size_bytes = num_elements * sizeof(float);\n\n    float* h_A = (float*)malloc(size_bytes);\n    float* h_B = (float*)malloc(size_bytes);\n\n    read_binary(\"data/matrix_input.bin\", h_A, num_elements);\n\n    float *d_A, *d_B;\n    cudaMalloc(&d_A, size_bytes);\n    cudaMalloc(&d_B, size_bytes);\n\n    cudaMemcpy(d_A, h_A, size_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((N + threads.x - 1) / threads.x,\n                (N + threads.y - 1) / threads.y);\n\n    matrix_copy_kernel<<<blocks, threads>>>(d_A, d_B, N);\n    cudaMemcpy(h_B, d_B, size_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matrix_out.bin\", h_B, num_elements);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 12\n\nmatrix = np.random.rand(N, N).astype(np.float32)\n\nmatrix.tofile(\"data/matrix_input.bin\")\nmatrix.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 12\n    size = N * N\n\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Matrix_Copy that copies a 4096x4096 matrix of single-precision floating-point numbers from an input tensor to an output tensor. The input tensor is named 'matrix_input' and the output tensor is named 'matrix_out', both with shape (4096, 4096) and data type float32. The kernel must copy each element exactly without modification.", "level2_prompt": "Implement the Matrix_Copy operation: for a 4096x4096 matrix, copy each element from the input matrix to the corresponding position in the output matrix.", "level3_prompt": "Compute the Matrix_Copy kernel on GPU using CUDA."}
{"id": 28, "task_name": "Matrix_Copy", "task_description": "Compute the Matrix_Copy kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(8192, 8192)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(67108864,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 13;\n\n__global__ void matrix_copy_kernel(const float* A, float* B, int width) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < width && col < width) {\n        int idx = row * width + col;\n        B[idx] = A[idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t num_elements = static_cast<size_t>(N) * N;\n    size_t size_bytes = num_elements * sizeof(float);\n\n    float* h_A = (float*)malloc(size_bytes);\n    float* h_B = (float*)malloc(size_bytes);\n\n    read_binary(\"data/matrix_input.bin\", h_A, num_elements);\n\n    float *d_A, *d_B;\n    cudaMalloc(&d_A, size_bytes);\n    cudaMalloc(&d_B, size_bytes);\n\n    cudaMemcpy(d_A, h_A, size_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((N + threads.x - 1) / threads.x,\n                (N + threads.y - 1) / threads.y);\n\n    matrix_copy_kernel<<<blocks, threads>>>(d_A, d_B, N);\n    cudaMemcpy(h_B, d_B, size_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matrix_out.bin\", h_B, num_elements);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 13\n\nmatrix = np.random.rand(N, N).astype(np.float32)\n\nmatrix.tofile(\"data/matrix_input.bin\")\nmatrix.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 13\n    size = N * N\n\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Matrix_Copy that copies a 8192x8192 matrix of float32 elements to a flattened output vector. The input matrix is stored in row-major order, and the output must be a 67108864-element float32 vector containing an exact copy of the input data. The kernel must only process valid indices within the matrix dimensions and preserve the original data layout.", "level2_prompt": "Create a CUDA kernel that performs element-wise copying from a 2D matrix to a 1D output array. Given an input matrix of size 8192x8192, each element at position (i,j) should be copied to output position (i*8192 + j) in the output vector. The kernel must handle all valid matrix indices without modification.", "level3_prompt": "Compute the Matrix_Copy kernel on GPU using CUDA."}
{"id": 29, "task_name": "Matrix_Copy", "task_description": "Compute the Matrix_Copy kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(16384, 16384)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(16384, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 14;\n\n__global__ void matrix_copy_kernel(const float* A, float* B, int width) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < width && col < width) {\n        int idx = row * width + col;\n        B[idx] = A[idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t num_elements = static_cast<size_t>(N) * N;\n    size_t size_bytes = num_elements * sizeof(float);\n\n    float* h_A = (float*)malloc(size_bytes);\n    float* h_B = (float*)malloc(size_bytes);\n\n    read_binary(\"data/matrix_input.bin\", h_A, num_elements);\n\n    float *d_A, *d_B;\n    cudaMalloc(&d_A, size_bytes);\n    cudaMalloc(&d_B, size_bytes);\n\n    cudaMemcpy(d_A, h_A, size_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((N + threads.x - 1) / threads.x,\n                (N + threads.y - 1) / threads.y);\n\n    matrix_copy_kernel<<<blocks, threads>>>(d_A, d_B, N);\n    cudaMemcpy(h_B, d_B, size_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matrix_out.bin\", h_B, num_elements);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 14\n\nmatrix = np.random.rand(N, N).astype(np.float32)\n\nmatrix.tofile(\"data/matrix_input.bin\")\nmatrix.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n\n    if out.shape != ref.shape:\n        return False\n\n    return np.allclose(out, ref, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 14\n    size = N * N\n\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Matrix_Copy that copies a 16384x16384 matrix of single-precision floating-point numbers from an input array to an output array. The input tensor is named 'matrix_input' and the output tensor is named 'matrix_out'. The kernel must be designed to handle the entire matrix and only operate on valid indices within the matrix dimensions.", "level2_prompt": "Perform a matrix copy operation for a 16384x16384 matrix. For each element at position (i, j), copy the value from the input matrix to the output matrix.", "level3_prompt": "Compute the Matrix_Copy kernel on GPU using CUDA."}
{"id": 30, "task_name": "Reduction", "task_description": "Compute the Reduction kernel on GPU using CUDA.", "inputs": [{"name": "reduce_input", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "reduce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 10;\n\n__global__ void reduction_kernel(const float* input, float* sum, size_t n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(sum, input[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    read_binary(\"data/reduce_input.bin\", h_input, N);\n\n    float *d_input, *d_sum;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    reduction_kernel<<<blocks, threads>>>(d_input, d_sum, N);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/reduce_out.bin\", &h_sum, 1);\n\n    cudaFree(d_input);\n    cudaFree(d_sum);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 10\n\ndata = (np.random.rand(N) * 10 - 5).astype(np.float32)\nref_sum = np.sum(data).astype(np.float32)\n\ndata.tofile(\"data/reduce_input.bin\")\nnp.array([ref_sum], dtype=np.float32).tofile(\"data/reduce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/reduce_out.bin\"\n    ref_file = \"data/reduce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reduction. Compute the sum of all elements in a 1D input tensor containing 1024 float32 values. The kernel must process each element exactly once and produce a single float32 output value representing the total sum. The implementation must be numerically stable and handle all 1024 elements.", "level2_prompt": "Task: Reduction. Calculate the summation of all elements in a one-dimensional array of 1024 floating-point numbers. The algorithm should accumulate each element's value into a single result.", "level3_prompt": "Compute the Reduction kernel on GPU using CUDA."}
{"id": 31, "task_name": "Reduction", "task_description": "Compute the Reduction kernel on GPU using CUDA.", "inputs": [{"name": "reduce_input", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "reduce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 12;\n\n__global__ void reduction_kernel(const float* input, float* sum, size_t n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(sum, input[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    read_binary(\"data/reduce_input.bin\", h_input, N);\n\n    float *d_input, *d_sum;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    reduction_kernel<<<blocks, threads>>>(d_input, d_sum, N);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/reduce_out.bin\", &h_sum, 1);\n\n    cudaFree(d_input);\n    cudaFree(d_sum);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 12\n\ndata = (np.random.rand(N) * 10 - 5).astype(np.float32)\nref_sum = np.sum(data).astype(np.float32)\n\ndata.tofile(\"data/reduce_input.bin\")\nnp.array([ref_sum], dtype=np.float32).tofile(\"data/reduce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/reduce_out.bin\"\n    ref_file = \"data/reduce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reduction. Compute the sum of all elements in a one-dimensional input tensor. The input tensor is of shape (4096,) and data type float32. The output is a single float32 value in a tensor of shape (1,) which is the sum. The computed sum must be accurate within a tolerance of 1e-2 relative to a reference sum.", "level2_prompt": "Reduction: Sum all elements of an array of 4096 float32 numbers.", "level3_prompt": "Compute the Reduction kernel on GPU using CUDA."}
{"id": 32, "task_name": "Reduction", "task_description": "Compute the Reduction kernel on GPU using CUDA.", "inputs": [{"name": "reduce_input", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "reduce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 14;\n\n__global__ void reduction_kernel(const float* input, float* sum, size_t n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(sum, input[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    read_binary(\"data/reduce_input.bin\", h_input, N);\n\n    float *d_input, *d_sum;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    reduction_kernel<<<blocks, threads>>>(d_input, d_sum, N);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/reduce_out.bin\", &h_sum, 1);\n\n    cudaFree(d_input);\n    cudaFree(d_sum);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 14\n\ndata = (np.random.rand(N) * 10 - 5).astype(np.float32)\nref_sum = np.sum(data).astype(np.float32)\n\ndata.tofile(\"data/reduce_input.bin\")\nnp.array([ref_sum], dtype=np.float32).tofile(\"data/reduce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/reduce_out.bin\"\n    ref_file = \"data/reduce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reduction. Compute the sum of all elements in a one-dimensional input array containing 16384 float32 values. The output should be a single float32 value representing the total sum. The kernel must handle concurrent thread updates correctly to avoid race conditions and produce a result accurate within a tolerance of ±0.01 relative to the reference sum.", "level2_prompt": "Task: Reduction. For an input array of 16384 float32 elements, calculate the cumulative sum of all array values. The algorithm must aggregate every element exactly once into a single global accumulator value.", "level3_prompt": "Compute the Reduction kernel on GPU using CUDA."}
{"id": 33, "task_name": "Reduction", "task_description": "Compute the Reduction kernel on GPU using CUDA.", "inputs": [{"name": "reduce_input", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "reduce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 16;\n\n__global__ void reduction_kernel(const float* input, float* sum, size_t n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(sum, input[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    read_binary(\"data/reduce_input.bin\", h_input, N);\n\n    float *d_input, *d_sum;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    reduction_kernel<<<blocks, threads>>>(d_input, d_sum, N);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/reduce_out.bin\", &h_sum, 1);\n\n    cudaFree(d_input);\n    cudaFree(d_sum);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 16\n\ndata = (np.random.rand(N) * 10 - 5).astype(np.float32)\nref_sum = np.sum(data).astype(np.float32)\n\ndata.tofile(\"data/reduce_input.bin\")\nnp.array([ref_sum], dtype=np.float32).tofile(\"data/reduce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/reduce_out.bin\"\n    ref_file = \"data/reduce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reduction. Compute the sum of all elements in a one-dimensional input tensor of size 65,536 with float32 data type. The output is a single float32 value representing the total sum. The kernel must ensure that all input elements are processed correctly, and the output accurately reflects the sum without omitting any elements, respecting floating-point precision constraints.", "level2_prompt": "Task: Reduction. Mathematically, sum all values in a given array of floating-point numbers to produce a single scalar sum.", "level3_prompt": "Compute the sum of all elements in an input tensor."}
{"id": 34, "task_name": "Reduction", "task_description": "Compute the Reduction kernel on GPU using CUDA.", "inputs": [{"name": "reduce_input", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "reduce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 18;\n\n__global__ void reduction_kernel(const float* input, float* sum, size_t n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(sum, input[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    read_binary(\"data/reduce_input.bin\", h_input, N);\n\n    float *d_input, *d_sum;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    reduction_kernel<<<blocks, threads>>>(d_input, d_sum, N);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/reduce_out.bin\", &h_sum, 1);\n\n    cudaFree(d_input);\n    cudaFree(d_sum);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 18\n\ndata = (np.random.rand(N) * 10 - 5).astype(np.float32)\nref_sum = np.sum(data).astype(np.float32)\n\ndata.tofile(\"data/reduce_input.bin\")\nnp.array([ref_sum], dtype=np.float32).tofile(\"data/reduce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/reduce_out.bin\"\n    ref_file = \"data/reduce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a Reduction kernel that computes the sum of all elements in a 1D input tensor of 262144 float32 values. The output must be a single float32 value representing the total sum. The kernel must handle concurrent updates correctly to avoid race conditions.", "level2_prompt": "Implement a kernel that sums all elements of a 1D float32 array of size 262144. The output should be a single float32 value equal to the total sum of the input elements.", "level3_prompt": "Compute the Reduction kernel on GPU using CUDA."}
{"id": 35, "task_name": "Dot_Product", "task_description": "Compute the Dot_Product kernel on GPU using CUDA.", "inputs": [{"name": "dot_input_a", "dtype": "float32", "shape": "(65536,)"}, {"name": "dot_input_b", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "dot_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 16;\n\n__global__ void dot_product_kernel(const float* A, const float* B, float* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(result, A[idx] * B[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_A = (float*)malloc(bytes);\n    float* h_B = (float*)malloc(bytes);\n\n    read_binary(\"data/dot_input_a.bin\", h_A, N);\n    read_binary(\"data/dot_input_b.bin\", h_B, N);\n\n    float *d_A, *d_B, *d_result;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_result, sizeof(float));\n    cudaMemset(d_result, 0, sizeof(float));\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    dot_product_kernel<<<blocks, threads>>>(d_A, d_B, d_result, N);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_result, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/dot_out.bin\", &h_result, 1);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_result);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 16\n\na = (np.random.rand(N) * 2 - 1).astype(np.float32)\nb = (np.random.rand(N) * 5 - 1).astype(np.float32)\ndot_product = np.dot(a, b).astype(np.float32)\n\na.tofile(\"data/dot_input_a.bin\")\nb.tofile(\"data/dot_input_b.bin\")\nnp.array([dot_product], dtype=np.float32).tofile(\"data/dot_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/dot_out.bin\"\n    ref_file = \"data/dot_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel to compute the dot product of two input vectors. The kernel takes two input tensors 'dot_input_a' and 'dot_input_b', each containing 65536 float32 elements. The output should be a single float32 value in tensor 'dot_out' representing the sum of element-wise products. The kernel must handle parallel reduction correctly using atomic operations to ensure accuracy.", "level2_prompt": "Compute the dot product of two vectors by summing the products of corresponding elements. Given vectors A and B of length 65536, calculate Σ(A[i] * B[i]) for i from 0 to 65535. Output the result as a single scalar value.", "level3_prompt": "Compute the Dot_Product kernel on GPU using CUDA."}
{"id": 36, "task_name": "Dot_Product", "task_description": "Compute the Dot_Product kernel on GPU using CUDA.", "inputs": [{"name": "dot_input_a", "dtype": "float32", "shape": "(131072,)"}, {"name": "dot_input_b", "dtype": "float32", "shape": "(131072,)"}], "outputs": [{"name": "dot_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 17;\n\n__global__ void dot_product_kernel(const float* A, const float* B, float* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(result, A[idx] * B[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_A = (float*)malloc(bytes);\n    float* h_B = (float*)malloc(bytes);\n\n    read_binary(\"data/dot_input_a.bin\", h_A, N);\n    read_binary(\"data/dot_input_b.bin\", h_B, N);\n\n    float *d_A, *d_B, *d_result;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_result, sizeof(float));\n    cudaMemset(d_result, 0, sizeof(float));\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    dot_product_kernel<<<blocks, threads>>>(d_A, d_B, d_result, N);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_result, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/dot_out.bin\", &h_result, 1);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_result);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 17\n\na = (np.random.rand(N) * 2 - 1).astype(np.float32)\nb = (np.random.rand(N) * 5 - 1).astype(np.float32)\ndot_product = np.dot(a, b).astype(np.float32)\n\na.tofile(\"data/dot_input_a.bin\")\nb.tofile(\"data/dot_input_b.bin\")\nnp.array([dot_product], dtype=np.float32).tofile(\"data/dot_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/dot_out.bin\"\n    ref_file = \"data/dot_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Dot_Product. Compute the dot product of two input vectors. The inputs are two vectors of 131072 elements each, with data type float32. The output is a single scalar value of data type float32. The kernel must compute the sum of the products of corresponding elements from the two vectors.", "level2_prompt": "Task: Dot_Product. Calculate the dot product of two vectors by summing the element-wise products of all corresponding elements in the input vectors.", "level3_prompt": "Compute the dot product of two vectors."}
{"id": 37, "task_name": "Dot_Product", "task_description": "Compute the Dot_Product kernel on GPU using CUDA.", "inputs": [{"name": "dot_input_a", "dtype": "float32", "shape": "(262144,)"}, {"name": "dot_input_b", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "dot_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 18;\n\n__global__ void dot_product_kernel(const float* A, const float* B, float* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(result, A[idx] * B[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_A = (float*)malloc(bytes);\n    float* h_B = (float*)malloc(bytes);\n\n    read_binary(\"data/dot_input_a.bin\", h_A, N);\n    read_binary(\"data/dot_input_b.bin\", h_B, N);\n\n    float *d_A, *d_B, *d_result;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_result, sizeof(float));\n    cudaMemset(d_result, 0, sizeof(float));\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    dot_product_kernel<<<blocks, threads>>>(d_A, d_B, d_result, N);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_result, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/dot_out.bin\", &h_result, 1);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_result);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 18\n\na = (np.random.rand(N) * 2 - 1).astype(np.float32)\nb = (np.random.rand(N) * 5 - 1).astype(np.float32)\ndot_product = np.dot(a, b).astype(np.float32)\n\na.tofile(\"data/dot_input_a.bin\")\nb.tofile(\"data/dot_input_b.bin\")\nnp.array([dot_product], dtype=np.float32).tofile(\"data/dot_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/dot_out.bin\"\n    ref_file = \"data/dot_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Dot_Product. Compute the dot product of two vectors. Inputs are two vectors dot_input_a and dot_input_b, each containing 262144 elements of type float32. Output is a single float32 value stored in a tensor of shape (1,). The kernel must multiply corresponding elements from both vectors and accumulate their sum into a single result. The kernel must handle the entire vector length of 262144.", "level2_prompt": "Compute the dot product of two vectors by summing the products of their corresponding elements.", "level3_prompt": "Compute the Dot_Product kernel on GPU using CUDA."}
{"id": 38, "task_name": "Dot_Product", "task_description": "Compute the Dot_Product kernel on GPU using CUDA.", "inputs": [{"name": "dot_input_a", "dtype": "float32", "shape": "(524288,)"}, {"name": "dot_input_b", "dtype": "float32", "shape": "(524288,)"}], "outputs": [{"name": "dot_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 19;\n\n__global__ void dot_product_kernel(const float* A, const float* B, float* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(result, A[idx] * B[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_A = (float*)malloc(bytes);\n    float* h_B = (float*)malloc(bytes);\n\n    read_binary(\"data/dot_input_a.bin\", h_A, N);\n    read_binary(\"data/dot_input_b.bin\", h_B, N);\n\n    float *d_A, *d_B, *d_result;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_result, sizeof(float));\n    cudaMemset(d_result, 0, sizeof(float));\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    dot_product_kernel<<<blocks, threads>>>(d_A, d_B, d_result, N);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_result, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/dot_out.bin\", &h_result, 1);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_result);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 19\n\na = (np.random.rand(N) * 2 - 1).astype(np.float32)\nb = (np.random.rand(N) * 5 - 1).astype(np.float32)\ndot_product = np.dot(a, b).astype(np.float32)\n\na.tofile(\"data/dot_input_a.bin\")\nb.tofile(\"data/dot_input_b.bin\")\nnp.array([dot_product], dtype=np.float32).tofile(\"data/dot_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/dot_out.bin\"\n    ref_file = \"data/dot_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Dot_Product. Compute the dot product of two input vectors. The inputs are two one-dimensional tensors named dot_input_a and dot_input_b, each containing 524288 elements of type float32. The output is a single scalar value stored in a tensor named dot_out with shape (1,) and dtype float32. The kernel must calculate the sum of element-wise products of corresponding elements from both input vectors.", "level2_prompt": "Dot_Product: Calculate the sum of the products of corresponding elements from two equal-length vectors to produce a single scalar result.", "level3_prompt": "Compute the Dot_Product kernel on GPU using CUDA."}
{"id": 39, "task_name": "Dot_Product", "task_description": "Compute the Dot_Product kernel on GPU using CUDA.", "inputs": [{"name": "dot_input_a", "dtype": "float32", "shape": "(1048576,)"}, {"name": "dot_input_b", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "dot_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 20;\n\n__global__ void dot_product_kernel(const float* A, const float* B, float* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < n) {\n        atomicAdd(result, A[idx] * B[idx]);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_A = (float*)malloc(bytes);\n    float* h_B = (float*)malloc(bytes);\n\n    read_binary(\"data/dot_input_a.bin\", h_A, N);\n    read_binary(\"data/dot_input_b.bin\", h_B, N);\n\n    float *d_A, *d_B, *d_result;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_result, sizeof(float));\n    cudaMemset(d_result, 0, sizeof(float));\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    dot_product_kernel<<<blocks, threads>>>(d_A, d_B, d_result, N);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_result, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/dot_out.bin\", &h_result, 1);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_result);\n    free(h_A);\n    free(h_B);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 20\n\na = (np.random.rand(N) * 2 - 1).astype(np.float32)\nb = (np.random.rand(N) * 5 - 1).astype(np.float32)\ndot_product = np.dot(a, b).astype(np.float32)\n\na.tofile(\"data/dot_input_a.bin\")\nb.tofile(\"data/dot_input_b.bin\")\nnp.array([dot_product], dtype=np.float32).tofile(\"data/dot_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    out_file = \"data/dot_out.bin\"\n    ref_file = \"data/dot_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, 1)\n    ref = read_binary(ref_file, 1)\n\n    if np.allclose(out, ref, atol=1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Dot_Product' that computes the dot product of two input vectors. The inputs are two one-dimensional tensors named 'dot_input_a' and 'dot_input_b', each containing 1048576 elements of type float32. The output is a single-element tensor named 'dot_out' of type float32, holding the sum of element-wise multiplications between corresponding elements of the input vectors. The kernel must handle the entire vector length accurately using atomic operations or reduction techniques to accumulate partial sums.", "level2_prompt": "Design the 'Dot_Product' kernel to calculate the scalar product of two float32 vectors. Each element in the first vector is multiplied by the corresponding element in the second vector, and all resulting products are summed into a single float32 output value. The vectors have a fixed length of 1048576 elements.", "level3_prompt": "Compute the Dot_Product kernel on GPU using CUDA."}
{"id": 40, "task_name": "Prefix_Sum", "task_description": "Compute the Prefix_Sum kernel on GPU using CUDA.", "inputs": [{"name": "prefix_input", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "prefix_out", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 10;\n\n__global__ void prefix_sum_kernel(const float* input, float* output, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        float sum = 0.0f;\n        for (int i = 0; i < n; ++i) {\n            sum += input[i];\n            output[i] = sum;\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    read_binary(\"data/prefix_input.bin\", h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    prefix_sum_kernel<<<1, 1>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/prefix_out.bin\", h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 10\n\ndata = (np.random.rand(N) * 10).astype(np.float32)\nprefix = np.cumsum(data).astype(np.float32)\n\ndata.tofile(\"data/prefix_input.bin\")\nprefix.tofile(\"data/prefix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    N = 1 << 10\n\n    out_file = \"data/prefix_out.bin\"\n    ref_file = \"data/prefix_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, N)\n    ref = read_binary(ref_file, N)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the Prefix_Sum task. The kernel should compute the inclusive prefix sum (cumulative sum) of a 1D input tensor containing 1024 float32 values. The output tensor must be a 1D float32 array of 1024 elements where each element at index i is the sum of all input elements from index 0 to i inclusive. The kernel must produce numerically accurate results matching a sequential cumulative sum calculation.", "level2_prompt": "Compute the inclusive prefix sum for a 1D array of 1024 floating-point numbers. Each output element should represent the cumulative sum of all preceding input elements including the current position.", "level3_prompt": "Compute the Prefix_Sum kernel on GPU using CUDA."}
{"id": 41, "task_name": "Prefix_Sum", "task_description": "Compute the Prefix_Sum kernel on GPU using CUDA.", "inputs": [{"name": "prefix_input", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "prefix_out", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 12;\n\n__global__ void prefix_sum_kernel(const float* input, float* output, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        float sum = 0.0f;\n        for (int i = 0; i < n; ++i) {\n            sum += input[i];\n            output[i] = sum;\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    read_binary(\"data/prefix_input.bin\", h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    prefix_sum_kernel<<<1, 1>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/prefix_out.bin\", h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 12\n\ndata = (np.random.rand(N) * 10).astype(np.float32)\nprefix = np.cumsum(data).astype(np.float32)\n\ndata.tofile(\"data/prefix_input.bin\")\nprefix.tofile(\"data/prefix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    N = 1 << 12\n\n    out_file = \"data/prefix_out.bin\"\n    ref_file = \"data/prefix_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, N)\n    ref = read_binary(ref_file, N)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the Prefix_Sum task. The kernel must compute the cumulative sum (prefix sum) of a one-dimensional input tensor containing 4096 float32 elements. The output tensor should be the same shape and data type, where each element at position i is the sum of all input elements from index 0 to i. The kernel must produce results within a tolerance of 0.01 compared to a reference cumulative sum.", "level2_prompt": "Perform a prefix sum operation where each element in the output array is the cumulative sum of all preceding elements in the input array, including the current element. The input is a float32 array of length 4096, and the output must be an equally sized float32 array representing the cumulative sums.", "level3_prompt": "Compute the prefix sum of a float32 array with 4096 elements."}
{"id": 42, "task_name": "Prefix_Sum", "task_description": "Compute the Prefix_Sum kernel on GPU using CUDA.", "inputs": [{"name": "prefix_input", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "prefix_out", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 14;\n\n__global__ void prefix_sum_kernel(const float* input, float* output, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        float sum = 0.0f;\n        for (int i = 0; i < n; ++i) {\n            sum += input[i];\n            output[i] = sum;\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    read_binary(\"data/prefix_input.bin\", h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    prefix_sum_kernel<<<1, 1>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/prefix_out.bin\", h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 14\n\ndata = (np.random.rand(N) * 10).astype(np.float32)\nprefix = np.cumsum(data).astype(np.float32)\n\ndata.tofile(\"data/prefix_input.bin\")\nprefix.tofile(\"data/prefix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    N = 1 << 14\n\n    out_file = \"data/prefix_out.bin\"\n    ref_file = \"data/prefix_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, N)\n    ref = read_binary(ref_file, N)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Prefix_Sum. Implement a CUDA kernel that computes the prefix sum (cumulative sum) of a 1D input array. The input is a tensor named 'prefix_input' with shape (16384,) and dtype float32. The output tensor 'prefix_out' must have the same shape and dtype, where each element at position i is the sum of all input elements from index 0 to i. The kernel must maintain sequential accumulation order and produce results within a numerical tolerance of 1e-2 relative to the reference implementation.", "level2_prompt": "Task: Prefix_Sum. For an input array of length 16384, compute an output array where each element output[i] equals the sum of input elements from input[0] to input[i]. This requires sequentially accumulating sums across the array indices.", "level3_prompt": "Compute the Prefix_Sum kernel on GPU using CUDA."}
{"id": 43, "task_name": "Prefix_Sum", "task_description": "Compute the Prefix_Sum kernel on GPU using CUDA.", "inputs": [{"name": "prefix_input", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "prefix_out", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 16;\n\n__global__ void prefix_sum_kernel(const float* input, float* output, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        float sum = 0.0f;\n        for (int i = 0; i < n; ++i) {\n            sum += input[i];\n            output[i] = sum;\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    read_binary(\"data/prefix_input.bin\", h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    prefix_sum_kernel<<<1, 1>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/prefix_out.bin\", h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 16\n\ndata = (np.random.rand(N) * 10).astype(np.float32)\nprefix = np.cumsum(data).astype(np.float32)\n\ndata.tofile(\"data/prefix_input.bin\")\nprefix.tofile(\"data/prefix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    N = 1 << 16\n\n    out_file = \"data/prefix_out.bin\"\n    ref_file = \"data/prefix_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, N)\n    ref = read_binary(ref_file, N)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for computing the inclusive prefix sum (also known as an inclusive scan) of a 1D array. The input is a single tensor named 'prefix_input' containing 65536 elements of type float32. The output tensor 'prefix_out' must have the same shape and data type, where each element at index i represents the sum of all input elements from index 0 to index i. The kernel must be implemented for GPU execution and produce results with an absolute tolerance of 0.01 compared to a sequential reference implementation.", "level2_prompt": "Compute the inclusive prefix sum operation on a 1D array of 65532 float32 elements. For each position i in the output array, the value must equal the cumulative sum of all elements from index 0 to i in the input array. The algorithm should be parallelized for GPU execution.", "level3_prompt": "Compute the Prefix_Sum kernel on GPU using CUDA."}
{"id": 44, "task_name": "Prefix_Sum", "task_description": "Compute the Prefix_Sum kernel on GPU using CUDA.", "inputs": [{"name": "prefix_input", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "prefix_out", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 18;\n\n__global__ void prefix_sum_kernel(const float* input, float* output, int n) {\n    if (threadIdx.x == 0 && blockIdx.x == 0) {\n        float sum = 0.0f;\n        for (int i = 0; i < n; ++i) {\n            sum += input[i];\n            output[i] = sum;\n        }\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n    float* h_output = (float*)malloc(bytes);\n\n    read_binary(\"data/prefix_input.bin\", h_input, N);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    prefix_sum_kernel<<<1, 1>>>(d_input, d_output, N);\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/prefix_out.bin\", h_output, N);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 18\n\ndata = (np.random.rand(N) * 10).astype(np.float32)\nprefix = np.cumsum(data).astype(np.float32)\n\ndata.tofile(\"data/prefix_input.bin\")\nprefix.tofile(\"data/prefix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    N = 1 << 18\n\n    out_file = \"data/prefix_out.bin\"\n    ref_file = \"data/prefix_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_binary(out_file, N)\n    ref = read_binary(ref_file, N)\n\n    if np.allclose(out, ref, atol=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Prefix_Sum' that computes the cumulative sum (prefix sum) of a one-dimensional input tensor. The input tensor is named 'prefix_input', has a shape of (262144,), and uses float32 data type. The output tensor 'prefix_out' must have the same shape and data type, where each element at index i is the sum of all input elements from index 0 to i. The kernel must maintain sequential dependency where each output element depends on the previous sum.", "level2_prompt": "Create a CUDA kernel for the 'Prefix_Sum' operation. The kernel should compute an output array where each element at position i equals the sum of all elements from index 0 to i in the input array. The input is a one-dimensional float32 array of size 262144, and the output must be a float32 array of the same size.", "level3_prompt": "Compute the Prefix_Sum kernel on GPU using CUDA."}
{"id": 45, "task_name": "Categorical_Cross-Entropy_Loss", "task_description": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "ce_logits", "dtype": "float32", "shape": "(16384, 10)"}, {"name": "ce_labels", "dtype": "int32", "shape": "(16384,)"}], "outputs": [{"name": "ce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define C 10\nconst int N = 1 << 14;\n\n__global__ void cross_entropy_kernel(const float* logits, const int* labels, float* loss_sum) {\n    int j = blockIdx.x * blockDim.x + threadIdx.x;\n    if (j >= N) return;\n\n    float max_logit = -1e20f;\n    for (int k = 0; k < C; ++k) {\n        float z = logits[j * C + k];\n        if (z > max_logit) max_logit = z;\n    }\n\n    float exp_sum = 0.0f;\n    for (int k = 0; k < C; ++k) {\n        exp_sum += expf(logits[j * C + k] - max_logit);\n    }\n\n    float log_sum = logf(exp_sum);\n    float loss = log_sum + max_logit - logits[j * C + labels[j]];\n    atomicAdd(loss_sum, loss / N);\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nint main() {\n    size_t logits_elems = N * C;\n    size_t logits_bytes = logits_elems * sizeof(float);\n    size_t labels_bytes = N * sizeof(int);\n\n    float* h_logits = (float*)malloc(logits_bytes);\n    int* h_labels = (int*)malloc(labels_bytes);\n\n    read_binary_float(\"data/ce_logits.bin\", h_logits, logits_elems);\n    read_binary_int(\"data/ce_labels.bin\", h_labels, N);\n\n    float *d_logits, *d_loss;\n    int *d_labels;\n\n    cudaMalloc(&d_logits, logits_bytes);\n    cudaMalloc(&d_labels, labels_bytes);\n    cudaMalloc(&d_loss, sizeof(float));\n\n    cudaMemcpy(d_logits, h_logits, logits_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_labels, h_labels, labels_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_loss, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n\n    cross_entropy_kernel<<<blocks, threads>>>(d_logits, d_labels, d_loss);\n\n    float h_loss = 0.0f;\n    cudaMemcpy(&h_loss, d_loss, sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::ofstream out(\"data/ce_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_loss), sizeof(float));\n    out.close();\n\n    cudaFree(d_logits);\n    cudaFree(d_labels);\n    cudaFree(d_loss);\n\n    free(h_logits);\n    free(h_labels);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(30)\n\nC = 10\nN = 1 << 14\n\nlogits = (np.random.randn(N, C) * 3).astype(np.float32)\nlabels = np.random.randint(0, C, size=N, dtype=np.int32)\n\nlogits_max = logits.max(axis=1, keepdims=True)\nexp_logits = np.exp(logits - logits_max)\nlog_sum_exp = np.log(exp_logits.sum(axis=1))\nlosses = log_sum_exp + logits_max[:, 0] - logits[np.arange(N), labels]\navg_loss = losses.mean().astype(np.float32)\n\nlogits.tofile(\"data/ce_logits.bin\")\nlabels.tofile(\"data/ce_labels.bin\")\nnp.array([avg_loss], dtype=np.float32).tofile(\"data/ce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nif __name__ == \"__main__\":\n    out_file = \"data/ce_out.bin\"\n    ref_file = \"data/ce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_scalar(out_file)\n    ref = read_scalar(ref_file)\n\n    if abs(out - ref) < 1e-2:\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel to compute the categorical cross-entropy loss. The kernel should take two inputs: a 2D float32 tensor of logits with shape (16384, 10) and a 1D int32 tensor of labels with shape (16384). The output is a single float32 scalar representing the average loss across all samples. For each sample, first find the maximum logit value for numerical stability, then compute the exponential of each logit minus this maximum, sum these exponentials, take the logarithm of this sum, and calculate the loss as the logarithm plus the maximum minus the logit corresponding to the true label. Finally, average these per-sample losses across all 16384 samples.", "level2_prompt": "Compute the average categorical cross-entropy loss for a batch of 16384 samples with 10 classes. For each sample, determine the loss by subtracting the true label's logit from the logarithm of the sum of exponentials of all logits after adjusting for numerical stability. The final output should be the mean of these individual losses.", "level3_prompt": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA."}
{"id": 46, "task_name": "Categorical_Cross-Entropy_Loss", "task_description": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "ce_logits", "dtype": "float32", "shape": "(65536, 10)"}, {"name": "ce_labels", "dtype": "int32", "shape": "(65536,)"}], "outputs": [{"name": "ce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define C 10\nconst int N = 1 << 16;\n\n__global__ void cross_entropy_kernel(const float* logits, const int* labels, float* loss_sum) {\n    int j = blockIdx.x * blockDim.x + threadIdx.x;\n    if (j >= N) return;\n\n    float max_logit = -1e20f;\n    for (int k = 0; k < C; ++k) {\n        float z = logits[j * C + k];\n        if (z > max_logit) max_logit = z;\n    }\n\n    float exp_sum = 0.0f;\n    for (int k = 0; k < C; ++k) {\n        exp_sum += expf(logits[j * C + k] - max_logit);\n    }\n\n    float log_sum = logf(exp_sum);\n    float loss = log_sum + max_logit - logits[j * C + labels[j]];\n    atomicAdd(loss_sum, loss / N);\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nint main() {\n    size_t logits_elems = N * C;\n    size_t logits_bytes = logits_elems * sizeof(float);\n    size_t labels_bytes = N * sizeof(int);\n\n    float* h_logits = (float*)malloc(logits_bytes);\n    int* h_labels = (int*)malloc(labels_bytes);\n\n    read_binary_float(\"data/ce_logits.bin\", h_logits, logits_elems);\n    read_binary_int(\"data/ce_labels.bin\", h_labels, N);\n\n    float *d_logits, *d_loss;\n    int *d_labels;\n\n    cudaMalloc(&d_logits, logits_bytes);\n    cudaMalloc(&d_labels, labels_bytes);\n    cudaMalloc(&d_loss, sizeof(float));\n\n    cudaMemcpy(d_logits, h_logits, logits_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_labels, h_labels, labels_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_loss, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n\n    cross_entropy_kernel<<<blocks, threads>>>(d_logits, d_labels, d_loss);\n\n    float h_loss = 0.0f;\n    cudaMemcpy(&h_loss, d_loss, sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::ofstream out(\"data/ce_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_loss), sizeof(float));\n    out.close();\n\n    cudaFree(d_logits);\n    cudaFree(d_labels);\n    cudaFree(d_loss);\n\n    free(h_logits);\n    free(h_labels);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(30)\n\nC = 10\nN = 1 << 16\n\nlogits = (np.random.randn(N, C) * 3).astype(np.float32)\nlabels = np.random.randint(0, C, size=N, dtype=np.int32)\n\nlogits_max = logits.max(axis=1, keepdims=True)\nexp_logits = np.exp(logits - logits_max)\nlog_sum_exp = np.log(exp_logits.sum(axis=1))\nlosses = log_sum_exp + logits_max[:, 0] - logits[np.arange(N), labels]\navg_loss = losses.mean().astype(np.float32)\n\nlogits.tofile(\"data/ce_logits.bin\")\nlabels.tofile(\"data/ce_labels.bin\")\nnp.array([avg_loss], dtype=np.float32).tofile(\"data/ce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nif __name__ == \"__main__\":\n    out_file = \"data/ce_out.bin\"\n    ref_file = \"data/ce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_scalar(out_file)\n    ref = read_scalar(ref_file)\n\n    if abs(out - ref) < 1e-2:\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Categorical_Cross-Entropy_Loss. Compute the average cross-entropy loss for a batch of 65536 samples across 10 classes. Inputs: 'ce_logits' is a float32 tensor of shape (65536, 10) containing unnormalized log probabilities, and 'ce_labels' is an int32 tensor of shape (65536,) containing true class indices in [0,9]. Output: 'ce_out' is a float32 scalar representing the batch-averaged loss. For each sample, find the maximum logit in its row, compute the log-sum-exp of shifted logits, and calculate loss as log-sum-exp plus max logit minus the true class logit. Accumulate each sample's loss contribution (divided by 65536) atomically into the output scalar to avoid race conditions.", "level2_prompt": "Task: Categorical_Cross-Entropy_Loss. For N samples and C classes (N=65536, C=10), compute L = (1/N) * Σ_{i=0}^{N-1} [log(Σ_{k=0}^{C-1} exp(z_{i,k} - max_i)) + max_i - z_{i,y_i}], where z_{i,k} are logits, y_i are true labels, and max_i is the maximum logit in row i.", "level3_prompt": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA."}
{"id": 47, "task_name": "Categorical_Cross-Entropy_Loss", "task_description": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "ce_logits", "dtype": "float32", "shape": "(262144, 10)"}, {"name": "ce_labels", "dtype": "int32", "shape": "(262144,)"}], "outputs": [{"name": "ce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define C 10\nconst int N = 1 << 18;\n\n__global__ void cross_entropy_kernel(const float* logits, const int* labels, float* loss_sum) {\n    int j = blockIdx.x * blockDim.x + threadIdx.x;\n    if (j >= N) return;\n\n    float max_logit = -1e20f;\n    for (int k = 0; k < C; ++k) {\n        float z = logits[j * C + k];\n        if (z > max_logit) max_logit = z;\n    }\n\n    float exp_sum = 0.0f;\n    for (int k = 0; k < C; ++k) {\n        exp_sum += expf(logits[j * C + k] - max_logit);\n    }\n\n    float log_sum = logf(exp_sum);\n    float loss = log_sum + max_logit - logits[j * C + labels[j]];\n    atomicAdd(loss_sum, loss / N);\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nint main() {\n    size_t logits_elems = N * C;\n    size_t logits_bytes = logits_elems * sizeof(float);\n    size_t labels_bytes = N * sizeof(int);\n\n    float* h_logits = (float*)malloc(logits_bytes);\n    int* h_labels = (int*)malloc(labels_bytes);\n\n    read_binary_float(\"data/ce_logits.bin\", h_logits, logits_elems);\n    read_binary_int(\"data/ce_labels.bin\", h_labels, N);\n\n    float *d_logits, *d_loss;\n    int *d_labels;\n\n    cudaMalloc(&d_logits, logits_bytes);\n    cudaMalloc(&d_labels, labels_bytes);\n    cudaMalloc(&d_loss, sizeof(float));\n\n    cudaMemcpy(d_logits, h_logits, logits_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_labels, h_labels, labels_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_loss, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n\n    cross_entropy_kernel<<<blocks, threads>>>(d_logits, d_labels, d_loss);\n\n    float h_loss = 0.0f;\n    cudaMemcpy(&h_loss, d_loss, sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::ofstream out(\"data/ce_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_loss), sizeof(float));\n    out.close();\n\n    cudaFree(d_logits);\n    cudaFree(d_labels);\n    cudaFree(d_loss);\n\n    free(h_logits);\n    free(h_labels);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(30)\n\nC = 10\nN = 1 << 18\n\nlogits = (np.random.randn(N, C) * 3).astype(np.float32)\nlabels = np.random.randint(0, C, size=N, dtype=np.int32)\n\nlogits_max = logits.max(axis=1, keepdims=True)\nexp_logits = np.exp(logits - logits_max)\nlog_sum_exp = np.log(exp_logits.sum(axis=1))\nlosses = log_sum_exp + logits_max[:, 0] - logits[np.arange(N), labels]\navg_loss = losses.mean().astype(np.float32)\n\nlogits.tofile(\"data/ce_logits.bin\")\nlabels.tofile(\"data/ce_labels.bin\")\nnp.array([avg_loss], dtype=np.float32).tofile(\"data/ce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nif __name__ == \"__main__\":\n    out_file = \"data/ce_out.bin\"\n    ref_file = \"data/ce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_scalar(out_file)\n    ref = read_scalar(ref_file)\n\n    if abs(out - ref) < 1e-2:\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Categorical_Cross-Entropy_Loss. Compute the average cross-entropy loss for a batch of 262144 samples across 10 classes. Inputs: 'ce_logits' is a 2D float32 tensor of shape (262144, 10) representing unnormalized logits, and 'ce_labels' is a 1D int32 tensor of shape (262144,) containing true class indices (0-9). Output: 'ce_out' is a scalar float32 tensor (shape (1,)) holding the mean loss. For each sample, first find the maximum logit value for numerical stability. Then compute the exponential sum of logits adjusted by this max value, take its logarithm, and derive the loss as log_sum_exp plus max_logit minus the true class logit. Accumulate losses atomically across all samples and divide by 262144 to compute the final average.", "level2_prompt": "Task: Categorical_Cross-Entropy_Loss. For each sample i (0 ≤ i < 262144), given logits vector L_i (length 10) and true label T_i: Compute max_logit_i = max(L_i). Calculate S_i = sum(exp(L_i[k] - max_logit_i) for k=0 to 9. Then loss_i = log(S_i) + max_logit_i - L_i[T_i]. The final output is the average of loss_i over all samples: (1/262144) * sum(loss_i).", "level3_prompt": "Compute the average categorical cross-entropy loss."}
{"id": 48, "task_name": "Categorical_Cross-Entropy_Loss", "task_description": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "ce_logits", "dtype": "float32", "shape": "(1048576, 10)"}, {"name": "ce_labels", "dtype": "int32", "shape": "(1048576,)"}], "outputs": [{"name": "ce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define C 10\nconst int N = 1 << 20;\n\n__global__ void cross_entropy_kernel(const float* logits, const int* labels, float* loss_sum) {\n    int j = blockIdx.x * blockDim.x + threadIdx.x;\n    if (j >= N) return;\n\n    float max_logit = -1e20f;\n    for (int k = 0; k < C; ++k) {\n        float z = logits[j * C + k];\n        if (z > max_logit) max_logit = z;\n    }\n\n    float exp_sum = 0.0f;\n    for (int k = 0; k < C; ++k) {\n        exp_sum += expf(logits[j * C + k] - max_logit);\n    }\n\n    float log_sum = logf(exp_sum);\n    float loss = log_sum + max_logit - logits[j * C + labels[j]];\n    atomicAdd(loss_sum, loss / N);\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nint main() {\n    size_t logits_elems = N * C;\n    size_t logits_bytes = logits_elems * sizeof(float);\n    size_t labels_bytes = N * sizeof(int);\n\n    float* h_logits = (float*)malloc(logits_bytes);\n    int* h_labels = (int*)malloc(labels_bytes);\n\n    read_binary_float(\"data/ce_logits.bin\", h_logits, logits_elems);\n    read_binary_int(\"data/ce_labels.bin\", h_labels, N);\n\n    float *d_logits, *d_loss;\n    int *d_labels;\n\n    cudaMalloc(&d_logits, logits_bytes);\n    cudaMalloc(&d_labels, labels_bytes);\n    cudaMalloc(&d_loss, sizeof(float));\n\n    cudaMemcpy(d_logits, h_logits, logits_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_labels, h_labels, labels_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_loss, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n\n    cross_entropy_kernel<<<blocks, threads>>>(d_logits, d_labels, d_loss);\n\n    float h_loss = 0.0f;\n    cudaMemcpy(&h_loss, d_loss, sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::ofstream out(\"data/ce_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_loss), sizeof(float));\n    out.close();\n\n    cudaFree(d_logits);\n    cudaFree(d_labels);\n    cudaFree(d_loss);\n\n    free(h_logits);\n    free(h_labels);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(30)\n\nC = 10\nN = 1 << 20\n\nlogits = (np.random.randn(N, C) * 3).astype(np.float32)\nlabels = np.random.randint(0, C, size=N, dtype=np.int32)\n\nlogits_max = logits.max(axis=1, keepdims=True)\nexp_logits = np.exp(logits - logits_max)\nlog_sum_exp = np.log(exp_logits.sum(axis=1))\nlosses = log_sum_exp + logits_max[:, 0] - logits[np.arange(N), labels]\navg_loss = losses.mean().astype(np.float32)\n\nlogits.tofile(\"data/ce_logits.bin\")\nlabels.tofile(\"data/ce_labels.bin\")\nnp.array([avg_loss], dtype=np.float32).tofile(\"data/ce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nif __name__ == \"__main__\":\n    out_file = \"data/ce_out.bin\"\n    ref_file = \"data/ce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_scalar(out_file)\n    ref = read_scalar(ref_file)\n\n    if abs(out - ref) < 1e-2:\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Categorical Cross-Entropy Loss computation. The input consists of a 2D float32 tensor 'ce_logits' with shape (1048576, 10) representing logits for 1048576 samples across 10 classes, and a 1D int32 tensor 'ce_labels' with shape (1048576,) containing the true class indices. The output should be a scalar float32 tensor 'ce_out' representing the average cross-entropy loss. For each sample, compute the loss by: 1) finding the maximum logit value, 2) calculating the sum of exponentials of (logit - max_logit) for all classes, 3) taking the logarithm of this sum, and 4) subtracting the true class's logit from (log_sum + max_logit). Accumulate each sample's loss divided by 1048576 into the output scalar. Numeric stability must be maintained through max subtraction.", "level2_prompt": "Compute the average categorical cross-entropy loss across 1048576 samples. For each sample: determine the maximum logit value among its 10 classes, compute the sum of exponentials of (each logit minus this maximum), take the logarithm of this sum, then calculate loss as (log_sum + max_logit - true_class_logit). Sum all sample losses divided by 1048576 to produce a single scalar output.", "level3_prompt": "Compute the Categorical Cross-Entropy Loss kernel on GPU."}
{"id": 49, "task_name": "Categorical_Cross-Entropy_Loss", "task_description": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "ce_logits", "dtype": "float32", "shape": "(4194304, 10)"}, {"name": "ce_labels", "dtype": "int32", "shape": "(4194304,)"}], "outputs": [{"name": "ce_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define C 10\nconst int N = 1 << 22;\n\n__global__ void cross_entropy_kernel(const float* logits, const int* labels, float* loss_sum) {\n    int j = blockIdx.x * blockDim.x + threadIdx.x;\n    if (j >= N) return;\n\n    float max_logit = -1e20f;\n    for (int k = 0; k < C; ++k) {\n        float z = logits[j * C + k];\n        if (z > max_logit) max_logit = z;\n    }\n\n    float exp_sum = 0.0f;\n    for (int k = 0; k < C; ++k) {\n        exp_sum += expf(logits[j * C + k] - max_logit);\n    }\n\n    float log_sum = logf(exp_sum);\n    float loss = log_sum + max_logit - logits[j * C + labels[j]];\n    atomicAdd(loss_sum, loss / N);\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nint main() {\n    size_t logits_elems = N * C;\n    size_t logits_bytes = logits_elems * sizeof(float);\n    size_t labels_bytes = N * sizeof(int);\n\n    float* h_logits = (float*)malloc(logits_bytes);\n    int* h_labels = (int*)malloc(labels_bytes);\n\n    read_binary_float(\"data/ce_logits.bin\", h_logits, logits_elems);\n    read_binary_int(\"data/ce_labels.bin\", h_labels, N);\n\n    float *d_logits, *d_loss;\n    int *d_labels;\n\n    cudaMalloc(&d_logits, logits_bytes);\n    cudaMalloc(&d_labels, labels_bytes);\n    cudaMalloc(&d_loss, sizeof(float));\n\n    cudaMemcpy(d_logits, h_logits, logits_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_labels, h_labels, labels_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_loss, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n\n    cross_entropy_kernel<<<blocks, threads>>>(d_logits, d_labels, d_loss);\n\n    float h_loss = 0.0f;\n    cudaMemcpy(&h_loss, d_loss, sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::ofstream out(\"data/ce_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_loss), sizeof(float));\n    out.close();\n\n    cudaFree(d_logits);\n    cudaFree(d_labels);\n    cudaFree(d_loss);\n\n    free(h_logits);\n    free(h_labels);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(30)\n\nC = 10\nN = 1 << 22\n\nlogits = (np.random.randn(N, C) * 3).astype(np.float32)\nlabels = np.random.randint(0, C, size=N, dtype=np.int32)\n\nlogits_max = logits.max(axis=1, keepdims=True)\nexp_logits = np.exp(logits - logits_max)\nlog_sum_exp = np.log(exp_logits.sum(axis=1))\nlosses = log_sum_exp + logits_max[:, 0] - logits[np.arange(N), labels]\navg_loss = losses.mean().astype(np.float32)\n\nlogits.tofile(\"data/ce_logits.bin\")\nlabels.tofile(\"data/ce_labels.bin\")\nnp.array([avg_loss], dtype=np.float32).tofile(\"data/ce_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nif __name__ == \"__main__\":\n    out_file = \"data/ce_out.bin\"\n    ref_file = \"data/ce_ref.bin\"\n\n    if not os.path.exists(out_file) or not os.path.exists(ref_file):\n        print(\"F\")\n        exit(0)\n\n    out = read_scalar(out_file)\n    ref = read_scalar(ref_file)\n\n    if abs(out - ref) < 1e-2:\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "The task is to compute the categorical cross-entropy loss. Inputs are a 2D float32 tensor 'ce_logits' with shape (4194304, 10) representing logits for each sample and class, and a 1D int32 tensor 'ce_labels' with shape (4194304) containing the true class indices. The output is a single float32 scalar 'ce_out' representing the average loss. For each sample, determine the maximum logit value across classes to ensure numerical stability. Compute the sum of exponentials of (each logit minus the maximum logit). Calculate the loss as the logarithm of this sum plus the maximum logit, minus the logit corresponding to the true label. Accumulate these sample losses and compute their average across all samples. The kernel must handle atomic accumulation to avoid race conditions and ensure numerical stability.", "level2_prompt": "Compute the categorical cross-entropy loss by processing each sample independently. For each sample, find the maximum logit value. Sum the exponentials of (each logit minus this maximum). Then, calculate the loss as log(sum) + maximum logit minus the true class logit. Average these individual losses across all samples to produce a single scalar output.", "level3_prompt": "Compute the Categorical_Cross-Entropy_Loss kernel on GPU."}
{"id": 50, "task_name": "Monte_Carlo_Integration", "task_description": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA.", "inputs": [{"name": "mc_y", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "mc_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 14;\nconst float a = 0.0f;\nconst float b = 0.5f;\n\n__global__ void monte_carlo_kernel(const float* y_values, float* integral_sum) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        atomicAdd(integral_sum, y_values[idx] / N);\n    }\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(float);\n\n    float* h_y = (float*)malloc(data_bytes);\n    read_binary_float(\"data/mc_y.bin\", h_y, N);\n\n    float *d_y, *d_integral;\n    cudaMalloc(&d_y, data_bytes);\n    cudaMalloc(&d_integral, sizeof(float));\n\n    cudaMemcpy(d_y, h_y, data_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_integral, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    monte_carlo_kernel<<<blocks, threads>>>(d_y, d_integral);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_integral, sizeof(float), cudaMemcpyDeviceToHost);\n    h_result *= (b - a);\n\n    std::ofstream out(\"data/mc_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_result), sizeof(float));\n    out.close();\n\n    cudaFree(d_y);\n    cudaFree(d_integral);\n    free(h_y);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 14\na, b = 0.0, 0.5\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nx = np.random.uniform(a, b, size=N).astype(np.float32)\ny = f(x).astype(np.float32)\nestimate = ((b - a) * np.mean(y)).astype(np.float32)\n\ny.tofile(\"data/mc_y.bin\")\nnp.array([estimate], dtype=np.float32).tofile(\"data/mc_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nout_file = \"data/mc_out.bin\"\nref_file = \"data/mc_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_scalar(out_file)\nref = read_scalar(ref_file)\n\nif abs(out - ref) < 1e-2:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement the Monte_Carlo_Integration kernel. The kernel must approximate the integral of a function over the interval [0.0, 0.5] using the Monte Carlo method. The input is a 1D tensor named 'mc_y' with 16384 float32 values, representing function evaluations at random points in the interval. The output is a single float32 value in a tensor named 'mc_out', which is the estimated integral scaled by the interval length (0.5). The kernel must compute the average of the input values (by summing each value divided by 16384) and use atomic operations to accumulate the result. The kernel must process all 16384 elements.", "level2_prompt": "The Monte_Carlo_Integration kernel computes the average of input function evaluations. For each element in the input array, the kernel adds the element divided by the total number of elements (16384) to a global sum variable. The global sum is accumulated using atomic operations to avoid race conditions.", "level3_prompt": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA."}
{"id": 51, "task_name": "Monte_Carlo_Integration", "task_description": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA.", "inputs": [{"name": "mc_y", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "mc_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 16;\nconst float a = 0.0f;\nconst float b = 0.5f;\n\n__global__ void monte_carlo_kernel(const float* y_values, float* integral_sum) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        atomicAdd(integral_sum, y_values[idx] / N);\n    }\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(float);\n\n    float* h_y = (float*)malloc(data_bytes);\n    read_binary_float(\"data/mc_y.bin\", h_y, N);\n\n    float *d_y, *d_integral;\n    cudaMalloc(&d_y, data_bytes);\n    cudaMalloc(&d_integral, sizeof(float));\n\n    cudaMemcpy(d_y, h_y, data_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_integral, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    monte_carlo_kernel<<<blocks, threads>>>(d_y, d_integral);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_integral, sizeof(float), cudaMemcpyDeviceToHost);\n    h_result *= (b - a);\n\n    std::ofstream out(\"data/mc_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_result), sizeof(float));\n    out.close();\n\n    cudaFree(d_y);\n    cudaFree(d_integral);\n    free(h_y);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 16\na, b = 0.0, 0.5\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nx = np.random.uniform(a, b, size=N).astype(np.float32)\ny = f(x).astype(np.float32)\nestimate = ((b - a) * np.mean(y)).astype(np.float32)\n\ny.tofile(\"data/mc_y.bin\")\nnp.array([estimate], dtype=np.float32).tofile(\"data/mc_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nout_file = \"data/mc_out.bin\"\nref_file = \"data/mc_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_scalar(out_file)\nref = read_scalar(ref_file)\n\nif abs(out - ref) < 1e-2:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for Monte Carlo integration. The kernel should approximate the definite integral of a function over the interval [0.0, 0.5] using 65536 randomly sampled points. The input is a one-dimensional float32 tensor 'mc_y' of shape (65536,) containing function evaluations at random points in the interval. The output should be a single float32 value 'mc_out' of shape (1,) representing the integral estimate. The kernel must compute the average of all input values, scale it by the interval length (0.5 - 0.0), and use atomic operations for thread-safe accumulation.", "level2_prompt": "Compute a Monte Carlo integration estimate using 65536 samples. Given input values representing function evaluations at uniformly distributed random points between 0.0 and 0.5, calculate the integral approximation by averaging all values and multiplying by the interval length (0.5 - 0.0). Use atomic operations to safely accumulate partial sums.", "level3_prompt": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA."}
{"id": 52, "task_name": "Monte_Carlo_Integration", "task_description": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA.", "inputs": [{"name": "mc_y", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "mc_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 18;\nconst float a = 0.0f;\nconst float b = 0.5f;\n\n__global__ void monte_carlo_kernel(const float* y_values, float* integral_sum) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        atomicAdd(integral_sum, y_values[idx] / N);\n    }\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(float);\n\n    float* h_y = (float*)malloc(data_bytes);\n    read_binary_float(\"data/mc_y.bin\", h_y, N);\n\n    float *d_y, *d_integral;\n    cudaMalloc(&d_y, data_bytes);\n    cudaMalloc(&d_integral, sizeof(float));\n\n    cudaMemcpy(d_y, h_y, data_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_integral, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    monte_carlo_kernel<<<blocks, threads>>>(d_y, d_integral);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_integral, sizeof(float), cudaMemcpyDeviceToHost);\n    h_result *= (b - a);\n\n    std::ofstream out(\"data/mc_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_result), sizeof(float));\n    out.close();\n\n    cudaFree(d_y);\n    cudaFree(d_integral);\n    free(h_y);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 18\na, b = 0.0, 0.5\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nx = np.random.uniform(a, b, size=N).astype(np.float32)\ny = f(x).astype(np.float32)\nestimate = ((b - a) * np.mean(y)).astype(np.float32)\n\ny.tofile(\"data/mc_y.bin\")\nnp.array([estimate], dtype=np.float32).tofile(\"data/mc_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nout_file = \"data/mc_out.bin\"\nref_file = \"data/mc_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_scalar(out_file)\nref = read_scalar(ref_file)\n\nif abs(out - ref) < 1e-2:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a Monte Carlo integration kernel to approximate the definite integral of sin(2πx) over the interval [0, 0.5]. The input is a 1D tensor 'mc_y' containing 262144 float32 values representing function evaluations at randomly sampled points. The kernel must compute the average of these values and store the result in a scalar output tensor 'mc_out' of float32 type. Use atomic operations to safely accumulate partial sums across threads. The final scaling by the interval length (0.5) occurs after kernel execution.", "level2_prompt": "Compute the Monte Carlo integration of sin(2πx) between 0 and 0.5. Given a vector of function evaluations at random points, calculate their mean value. Each thread processes one element, contributing its value divided by the total sample count to a global sum using atomic addition.", "level3_prompt": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA."}
{"id": 53, "task_name": "Monte_Carlo_Integration", "task_description": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA.", "inputs": [{"name": "mc_y", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "mc_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 20;\nconst float a = 0.0f;\nconst float b = 0.5f;\n\n__global__ void monte_carlo_kernel(const float* y_values, float* integral_sum) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        atomicAdd(integral_sum, y_values[idx] / N);\n    }\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(float);\n\n    float* h_y = (float*)malloc(data_bytes);\n    read_binary_float(\"data/mc_y.bin\", h_y, N);\n\n    float *d_y, *d_integral;\n    cudaMalloc(&d_y, data_bytes);\n    cudaMalloc(&d_integral, sizeof(float));\n\n    cudaMemcpy(d_y, h_y, data_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_integral, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    monte_carlo_kernel<<<blocks, threads>>>(d_y, d_integral);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_integral, sizeof(float), cudaMemcpyDeviceToHost);\n    h_result *= (b - a);\n\n    std::ofstream out(\"data/mc_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_result), sizeof(float));\n    out.close();\n\n    cudaFree(d_y);\n    cudaFree(d_integral);\n    free(h_y);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 20\na, b = 0.0, 0.5\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nx = np.random.uniform(a, b, size=N).astype(np.float32)\ny = f(x).astype(np.float32)\nestimate = ((b - a) * np.mean(y)).astype(np.float32)\n\ny.tofile(\"data/mc_y.bin\")\nnp.array([estimate], dtype=np.float32).tofile(\"data/mc_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nout_file = \"data/mc_out.bin\"\nref_file = \"data/mc_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_scalar(out_file)\nref = read_scalar(ref_file)\n\nif abs(out - ref) < 1e-2:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Monte Carlo Integration. Approximate the integral of a function over the interval [0.0, 0.5] using Monte Carlo integration with 1048576 samples. The input tensor 'mc_y' (shape: (1048576,), dtype: float32) contains function values at randomly sampled points. The output tensor 'mc_out' (shape: (1,), dtype: float32) must be computed as the average of all values in 'mc_y' multiplied by the interval length (0.5). The kernel must correctly accumulate contributions from all samples without race conditions.", "level2_prompt": "Monte Carlo Integration: Estimate the integral ∫₀⁰·⁵ f(x)dx using the formula (b-a) × (1/N) × Σᵢ f(xᵢ), where N=1048576, a=0.0, b=0.5. The input provides f(xᵢ) values, and the output is a single float representing the integral approximation.", "level3_prompt": "Compute Monte Carlo integration."}
{"id": 54, "task_name": "Monte_Carlo_Integration", "task_description": "Compute the Monte_Carlo_Integration kernel on GPU using CUDA.", "inputs": [{"name": "mc_y", "dtype": "float32", "shape": "(4194304,)"}], "outputs": [{"name": "mc_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 1 << 22;\nconst float a = 0.0f;\nconst float b = 0.5f;\n\n__global__ void monte_carlo_kernel(const float* y_values, float* integral_sum) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < N) {\n        atomicAdd(integral_sum, y_values[idx] / N);\n    }\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(float);\n\n    float* h_y = (float*)malloc(data_bytes);\n    read_binary_float(\"data/mc_y.bin\", h_y, N);\n\n    float *d_y, *d_integral;\n    cudaMalloc(&d_y, data_bytes);\n    cudaMalloc(&d_integral, sizeof(float));\n\n    cudaMemcpy(d_y, h_y, data_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_integral, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    monte_carlo_kernel<<<blocks, threads>>>(d_y, d_integral);\n\n    float h_result = 0.0f;\n    cudaMemcpy(&h_result, d_integral, sizeof(float), cudaMemcpyDeviceToHost);\n    h_result *= (b - a);\n\n    std::ofstream out(\"data/mc_out.bin\", std::ios::binary);\n    out.write(reinterpret_cast<char*>(&h_result), sizeof(float));\n    out.close();\n\n    cudaFree(d_y);\n    cudaFree(d_integral);\n    free(h_y);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 22\na, b = 0.0, 0.5\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nx = np.random.uniform(a, b, size=N).astype(np.float32)\ny = f(x).astype(np.float32)\nestimate = ((b - a) * np.mean(y)).astype(np.float32)\n\ny.tofile(\"data/mc_y.bin\")\nnp.array([estimate], dtype=np.float32).tofile(\"data/mc_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_scalar(filename):\n    return np.fromfile(filename, dtype=np.float32, count=1)[0]\n\nout_file = \"data/mc_out.bin\"\nref_file = \"data/mc_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_scalar(out_file)\nref = read_scalar(ref_file)\n\nif abs(out - ref) < 1e-2:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a GPU kernel for Monte Carlo integration. The input is a 1D tensor named `mc_y` containing 4194304 float32 values, which are function evaluations of sin(2*pi*x) at random points uniformly sampled in the interval [0.0, 0.5]. The kernel must compute the average of these function evaluations by having each thread process one element, divide it by 4194304, and atomically add the result to a global accumulator. The output is a single float32 scalar representing this average. Note that the integral estimate is obtained by multiplying this average by the interval length (0.5) in the host code.", "level2_prompt": "The kernel computes the average of 4194304 float32 input values. Each thread processes one element, divides it by 4194304, and atomically adds the result to a global accumulator, producing a single float32 output value.", "level3_prompt": "Compute the Monte Carlo integration kernel on GPU."}
{"id": 55, "task_name": "Histogramming", "task_description": "Compute the Histogramming kernel on GPU using CUDA.", "inputs": [{"name": "hist_input", "dtype": "int32", "shape": "(65536,)"}], "outputs": [{"name": "hist_out", "dtype": "int32", "shape": "(256,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n#include <cstring>\n\n#define NUM_BINS 256\nconst int N = 1 << 16;\n\n__global__ void histogram_kernel(const int* input, int* histogram) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    int val = input[idx];\n    if (val >= 0 && val < NUM_BINS) {\n        atomicAdd(&histogram[val], 1);\n    }\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nvoid write_binary_int(const std::string& filename, const int* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(int));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(int);\n    size_t hist_bytes = NUM_BINS * sizeof(int);\n\n    int* h_input = (int*)malloc(input_bytes);\n    int* h_output = (int*)malloc(hist_bytes);\n    memset(h_output, 0, hist_bytes);\n\n    read_binary_int(\"data/hist_input.bin\", h_input, N);\n\n    int *d_input, *d_histogram;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_histogram, hist_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_histogram, 0, hist_bytes);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    histogram_kernel<<<blocks, threads>>>(d_input, d_histogram);\n\n    cudaMemcpy(h_output, d_histogram, hist_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary_int(\"data/hist_out.bin\", h_output, NUM_BINS);\n\n    cudaFree(d_input);\n    cudaFree(d_histogram);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nnum_bins = 256\nN = 1 << 16\n\ninput_array = np.random.randint(0, num_bins, size=N, dtype=np.int32)\nhistogram = np.bincount(input_array, minlength=num_bins).astype(np.int32)\n\ninput_array.tofile(\"data/hist_input.bin\")\nhistogram.tofile(\"data/hist_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nNUM_BINS = 256\n\ndef read_ints(filename, size):\n    return np.fromfile(filename, dtype=np.int32, count=size)\n\nout_file = \"data/hist_out.bin\"\nref_file = \"data/hist_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_ints(out_file, NUM_BINS)\nref = read_ints(ref_file, NUM_BINS)\n\nif np.array_equal(out, ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a Histogramming kernel that counts the frequency of integer values in an input array. The input is a 1D tensor of 65536 integers (int32). The output should be a 1D tensor of 256 integers (int32) representing counts for values 0 through 255. Only values between 0 and 255 inclusive should be counted. The kernel must safely handle concurrent updates to histogram bins when multiple input values map to the same bin.", "level2_prompt": "Compute a histogram with 256 bins from an array of 65536 integers. For each integer in the input, if its value falls between 0 and 255, increment the corresponding bin count. The output should be a 256-element array where each element contains the count of its corresponding integer value in the input.", "level3_prompt": "Compute the Histogramming kernel on GPU using CUDA."}
{"id": 56, "task_name": "Histogramming", "task_description": "Compute the Histogramming kernel on GPU using CUDA.", "inputs": [{"name": "hist_input", "dtype": "int32", "shape": "(262144,)"}], "outputs": [{"name": "hist_out", "dtype": "int32", "shape": "(256,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n#include <cstring>\n\n#define NUM_BINS 256\nconst int N = 1 << 18;\n\n__global__ void histogram_kernel(const int* input, int* histogram) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    int val = input[idx];\n    if (val >= 0 && val < NUM_BINS) {\n        atomicAdd(&histogram[val], 1);\n    }\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nvoid write_binary_int(const std::string& filename, const int* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(int));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(int);\n    size_t hist_bytes = NUM_BINS * sizeof(int);\n\n    int* h_input = (int*)malloc(input_bytes);\n    int* h_output = (int*)malloc(hist_bytes);\n    memset(h_output, 0, hist_bytes);\n\n    read_binary_int(\"data/hist_input.bin\", h_input, N);\n\n    int *d_input, *d_histogram;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_histogram, hist_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_histogram, 0, hist_bytes);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    histogram_kernel<<<blocks, threads>>>(d_input, d_histogram);\n\n    cudaMemcpy(h_output, d_histogram, hist_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary_int(\"data/hist_out.bin\", h_output, NUM_BINS);\n\n    cudaFree(d_input);\n    cudaFree(d_histogram);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nnum_bins = 256\nN = 1 << 18\n\ninput_array = np.random.randint(0, num_bins, size=N, dtype=np.int32)\nhistogram = np.bincount(input_array, minlength=num_bins).astype(np.int32)\n\ninput_array.tofile(\"data/hist_input.bin\")\nhistogram.tofile(\"data/hist_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nNUM_BINS = 256\n\ndef read_ints(filename, size):\n    return np.fromfile(filename, dtype=np.int32, count=size)\n\nout_file = \"data/hist_out.bin\"\nref_file = \"data/hist_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_ints(out_file, NUM_BINS)\nref = read_ints(ref_file, NUM_BINS)\n\nif np.array_equal(out, ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for Histogramming. The kernel takes a 1D input tensor 'hist_input' with 262144 elements of type int32. It must compute a histogram output tensor 'hist_out' with 256 elements of type int32, where each element at index i contains the count of how many times the value i appears in the input. Values in the input must be between 0 and 255 inclusive; any values outside this range should be ignored. The implementation must use atomic operations to ensure thread safety when updating the histogram bins.", "level2_prompt": "Create a Histogramming kernel that counts the frequency of each integer value in the input array. For each element in the input array, if the value is between 0 and 255, increment the corresponding bin in the output histogram. Values outside the 0-255 range should be disregarded. The output is a 256-element array where each index represents a value and contains its occurrence count.", "level3_prompt": "Compute a histogram for integer values in the range 0 to 255 from an input array."}
{"id": 57, "task_name": "Histogramming", "task_description": "Compute the Histogramming kernel on GPU using CUDA.", "inputs": [{"name": "hist_input", "dtype": "int32", "shape": "(1048576,)"}], "outputs": [{"name": "hist_out", "dtype": "int32", "shape": "(256,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n#include <cstring>\n\n#define NUM_BINS 256\nconst int N = 1 << 20;\n\n__global__ void histogram_kernel(const int* input, int* histogram) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    int val = input[idx];\n    if (val >= 0 && val < NUM_BINS) {\n        atomicAdd(&histogram[val], 1);\n    }\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nvoid write_binary_int(const std::string& filename, const int* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(int));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(int);\n    size_t hist_bytes = NUM_BINS * sizeof(int);\n\n    int* h_input = (int*)malloc(input_bytes);\n    int* h_output = (int*)malloc(hist_bytes);\n    memset(h_output, 0, hist_bytes);\n\n    read_binary_int(\"data/hist_input.bin\", h_input, N);\n\n    int *d_input, *d_histogram;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_histogram, hist_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_histogram, 0, hist_bytes);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    histogram_kernel<<<blocks, threads>>>(d_input, d_histogram);\n\n    cudaMemcpy(h_output, d_histogram, hist_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary_int(\"data/hist_out.bin\", h_output, NUM_BINS);\n\n    cudaFree(d_input);\n    cudaFree(d_histogram);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nnum_bins = 256\nN = 1 << 20\n\ninput_array = np.random.randint(0, num_bins, size=N, dtype=np.int32)\nhistogram = np.bincount(input_array, minlength=num_bins).astype(np.int32)\n\ninput_array.tofile(\"data/hist_input.bin\")\nhistogram.tofile(\"data/hist_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nNUM_BINS = 256\n\ndef read_ints(filename, size):\n    return np.fromfile(filename, dtype=np.int32, count=size)\n\nout_file = \"data/hist_out.bin\"\nref_file = \"data/hist_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_ints(out_file, NUM_BINS)\nref = read_ints(ref_file, NUM_BINS)\n\nif np.array_equal(out, ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Histogramming. Compute a histogram from an input array of integers. The input is a 1D tensor named 'hist_input' with 1,048,576 elements of type int32. The output is a 1D tensor named 'hist_out' with 256 elements of type int32, where each element at index i represents the count of value i in the input. Input values must be in the range [0, 255]; values outside this range should be ignored. The histogram must be computed by incrementing counts using thread-safe operations.", "level2_prompt": "Task: Histogramming. For each element in the input array, map its integer value to a bin index between 0 and 255. If the value is within this range, increment the corresponding bin's count in the output histogram array. The histogram array must be initialized to zero before counting.", "level3_prompt": "Compute a histogram with 256 bins for the input array."}
{"id": 58, "task_name": "Histogramming", "task_description": "Compute the Histogramming kernel on GPU using CUDA.", "inputs": [{"name": "hist_input", "dtype": "int32", "shape": "(4194304,)"}], "outputs": [{"name": "hist_out", "dtype": "int32", "shape": "(256,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n#include <cstring>\n\n#define NUM_BINS 256\nconst int N = 1 << 22;\n\n__global__ void histogram_kernel(const int* input, int* histogram) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    int val = input[idx];\n    if (val >= 0 && val < NUM_BINS) {\n        atomicAdd(&histogram[val], 1);\n    }\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nvoid write_binary_int(const std::string& filename, const int* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(int));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(int);\n    size_t hist_bytes = NUM_BINS * sizeof(int);\n\n    int* h_input = (int*)malloc(input_bytes);\n    int* h_output = (int*)malloc(hist_bytes);\n    memset(h_output, 0, hist_bytes);\n\n    read_binary_int(\"data/hist_input.bin\", h_input, N);\n\n    int *d_input, *d_histogram;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_histogram, hist_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_histogram, 0, hist_bytes);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    histogram_kernel<<<blocks, threads>>>(d_input, d_histogram);\n\n    cudaMemcpy(h_output, d_histogram, hist_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary_int(\"data/hist_out.bin\", h_output, NUM_BINS);\n\n    cudaFree(d_input);\n    cudaFree(d_histogram);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nnum_bins = 256\nN = 1 << 22\n\ninput_array = np.random.randint(0, num_bins, size=N, dtype=np.int32)\nhistogram = np.bincount(input_array, minlength=num_bins).astype(np.int32)\n\ninput_array.tofile(\"data/hist_input.bin\")\nhistogram.tofile(\"data/hist_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nNUM_BINS = 256\n\ndef read_ints(filename, size):\n    return np.fromfile(filename, dtype=np.int32, count=size)\n\nout_file = \"data/hist_out.bin\"\nref_file = \"data/hist_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_ints(out_file, NUM_BINS)\nref = read_ints(ref_file, NUM_BINS)\n\nif np.array_equal(out, ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Histogramming. Compute a histogram of the input array, where each element represents an integer value. The input is a 1D tensor with 4,194,304 elements of type int32, and each value must be in the range [0, 255]. The output is a 1D tensor with 256 elements of type int32, where each element at index i indicates the count of occurrences of the value i in the input. Values outside the [0, 255] range should be ignored, and the output histogram must be initialized to zero before accumulation.", "level2_prompt": "Task: Histogramming. Given an array of integers, count the frequency of each value between 0 and 255. For each element in the input, if the value is within this range, increment the corresponding bin in the histogram. The histogram has 256 bins, all initialized to zero.", "level3_prompt": "Compute a histogram with 256 bins for the input array."}
{"id": 59, "task_name": "Histogramming", "task_description": "Compute the Histogramming kernel on GPU using CUDA.", "inputs": [{"name": "hist_input", "dtype": "int32", "shape": "(16777216,)"}], "outputs": [{"name": "hist_out", "dtype": "int32", "shape": "(256,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n#include <cstring>\n\n#define NUM_BINS 256\nconst int N = 1 << 24;\n\n__global__ void histogram_kernel(const int* input, int* histogram) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    int val = input[idx];\n    if (val >= 0 && val < NUM_BINS) {\n        atomicAdd(&histogram[val], 1);\n    }\n}\n\nvoid read_binary_int(const std::string& filename, int* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(int));\n    in.close();\n}\n\nvoid write_binary_int(const std::string& filename, const int* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(int));\n    out.close();\n}\n\nint main() {\n    size_t input_bytes = N * sizeof(int);\n    size_t hist_bytes = NUM_BINS * sizeof(int);\n\n    int* h_input = (int*)malloc(input_bytes);\n    int* h_output = (int*)malloc(hist_bytes);\n    memset(h_output, 0, hist_bytes);\n\n    read_binary_int(\"data/hist_input.bin\", h_input, N);\n\n    int *d_input, *d_histogram;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_histogram, hist_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_histogram, 0, hist_bytes);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    histogram_kernel<<<blocks, threads>>>(d_input, d_histogram);\n\n    cudaMemcpy(h_output, d_histogram, hist_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary_int(\"data/hist_out.bin\", h_output, NUM_BINS);\n\n    cudaFree(d_input);\n    cudaFree(d_histogram);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nnum_bins = 256\nN = 1 << 24\n\ninput_array = np.random.randint(0, num_bins, size=N, dtype=np.int32)\nhistogram = np.bincount(input_array, minlength=num_bins).astype(np.int32)\n\ninput_array.tofile(\"data/hist_input.bin\")\nhistogram.tofile(\"data/hist_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nNUM_BINS = 256\n\ndef read_ints(filename, size):\n    return np.fromfile(filename, dtype=np.int32, count=size)\n\nout_file = \"data/hist_out.bin\"\nref_file = \"data/hist_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_ints(out_file, NUM_BINS)\nref = read_ints(ref_file, NUM_BINS)\n\nif np.array_equal(out, ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Histogramming. Compute a 256-bin histogram for an input array of 16,777,216 integers. The input array contains values between 0 and 255 inclusive. The output is a 256-element array where each element at index i represents the count of occurrences of value i in the input. The kernel must ignore input values outside the [0,255] range and initialize the output array to zeros before accumulation.", "level2_prompt": "Task: Histogramming. For each element in the input array, if the value v is between 0 and 255, increment the v-th position in the output array. The output array has 256 elements initialized to zero, with each element representing the frequency count of its corresponding index value in the input.", "level3_prompt": "Compute the Histogramming kernel on GPU using CUDA."}
{"id": 60, "task_name": "Sigmoid", "task_description": "Compute the Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <cmath>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n#define TOLERANCE 1e-5f\n\n__global__ void sigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 1.0f / (1.0f + expf(-x)); \n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    sigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 49\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32)\noutput_tensor = torch.sigmoid(input_tensor)\n\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Sigmoid. Implement a CUDA kernel that computes the sigmoid function for each element in a 2D input tensor of shape (16, 1024) with float32 data type. The output tensor must have the same shape and data type. The sigmoid function is defined as output = 1.0 / (1.0 + exp(-input)) for each element. The kernel must handle all elements independently and respect the input tensor's dimensions.", "level2_prompt": "Task: Sigmoid. Apply the sigmoid activation function element-wise to a 2D tensor. For each value x in the input tensor, compute y = 1/(1 + exp(-x)). The input tensor has dimensions 16x1024 and float32 data type, and the output must match these specifications.", "level3_prompt": "Compute the Sigmoid kernel on GPU using CUDA."}
{"id": 61, "task_name": "Sigmoid", "task_description": "Compute the Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <cmath>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n#define TOLERANCE 1e-5f\n\n__global__ void sigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 1.0f / (1.0f + expf(-x)); \n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    sigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 49\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32)\noutput_tensor = torch.sigmoid(input_tensor)\n\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the Sigmoid task. The kernel must compute the sigmoid function for each element in a 16x4096 input tensor of 32-bit floats. The sigmoid function is defined as 1/(1 + exp(-x)). The output tensor must be the same shape and data type as the input. All elements must be processed independently, and the output values must lie within the range (0,1).", "level2_prompt": "Sigmoid task: For each element x in the input tensor, compute the function f(x) = 1/(1 + exp(-x)). The operation is applied element-wise across a 16x4096 float32 tensor.", "level3_prompt": "Compute the Sigmoid kernel on GPU using CUDA."}
{"id": 62, "task_name": "Sigmoid", "task_description": "Compute the Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <cmath>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n#define TOLERANCE 1e-5f\n\n__global__ void sigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 1.0f / (1.0f + expf(-x)); \n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    sigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 49\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32)\noutput_tensor = torch.sigmoid(input_tensor)\n\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Sigmoid task: Implement a CUDA kernel to compute the sigmoid function for each element in a 2D input tensor. The input is a float32 tensor of shape (16, 16384), and the output must be a float32 tensor of identical shape. The sigmoid function is defined as 1 / (1 + exp(-x)) for each element x. The kernel must process all 262,144 elements independently with numerical precision within 1e-5 tolerance compared to a reference implementation.", "level2_prompt": "Sigmoid computation: For each element in a 16x16384 matrix, apply the sigmoid function f(x) = 1 / (1 + e^{-x}). The operation must be performed element-wise with floating-point precision.", "level3_prompt": "Compute the Sigmoid kernel on GPU using CUDA."}
{"id": 63, "task_name": "Sigmoid", "task_description": "Compute the Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <cmath>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n#define TOLERANCE 1e-5f\n\n__global__ void sigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 1.0f / (1.0f + expf(-x)); \n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    sigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 49\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32)\noutput_tensor = torch.sigmoid(input_tensor)\n\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Sigmoid kernel on GPU. The kernel should compute the sigmoid function element-wise for a 16x65536 input tensor of float32 values, producing a flattened output tensor of 1048576 float32 elements. The sigmoid function is defined as output = 1.0 / (1.0 + exp(-input)) for each element. The kernel must produce results within 1e-5 tolerance relative to a reference implementation.", "level2_prompt": "Compute the Sigmoid function for each element in a tensor. Given an input tensor of shape (16, 65536) with float32 values, apply the transformation: output[i] = 1.0 / (1.0 + exp(-input[i])) to produce a flattened output tensor with 1048576 float32 elements.", "level3_prompt": "Compute the Sigmoid kernel on GPU."}
{"id": 64, "task_name": "Sigmoid", "task_description": "Compute the Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <cmath>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n#define TOLERANCE 1e-5f\n\n__global__ void sigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 1.0f / (1.0f + expf(-x)); \n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    sigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 49\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32)\noutput_tensor = torch.sigmoid(input_tensor)\n\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Sigmoid' that computes the sigmoid function element-wise on a 2D input tensor of shape (16, 262144) with float32 data type. The input tensor is named 'input', and the output tensor must have the same shape and data type, named 'output'. For each element x in the input, the output must be computed as 1.0 / (1.0 + exp(-x)). The kernel must handle all elements independently and preserve input-output dimensionality.", "level2_prompt": "Create a GPU kernel called 'Sigmoid' that applies the sigmoid function element-wise to each value in a 16x262144 float32 tensor. The sigmoid function transforms each input value x into 1/(1 + exp(-x)). The output tensor must match the input dimensions exactly.", "level3_prompt": "Compute the Sigmoid kernel on GPU using CUDA."}
{"id": 65, "task_name": "Ordinary_Least_Squares_Regression", "task_description": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA.", "inputs": [{"name": "ols_X", "dtype": "float32", "shape": "(16384, 10)"}, {"name": "ols_y", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "ols_out", "dtype": "float32", "shape": "(10,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <vector>\n#include <string>\n\n#define D 10\nconst int N = 1 << 14;\n\n__global__ void compute_XTX_XTy_kernel(const float* X, const float* y, float* XTX, float* XTy) {\n    int i = threadIdx.y;\n    int j = threadIdx.x;\n    if (i >= D || j >= D) return;\n\n    float sum = 0.0f;\n    for (int n = 0; n < N; ++n) {\n        sum += X[n * D + i] * X[n * D + j];\n    }\n    XTX[i * D + j] = sum;\n\n    if (j == 0) {\n        float yt = 0.0f;\n        for (int n = 0; n < N; ++n) {\n            yt += X[n * D + i] * y[n];\n        }\n        XTy[i] = yt;\n    }\n}\n\nbool solve_linear_system_cpu(const float* A, const float* b, float* x, int n) {\n    std::vector<std::vector<float>> mat(n, std::vector<float>(n + 1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) mat[i][j] = A[i * n + j];\n        mat[i][n] = b[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (fabs(mat[i][i]) < 1e-6) return false;\n        for (int j = i + 1; j < n; ++j) {\n            float f = mat[j][i] / mat[i][i];\n            for (int k = i; k <= n; ++k)\n                mat[j][k] -= f * mat[i][k];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        x[i] = mat[i][n];\n        for (int j = i + 1; j < n; ++j)\n            x[i] -= mat[i][j] * x[j];\n        x[i] /= mat[i][i];\n    }\n    return true;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary_float(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t X_bytes = N * D * sizeof(float);\n    size_t y_bytes = N * sizeof(float);\n\n    float *h_X = (float*)malloc(X_bytes);\n    float *h_y = (float*)malloc(y_bytes);\n\n    read_binary_float(\"data/ols_X.bin\", h_X, N * D);\n    read_binary_float(\"data/ols_y.bin\", h_y, N);\n\n    float *d_X, *d_y, *d_XTX, *d_XTy;\n    cudaMalloc(&d_X, X_bytes);\n    cudaMalloc(&d_y, y_bytes);\n    cudaMalloc(&d_XTX, D * D * sizeof(float));\n    cudaMalloc(&d_XTy, D * sizeof(float));\n\n    cudaMemcpy(d_X, h_X, X_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_y, h_y, y_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_XTX, 0, D * D * sizeof(float));\n    cudaMemset(d_XTy, 0, D * sizeof(float));\n\n    dim3 threads(D, D);\n    compute_XTX_XTy_kernel<<<1, threads>>>(d_X, d_y, d_XTX, d_XTy);\n\n    float* h_XTX = (float*)malloc(D * D * sizeof(float));\n    float* h_XTy = (float*)malloc(D * sizeof(float));\n\n    cudaMemcpy(h_XTX, d_XTX, D * D * sizeof(float), cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_XTy, d_XTy, D * sizeof(float), cudaMemcpyDeviceToHost);\n\n    float h_beta[D];\n    if (!solve_linear_system_cpu(h_XTX, h_XTy, h_beta, D)) {\n        std::cout << \"F\" << std::endl;\n        return 0;\n    }\n\n    write_binary_float(\"data/ols_out.bin\", h_beta, D);\n\n    cudaFree(d_X); cudaFree(d_y); cudaFree(d_XTX); cudaFree(d_XTy);\n    free(h_X); free(h_y); free(h_XTX); free(h_XTy);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nD = 10\nN = 1 << 14\n\nX = np.random.randn(N, D).astype(np.float32)\ntrue_beta = np.random.randn(D).astype(np.float32)\ny = X @ true_beta + np.random.randn(N).astype(np.float32) * 0.1\n\nXTX = X.T @ X\nXTy = X.T @ y\nbeta = np.linalg.solve(XTX, XTy).astype(np.float32)\n\nX.tofile(\"data/ols_X.bin\")\ny.astype(np.float32).tofile(\"data/ols_y.bin\")\nbeta.tofile(\"data/ols_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nD = 10\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/ols_out.bin\"\nref_file = \"data/ols_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, D)\nref = read_binary(ref_file, D)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Ordinary Least Squares Regression. Given a feature matrix X of shape (16384, 10) with float32 data type and a target vector y of shape (16384,) with float32 data type, compute the regression coefficients vector beta of shape (10,) with float32 data type. The solution must first compute the matrix X^T * X and the vector X^T * y, then solve the linear system (X^T * X) * beta = X^T * y for beta. The dimensions are fixed: 16384 samples and 10 features. The computation must respect numerical precision constraints for float32.", "level2_prompt": "Task: Ordinary Least Squares Regression. Given matrix X (16384×10) and vector y (16384×1), compute coefficient vector beta (10×1) by solving the normal equations. First, calculate matrix A = X^T * X (10×10) and vector b = X^T * y (10×1). Then solve the linear system A * beta = b to obtain the regression coefficients.", "level3_prompt": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA."}
{"id": 66, "task_name": "Ordinary_Least_Squares_Regression", "task_description": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA.", "inputs": [{"name": "ols_X", "dtype": "float32", "shape": "(65536, 10)"}, {"name": "ols_y", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "ols_out", "dtype": "float32", "shape": "(10,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <vector>\n#include <string>\n\n#define D 10\nconst int N = 1 << 16;\n\n__global__ void compute_XTX_XTy_kernel(const float* X, const float* y, float* XTX, float* XTy) {\n    int i = threadIdx.y;\n    int j = threadIdx.x;\n    if (i >= D || j >= D) return;\n\n    float sum = 0.0f;\n    for (int n = 0; n < N; ++n) {\n        sum += X[n * D + i] * X[n * D + j];\n    }\n    XTX[i * D + j] = sum;\n\n    if (j == 0) {\n        float yt = 0.0f;\n        for (int n = 0; n < N; ++n) {\n            yt += X[n * D + i] * y[n];\n        }\n        XTy[i] = yt;\n    }\n}\n\nbool solve_linear_system_cpu(const float* A, const float* b, float* x, int n) {\n    std::vector<std::vector<float>> mat(n, std::vector<float>(n + 1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) mat[i][j] = A[i * n + j];\n        mat[i][n] = b[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (fabs(mat[i][i]) < 1e-6) return false;\n        for (int j = i + 1; j < n; ++j) {\n            float f = mat[j][i] / mat[i][i];\n            for (int k = i; k <= n; ++k)\n                mat[j][k] -= f * mat[i][k];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        x[i] = mat[i][n];\n        for (int j = i + 1; j < n; ++j)\n            x[i] -= mat[i][j] * x[j];\n        x[i] /= mat[i][i];\n    }\n    return true;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary_float(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t X_bytes = N * D * sizeof(float);\n    size_t y_bytes = N * sizeof(float);\n\n    float *h_X = (float*)malloc(X_bytes);\n    float *h_y = (float*)malloc(y_bytes);\n\n    read_binary_float(\"data/ols_X.bin\", h_X, N * D);\n    read_binary_float(\"data/ols_y.bin\", h_y, N);\n\n    float *d_X, *d_y, *d_XTX, *d_XTy;\n    cudaMalloc(&d_X, X_bytes);\n    cudaMalloc(&d_y, y_bytes);\n    cudaMalloc(&d_XTX, D * D * sizeof(float));\n    cudaMalloc(&d_XTy, D * sizeof(float));\n\n    cudaMemcpy(d_X, h_X, X_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_y, h_y, y_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_XTX, 0, D * D * sizeof(float));\n    cudaMemset(d_XTy, 0, D * sizeof(float));\n\n    dim3 threads(D, D);\n    compute_XTX_XTy_kernel<<<1, threads>>>(d_X, d_y, d_XTX, d_XTy);\n\n    float* h_XTX = (float*)malloc(D * D * sizeof(float));\n    float* h_XTy = (float*)malloc(D * sizeof(float));\n\n    cudaMemcpy(h_XTX, d_XTX, D * D * sizeof(float), cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_XTy, d_XTy, D * sizeof(float), cudaMemcpyDeviceToHost);\n\n    float h_beta[D];\n    if (!solve_linear_system_cpu(h_XTX, h_XTy, h_beta, D)) {\n        std::cout << \"F\" << std::endl;\n        return 0;\n    }\n\n    write_binary_float(\"data/ols_out.bin\", h_beta, D);\n\n    cudaFree(d_X); cudaFree(d_y); cudaFree(d_XTX); cudaFree(d_XTy);\n    free(h_X); free(h_y); free(h_XTX); free(h_XTy);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nD = 10\nN = 1 << 16\n\nX = np.random.randn(N, D).astype(np.float32)\ntrue_beta = np.random.randn(D).astype(np.float32)\ny = X @ true_beta + np.random.randn(N).astype(np.float32) * 0.1\n\nXTX = X.T @ X\nXTy = X.T @ y\nbeta = np.linalg.solve(XTX, XTy).astype(np.float32)\n\nX.tofile(\"data/ols_X.bin\")\ny.astype(np.float32).tofile(\"data/ols_y.bin\")\nbeta.tofile(\"data/ols_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nD = 10\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/ols_out.bin\"\nref_file = \"data/ols_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, D)\nref = read_binary(ref_file, D)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Ordinary Least Squares Regression. Implement a CUDA kernel to compute linear regression coefficients. Inputs: a feature matrix 'ols_X' of shape (65536, 10) with float32 data type, and a target vector 'ols_y' of shape (65536,) with float32 data type. Output: a coefficient vector 'ols_out' of shape (10,) with float32 data type. The kernel must compute X^T X (10x10 matrix) and X^T y (10-element vector) on GPU, then solve the linear system (X^T X)β = X^T y on CPU to obtain coefficients. The solution must match reference within tolerance.", "level2_prompt": "Task: Ordinary Least Squares Regression. Compute regression coefficients β by: (1) calculating matrix product X^T X (10x10 symmetric matrix), (2) calculating vector product X^T y (10-element vector), and (3) solving the linear system (X^T X)β = X^T y. Dimensions: 65536 samples, 10 features.", "level3_prompt": "Compute the Ordinary Least Squares Regression coefficients."}
{"id": 67, "task_name": "Ordinary_Least_Squares_Regression", "task_description": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA.", "inputs": [{"name": "ols_X", "dtype": "float32", "shape": "(262144, 10)"}, {"name": "ols_y", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "ols_out", "dtype": "float32", "shape": "(10,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <vector>\n#include <string>\n\n#define D 10\nconst int N = 1 << 18;\n\n__global__ void compute_XTX_XTy_kernel(const float* X, const float* y, float* XTX, float* XTy) {\n    int i = threadIdx.y;\n    int j = threadIdx.x;\n    if (i >= D || j >= D) return;\n\n    float sum = 0.0f;\n    for (int n = 0; n < N; ++n) {\n        sum += X[n * D + i] * X[n * D + j];\n    }\n    XTX[i * D + j] = sum;\n\n    if (j == 0) {\n        float yt = 0.0f;\n        for (int n = 0; n < N; ++n) {\n            yt += X[n * D + i] * y[n];\n        }\n        XTy[i] = yt;\n    }\n}\n\nbool solve_linear_system_cpu(const float* A, const float* b, float* x, int n) {\n    std::vector<std::vector<float>> mat(n, std::vector<float>(n + 1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) mat[i][j] = A[i * n + j];\n        mat[i][n] = b[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (fabs(mat[i][i]) < 1e-6) return false;\n        for (int j = i + 1; j < n; ++j) {\n            float f = mat[j][i] / mat[i][i];\n            for (int k = i; k <= n; ++k)\n                mat[j][k] -= f * mat[i][k];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        x[i] = mat[i][n];\n        for (int j = i + 1; j < n; ++j)\n            x[i] -= mat[i][j] * x[j];\n        x[i] /= mat[i][i];\n    }\n    return true;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary_float(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t X_bytes = N * D * sizeof(float);\n    size_t y_bytes = N * sizeof(float);\n\n    float *h_X = (float*)malloc(X_bytes);\n    float *h_y = (float*)malloc(y_bytes);\n\n    read_binary_float(\"data/ols_X.bin\", h_X, N * D);\n    read_binary_float(\"data/ols_y.bin\", h_y, N);\n\n    float *d_X, *d_y, *d_XTX, *d_XTy;\n    cudaMalloc(&d_X, X_bytes);\n    cudaMalloc(&d_y, y_bytes);\n    cudaMalloc(&d_XTX, D * D * sizeof(float));\n    cudaMalloc(&d_XTy, D * sizeof(float));\n\n    cudaMemcpy(d_X, h_X, X_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_y, h_y, y_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_XTX, 0, D * D * sizeof(float));\n    cudaMemset(d_XTy, 0, D * sizeof(float));\n\n    dim3 threads(D, D);\n    compute_XTX_XTy_kernel<<<1, threads>>>(d_X, d_y, d_XTX, d_XTy);\n\n    float* h_XTX = (float*)malloc(D * D * sizeof(float));\n    float* h_XTy = (float*)malloc(D * sizeof(float));\n\n    cudaMemcpy(h_XTX, d_XTX, D * D * sizeof(float), cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_XTy, d_XTy, D * sizeof(float), cudaMemcpyDeviceToHost);\n\n    float h_beta[D];\n    if (!solve_linear_system_cpu(h_XTX, h_XTy, h_beta, D)) {\n        std::cout << \"F\" << std::endl;\n        return 0;\n    }\n\n    write_binary_float(\"data/ols_out.bin\", h_beta, D);\n\n    cudaFree(d_X); cudaFree(d_y); cudaFree(d_XTX); cudaFree(d_XTy);\n    free(h_X); free(h_y); free(h_XTX); free(h_XTy);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nD = 10\nN = 1 << 18\n\nX = np.random.randn(N, D).astype(np.float32)\ntrue_beta = np.random.randn(D).astype(np.float32)\ny = X @ true_beta + np.random.randn(N).astype(np.float32) * 0.1\n\nXTX = X.T @ X\nXTy = X.T @ y\nbeta = np.linalg.solve(XTX, XTy).astype(np.float32)\n\nX.tofile(\"data/ols_X.bin\")\ny.astype(np.float32).tofile(\"data/ols_y.bin\")\nbeta.tofile(\"data/ols_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nD = 10\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/ols_out.bin\"\nref_file = \"data/ols_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, D)\nref = read_binary(ref_file, D)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Ordinary Least Squares Regression. Description: Implement a CUDA kernel to compute linear regression coefficients using ordinary least squares. The input consists of a feature matrix 'ols_X' with dimensions (262144, 10) and float32 data type, and a target vector 'ols_y' with length 262144 and float32 data type. The output must be a vector 'ols_out' of length 10 with float32 data type, representing the regression coefficients. The kernel must compute the solution to the normal equations (X^T X)β = X^T y, where X is the feature matrix and y is the target vector. The computed coefficients must match reference values within an absolute tolerance of 1e-2.", "level2_prompt": "Task: Ordinary Least Squares Regression. Description: Compute linear regression coefficients by solving the normal equations. Given a feature matrix X of dimensions (262144, 10) and a target vector y of length 262144, both with float32 data type, calculate the coefficient vector β that satisfies (X^T X)β = X^T y. The output is a 10-element float32 vector.", "level3_prompt": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA."}
{"id": 68, "task_name": "Ordinary_Least_Squares_Regression", "task_description": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA.", "inputs": [{"name": "ols_X", "dtype": "float32", "shape": "(1048576, 10)"}, {"name": "ols_y", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "ols_out", "dtype": "float32", "shape": "(10,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <vector>\n#include <string>\n\n#define D 10\nconst int N = 1 << 20;\n\n__global__ void compute_XTX_XTy_kernel(const float* X, const float* y, float* XTX, float* XTy) {\n    int i = threadIdx.y;\n    int j = threadIdx.x;\n    if (i >= D || j >= D) return;\n\n    float sum = 0.0f;\n    for (int n = 0; n < N; ++n) {\n        sum += X[n * D + i] * X[n * D + j];\n    }\n    XTX[i * D + j] = sum;\n\n    if (j == 0) {\n        float yt = 0.0f;\n        for (int n = 0; n < N; ++n) {\n            yt += X[n * D + i] * y[n];\n        }\n        XTy[i] = yt;\n    }\n}\n\nbool solve_linear_system_cpu(const float* A, const float* b, float* x, int n) {\n    std::vector<std::vector<float>> mat(n, std::vector<float>(n + 1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) mat[i][j] = A[i * n + j];\n        mat[i][n] = b[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (fabs(mat[i][i]) < 1e-6) return false;\n        for (int j = i + 1; j < n; ++j) {\n            float f = mat[j][i] / mat[i][i];\n            for (int k = i; k <= n; ++k)\n                mat[j][k] -= f * mat[i][k];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        x[i] = mat[i][n];\n        for (int j = i + 1; j < n; ++j)\n            x[i] -= mat[i][j] * x[j];\n        x[i] /= mat[i][i];\n    }\n    return true;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary_float(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t X_bytes = N * D * sizeof(float);\n    size_t y_bytes = N * sizeof(float);\n\n    float *h_X = (float*)malloc(X_bytes);\n    float *h_y = (float*)malloc(y_bytes);\n\n    read_binary_float(\"data/ols_X.bin\", h_X, N * D);\n    read_binary_float(\"data/ols_y.bin\", h_y, N);\n\n    float *d_X, *d_y, *d_XTX, *d_XTy;\n    cudaMalloc(&d_X, X_bytes);\n    cudaMalloc(&d_y, y_bytes);\n    cudaMalloc(&d_XTX, D * D * sizeof(float));\n    cudaMalloc(&d_XTy, D * sizeof(float));\n\n    cudaMemcpy(d_X, h_X, X_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_y, h_y, y_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_XTX, 0, D * D * sizeof(float));\n    cudaMemset(d_XTy, 0, D * sizeof(float));\n\n    dim3 threads(D, D);\n    compute_XTX_XTy_kernel<<<1, threads>>>(d_X, d_y, d_XTX, d_XTy);\n\n    float* h_XTX = (float*)malloc(D * D * sizeof(float));\n    float* h_XTy = (float*)malloc(D * sizeof(float));\n\n    cudaMemcpy(h_XTX, d_XTX, D * D * sizeof(float), cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_XTy, d_XTy, D * sizeof(float), cudaMemcpyDeviceToHost);\n\n    float h_beta[D];\n    if (!solve_linear_system_cpu(h_XTX, h_XTy, h_beta, D)) {\n        std::cout << \"F\" << std::endl;\n        return 0;\n    }\n\n    write_binary_float(\"data/ols_out.bin\", h_beta, D);\n\n    cudaFree(d_X); cudaFree(d_y); cudaFree(d_XTX); cudaFree(d_XTy);\n    free(h_X); free(h_y); free(h_XTX); free(h_XTy);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nD = 10\nN = 1 << 20\n\nX = np.random.randn(N, D).astype(np.float32)\ntrue_beta = np.random.randn(D).astype(np.float32)\ny = X @ true_beta + np.random.randn(N).astype(np.float32) * 0.1\n\nXTX = X.T @ X\nXTy = X.T @ y\nbeta = np.linalg.solve(XTX, XTy).astype(np.float32)\n\nX.tofile(\"data/ols_X.bin\")\ny.astype(np.float32).tofile(\"data/ols_y.bin\")\nbeta.tofile(\"data/ols_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nD = 10\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/ols_out.bin\"\nref_file = \"data/ols_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, D)\nref = read_binary(ref_file, D)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Ordinary Least Squares Regression: Implement a CUDA kernel to compute the linear regression coefficients for a given dataset. The inputs are a feature matrix 'ols_X' of shape (1048576, 10) with float32 values and a target vector 'ols_y' of shape (1048576,) with float32 values. The output is a coefficient vector 'ols_out' of shape (10,) with float32 values. The kernel must compute X^T X and X^T y, then solve the linear system (X^T X) * beta = X^T y to obtain the regression coefficients. The solution must be accurate within a tolerance of 1e-2 relative to the reference implementation.", "level2_prompt": "Ordinary Least Squares Regression: Given a feature matrix X of dimensions (1048576, 10) and target vector y of length 1048576, compute the regression coefficients beta by solving the normal equations (X^T X) * beta = X^T y. First, calculate the matrix product X^T X (10x10 matrix) and the vector product X^T y (10-element vector), then solve the resulting linear system for beta.", "level3_prompt": "Compute the Ordinary Least Squares Regression kernel on GPU using CUDA."}
{"id": 69, "task_name": "Ordinary_Least_Squares_Regression", "task_description": "Compute the Ordinary_Least_Squares_Regression kernel on GPU using CUDA.", "inputs": [{"name": "ols_X", "dtype": "float32", "shape": "(4194304, 10)"}, {"name": "ols_y", "dtype": "float32", "shape": "(4194304,)"}], "outputs": [{"name": "ols_out", "dtype": "float32", "shape": "(10,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <vector>\n#include <string>\n\n#define D 10\nconst int N = 1 << 22;\n\n__global__ void compute_XTX_XTy_kernel(const float* X, const float* y, float* XTX, float* XTy) {\n    int i = threadIdx.y;\n    int j = threadIdx.x;\n    if (i >= D || j >= D) return;\n\n    float sum = 0.0f;\n    for (int n = 0; n < N; ++n) {\n        sum += X[n * D + i] * X[n * D + j];\n    }\n    XTX[i * D + j] = sum;\n\n    if (j == 0) {\n        float yt = 0.0f;\n        for (int n = 0; n < N; ++n) {\n            yt += X[n * D + i] * y[n];\n        }\n        XTy[i] = yt;\n    }\n}\n\nbool solve_linear_system_cpu(const float* A, const float* b, float* x, int n) {\n    std::vector<std::vector<float>> mat(n, std::vector<float>(n + 1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) mat[i][j] = A[i * n + j];\n        mat[i][n] = b[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (fabs(mat[i][i]) < 1e-6) return false;\n        for (int j = i + 1; j < n; ++j) {\n            float f = mat[j][i] / mat[i][i];\n            for (int k = i; k <= n; ++k)\n                mat[j][k] -= f * mat[i][k];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        x[i] = mat[i][n];\n        for (int j = i + 1; j < n; ++j)\n            x[i] -= mat[i][j] * x[j];\n        x[i] /= mat[i][i];\n    }\n    return true;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary_float(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t X_bytes = N * D * sizeof(float);\n    size_t y_bytes = N * sizeof(float);\n\n    float *h_X = (float*)malloc(X_bytes);\n    float *h_y = (float*)malloc(y_bytes);\n\n    read_binary_float(\"data/ols_X.bin\", h_X, N * D);\n    read_binary_float(\"data/ols_y.bin\", h_y, N);\n\n    float *d_X, *d_y, *d_XTX, *d_XTy;\n    cudaMalloc(&d_X, X_bytes);\n    cudaMalloc(&d_y, y_bytes);\n    cudaMalloc(&d_XTX, D * D * sizeof(float));\n    cudaMalloc(&d_XTy, D * sizeof(float));\n\n    cudaMemcpy(d_X, h_X, X_bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_y, h_y, y_bytes, cudaMemcpyHostToDevice);\n    cudaMemset(d_XTX, 0, D * D * sizeof(float));\n    cudaMemset(d_XTy, 0, D * sizeof(float));\n\n    dim3 threads(D, D);\n    compute_XTX_XTy_kernel<<<1, threads>>>(d_X, d_y, d_XTX, d_XTy);\n\n    float* h_XTX = (float*)malloc(D * D * sizeof(float));\n    float* h_XTy = (float*)malloc(D * sizeof(float));\n\n    cudaMemcpy(h_XTX, d_XTX, D * D * sizeof(float), cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_XTy, d_XTy, D * sizeof(float), cudaMemcpyDeviceToHost);\n\n    float h_beta[D];\n    if (!solve_linear_system_cpu(h_XTX, h_XTy, h_beta, D)) {\n        std::cout << \"F\" << std::endl;\n        return 0;\n    }\n\n    write_binary_float(\"data/ols_out.bin\", h_beta, D);\n\n    cudaFree(d_X); cudaFree(d_y); cudaFree(d_XTX); cudaFree(d_XTy);\n    free(h_X); free(h_y); free(h_XTX); free(h_XTy);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nD = 10\nN = 1 << 22\n\nX = np.random.randn(N, D).astype(np.float32)\ntrue_beta = np.random.randn(D).astype(np.float32)\ny = X @ true_beta + np.random.randn(N).astype(np.float32) * 0.1\n\nXTX = X.T @ X\nXTy = X.T @ y\nbeta = np.linalg.solve(XTX, XTy).astype(np.float32)\n\nX.tofile(\"data/ols_X.bin\")\ny.astype(np.float32).tofile(\"data/ols_y.bin\")\nbeta.tofile(\"data/ols_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nD = 10\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/ols_out.bin\"\nref_file = \"data/ols_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, D)\nref = read_binary(ref_file, D)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Ordinary Least Squares Regression: Compute the regression coefficients for a linear model by solving the normal equations. Inputs include a feature matrix 'ols_X' of shape (4194304, 10) and a target vector 'ols_y' of shape (4194304), both float32. Output is a coefficient vector 'ols_out' of shape (10) as float32. The solution must compute the matrix product X^T·X and vector product X^T·y, then solve the linear system (X^T·X)·β = X^T·y. The computed coefficients must match reference solutions within a tolerance of 1e-2.", "level2_prompt": "Ordinary Least Squares Regression: Given feature matrix X (N×D) and target vector y (N×1), compute coefficient vector β (D×1) by solving the normal equations: (X^T·X)·β = X^T·y. This requires calculating the symmetric matrix X^T·X (D×D) and vector X^T·y (D×1), then solving the resulting linear system.", "level3_prompt": "Compute the Ordinary Least Squares Regression kernel on GPU using CUDA."}
{"id": 70, "task_name": "Batched_Matrix_Multiplication", "task_description": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "batchA", "dtype": "float32", "shape": "(4, 128, 256)"}, {"name": "batchB", "dtype": "float32", "shape": "(4, 256, 128)"}], "outputs": [{"name": "batchC_out", "dtype": "float32", "shape": "(4, 128, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define B 4\n#define M 128\n#define K 256\n#define N 128\n#define TILE 16\n\n__global__ void BatchedMatMulKernel(\n    const float* A,\n    const float* Bmat,\n    float* C)\n{\n    int b = blockIdx.z;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        const float* Ab = A + b * M * K;\n        const float* Bb = Bmat + b * K * N;\n        float* Cb = C + b * M * N;\n\n        for (int i = 0; i < K; i++) {\n            sum += Ab[row * K + i] * Bb[i * N + col];\n        }\n        Cb[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = B * M * K;\n    size_t size_B = B * K * N;\n    size_t size_C = B * M * N;\n\n    float* h_A = new float[size_A];\n    float* h_B = new float[size_B];\n    float* h_C = new float[size_C];\n\n    read_binary(\"./data/batchA.bin\", h_A, size_A);\n    read_binary(\"./data/batchB.bin\", h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE,\n              (M + TILE - 1) / TILE,\n              B);\n\n    BatchedMatMulKernel<<<grid, block>>>(d_A, d_B, d_C);\n\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/batchC_out.bin\", h_C, size_C);\n\n    cudaFree(d_A); cudaFree(d_B); cudaFree(d_C);\n    delete[] h_A; delete[] h_B; delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nB = 4\nM = 128\nK = 256\nN = 128\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(B, M, K, dtype=torch.float32)\nB_mat = torch.randn(B, K, N, dtype=torch.float32)\nC = torch.bmm(A, B_mat)\n\nA.numpy().tofile(\"data/batchA.bin\")\nB_mat.numpy().tofile(\"data/batchB.bin\")\nC.numpy().tofile(\"data/batchC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nB = 4\nM = 128\nK = 256\nN = 128\n\nsize = B * M * N\n\ndef read_binary(file, size):\n    return np.fromfile(file, dtype=np.float32, count=size)\n\nout_file = \"data/batchC_out.bin\"\nref_file = \"data/batchC_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, size)\nref = read_binary(ref_file, size)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement the Batched_Matrix_Multiplication kernel. Given two input tensors: 'batchA' of shape (4, 128, 256) and 'batchB' of shape (4, 256, 128), both with float32 data type, compute a batch of matrix multiplications. For each of the 4 matrices in the batch, multiply the 128x256 matrix from 'batchA' with the corresponding 256x128 matrix from 'batchB'. The result should be a single output tensor 'batchC_out' of shape (4, 128, 128) with float32 data type, where each 128x128 matrix is the product of the corresponding input matrices. The kernel must handle all 4 batches simultaneously and compute each element as the dot product of the appropriate row and column vectors.", "level2_prompt": "Perform batched matrix multiplication. For each index b in the batch size of 4, multiply matrix A[b] (dimensions 128x256) with matrix B[b] (dimensions 256x128). The resulting matrix C[b] should have dimensions 128x128, where each element C[b][i][j] is the sum of products of elements from the i-th row of A[b] and the j-th column of B[b].", "level3_prompt": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA."}
{"id": 71, "task_name": "Batched_Matrix_Multiplication", "task_description": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "batchA", "dtype": "float32", "shape": "(8, 256, 256)"}, {"name": "batchB", "dtype": "float32", "shape": "(8, 256, 256)"}], "outputs": [{"name": "batchC_out", "dtype": "float32", "shape": "(8, 256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define B 8\n#define M 256\n#define K 256\n#define N 256\n#define TILE 16\n\n__global__ void BatchedMatMulKernel(\n    const float* A,\n    const float* Bmat,\n    float* C)\n{\n    int b = blockIdx.z;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        const float* Ab = A + b * M * K;\n        const float* Bb = Bmat + b * K * N;\n        float* Cb = C + b * M * N;\n\n        for (int i = 0; i < K; i++) {\n            sum += Ab[row * K + i] * Bb[i * N + col];\n        }\n        Cb[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = B * M * K;\n    size_t size_B = B * K * N;\n    size_t size_C = B * M * N;\n\n    float* h_A = new float[size_A];\n    float* h_B = new float[size_B];\n    float* h_C = new float[size_C];\n\n    read_binary(\"./data/batchA.bin\", h_A, size_A);\n    read_binary(\"./data/batchB.bin\", h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE,\n              (M + TILE - 1) / TILE,\n              B);\n\n    BatchedMatMulKernel<<<grid, block>>>(d_A, d_B, d_C);\n\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/batchC_out.bin\", h_C, size_C);\n\n    cudaFree(d_A); cudaFree(d_B); cudaFree(d_C);\n    delete[] h_A; delete[] h_B; delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nB = 8\nM = 256\nK = 256\nN = 256\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(B, M, K, dtype=torch.float32)\nB_mat = torch.randn(B, K, N, dtype=torch.float32)\nC = torch.bmm(A, B_mat)\n\nA.numpy().tofile(\"data/batchA.bin\")\nB_mat.numpy().tofile(\"data/batchB.bin\")\nC.numpy().tofile(\"data/batchC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nB = 8\nM = 256\nK = 256\nN = 256\n\nsize = B * M * N\n\ndef read_binary(file, size):\n    return np.fromfile(file, dtype=np.float32, count=size)\n\nout_file = \"data/batchC_out.bin\"\nref_file = \"data/batchC_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, size)\nref = read_binary(ref_file, size)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Batched Matrix Multiplication. Compute matrix multiplication for a batch of 8 matrices. Inputs are two float32 tensors: batchA with shape (8, 256, 256) and batchB with shape (8, 256, 256). Output is a float32 tensor batchC_out with shape (8, 256, 256). For each batch index b from 0 to 7, multiply matrix batchA[b] (256x256) with matrix batchB[b] (256x256) to produce output matrix batchC_out[b] (256x256). Each element (i,j) in the output matrix must be the dot product of the i-th row of batchA[b] and the j-th column of batchB[b]. The kernel must handle all 8 batches and matrix dimensions exactly as specified.", "level2_prompt": "Task: Batched Matrix Multiplication. For each batch index b in [0,7], multiply matrix A_b (256x256) from batchA with matrix B_b (256x256) from batchB to produce output matrix C_b (256x256) in batchC_out. Each element C_b[i][j] is computed as the sum over k from 0 to 255 of A_b[i][k] * B_b[k][j].", "level3_prompt": "Compute batched matrix multiplication."}
{"id": 72, "task_name": "Batched_Matrix_Multiplication", "task_description": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "batchA", "dtype": "float32", "shape": "(16, 512, 256)"}, {"name": "batchB", "dtype": "float32", "shape": "(16, 256, 128)"}], "outputs": [{"name": "batchC_out", "dtype": "float32", "shape": "(16, 512, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define B 16\n#define M 512\n#define K 256\n#define N 128\n#define TILE 16\n\n__global__ void BatchedMatMulKernel(\n    const float* A,\n    const float* Bmat,\n    float* C)\n{\n    int b = blockIdx.z;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        const float* Ab = A + b * M * K;\n        const float* Bb = Bmat + b * K * N;\n        float* Cb = C + b * M * N;\n\n        for (int i = 0; i < K; i++) {\n            sum += Ab[row * K + i] * Bb[i * N + col];\n        }\n        Cb[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = B * M * K;\n    size_t size_B = B * K * N;\n    size_t size_C = B * M * N;\n\n    float* h_A = new float[size_A];\n    float* h_B = new float[size_B];\n    float* h_C = new float[size_C];\n\n    read_binary(\"./data/batchA.bin\", h_A, size_A);\n    read_binary(\"./data/batchB.bin\", h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE,\n              (M + TILE - 1) / TILE,\n              B);\n\n    BatchedMatMulKernel<<<grid, block>>>(d_A, d_B, d_C);\n\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/batchC_out.bin\", h_C, size_C);\n\n    cudaFree(d_A); cudaFree(d_B); cudaFree(d_C);\n    delete[] h_A; delete[] h_B; delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nB = 16\nM = 512\nK = 256\nN = 128\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(B, M, K, dtype=torch.float32)\nB_mat = torch.randn(B, K, N, dtype=torch.float32)\nC = torch.bmm(A, B_mat)\n\nA.numpy().tofile(\"data/batchA.bin\")\nB_mat.numpy().tofile(\"data/batchB.bin\")\nC.numpy().tofile(\"data/batchC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nB = 16\nM = 512\nK = 256\nN = 128\n\nsize = B * M * N\n\ndef read_binary(file, size):\n    return np.fromfile(file, dtype=np.float32, count=size)\n\nout_file = \"data/batchC_out.bin\"\nref_file = \"data/batchC_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, size)\nref = read_binary(ref_file, size)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Batched_Matrix_Multiplication. Compute matrix multiplications for a batch of matrices. Inputs: 'batchA' (16 matrices, each 512x256, float32) and 'batchB' (16 matrices, each 256x128, float32). Output: 'batchC_out' (16 matrices, each 512x128, float32). Each output matrix must be computed as the matrix multiplication of the corresponding input matrices from batchA and batchB. The kernel must respect matrix dimensions and batch independence, ensuring each batch element is processed separately.", "level2_prompt": "Task: Batched_Matrix_Multiplication. For each batch index, multiply a 512x256 matrix by a 256x128 matrix to produce a 512x128 output matrix. Each element of the output matrix is computed as the dot product of a row from the first matrix and a column from the second matrix.", "level3_prompt": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA."}
{"id": 73, "task_name": "Batched_Matrix_Multiplication", "task_description": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "batchA", "dtype": "float32", "shape": "(32, 1024, 512)"}, {"name": "batchB", "dtype": "float32", "shape": "(32, 512, 256)"}], "outputs": [{"name": "batchC_out", "dtype": "float32", "shape": "(32, 1024, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define B 32\n#define M 1024\n#define K 512\n#define N 256\n#define TILE 16\n\n__global__ void BatchedMatMulKernel(\n    const float* A,\n    const float* Bmat,\n    float* C)\n{\n    int b = blockIdx.z;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        const float* Ab = A + b * M * K;\n        const float* Bb = Bmat + b * K * N;\n        float* Cb = C + b * M * N;\n\n        for (int i = 0; i < K; i++) {\n            sum += Ab[row * K + i] * Bb[i * N + col];\n        }\n        Cb[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = B * M * K;\n    size_t size_B = B * K * N;\n    size_t size_C = B * M * N;\n\n    float* h_A = new float[size_A];\n    float* h_B = new float[size_B];\n    float* h_C = new float[size_C];\n\n    read_binary(\"./data/batchA.bin\", h_A, size_A);\n    read_binary(\"./data/batchB.bin\", h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE,\n              (M + TILE - 1) / TILE,\n              B);\n\n    BatchedMatMulKernel<<<grid, block>>>(d_A, d_B, d_C);\n\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/batchC_out.bin\", h_C, size_C);\n\n    cudaFree(d_A); cudaFree(d_B); cudaFree(d_C);\n    delete[] h_A; delete[] h_B; delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nB = 32\nM = 1024\nK = 512\nN = 256\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(B, M, K, dtype=torch.float32)\nB_mat = torch.randn(B, K, N, dtype=torch.float32)\nC = torch.bmm(A, B_mat)\n\nA.numpy().tofile(\"data/batchA.bin\")\nB_mat.numpy().tofile(\"data/batchB.bin\")\nC.numpy().tofile(\"data/batchC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nB = 32\nM = 1024\nK = 512\nN = 256\n\nsize = B * M * N\n\ndef read_binary(file, size):\n    return np.fromfile(file, dtype=np.float32, count=size)\n\nout_file = \"data/batchC_out.bin\"\nref_file = \"data/batchC_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, size)\nref = read_binary(ref_file, size)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for Batched_Matrix_Multiplication. The kernel must multiply 32 pairs of matrices independently: each matrix A of shape (1024, 512) from input batchA with a corresponding matrix B of shape (512, 256) from input batchB, producing an output matrix C of shape (1024, 256) in batchC_out. All tensors are float32. The computation must follow standard matrix multiplication rules where each element in C is the dot product of corresponding rows from A and columns from B. The kernel must process all 32 batches in parallel without inter-batch dependencies.", "level2_prompt": "Perform batched matrix multiplication for 32 independent pairs of matrices. For each batch index, multiply a 1024x512 matrix by a 512x256 matrix to produce a 1024x256 result matrix. Each element (i,j) in the result is computed as the sum of products between the i-th row of the first matrix and j-th column of the second matrix.", "level3_prompt": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA."}
{"id": 74, "task_name": "Batched_Matrix_Multiplication", "task_description": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "batchA", "dtype": "float32", "shape": "(4, 2048, 1024)"}, {"name": "batchB", "dtype": "float32", "shape": "(4, 1024, 512)"}], "outputs": [{"name": "batchC_out", "dtype": "float32", "shape": "(4, 2048, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define B 4\n#define M 2048\n#define K 1024\n#define N 512\n#define TILE 16\n\n__global__ void BatchedMatMulKernel(\n    const float* A,\n    const float* Bmat,\n    float* C)\n{\n    int b = blockIdx.z;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        const float* Ab = A + b * M * K;\n        const float* Bb = Bmat + b * K * N;\n        float* Cb = C + b * M * N;\n\n        for (int i = 0; i < K; i++) {\n            sum += Ab[row * K + i] * Bb[i * N + col];\n        }\n        Cb[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = B * M * K;\n    size_t size_B = B * K * N;\n    size_t size_C = B * M * N;\n\n    float* h_A = new float[size_A];\n    float* h_B = new float[size_B];\n    float* h_C = new float[size_C];\n\n    read_binary(\"./data/batchA.bin\", h_A, size_A);\n    read_binary(\"./data/batchB.bin\", h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE,\n              (M + TILE - 1) / TILE,\n              B);\n\n    BatchedMatMulKernel<<<grid, block>>>(d_A, d_B, d_C);\n\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/batchC_out.bin\", h_C, size_C);\n\n    cudaFree(d_A); cudaFree(d_B); cudaFree(d_C);\n    delete[] h_A; delete[] h_B; delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nB = 4\nM = 2048\nK = 1024\nN = 512\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(B, M, K, dtype=torch.float32)\nB_mat = torch.randn(B, K, N, dtype=torch.float32)\nC = torch.bmm(A, B_mat)\n\nA.numpy().tofile(\"data/batchA.bin\")\nB_mat.numpy().tofile(\"data/batchB.bin\")\nC.numpy().tofile(\"data/batchC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nB = 4\nM = 2048\nK = 1024\nN = 512\n\nsize = B * M * N\n\ndef read_binary(file, size):\n    return np.fromfile(file, dtype=np.float32, count=size)\n\nout_file = \"data/batchC_out.bin\"\nref_file = \"data/batchC_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, size)\nref = read_binary(ref_file, size)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Batched_Matrix_Multiplication. Compute matrix multiplication for a batch of matrices. Input batchA is a float32 tensor of shape (4, 2048, 1024) containing 4 matrices of size 2048x1024. Input batchB is a float32 tensor of shape (4, 1024, 512) containing 4 matrices of size 1024x512. Output batchC_out must be a float32 tensor of shape (4, 2048, 512) containing 4 matrices of size 2048x512. Each output matrix must be the product of corresponding matrices from batchA and batchB, computed independently per batch. The kernel must compute the standard matrix multiplication where each element in the output is the dot product of a row from the first matrix and a column from the second matrix.", "level2_prompt": "Task: Batched_Matrix_Multiplication. For each batch index, multiply two matrices: one of dimensions 2048x1024 from batchA and one of dimensions 1024x512 from batchB. The result for each batch should be a 2048x512 matrix where each element (i, j) is the sum of element-wise products between the i-th row of the first matrix and the j-th column of the second matrix. Computations must be performed independently for each batch.", "level3_prompt": "Compute the Batched_Matrix_Multiplication kernel on GPU using CUDA."}
{"id": 75, "task_name": "Gaussian_Blur", "task_description": "Compute the Gaussian_Blur kernel on GPU using CUDA.", "inputs": [{"name": "image", "dtype": "float32", "shape": "(256, 256)"}, {"name": "kernel", "dtype": "float32", "shape": "(3, 3)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define H 256\n#define W 256\n#define KH 3\n#define KW 3\n\n__global__ void gaussian_blur_kernel(\n    const float* input,\n    const float* kernel,\n    float* output\n) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    float sum = 0.0f;\n    int cy = KH / 2;\n    int cx = KW / 2;\n\n    for (int i = 0; i < KH; ++i) {\n        for (int j = 0; j < KW; ++j) {\n            int iy = y + i - cy;\n            int ix = x + j - cx;\n            if (iy >= 0 && iy < H && ix >= 0 && ix < W) {\n                sum += input[iy * W + ix] * kernel[i * KW + j];\n            }\n        }\n    }\n    output[y * W + x] = sum;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t image_size = H * W;\n    size_t kernel_size = KH * KW;\n\n    float* h_image = new float[image_size];\n    float* h_kernel = new float[kernel_size];\n    float* h_output = new float[image_size];\n\n    read_binary(\"data/image.bin\", h_image, image_size);\n    read_binary(\"data/kernel.bin\", h_kernel, kernel_size);\n\n    float *d_image, *d_kernel, *d_output;\n    cudaMalloc(&d_image, image_size * sizeof(float));\n    cudaMalloc(&d_kernel, kernel_size * sizeof(float));\n    cudaMalloc(&d_output, image_size * sizeof(float));\n\n    cudaMemcpy(d_image, h_image, image_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, kernel_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + 15) / 16, (H + 15) / 16);\n\n    gaussian_blur_kernel<<<grid, block>>>(d_image, d_kernel, d_output);\n\n    cudaMemcpy(h_output, d_output, image_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", h_output, image_size);\n\n    cudaFree(d_image);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_image;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nH = 256\nW = 256\nKH = 3\nKW = 3\nSIGMA = 1.0\n\nnp.random.seed(42)\n\nimage = np.random.rand(H, W).astype(np.float32)\n\ndef gaussian_kernel(h, w, sigma):\n    cy = h // 2\n    cx = w // 2\n    kernel = np.zeros((h, w), dtype=np.float32)\n    for i in range(h):\n        for j in range(w):\n            y = i - cy\n            x = j - cx\n            kernel[i, j] = np.exp(-(x*x + y*y) / (2 * sigma * sigma))\n    kernel /= kernel.sum()\n    return kernel\n\nkernel = gaussian_kernel(KH, KW, SIGMA)\n\npad_h = KH // 2\npad_w = KW // 2\npadded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode=\"constant\")\n\noutput = np.zeros_like(image)\n\nfor i in range(H):\n    for j in range(W):\n        region = padded[i:i+KH, j:j+KW]\n        output[i, j] = np.sum(region * kernel)\n\nimage.tofile(\"data/image.bin\")\nkernel.tofile(\"data/kernel.bin\")\noutput.tofile(\"data/output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nH = 256\nW = 256\nSIZE = H * W\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/output.bin\"\nref_file = \"data/output_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, SIZE)\nref = read_binary(ref_file, SIZE)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a Gaussian blur filter on a 256x256 image using CUDA. The input consists of a 256x256 float32 image tensor and a 3x3 float32 kernel tensor. The output should be a 256x256 float32 tensor where each pixel is computed by convolving the kernel with the surrounding pixels. The kernel must be centered on each pixel, and boundary conditions should be handled by ignoring out-of-bound pixels during convolution.", "level2_prompt": "Apply Gaussian blur by convolving a 3x3 kernel over each pixel of a 256x256 image. For each output pixel, compute the weighted sum of the corresponding input pixel and its neighbors within the kernel's radius, using kernel values as weights. Only valid image pixels within boundaries should contribute to the sum.", "level3_prompt": "Compute the Gaussian_Blur kernel on GPU using CUDA."}
{"id": 76, "task_name": "Gaussian_Blur", "task_description": "Compute the Gaussian_Blur kernel on GPU using CUDA.", "inputs": [{"name": "image", "dtype": "float32", "shape": "(512, 512)"}, {"name": "kernel", "dtype": "float32", "shape": "(5, 5)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define H 512\n#define W 512\n#define KH 5\n#define KW 5\n\n__global__ void gaussian_blur_kernel(\n    const float* input,\n    const float* kernel,\n    float* output\n) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    float sum = 0.0f;\n    int cy = KH / 2;\n    int cx = KW / 2;\n\n    for (int i = 0; i < KH; ++i) {\n        for (int j = 0; j < KW; ++j) {\n            int iy = y + i - cy;\n            int ix = x + j - cx;\n            if (iy >= 0 && iy < H && ix >= 0 && ix < W) {\n                sum += input[iy * W + ix] * kernel[i * KW + j];\n            }\n        }\n    }\n    output[y * W + x] = sum;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t image_size = H * W;\n    size_t kernel_size = KH * KW;\n\n    float* h_image = new float[image_size];\n    float* h_kernel = new float[kernel_size];\n    float* h_output = new float[image_size];\n\n    read_binary(\"data/image.bin\", h_image, image_size);\n    read_binary(\"data/kernel.bin\", h_kernel, kernel_size);\n\n    float *d_image, *d_kernel, *d_output;\n    cudaMalloc(&d_image, image_size * sizeof(float));\n    cudaMalloc(&d_kernel, kernel_size * sizeof(float));\n    cudaMalloc(&d_output, image_size * sizeof(float));\n\n    cudaMemcpy(d_image, h_image, image_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, kernel_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + 15) / 16, (H + 15) / 16);\n\n    gaussian_blur_kernel<<<grid, block>>>(d_image, d_kernel, d_output);\n\n    cudaMemcpy(h_output, d_output, image_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", h_output, image_size);\n\n    cudaFree(d_image);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_image;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nH = 512\nW = 512\nKH = 5\nKW = 5\nSIGMA = 1.0\n\nnp.random.seed(42)\n\nimage = np.random.rand(H, W).astype(np.float32)\n\ndef gaussian_kernel(h, w, sigma):\n    cy = h // 2\n    cx = w // 2\n    kernel = np.zeros((h, w), dtype=np.float32)\n    for i in range(h):\n        for j in range(w):\n            y = i - cy\n            x = j - cx\n            kernel[i, j] = np.exp(-(x*x + y*y) / (2 * sigma * sigma))\n    kernel /= kernel.sum()\n    return kernel\n\nkernel = gaussian_kernel(KH, KW, SIGMA)\n\npad_h = KH // 2\npad_w = KW // 2\npadded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode=\"constant\")\n\noutput = np.zeros_like(image)\n\nfor i in range(H):\n    for j in range(W):\n        region = padded[i:i+KH, j:j+KW]\n        output[i, j] = np.sum(region * kernel)\n\nimage.tofile(\"data/image.bin\")\nkernel.tofile(\"data/kernel.bin\")\noutput.tofile(\"data/output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nH = 512\nW = 512\nSIZE = H * W\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/output.bin\"\nref_file = \"data/output_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, SIZE)\nref = read_binary(ref_file, SIZE)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a Gaussian blur filter for an image on a GPU. The input is a 512x512 float32 image and a 5x5 float32 kernel matrix. The output should be a 512x512 float32 blurred image. For each output pixel, compute a weighted sum of surrounding pixels using the kernel weights, handling image boundaries by skipping out-of-range pixels. The kernel center must be aligned with each pixel location during computation.", "level2_prompt": "Apply Gaussian blur convolution to an image. For each pixel coordinate (x,y) in the output, compute the sum of input image pixels within a 5x5 window centered at (x,y) multiplied by corresponding kernel weights. Skip contributions from coordinates outside the image boundaries.", "level3_prompt": "Compute Gaussian blur convolution on a 512x512 image using a 5x5 kernel."}
{"id": 77, "task_name": "Gaussian_Blur", "task_description": "Compute the Gaussian_Blur kernel on GPU using CUDA.", "inputs": [{"name": "image", "dtype": "float32", "shape": "(1024, 1024)"}, {"name": "kernel", "dtype": "float32", "shape": "(7, 7)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define H 1024\n#define W 1024\n#define KH 7\n#define KW 7\n\n__global__ void gaussian_blur_kernel(\n    const float* input,\n    const float* kernel,\n    float* output\n) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    float sum = 0.0f;\n    int cy = KH / 2;\n    int cx = KW / 2;\n\n    for (int i = 0; i < KH; ++i) {\n        for (int j = 0; j < KW; ++j) {\n            int iy = y + i - cy;\n            int ix = x + j - cx;\n            if (iy >= 0 && iy < H && ix >= 0 && ix < W) {\n                sum += input[iy * W + ix] * kernel[i * KW + j];\n            }\n        }\n    }\n    output[y * W + x] = sum;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t image_size = H * W;\n    size_t kernel_size = KH * KW;\n\n    float* h_image = new float[image_size];\n    float* h_kernel = new float[kernel_size];\n    float* h_output = new float[image_size];\n\n    read_binary(\"data/image.bin\", h_image, image_size);\n    read_binary(\"data/kernel.bin\", h_kernel, kernel_size);\n\n    float *d_image, *d_kernel, *d_output;\n    cudaMalloc(&d_image, image_size * sizeof(float));\n    cudaMalloc(&d_kernel, kernel_size * sizeof(float));\n    cudaMalloc(&d_output, image_size * sizeof(float));\n\n    cudaMemcpy(d_image, h_image, image_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, kernel_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + 15) / 16, (H + 15) / 16);\n\n    gaussian_blur_kernel<<<grid, block>>>(d_image, d_kernel, d_output);\n\n    cudaMemcpy(h_output, d_output, image_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", h_output, image_size);\n\n    cudaFree(d_image);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_image;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nH = 1024\nW = 1024\nKH = 7\nKW = 7\nSIGMA = 1.0\n\nnp.random.seed(42)\n\nimage = np.random.rand(H, W).astype(np.float32)\n\ndef gaussian_kernel(h, w, sigma):\n    cy = h // 2\n    cx = w // 2\n    kernel = np.zeros((h, w), dtype=np.float32)\n    for i in range(h):\n        for j in range(w):\n            y = i - cy\n            x = j - cx\n            kernel[i, j] = np.exp(-(x*x + y*y) / (2 * sigma * sigma))\n    kernel /= kernel.sum()\n    return kernel\n\nkernel = gaussian_kernel(KH, KW, SIGMA)\n\npad_h = KH // 2\npad_w = KW // 2\npadded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode=\"constant\")\n\noutput = np.zeros_like(image)\n\nfor i in range(H):\n    for j in range(W):\n        region = padded[i:i+KH, j:j+KW]\n        output[i, j] = np.sum(region * kernel)\n\nimage.tofile(\"data/image.bin\")\nkernel.tofile(\"data/kernel.bin\")\noutput.tofile(\"data/output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nH = 1024\nW = 1024\nSIZE = H * W\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/output.bin\"\nref_file = \"data/output_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, SIZE)\nref = read_binary(ref_file, SIZE)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a Gaussian blur kernel for image processing. The input consists of a 1024x1024 float32 image and a 7x7 float32 kernel. The kernel should convolve the image with the Gaussian kernel, computing each output pixel as the weighted sum of surrounding pixels within the kernel window. Boundary handling must ignore out-of-bound pixels. Output is a 1048576-element float32 tensor (flattened 1024x1024 blurred image).", "level2_prompt": "Perform Gaussian blur convolution. For each pixel in the 1024x1024 input image, compute the weighted sum of its neighborhood using the 7x7 kernel. When kernel window extends beyond image boundaries, only valid pixels should be considered. Output dimensions match input image dimensions.", "level3_prompt": "Compute Gaussian blur convolution for an image using a given kernel."}
{"id": 78, "task_name": "Gaussian_Blur", "task_description": "Compute the Gaussian_Blur kernel on GPU using CUDA.", "inputs": [{"name": "image", "dtype": "float32", "shape": "(1024, 2048)"}, {"name": "kernel", "dtype": "float32", "shape": "(9, 9)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1024, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define H 1024\n#define W 2048\n#define KH 9\n#define KW 9\n\n__global__ void gaussian_blur_kernel(\n    const float* input,\n    const float* kernel,\n    float* output\n) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    float sum = 0.0f;\n    int cy = KH / 2;\n    int cx = KW / 2;\n\n    for (int i = 0; i < KH; ++i) {\n        for (int j = 0; j < KW; ++j) {\n            int iy = y + i - cy;\n            int ix = x + j - cx;\n            if (iy >= 0 && iy < H && ix >= 0 && ix < W) {\n                sum += input[iy * W + ix] * kernel[i * KW + j];\n            }\n        }\n    }\n    output[y * W + x] = sum;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t image_size = H * W;\n    size_t kernel_size = KH * KW;\n\n    float* h_image = new float[image_size];\n    float* h_kernel = new float[kernel_size];\n    float* h_output = new float[image_size];\n\n    read_binary(\"data/image.bin\", h_image, image_size);\n    read_binary(\"data/kernel.bin\", h_kernel, kernel_size);\n\n    float *d_image, *d_kernel, *d_output;\n    cudaMalloc(&d_image, image_size * sizeof(float));\n    cudaMalloc(&d_kernel, kernel_size * sizeof(float));\n    cudaMalloc(&d_output, image_size * sizeof(float));\n\n    cudaMemcpy(d_image, h_image, image_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, kernel_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + 15) / 16, (H + 15) / 16);\n\n    gaussian_blur_kernel<<<grid, block>>>(d_image, d_kernel, d_output);\n\n    cudaMemcpy(h_output, d_output, image_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", h_output, image_size);\n\n    cudaFree(d_image);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_image;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nH = 1024\nW = 2048\nKH = 9\nKW = 9\nSIGMA = 1.0\n\nnp.random.seed(42)\n\nimage = np.random.rand(H, W).astype(np.float32)\n\ndef gaussian_kernel(h, w, sigma):\n    cy = h // 2\n    cx = w // 2\n    kernel = np.zeros((h, w), dtype=np.float32)\n    for i in range(h):\n        for j in range(w):\n            y = i - cy\n            x = j - cx\n            kernel[i, j] = np.exp(-(x*x + y*y) / (2 * sigma * sigma))\n    kernel /= kernel.sum()\n    return kernel\n\nkernel = gaussian_kernel(KH, KW, SIGMA)\n\npad_h = KH // 2\npad_w = KW // 2\npadded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode=\"constant\")\n\noutput = np.zeros_like(image)\n\nfor i in range(H):\n    for j in range(W):\n        region = padded[i:i+KH, j:j+KW]\n        output[i, j] = np.sum(region * kernel)\n\nimage.tofile(\"data/image.bin\")\nkernel.tofile(\"data/kernel.bin\")\noutput.tofile(\"data/output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nH = 1024\nW = 2048\nSIZE = H * W\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/output.bin\"\nref_file = \"data/output_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, SIZE)\nref = read_binary(ref_file, SIZE)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Gaussian_Blur that applies a Gaussian blur filter to an input image. The input is a 1024x2048 float32 image tensor and a 9x9 float32 kernel tensor. The output should be a 1024x2048 float32 tensor where each pixel is computed as the weighted sum of its neighbors using the kernel weights. The kernel must handle boundary conditions by only including pixels within image bounds and maintain the original image dimensions.", "level2_prompt": "Create a Gaussian_Blur kernel that for each output pixel, computes a weighted sum of pixels in a 9x9 neighborhood centered at that pixel, using the provided kernel weights. Skip out-of-bound neighbors during computation. Input is a 1024x2048 image and 9x9 kernel; output is a blurred image of identical dimensions.", "level3_prompt": "Compute Gaussian blur on an image using a given kernel."}
{"id": 79, "task_name": "Gaussian_Blur", "task_description": "Compute the Gaussian_Blur kernel on GPU using CUDA.", "inputs": [{"name": "image", "dtype": "float32", "shape": "(2048, 2048)"}, {"name": "kernel", "dtype": "float32", "shape": "(11, 11)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define H 2048\n#define W 2048\n#define KH 11\n#define KW 11\n\n__global__ void gaussian_blur_kernel(\n    const float* input,\n    const float* kernel,\n    float* output\n) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    float sum = 0.0f;\n    int cy = KH / 2;\n    int cx = KW / 2;\n\n    for (int i = 0; i < KH; ++i) {\n        for (int j = 0; j < KW; ++j) {\n            int iy = y + i - cy;\n            int ix = x + j - cx;\n            if (iy >= 0 && iy < H && ix >= 0 && ix < W) {\n                sum += input[iy * W + ix] * kernel[i * KW + j];\n            }\n        }\n    }\n    output[y * W + x] = sum;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t image_size = H * W;\n    size_t kernel_size = KH * KW;\n\n    float* h_image = new float[image_size];\n    float* h_kernel = new float[kernel_size];\n    float* h_output = new float[image_size];\n\n    read_binary(\"data/image.bin\", h_image, image_size);\n    read_binary(\"data/kernel.bin\", h_kernel, kernel_size);\n\n    float *d_image, *d_kernel, *d_output;\n    cudaMalloc(&d_image, image_size * sizeof(float));\n    cudaMalloc(&d_kernel, kernel_size * sizeof(float));\n    cudaMalloc(&d_output, image_size * sizeof(float));\n\n    cudaMemcpy(d_image, h_image, image_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, kernel_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + 15) / 16, (H + 15) / 16);\n\n    gaussian_blur_kernel<<<grid, block>>>(d_image, d_kernel, d_output);\n\n    cudaMemcpy(h_output, d_output, image_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", h_output, image_size);\n\n    cudaFree(d_image);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_image;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nH = 2048\nW = 2048\nKH = 11\nKW = 11\nSIGMA = 1.0\n\nnp.random.seed(42)\n\nimage = np.random.rand(H, W).astype(np.float32)\n\ndef gaussian_kernel(h, w, sigma):\n    cy = h // 2\n    cx = w // 2\n    kernel = np.zeros((h, w), dtype=np.float32)\n    for i in range(h):\n        for j in range(w):\n            y = i - cy\n            x = j - cx\n            kernel[i, j] = np.exp(-(x*x + y*y) / (2 * sigma * sigma))\n    kernel /= kernel.sum()\n    return kernel\n\nkernel = gaussian_kernel(KH, KW, SIGMA)\n\npad_h = KH // 2\npad_w = KW // 2\npadded = np.pad(image, ((pad_h, pad_h), (pad_w, pad_w)), mode=\"constant\")\n\noutput = np.zeros_like(image)\n\nfor i in range(H):\n    for j in range(W):\n        region = padded[i:i+KH, j:j+KW]\n        output[i, j] = np.sum(region * kernel)\n\nimage.tofile(\"data/image.bin\")\nkernel.tofile(\"data/kernel.bin\")\noutput.tofile(\"data/output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nH = 2048\nW = 2048\nSIZE = H * W\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nout_file = \"data/output.bin\"\nref_file = \"data/output_ref.bin\"\n\nif not os.path.exists(out_file) or not os.path.exists(ref_file):\n    print(\"F\")\n    exit(0)\n\nout = read_binary(out_file, SIZE)\nref = read_binary(ref_file, SIZE)\n\nif np.allclose(out, ref, atol=1e-2):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Gaussian_Blur. Perform a 2D convolution between a 2048x2048 image and an 11x11 Gaussian kernel to produce a blurred image. The input image is a 2D tensor of shape (2048, 2048) with float32 data type. The kernel is a 2D tensor of shape (11, 11) with float32 data type. The output is a flattened 1D tensor of 4194304 float32 elements representing the blurred image in row-major order. Handle boundary conditions by only including pixels within the image boundaries when the kernel window extends beyond edges.", "level2_prompt": "For each pixel (x,y) in the output image, compute the weighted sum of pixels in an 11x11 neighborhood centered at (x,y) in the input image, using the kernel as weights. If the neighborhood extends beyond image boundaries, only include valid pixels within the image.", "level3_prompt": "Apply Gaussian blur to an image using a provided kernel."}
{"id": 80, "task_name": "Matrix_Power", "task_description": "Compute the Matrix_Power kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(64, 64)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(64, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define N 64\n#define P 4\n#define TILE 16\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int n) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < n && col < n) {\n        float sum = 0.0f;\n        for (int k = 0; k < n; ++k) {\n            sum += A[row * n + k] * B[k * n + col];\n        }\n        C[row * n + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * N * sizeof(float);\n\n    float* h_A = new float[N * N];\n    float* h_C = new float[N * N];\n\n    read_binary(\"data/matA.bin\", h_A, N * N);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_C, bytes);\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_A, bytes, cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE, (N + TILE - 1) / TILE);\n\n    for (int i = 1; i < P; ++i) {\n        matmul_kernel<<<grid, block>>>(d_A, d_B, d_C, N);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_B, d_C, bytes, cudaMemcpyDeviceToDevice);\n    }\n\n    cudaMemcpy(h_C, d_B, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matC_out.bin\", h_C, N * N);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 64\nP = 4\nnp.random.seed(42)\n\nA = np.random.randn(N, N).astype(np.float32)\n\nC = np.linalg.matrix_power(A, P).astype(np.float32)\n\nA.tofile(\"data/matA.bin\")\nC.tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 64\nTOL = 1e-1\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nA = read_binary(\"data/matC_out.bin\", N * N).reshape(N, N)\nB = read_binary(\"data/matC_ref.bin\", N * N).reshape(N, N)\n\ndiff = np.abs(A - B)\nif np.all(diff < TOL):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Matrix_Power. Compute the 4th power of a 64x64 matrix. The input is a single matrix 'matA' of shape (64, 64) and data type float32. The output is a matrix 'matC_out' of the same shape and type, which is the input matrix multiplied by itself three times (i.e., matA^4). The exponent is fixed at 4 and the matrix size is fixed at 64x64. The computation must be performed by chaining three matrix multiplications.", "level2_prompt": "Matrix_Power: Compute the 4th power of a 64x64 matrix. The algorithm requires three iterative matrix multiplications. Starting with the original matrix, multiply it by itself to get the square, then multiply the square by the original matrix to get the cube, and then multiply the cube by the original matrix to get the fourth power. Each matrix multiplication is defined by the standard formula: the element at row i and column j of the product is the dot product of row i of the first matrix and column j of the second matrix.", "level3_prompt": "Compute the 4th power of a 64x64 matrix."}
{"id": 81, "task_name": "Matrix_Power", "task_description": "Compute the Matrix_Power kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(128, 128)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(128, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define N 128\n#define P 5\n#define TILE 16\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int n) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < n && col < n) {\n        float sum = 0.0f;\n        for (int k = 0; k < n; ++k) {\n            sum += A[row * n + k] * B[k * n + col];\n        }\n        C[row * n + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * N * sizeof(float);\n\n    float* h_A = new float[N * N];\n    float* h_C = new float[N * N];\n\n    read_binary(\"data/matA.bin\", h_A, N * N);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_C, bytes);\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_A, bytes, cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE, (N + TILE - 1) / TILE);\n\n    for (int i = 1; i < P; ++i) {\n        matmul_kernel<<<grid, block>>>(d_A, d_B, d_C, N);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_B, d_C, bytes, cudaMemcpyDeviceToDevice);\n    }\n\n    cudaMemcpy(h_C, d_B, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matC_out.bin\", h_C, N * N);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 128\nP = 5\nnp.random.seed(42)\n\nA = np.random.randn(N, N).astype(np.float32)\n\nC = np.linalg.matrix_power(A, P).astype(np.float32)\n\nA.tofile(\"data/matA.bin\")\nC.tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 128\nTOL = 1e-1\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nA = read_binary(\"data/matC_out.bin\", N * N).reshape(N, N)\nB = read_binary(\"data/matC_ref.bin\", N * N).reshape(N, N)\n\ndiff = np.abs(A - B)\nif np.all(diff < TOL):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Matrix_Power. Compute the 5th power of a 128x128 square matrix of 32-bit floating point numbers. The input is a matrix of shape (128, 128) and data type float32. The output must be a matrix of the same shape and type. The exponent is fixed at 5. The computation must be performed by multiplying the input matrix by itself four times (using matrix multiplication) to achieve the 5th power.", "level2_prompt": "Task: Matrix_Power. Given a 128x128 matrix of 32-bit floats, compute the matrix raised to the power of 5 by performing four matrix multiplications: start with the input matrix and multiply it by itself repeatedly until the exponent of 5 is reached.", "level3_prompt": "Compute the Matrix_Power kernel on GPU using CUDA."}
{"id": 82, "task_name": "Matrix_Power", "task_description": "Compute the Matrix_Power kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(96, 96)"}], "outputs": [], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define N 96\n#define P 3\n#define TILE 16\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int n) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < n && col < n) {\n        float sum = 0.0f;\n        for (int k = 0; k < n; ++k) {\n            sum += A[row * n + k] * B[k * n + col];\n        }\n        C[row * n + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * N * sizeof(float);\n\n    float* h_A = new float[N * N];\n    float* h_C = new float[N * N];\n\n    read_binary(\"data/matA.bin\", h_A, N * N);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_C, bytes);\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_A, bytes, cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE, (N + TILE - 1) / TILE);\n\n    for (int i = 1; i < P; ++i) {\n        matmul_kernel<<<grid, block>>>(d_A, d_B, d_C, N);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_B, d_C, bytes, cudaMemcpyDeviceToDevice);\n    }\n\n    cudaMemcpy(h_C, d_B, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matC_out.bin\", h_C, N * N);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 96\nP = 3\nnp.random.seed(42)\n\nA = np.random.randn(N, N).astype(np.float32)\n\nC = np.linalg.matrix_power(A, P).astype(np.float32)\n\nA.tofile(\"data/matA.bin\")\nC.tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 96\nTOL = 1e-1\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nA = read_binary(\"data/matC_out.bin\", N * N).reshape(N, N)\nB = read_binary(\"data/matC_ref.bin\", N * N).reshape(N, N)\n\ndiff = np.abs(A - B)\nif np.all(diff < TOL):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task name: Matrix_Power. Compute the cube (third power) of a 96x96 square matrix of 32-bit floating-point numbers. The input is a single matrix 'matA' of shape (96, 96) and dtype float32. The output must be a matrix of the same shape and dtype, which is the result of the matrix multiplication of the input matrix by itself twice. The exponent is fixed to 3 and the matrix dimensions are fixed at 96x96.", "level2_prompt": "Matrix_Power: Compute the third power of a square matrix by performing two matrix multiplications: first multiply the input matrix by itself to get the square, then multiply the square matrix by the original input matrix to get the cube.", "level3_prompt": "Compute the cube of a 96x96 matrix."}
{"id": 83, "task_name": "Matrix_Power", "task_description": "Compute the Matrix_Power kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(256, 256)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define N 256\n#define P 2\n#define TILE 16\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int n) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < n && col < n) {\n        float sum = 0.0f;\n        for (int k = 0; k < n; ++k) {\n            sum += A[row * n + k] * B[k * n + col];\n        }\n        C[row * n + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * N * sizeof(float);\n\n    float* h_A = new float[N * N];\n    float* h_C = new float[N * N];\n\n    read_binary(\"data/matA.bin\", h_A, N * N);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_C, bytes);\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_A, bytes, cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE, (N + TILE - 1) / TILE);\n\n    for (int i = 1; i < P; ++i) {\n        matmul_kernel<<<grid, block>>>(d_A, d_B, d_C, N);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_B, d_C, bytes, cudaMemcpyDeviceToDevice);\n    }\n\n    cudaMemcpy(h_C, d_B, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matC_out.bin\", h_C, N * N);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 256\nP = 2\nnp.random.seed(42)\n\nA = np.random.randn(N, N).astype(np.float32)\n\nC = np.linalg.matrix_power(A, P).astype(np.float32)\n\nA.tofile(\"data/matA.bin\")\nC.tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 256\nTOL = 1e-1\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nA = read_binary(\"data/matC_out.bin\", N * N).reshape(N, N)\nB = read_binary(\"data/matC_ref.bin\", N * N).reshape(N, N)\n\ndiff = np.abs(A - B)\nif np.all(diff < TOL):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Matrix_Power: Compute the square (second power) of a given 256x256 matrix. The input is a single-precision floating-point tensor of shape (256, 256), and the output must be a single-precision floating-point tensor of the same shape representing the matrix squared. The kernel must handle square matrices and compute the exact mathematical matrix power operation for exponent 2.", "level2_prompt": "Matrix_Power: Given a square matrix A of dimensions 256x256, compute A² by multiplying A by itself. The operation must result in a new matrix where each element is the dot product of corresponding rows and columns from the input matrix.", "level3_prompt": "Compute the Matrix_Power kernel for exponent 2 on a 256x256 matrix."}
{"id": 84, "task_name": "Matrix_Power", "task_description": "Compute the Matrix_Power kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(512, 512)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define N 512\n#define P 3\n#define TILE 16\n\n__global__ void matmul_kernel(const float* A, const float* B, float* C, int n) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < n && col < n) {\n        float sum = 0.0f;\n        for (int k = 0; k < n; ++k) {\n            sum += A[row * n + k] * B[k * n + col];\n        }\n        C[row * n + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * N * sizeof(float);\n\n    float* h_A = new float[N * N];\n    float* h_C = new float[N * N];\n\n    read_binary(\"data/matA.bin\", h_A, N * N);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, bytes);\n    cudaMalloc(&d_B, bytes);\n    cudaMalloc(&d_C, bytes);\n\n    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_A, bytes, cudaMemcpyHostToDevice);\n\n    dim3 block(TILE, TILE);\n    dim3 grid((N + TILE - 1) / TILE, (N + TILE - 1) / TILE);\n\n    for (int i = 1; i < P; ++i) {\n        matmul_kernel<<<grid, block>>>(d_A, d_B, d_C, N);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_B, d_C, bytes, cudaMemcpyDeviceToDevice);\n    }\n\n    cudaMemcpy(h_C, d_B, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/matC_out.bin\", h_C, N * N);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 512\nP = 3\nnp.random.seed(42)\n\nA = np.random.randn(N, N).astype(np.float32)\n\nC = np.linalg.matrix_power(A, P).astype(np.float32)\n\nA.tofile(\"data/matA.bin\")\nC.tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 512\nTOL = 1e-1\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nA = read_binary(\"data/matC_out.bin\", N * N).reshape(N, N)\nB = read_binary(\"data/matC_ref.bin\", N * N).reshape(N, N)\n\ndiff = np.abs(A - B)\nif np.all(diff < TOL):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Matrix_Power. Compute the matrix power of exponent 3 for a given 512x512 matrix. The input is a tensor named 'matA' of data type float32 and shape (512, 512). The output is a tensor named 'matC_out' of data type float32 and shape (512, 512). The exponent is fixed to 3 and the matrix dimension is fixed to 512.", "level2_prompt": "Matrix_Power: Given a square matrix A of size 512x512, compute the matrix power A raised to the exponent 3, which is equivalent to multiplying the matrix by itself twice (A * A * A).", "level3_prompt": "Compute the matrix power of a given matrix."}
{"id": 85, "task_name": "Binary_Cross_Entropy_Loss", "task_description": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(1024,)"}, {"name": "target", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "()"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n\n\n// binary cross entropy loss kernel\n// BCE Loss = -[y*log(p) + (1-y)*log(1-p)]\n__global__ void binary_cross_entropy_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float p = pred[idx];\n    float y = target[idx];\n    float loss = - (y * logf(p + 1e-12f) + (1 - y) * logf(1 - p + 1e-12f));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32)\npred_tensor = torch.sigmoid(pred_tensor)\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Binary_Cross_Entropy_Loss task. The kernel should compute the binary cross entropy loss for a batch of 1024 predictions and corresponding binary targets. The inputs are two 1D tensors of float32: 'pred' of shape (1024,) containing predicted probabilities, and 'target' of shape (1024,) containing true binary labels (values between 0 and 1). The output is a scalar float32 tensor containing the mean loss over the batch. Each thread should compute the loss for one element: loss_i = - (target_i * log(pred_i + 1e-12) + (1 - target_i) * log(1 - pred_i + 1e-12)). The kernel must accumulate these individual losses into a global sum using atomic operations. The final mean is computed by dividing the accumulated sum by 1024 on the host side.", "level2_prompt": "Compute the binary cross entropy loss for a batch of 1024 elements. For each element i, the loss is calculated as: - (target[i] * log(pred[i] + 1e-12) + (1 - target[i]) * log(1 - pred[i] + 1e-12)). The kernel must accumulate these losses into a single output variable. The batch size is 1024.", "level3_prompt": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 86, "task_name": "Binary_Cross_Entropy_Loss", "task_description": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(4096,)"}, {"name": "target", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n\n\n// binary cross entropy loss kernel\n// BCE Loss = -[y*log(p) + (1-y)*log(1-p)]\n__global__ void binary_cross_entropy_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float p = pred[idx];\n    float y = target[idx];\n    float loss = - (y * logf(p + 1e-12f) + (1 - y) * logf(1 - p + 1e-12f));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32)\npred_tensor = torch.sigmoid(pred_tensor)\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Binary_Cross_Entropy_Loss CUDA kernel. The kernel takes two input vectors of float32, each of size 4096: one for predictions (pred) and one for targets (target). The kernel must compute the binary cross entropy loss for each element: for each index i, the loss term is - [ target[i] * log(pred[i] + 1e-12) + (1 - target[i]) * log(1 - pred[i] + 1e-12) ]. The kernel must accumulate the total loss by summing all these terms into a single output scalar (of shape (1,)). The accumulation must be done in a thread-safe manner to avoid race conditions. Note: the kernel does not compute the mean loss; the mean is computed by the host code by dividing the total loss by 4096. The addition of 1e-12 is to prevent numerical instability.", "level2_prompt": "The Binary_Cross_Entropy_Loss kernel computes the binary cross entropy loss. For each element i, the loss term is: loss_i = - [ target[i] * log(pred[i] + 1e-12) + (1 - target[i]) * log(1 - pred[i] + 1e-12) ]. The total loss is the sum of loss_i over all elements. The mean loss is then computed by the host by dividing the total loss by the batch size (4096).", "level3_prompt": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 87, "task_name": "Binary_Cross_Entropy_Loss", "task_description": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(16384,)"}, {"name": "target", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16384\n\n\n// binary cross entropy loss kernel\n// BCE Loss = -[y*log(p) + (1-y)*log(1-p)]\n__global__ void binary_cross_entropy_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float p = pred[idx];\n    float y = target[idx];\n    float loss = - (y * logf(p + 1e-12f) + (1 - y) * logf(1 - p + 1e-12f));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16384\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32)\npred_tensor = torch.sigmoid(pred_tensor)\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel to compute the binary cross entropy loss. The kernel should process two input tensors: 'pred' and 'target', both float32 tensors of shape (16384,). For each element, compute the loss as -[target * log(pred + 1e-12) + (1 - target) * log(1 - pred + 1e-12)]. Accumulate all element losses using atomic operations into a single float32 output tensor of shape (1,). The final mean loss is computed by dividing the accumulated loss by the batch size (16384) in host code.", "level2_prompt": "Compute the binary cross entropy loss between prediction and target tensors. For each element, apply the formula: loss = -[y * log(p + ε) + (1-y) * log(1-p + ε)] where p is prediction, y is target, and ε=1e-12. Sum all individual losses into a single scalar output. The mean loss is obtained by dividing the sum by the batch size.", "level3_prompt": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 88, "task_name": "Binary_Cross_Entropy_Loss", "task_description": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(65536,)"}, {"name": "target", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 65536\n\n\n// binary cross entropy loss kernel\n// BCE Loss = -[y*log(p) + (1-y)*log(1-p)]\n__global__ void binary_cross_entropy_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float p = pred[idx];\n    float y = target[idx];\n    float loss = - (y * logf(p + 1e-12f) + (1 - y) * logf(1 - p + 1e-12f));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 65536\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32)\npred_tensor = torch.sigmoid(pred_tensor)\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for Binary Cross Entropy Loss. The kernel takes two input tensors: 'pred' (float32, shape [65536]) and 'target' (float32, shape [65536]). Compute the element-wise loss using the formula: -[target * log(pred + epsilon) + (1 - target) * log(1 - pred + epsilon)] where epsilon=1e-12. Atomically accumulate the sum of all losses into a single output scalar (float32, shape [1]). The host code will later divide this sum by 65536 to compute the average loss.", "level2_prompt": "Compute Binary Cross Entropy Loss by evaluating per-element losses between predicted and target values. Each thread calculates loss_i = -[target_i * log(pred_i + 1e-12) + (1 - target_i) * log(1 - pred_i + 1e-12)], then atomically sums these values into a single output scalar.", "level3_prompt": "Compute the Binary Cross Entropy Loss between two input tensors and output the accumulated loss sum."}
{"id": 89, "task_name": "Binary_Cross_Entropy_Loss", "task_description": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(262144,)"}, {"name": "target", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 262144\n\n\n// binary cross entropy loss kernel\n// BCE Loss = -[y*log(p) + (1-y)*log(1-p)]\n__global__ void binary_cross_entropy_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float p = pred[idx];\n    float y = target[idx];\n    float loss = - (y * logf(p + 1e-12f) + (1 - y) * logf(1 - p + 1e-12f));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 262144\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32)\npred_tensor = torch.sigmoid(pred_tensor)\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for Binary Cross Entropy Loss. The kernel takes two input vectors, 'pred' and 'target', each containing 262144 float32 values. For each element, compute the loss as: - [target * log(pred + 1e-12) + (1 - target) * log(1 - pred + 1e-12)]. The kernel must sum all these individual losses into a single output value (a scalar tensor of shape (1)). Use atomic operations to accumulate the sum. Ensure the kernel avoids out-of-bounds memory accesses by checking the index.", "level2_prompt": "Compute the binary cross entropy loss for a batch of 262144 elements. For each element i, the loss is computed as: - [target_i * log(pred_i + 1e-12) + (1 - target_i) * log(1 - pred_i + 1e-12)]. The output is the sum of these losses over all elements.", "level3_prompt": "Compute the Binary_Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 90, "task_name": "Binary_Cross_Entropy_With_Logits_Loss", "task_description": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(1024,)"}, {"name": "target", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n\n\n// binary cross entropy with logits loss kernel\n// BCE with logits: loss = -[y*log(sigmoid(p)) + (1-y)*log(1-sigmoid(p))]\n// where sigmoid(p) = 1 / (1 + exp(-p)) = exp(p) / (1 + exp(p))\n// BCE with logits: loss = -[y*(p - log(1 + exp(p))) + (1-y)*(-log(1 + exp(p)))]\n__global__ void binary_cross_entropy_with_logits_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // sigmoid and log\n    float p = pred[idx];\n    float y = target[idx];\n    float exp_p = expf(p);\n    float loss = - (y * (p - log1pf(exp_p)) + (1.0f - y) * (-log1pf(exp_p)));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_with_logits_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy_with_logits(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Binary Cross Entropy With Logits Loss kernel. Compute the loss for each element between prediction and target vectors, both float32 tensors of shape (1024,). Accumulate individual losses into a single scalar output float32 tensor of shape (1,). Ensure the kernel handles element-wise computation correctly and accumulates results without race conditions. The final output must represent the mean loss across all elements.", "level2_prompt": "Calculate the binary cross entropy with logits loss. For each pair of prediction and target values, compute the loss as -[target * (prediction - log(1 + exp(prediction))) + (1 - target) * (-log(1 + exp(prediction)))]. Sum all individual losses and return the mean value across the batch.", "level3_prompt": "Compute Binary Cross Entropy With Logits Loss."}
{"id": 91, "task_name": "Binary_Cross_Entropy_With_Logits_Loss", "task_description": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(4096,)"}, {"name": "target", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n\n\n// binary cross entropy with logits loss kernel\n// BCE with logits: loss = -[y*log(sigmoid(p)) + (1-y)*log(1-sigmoid(p))]\n// where sigmoid(p) = 1 / (1 + exp(-p)) = exp(p) / (1 + exp(p))\n// BCE with logits: loss = -[y*(p - log(1 + exp(p))) + (1-y)*(-log(1 + exp(p)))]\n__global__ void binary_cross_entropy_with_logits_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // sigmoid and log\n    float p = pred[idx];\n    float y = target[idx];\n    float exp_p = expf(p);\n    float loss = - (y * (p - log1pf(exp_p)) + (1.0f - y) * (-log1pf(exp_p)));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_with_logits_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy_with_logits(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task Name: Binary Cross Entropy With Logits Loss. Given two input tensors `pred` and `target`, both of shape (4096,) and dtype float32, compute the binary cross entropy loss with logits. The kernel must compute per-element losses using the formula: loss_i = -[target_i * (pred_i - log(1 + exp(pred_i))) + (1 - target_i) * (-log(1 + exp(pred_i)))]. The kernel must accumulate these losses into a single output scalar of shape (1,) and dtype float32 using atomic operations. Target values must be in the range [0,1], and the kernel must handle batch size 4096.", "level2_prompt": "Compute the Binary Cross Entropy With Logits Loss. For each element i, calculate loss_i = -[target_i * (pred_i - log(1 + exp(pred_i))) + (1 - target_i) * (-log(1 + exp(pred_i)))]. Sum all loss_i values into a single scalar output.", "level3_prompt": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA."}
{"id": 92, "task_name": "Binary_Cross_Entropy_With_Logits_Loss", "task_description": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(16384,)"}, {"name": "target", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16384\n\n\n// binary cross entropy with logits loss kernel\n// BCE with logits: loss = -[y*log(sigmoid(p)) + (1-y)*log(1-sigmoid(p))]\n// where sigmoid(p) = 1 / (1 + exp(-p)) = exp(p) / (1 + exp(p))\n// BCE with logits: loss = -[y*(p - log(1 + exp(p))) + (1-y)*(-log(1 + exp(p)))]\n__global__ void binary_cross_entropy_with_logits_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // sigmoid and log\n    float p = pred[idx];\n    float y = target[idx];\n    float exp_p = expf(p);\n    float loss = - (y * (p - log1pf(exp_p)) + (1.0f - y) * (-log1pf(exp_p)));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_with_logits_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16384\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy_with_logits(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Binary_Cross_Entropy_With_Logits_Loss. Compute the average binary cross-entropy loss with logits for a batch of predictions and targets. The inputs are two float32 tensors: 'pred' (shape 16384) containing predicted logits, and 'target' (shape 16384) containing ground truth labels between 0 and 1. The output is a single float32 scalar representing the average loss over all elements. The kernel must compute per-element losses using the formula -[y*(p - log(1+exp(p))) + (1-y)*(-log(1+exp(p)))] for each element, then safely accumulate and average them across all elements.", "level2_prompt": "Task: Binary_Cross_Entropy_With_Logits_Loss. For each element in the batch, compute the loss as: loss_i = - [target_i * (pred_i - log(1+exp(pred_i))) + (1-target_i) * (-log(1+exp(pred_i)))]. Sum all loss_i values, then divide the total by the batch size to obtain the final scalar output.", "level3_prompt": "Compute the Binary Cross Entropy with Logits Loss."}
{"id": 93, "task_name": "Binary_Cross_Entropy_With_Logits_Loss", "task_description": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(65536,)"}, {"name": "target", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 65536\n\n\n// binary cross entropy with logits loss kernel\n// BCE with logits: loss = -[y*log(sigmoid(p)) + (1-y)*log(1-sigmoid(p))]\n// where sigmoid(p) = 1 / (1 + exp(-p)) = exp(p) / (1 + exp(p))\n// BCE with logits: loss = -[y*(p - log(1 + exp(p))) + (1-y)*(-log(1 + exp(p)))]\n__global__ void binary_cross_entropy_with_logits_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // sigmoid and log\n    float p = pred[idx];\n    float y = target[idx];\n    float exp_p = expf(p);\n    float loss = - (y * (p - log1pf(exp_p)) + (1.0f - y) * (-log1pf(exp_p)));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_with_logits_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 65536\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy_with_logits(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Binary_Cross_Entropy_With_Logits_Loss task. The kernel takes two input tensors: 'pred' (float32, shape (65536)) containing logits, and 'target' (float32, shape (65536)) containing true labels (each between 0 and 1). The kernel must compute the binary cross entropy loss with logits for each element. The loss for an element is calculated as: loss_i = - [ target_i * (pred_i - log(1 + exp(pred_i))) + (1 - target_i) * (-log(1 + exp(pred_i))) ]. The kernel must accumulate the sum of all these element-wise losses into a single output value (a tensor of shape (1) and float32). The accumulation must be done in a thread-safe manner to avoid race conditions. Note: the division by the batch size (65536) to obtain the mean loss is performed by the host after the kernel execution.", "level2_prompt": "The Binary_Cross_Entropy_With_Logits_Loss task computes the total loss for a batch of logits and labels. The total loss is the sum of the element-wise losses. Each element's loss is computed as: loss_i = - [ target_i * (pred_i - log(1 + exp(pred_i))) + (1 - target_i) * (-log(1 + exp(pred_i))) ].", "level3_prompt": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA."}
{"id": 94, "task_name": "Binary_Cross_Entropy_With_Logits_Loss", "task_description": "Compute the Binary_Cross_Entropy_With_Logits_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(262144,)"}, {"name": "target", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 262144\n\n\n// binary cross entropy with logits loss kernel\n// BCE with logits: loss = -[y*log(sigmoid(p)) + (1-y)*log(1-sigmoid(p))]\n// where sigmoid(p) = 1 / (1 + exp(-p)) = exp(p) / (1 + exp(p))\n// BCE with logits: loss = -[y*(p - log(1 + exp(p))) + (1-y)*(-log(1 + exp(p)))]\n__global__ void binary_cross_entropy_with_logits_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // sigmoid and log\n    float p = pred[idx];\n    float y = target[idx];\n    float exp_p = expf(p);\n    float loss = - (y * (p - log1pf(exp_p)) + (1.0f - y) * (-log1pf(exp_p)));\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    binary_cross_entropy_with_logits_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 262144\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.binary_cross_entropy_with_logits(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Binary Cross Entropy With Logits Loss kernel. The kernel should compute the loss between prediction and target tensors. Inputs are two float32 tensors: 'pred' with shape (262144,) and 'target' with shape (262144,). The output is a single float32 value representing the mean loss. The loss for each element is calculated as: -[target * (pred - log(1 + exp(pred))) + (1 - target) * (-log(1 + exp(pred)))]. All individual losses must be summed atomically, and the final output should be divided by 262144 to compute the mean loss.", "level2_prompt": "Compute the Binary Cross Entropy With Logits Loss. For each element in the prediction and target tensors, calculate the loss using the formula: loss_i = -[target_i * (pred_i - log(1 + exp(pred_i))) + (1 - target_i) * (-log(1 + exp(pred_i)))]. Sum all individual losses and then compute the mean by dividing the total sum by the number of elements (262144). The result is a single scalar value.", "level3_prompt": "Compute the Binary Cross Entropy With Logits Loss kernel on GPU using CUDA."}
{"id": 95, "task_name": "CeLU", "task_description": "Compute the CeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define CELU_ALPHA 1.0f\n\n\n// CELU(x) = max(0, x) + min(0, alpha * (exp(x / alpha) - 1)))\n__global__ void celu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : CELU_ALPHA * (expf(x / CELU_ALPHA) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    celu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.celu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the CeLU kernel. The CeLU function is defined as: for each element x in the input tensor, if x > 0, output = x; else output = alpha * (exp(x / alpha) - 1), where alpha is 1.0. The input is a 2D tensor of shape (16, 1024) with float32 data type. The output must have the same shape and data type as the input. The kernel must apply this transformation element-wise to all values in the input tensor.", "level2_prompt": "Compute the Continuously Exponential Linear Unit (CeLU) activation function. For each element in the input tensor, if the value is positive, return the value unchanged; if negative, return alpha multiplied by (exponential of (value divided by alpha) minus one), with alpha fixed at 1.0.", "level3_prompt": "Compute the CeLU kernel on GPU using CUDA."}
{"id": 96, "task_name": "CeLU", "task_description": "Compute the CeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define CELU_ALPHA 1.0f\n\n\n// CELU(x) = max(0, x) + min(0, alpha * (exp(x / alpha) - 1)))\n__global__ void celu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : CELU_ALPHA * (expf(x / CELU_ALPHA) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    celu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.celu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: CeLU. Given an input tensor of shape (16, 4096) with float32 values, compute the output tensor of the same shape and type. For each element in the input, if the element is greater than zero, the output element is the same as the input. Otherwise, the output element is 1.0 multiplied by the exponential of the input element minus 1.0. The computation must be performed element-wise.", "level2_prompt": "CeLU: For each element x in the input tensor, the output is x if x > 0, or 1.0 * (exp(x) - 1.0) if x <= 0.", "level3_prompt": "Compute the CeLU activation function."}
{"id": 97, "task_name": "CeLU", "task_description": "Compute the CeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define CELU_ALPHA 1.0f\n\n\n// CELU(x) = max(0, x) + min(0, alpha * (exp(x / alpha) - 1)))\n__global__ void celu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : CELU_ALPHA * (expf(x / CELU_ALPHA) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    celu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.celu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the CeLU (Continuously Exponential Linear Unit) activation function on GPU. The input is a 2D float32 tensor of shape (16, 16384). For each element x in the input, the output should be x if x > 0, and alpha * (exp(x/alpha) - 1) if x <= 0, where alpha is fixed at 1.0. The output must be a float32 tensor with the same shape as the input. Each element must be processed independently.", "level2_prompt": "Compute the CeLU activation function element-wise. For each input value x, apply: output = x if x > 0, else alpha * (exp(x/alpha) - 1) with alpha=1.0.", "level3_prompt": "Compute the CeLU kernel on GPU using CUDA."}
{"id": 98, "task_name": "CeLU", "task_description": "Compute the CeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define CELU_ALPHA 1.0f\n\n\n// CELU(x) = max(0, x) + min(0, alpha * (exp(x / alpha) - 1)))\n__global__ void celu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : CELU_ALPHA * (expf(x / CELU_ALPHA) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    celu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.celu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a GPU kernel for the CeLU activation function. The input is a 16x65536 tensor of float32 values. The output must be a tensor of the same shape and data type. For each element, if the value is positive, output the value unchanged; if negative, apply the transformation: alpha * (exp(value / alpha) - 1), where alpha is fixed at 1.0.", "level2_prompt": "Compute the Continuously Exponential Linear Unit (CeLU) function element-wise. For each input value x, if x > 0, output x; else output alpha * (exp(x / alpha) - 1) with alpha=1.0.", "level3_prompt": "Compute the CeLU kernel on GPU using CUDA."}
{"id": 99, "task_name": "CeLU", "task_description": "Compute the CeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define CELU_ALPHA 1.0f\n\n\n// CELU(x) = max(0, x) + min(0, alpha * (exp(x / alpha) - 1)))\n__global__ void celu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : CELU_ALPHA * (expf(x / CELU_ALPHA) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    celu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.celu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the CeLU activation function kernel. The input is a 2D tensor of shape (16, 262144) with float32 data type. For each element in the input, if the value is greater than 0, output the same value; otherwise, output 1.0 multiplied by (exponential of the value divided by 1.0 minus 1). The output should be a 1D tensor of shape (4194304,) with float32 data type, which is the flattened result of applying CeLU to all input elements. The constant alpha is fixed at 1.0.", "level2_prompt": "Compute the CeLU activation function. For each element x in the input tensor: if x > 0, output x; else output 1.0 × (exp(x) - 1). The operation should be applied element-wise to transform the input tensor into the output tensor.", "level3_prompt": "Compute the CeLU kernel on GPU using CUDA."}
{"id": 100, "task_name": "Cross_Entropy_Loss", "task_description": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(1024, 128)"}, {"name": "target", "dtype": "int64", "shape": "(1024,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n#define DIM 128\n\n\n// cross entropy loss kernel\n// CrossEntropyLoss(x, y) = sum (-log(softmax(x)[i][y[i]])) / N\n__global__ void cross_entropy_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float val = pred[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute loss\n    int target_index = target[idx];\n    float log_softmax = pred[idx * dim + target_index] - old_max_val - logf(sum_exp);\n    atomicAdd(output, -log_softmax);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Cross_Entropy_Loss. Compute the mean cross entropy loss for a batch of predictions and target labels. Inputs include a float32 prediction tensor of shape (1024, 128) and an int64 target tensor of shape (1024,). The output is a single float32 value representing the averaged loss. The kernel must compute softmax values for each prediction row, calculate negative log probabilities for the target indices, sum these losses across all samples, and finally divide by batch size. Numerical stability must be maintained during softmax computation.", "level2_prompt": "Task: Cross_Entropy_Loss. For each of 1024 samples, compute the maximum value in its 128-element prediction vector. Calculate the sum of exponentials of prediction values shifted by this maximum. For the target index, derive the log probability as (prediction_value - max) minus log(sum_exp). The loss per sample is the negative of this log probability. Sum all sample losses and divide by 1024 to produce the final scalar output.", "level3_prompt": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 101, "task_name": "Cross_Entropy_Loss", "task_description": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(4096, 128)"}, {"name": "target", "dtype": "int64", "shape": "(4096,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n#define DIM 128\n\n\n// cross entropy loss kernel\n// CrossEntropyLoss(x, y) = sum (-log(softmax(x)[i][y[i]])) / N\n__global__ void cross_entropy_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float val = pred[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute loss\n    int target_index = target[idx];\n    float log_softmax = pred[idx * dim + target_index] - old_max_val - logf(sum_exp);\n    atomicAdd(output, -log_softmax);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Cross_Entropy_Loss. Compute the average cross-entropy loss for a batch of 4096 samples across 128 classes. Inputs: 'pred' is a float32 tensor of shape (4096, 128) representing predicted logits, 'target' is an int64 tensor of shape (4096,) representing true class indices (each between 0 and 127). Output: 'output' is a float32 scalar tensor containing the average loss. The kernel must compute per-sample loss using numerically stable softmax (online max and exponent sum), accumulate negative log softmax values atomically for the target index, and leave averaging by batch size to host code.", "level2_prompt": "Task: Cross_Entropy_Loss. For each sample in a batch of 4096: find the maximum logit value (for numerical stability), compute the sum of exponentiated logits adjusted by this max, derive the log softmax at the target index, calculate negative log softmax as the sample loss, and atomically accumulate this loss. The final output is the accumulated loss sum (averaging by batch size occurs outside the kernel).", "level3_prompt": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 102, "task_name": "Cross_Entropy_Loss", "task_description": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(16384, 128)"}, {"name": "target", "dtype": "int64", "shape": "(16384,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "()"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16384\n#define DIM 128\n\n\n// cross entropy loss kernel\n// CrossEntropyLoss(x, y) = sum (-log(softmax(x)[i][y[i]])) / N\n__global__ void cross_entropy_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float val = pred[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute loss\n    int target_index = target[idx];\n    float log_softmax = pred[idx * dim + target_index] - old_max_val - logf(sum_exp);\n    atomicAdd(output, -log_softmax);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16384\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Cross_Entropy_Loss. Compute the mean cross-entropy loss for a batch of predictions and targets. The inputs are a float32 tensor 'pred' with shape (16384, 128) representing predicted logits, and an int64 tensor 'target' with shape (16384,) representing the true class indices. The output is a float32 scalar 'output' representing the mean loss. For each sample, compute the softmax of the prediction vector, extract the log probability of the target class, negate it, sum these values across all samples, and divide by the batch size. The kernel must ensure numerical stability during softmax computation using an online approach and handle concurrent writes to the output with atomic operations.", "level2_prompt": "Task: Cross_Entropy_Loss. The algorithm calculates the average negative log-likelihood of the true class for each sample. For each prediction vector, apply the softmax function to convert logits to probabilities, then take the logarithm of the probability at the target index, negate it, sum these values over all samples, and divide by the batch size.", "level3_prompt": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 103, "task_name": "Cross_Entropy_Loss", "task_description": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(65536, 128)"}, {"name": "target", "dtype": "int64", "shape": "(65536,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 65536\n#define DIM 128\n\n\n// cross entropy loss kernel\n// CrossEntropyLoss(x, y) = sum (-log(softmax(x)[i][y[i]])) / N\n__global__ void cross_entropy_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float val = pred[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute loss\n    int target_index = target[idx];\n    float log_softmax = pred[idx * dim + target_index] - old_max_val - logf(sum_exp);\n    atomicAdd(output, -log_softmax);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 65536\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel to compute the cross entropy loss. The inputs are a 2D tensor 'pred' of float32 values with shape (65536, 128) representing predicted logits, and a 1D tensor 'target' of int64 values with shape (65536,) representing ground truth class indices. The output is a scalar float32 tensor of shape (1,) containing the average cross entropy loss. The kernel must compute the loss by applying a numerically stable softmax to each row of 'pred', taking the negative log probability of the target class, summing these values across all rows, and dividing by the batch size (65536).", "level2_prompt": "Compute the average cross entropy loss for a batch of predictions and targets. For each of the 65536 samples, calculate the softmax of the 128-dimensional logit vector. Extract the softmax probability of the target class index, compute its negative logarithm, and sum these values across all samples. Divide the total by the batch size to get the final loss.", "level3_prompt": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 104, "task_name": "Cross_Entropy_Loss", "task_description": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(262144, 128)"}, {"name": "target", "dtype": "int64", "shape": "(262144,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 262144\n#define DIM 128\n\n\n// cross entropy loss kernel\n// CrossEntropyLoss(x, y) = sum (-log(softmax(x)[i][y[i]])) / N\n__global__ void cross_entropy_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float val = pred[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute loss\n    int target_index = target[idx];\n    float log_softmax = pred[idx * dim + target_index] - old_max_val - logf(sum_exp);\n    atomicAdd(output, -log_softmax);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    cross_entropy_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 262144\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.cross_entropy(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for computing the cross entropy loss. The kernel should process a batch of predictions and target labels. Inputs: 'pred' is a float32 tensor with shape (262144, 128) representing predicted logits for each sample and class. 'target' is an int64 tensor with shape (262144,) representing the true class index for each sample. Output: 'output' is a float32 tensor with shape (1,) containing the average cross entropy loss across all samples. The kernel must compute softmax values for each sample using numerically stable methods, calculate the negative log likelihood for the target class, accumulate losses atomically, and normalize by batch size.", "level2_prompt": "Compute cross entropy loss for classification tasks. For each sample in the batch: calculate softmax probabilities from logits using maximum-based normalization for numerical stability, compute the negative log probability of the target class, and accumulate these values. Finally, average the accumulated loss over all samples to produce a single scalar output.", "level3_prompt": "Compute the Cross_Entropy_Loss kernel on GPU using CUDA."}
{"id": 105, "task_name": "ELU", "task_description": "Compute the ELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define ELU_ALPHA 1.0f\n\n// ELU(x) = x (x > 0), alpha * (exp(x) - 1) (x <= 0)\n__global__ void elu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : ELU_ALPHA * (expf(x) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    elu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.elu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the ELU activation function kernel. The kernel should take a 2D input tensor of shape (16, 1024) with float32 values and produce a 1D output tensor of 16384 float32 elements. For each element in the input, if the value is positive, output the value unchanged; if the value is non-positive, output alpha * (exp(value) - 1) where alpha is 1.0. The kernel must process all elements independently.", "level2_prompt": "Apply the ELU activation function element-wise. For each input value x, compute: output = x if x > 0, or output = 1.0 * (exp(x) - 1) if x ≤ 0. Input is a tensor of 16384 float32 elements.", "level3_prompt": "Compute the ELU kernel on GPU using CUDA."}
{"id": 106, "task_name": "ELU", "task_description": "Compute the ELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define ELU_ALPHA 1.0f\n\n// ELU(x) = x (x > 0), alpha * (exp(x) - 1) (x <= 0)\n__global__ void elu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : ELU_ALPHA * (expf(x) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    elu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.elu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the ELU activation function kernel. The input is a 2D tensor of shape (16, 4096) with float32 data type. The output must be a tensor of the same shape and data type. For each element in the input, if the element is positive, the output element is the same as the input. For elements that are less than or equal to zero, the output element is 1.0 multiplied by (the exponential of the input element minus 1). The kernel must perform this operation element-wise and independently for each element.", "level2_prompt": "ELU: For each element x, compute x if x > 0, otherwise compute 1.0 * (exp(x) - 1).", "level3_prompt": "Compute the ELU activation function."}
{"id": 107, "task_name": "ELU", "task_description": "Compute the ELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define ELU_ALPHA 1.0f\n\n// ELU(x) = x (x > 0), alpha * (exp(x) - 1) (x <= 0)\n__global__ void elu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : ELU_ALPHA * (expf(x) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    elu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.elu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the ELU activation function on a GPU using CUDA. The input is a 16x16384 tensor of 32-bit floats. For each element in the input tensor, if the value is greater than zero, output the same value; otherwise, output 1.0 multiplied by (exponential of the value minus 1). The output tensor must have the same shape and data type as the input. The kernel must be implemented for GPU execution.", "level2_prompt": "Apply the Exponential Linear Unit (ELU) function element-wise to a tensor. For each element x: if x > 0, output x; else output 1.0 × (eˣ - 1).", "level3_prompt": "Compute the ELU kernel on GPU using CUDA."}
{"id": 108, "task_name": "ELU", "task_description": "Compute the ELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define ELU_ALPHA 1.0f\n\n// ELU(x) = x (x > 0), alpha * (exp(x) - 1) (x <= 0)\n__global__ void elu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : ELU_ALPHA * (expf(x) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    elu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.elu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the ELU (Exponential Linear Unit) activation function kernel. The input is a 2D tensor of float32 values with shape (16, 65536). For each element in the input, if the value is greater than 0, output the same value. If the value is less than or equal to 0, output 1.0 multiplied by the exponential of the value minus 1. The output tensor must have the same shape and data type as the input. The operation must be applied element-wise independently.", "level2_prompt": "Compute the ELU activation function element-wise. For each input value x, the output is defined as: x if x > 0, otherwise 1.0 × (exp(x) - 1).", "level3_prompt": "Compute the ELU kernel on the input tensor."}
{"id": 109, "task_name": "ELU", "task_description": "Compute the ELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define ELU_ALPHA 1.0f\n\n// ELU(x) = x (x > 0), alpha * (exp(x) - 1) (x <= 0)\n__global__ void elu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : ELU_ALPHA * (expf(x) - 1.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    elu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.elu(input_tensor, alpha=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: ELU. Apply the Exponential Linear Unit (ELU) activation function element-wise to each value in the input tensor. The input is a 2D tensor of shape (16, 262144) with float32 data type. The output must be a 1D tensor of 4194304 float32 elements. For each element x in the input, if x > 0, output x unchanged; if x ≤ 0, output 1.0 × (e^x - 1). The operation must be performed independently for each element, and the alpha parameter is fixed to 1.0.", "level2_prompt": "Task name: ELU. For each element in the input tensor, compute the output value as follows: if the element is positive, return the element itself; if the element is non-positive, return 1.0 multiplied by the exponential of the element minus one.", "level3_prompt": "Compute the ELU activation function using CUDA."}
{"id": 110, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define GELU_ALPHA 0.7978845608028654f  // sqrt(2/pi)\n#define GELU_BETA 0.044715f\n\n\n// GELU(x) = 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))\n__global__ void gelu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 0.5f * x * (1.0f + tanhf(GELU_ALPHA * (x + GELU_BETA * x * x * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    gelu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.gelu(input_tensor, approximate='tanh')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the GELU activation function on a GPU using CUDA. The input is a 16x1024 float32 tensor. The output must be a 16x1024 float32 tensor where each element is computed as 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3))). The kernel must process elements independently and preserve input shape.", "level2_prompt": "Compute Gaussian Error Linear Unit (GELU) activation element-wise using the approximation: output = 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3))) for each value in the input tensor.", "level3_prompt": "Compute the GELU kernel on GPU using CUDA."}
{"id": 111, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define GELU_ALPHA 0.7978845608028654f  // sqrt(2/pi)\n#define GELU_BETA 0.044715f\n\n\n// GELU(x) = 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))\n__global__ void gelu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 0.5f * x * (1.0f + tanhf(GELU_ALPHA * (x + GELU_BETA * x * x * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    gelu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.gelu(input_tensor, approximate='tanh')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Gaussian Error Linear Unit (GELU) activation function as a CUDA kernel. The kernel should compute the GELU of each element in a 16x4096 input tensor of float32 values. The output must be a float32 tensor of identical dimensions. The GELU function is defined as: 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3))), using the constants sqrt(2/pi) ≈ 0.7978845608028654 and 0.044715. The kernel must process all 65,536 elements independently.", "level2_prompt": "Compute the element-wise Gaussian Error Linear Unit (GELU) transformation. For each element x in the input tensor, apply the formula: 0.5 * x * (1 + tanh(0.7978845608028654 * (x + 0.044715 * x^3))). The input is a 16x4096 float32 tensor, and the output must be a float32 tensor of the same shape.", "level3_prompt": "Compute the GELU kernel on GPU for a 16x4096 float32 tensor."}
{"id": 112, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define GELU_ALPHA 0.7978845608028654f  // sqrt(2/pi)\n#define GELU_BETA 0.044715f\n\n\n// GELU(x) = 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))\n__global__ void gelu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 0.5f * x * (1.0f + tanhf(GELU_ALPHA * (x + GELU_BETA * x * x * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    gelu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.gelu(input_tensor, approximate='tanh')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Gaussian Error Linear Unit (GELU) activation function kernel on GPU. The input is a 2D tensor of shape (16, 16384) with float32 data type. The output must be a tensor of identical shape and data type. For each element x in the input tensor, compute GELU(x) = 0.5 * x * (1 + tanh(α * (x + β * x³))) where α = √(2/π) ≈ 0.7978845608 and β = 0.044715. The kernel must process all elements independently and maintain numerical precision within tolerance limits.", "level2_prompt": "Compute the GELU activation function element-wise. For each input value x, apply the formula: 0.5 * x * (1 + tanh(α * (x + β * x³))) using constants α = √(2/π) and β = 0.044715.", "level3_prompt": "Compute the GELU kernel on GPU using CUDA."}
{"id": 113, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define GELU_ALPHA 0.7978845608028654f  // sqrt(2/pi)\n#define GELU_BETA 0.044715f\n\n\n// GELU(x) = 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))\n__global__ void gelu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 0.5f * x * (1.0f + tanhf(GELU_ALPHA * (x + GELU_BETA * x * x * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    gelu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.gelu(input_tensor, approximate='tanh')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: GELU. Compute the Gaussian Error Linear Unit (GELU) activation function for each element of the input tensor. The input is a 2D tensor of shape (16, 65536) with float32 data type. The output is a tensor of the same shape and data type. The GELU function is defined as: 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3))). The kernel must compute this function independently for every element.", "level2_prompt": "Task: GELU. Compute the GELU activation function for each element of the input tensor. The function is: GELU(x) = 0.5 * x * (1 + tanh(alpha * (x + beta * x^3))), where alpha is sqrt(2/pi) and beta is 0.044715.", "level3_prompt": "Compute the GELU kernel on GPU using CUDA."}
{"id": 114, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define GELU_ALPHA 0.7978845608028654f  // sqrt(2/pi)\n#define GELU_BETA 0.044715f\n\n\n// GELU(x) = 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))\n__global__ void gelu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = 0.5f * x * (1.0f + tanhf(GELU_ALPHA * (x + GELU_BETA * x * x * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    gelu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.gelu(input_tensor, approximate='tanh')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Gaussian Error Linear Unit (GELU) activation function. The kernel should compute the GELU function element-wise on a 2D input tensor of shape (16, 262144) with float32 data type. The output tensor must have the same shape and data type as the input. The GELU function is defined as: GELU(x) = 0.5 * x * (1 + tanh(α * (x + β * x³))), where α is sqrt(2/π) ≈ 0.7978845608028654 and β is 0.044715. The kernel must process each element independently and maintain numerical precision within an absolute tolerance of 1e-5 compared to a reference implementation.", "level2_prompt": "Implement a CUDA kernel for the GELU activation function. Apply the element-wise transformation GELU(x) = 0.5 * x * (1 + tanh(α * (x + β * x³))) where α = sqrt(2/π) and β = 0.044715. The input is a float32 tensor of shape (16, 262144), and the output must match this shape and data type.", "level3_prompt": "Compute the GELU kernel on GPU using CUDA."}
{"id": 115, "task_name": "Matrix_Multiplication", "task_description": "Compute the Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define K 4096\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 1024;\n\n__global__ void Matrix_Multiplication_Kernel(const float* A, const float* B, float* C, int M) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        for (int i = 0; i < K; i++) {\n            sum += A[row * K + i] * B[i * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = M * K;\n    size_t size_B = K * N;\n    size_t size_C = M * N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Matrix_Multiplication_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Write output\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nK = 4096\nN = 2048\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A @ B\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 2048\n    M = 1024\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for matrix multiplication. The kernel multiplies two matrices: matA (1024x4096, float32) and matB (4096x2048, float32), producing output matrix matC_out (1024x2048, float32). Each element of matC_out must be the dot product of the corresponding row from matA and column from matB. Ensure the kernel only processes valid indices within matrix dimensions.", "level2_prompt": "Perform matrix multiplication where matrix A (1024x4096) is multiplied by matrix B (4096x2048) to produce output matrix C (1024x2048). Each element C[i][j] is computed as the sum of A[i][k] * B[k][j] for k from 0 to 4095.", "level3_prompt": "Compute the matrix multiplication kernel on GPU using CUDA."}
{"id": 116, "task_name": "Matrix_Multiplication", "task_description": "Compute the Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define K 4096\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 4096;\n\n__global__ void Matrix_Multiplication_Kernel(const float* A, const float* B, float* C, int M) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        for (int i = 0; i < K; i++) {\n            sum += A[row * K + i] * B[i * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = M * K;\n    size_t size_B = K * N;\n    size_t size_C = M * N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Matrix_Multiplication_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Write output\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nK = 4096\nN = 2048\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A @ B\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 2048\n    M = 4096\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for matrix multiplication. The inputs are two matrices: matA of shape 4096x4096 and matB of shape 4096x2048, both with float32 elements. The output is a matrix matC_out of shape 4096x2048 with float32 elements. Each element (i, j) of matC_out must be computed as the dot product of the i-th row of matA and the j-th column of matB, summing over 4096 multiplications. The kernel must respect the matrix dimensions and only compute for valid indices (i in [0, 4095] and j in [0, 2047]).", "level2_prompt": "Multiply a 4096x4096 matrix by a 4096x2048 matrix to produce a 4096x2048 matrix. Each element of the output matrix is the sum of element-wise multiplications between a row of the first matrix and a column of the second matrix, over 4096 multiplications per element.", "level3_prompt": "Compute the Matrix_Multiplication kernel on GPU using CUDA."}
{"id": 117, "task_name": "Matrix_Multiplication", "task_description": "Compute the Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define K 4096\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void Matrix_Multiplication_Kernel(const float* A, const float* B, float* C, int M) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        for (int i = 0; i < K; i++) {\n            sum += A[row * K + i] * B[i * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = M * K;\n    size_t size_B = K * N;\n    size_t size_C = M * N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Matrix_Multiplication_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Write output\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nK = 4096\nN = 2048\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A @ B\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 2048\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Matrix_Multiplication: Multiply two input matrices, matA (16384 rows by 4096 columns, float32) and matB (4096 rows by 2048 columns, float32), to produce an output matrix matC_out (16384 rows by 2048 columns, float32). Each element in the output matrix at row i and column j is computed as the dot product of the i-th row of matA and the j-th column of matB. The kernel must respect the bounds of the output matrix and only compute for valid indices.", "level2_prompt": "Matrix_Multiplication: For each element at position (i, j) in the output matrix, compute the sum of the products of corresponding elements from the i-th row of the first matrix and the j-th column of the second matrix.", "level3_prompt": "Multiply two matrices to produce an output matrix."}
{"id": 118, "task_name": "Matrix_Multiplication", "task_description": "Compute the Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(65536, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define K 4096\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 65536;\n\n__global__ void Matrix_Multiplication_Kernel(const float* A, const float* B, float* C, int M) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        for (int i = 0; i < K; i++) {\n            sum += A[row * K + i] * B[i * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = M * K;\n    size_t size_B = K * N;\n    size_t size_C = M * N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Matrix_Multiplication_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Write output\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nK = 4096\nN = 2048\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A @ B\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 2048\n    M = 65536\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Matrix_Multiplication. Multiply two matrices matA (shape: 65536x4096) and matB (shape: 4096x2048), both float32, to produce output matrix matC_out (shape: 65536x2048) where each element C[i][j] is the dot product of row i from matA and column j from matB. The kernel must compute all valid output elements where 0 ≤ i < 65536 and 0 ≤ j < 2048, with no out-of-bounds access.", "level2_prompt": "Task: Matrix_Multiplication. For each element (i,j) in the output matrix, compute the sum of element-wise products between the i-th row of the first matrix and the j-th column of the second matrix.", "level3_prompt": "Matrix Multiplication"}
{"id": 119, "task_name": "Matrix_Multiplication", "task_description": "Compute the Matrix_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(262144, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define K 4096\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 262144;\n\n__global__ void Matrix_Multiplication_Kernel(const float* A, const float* B, float* C, int M) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float sum = 0.0f;\n        for (int i = 0; i < K; i++) {\n            sum += A[row * K + i] * B[i * N + col];\n        }\n        C[row * N + col] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = M * K;\n    size_t size_B = K * N;\n    size_t size_C = M * N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Matrix_Multiplication_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Write output\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nK = 4096\nN = 2048\n\nseed = 42\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A @ B\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 2048\n    M = 262144\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a matrix multiplication kernel for multiplying two matrices. The first input matrix, matA, is a float32 tensor with dimensions 262144 by 4096. The second input matrix, matB, is a float32 tensor with dimensions 4096 by 2048. The output matrix, matC_out, should be a float32 tensor with dimensions 262144 by 2048. Each element of the output matrix must be the dot product of the corresponding row from matA and column from matB. The kernel must handle boundary conditions to avoid out-of-bounds memory accesses and respect the specified matrix dimensions.", "level2_prompt": "Perform matrix multiplication where the output matrix is computed as the product of an M x K matrix and a K x N matrix. For each element (i, j) in the M x N output matrix, calculate the sum of the products of corresponding elements from the i-th row of the first matrix and the j-th column of the second matrix, summing over K elements.", "level3_prompt": "Compute the matrix multiplication of two given matrices."}
{"id": 120, "task_name": "Hard_Shrink", "task_description": "Compute the Hard_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define HARD_SHRINK_LAMBDA 0.5f\n\n// HardShrink(x) = x if |x| > lambd, else 0\n__global__ void hardshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > HARD_SHRINK_LAMBDA || x < -HARD_SHRINK_LAMBDA) ? x : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Shrink kernel for GPU computation. The kernel should apply an element-wise operation to an input tensor of shape (16, 1024) with float32 values. For each element, if its absolute value exceeds 0.5, preserve the original value; otherwise, set it to zero. The output tensor must match the input's shape and data type. The operation must be applied independently to each element without altering other data.", "level2_prompt": "Compute the Hard_Shrink function mathematically: for each element x in the input tensor, output = x if |x| > 0.5, else output = 0. The operation is applied independently to all elements of a 16x1024 float32 tensor.", "level3_prompt": "Compute the Hard_Shrink kernel on GPU using CUDA."}
{"id": 121, "task_name": "Hard_Shrink", "task_description": "Compute the Hard_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define HARD_SHRINK_LAMBDA 0.5f\n\n// HardShrink(x) = x if |x| > lambd, else 0\n__global__ void hardshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > HARD_SHRINK_LAMBDA || x < -HARD_SHRINK_LAMBDA) ? x : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Shrink. Implement a CUDA kernel that applies the Hard Shrink function to a 16 by 4096 float32 input tensor. The Hard Shrink function is defined as: for each element, if the absolute value is greater than 0.5, the output is the element itself; otherwise, the output is 0. The output tensor must have the same shape and data type as the input. The kernel must process each element independently.", "level2_prompt": "Hard_Shrink: For each element in the input tensor, output the element if its absolute value is greater than 0.5; otherwise output 0.", "level3_prompt": "Compute the Hard_Shrink kernel on GPU using CUDA."}
{"id": 122, "task_name": "Hard_Shrink", "task_description": "Compute the Hard_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define HARD_SHRINK_LAMBDA 0.5f\n\n// HardShrink(x) = x if |x| > lambd, else 0\n__global__ void hardshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > HARD_SHRINK_LAMBDA || x < -HARD_SHRINK_LAMBDA) ? x : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Shrink kernel for GPU computation. The kernel should process a 2D input tensor of shape (16, 16384) with float32 data type. For each element in the input tensor: if the absolute value of the element is greater than 0.5, output the element unchanged; otherwise, output zero. The output tensor must have identical shape and data type to the input. All elements must be processed independently with no data dependencies.", "level2_prompt": "Compute the Hard_Shrink function on GPU. For each element in a 2D float32 tensor of dimensions 16x16384: output the element if |x| > 0.5, otherwise output 0. The output tensor dimensions must match the input.", "level3_prompt": "Compute the Hard_Shrink kernel on GPU using CUDA."}
{"id": 123, "task_name": "Hard_Shrink", "task_description": "Compute the Hard_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define HARD_SHRINK_LAMBDA 0.5f\n\n// HardShrink(x) = x if |x| > lambd, else 0\n__global__ void hardshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > HARD_SHRINK_LAMBDA || x < -HARD_SHRINK_LAMBDA) ? x : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Shrink kernel to apply a thresholding function on a 16x65536 float32 input tensor. The kernel must output a float32 tensor of identical shape where each element equals the input value if its absolute value exceeds 0.5, otherwise output zero. The computation must be element-wise independent and preserve the input tensor's dimensions.", "level2_prompt": "For each element in a 16x65536 tensor, output the element if |x| > 0.5, otherwise output zero. The operation must be applied independently to all elements.", "level3_prompt": "Compute the Hard_Shrink kernel for a 16x65536 float32 tensor."}
{"id": 124, "task_name": "Hard_Shrink", "task_description": "Compute the Hard_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define HARD_SHRINK_LAMBDA 0.5f\n\n// HardShrink(x) = x if |x| > lambd, else 0\n__global__ void hardshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > HARD_SHRINK_LAMBDA || x < -HARD_SHRINK_LAMBDA) ? x : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Shrink. Implement a CUDA kernel that applies the Hard Shrink function to each element of a 16x262144 float32 input tensor. The function outputs the element's value if its absolute value exceeds 0.5, otherwise outputs 0. The output tensor must have identical shape and data type to the input. Each element must be processed independently.", "level2_prompt": "Task: Hard_Shrink. For each element in a 16x262144 float32 tensor, output the element if |x| > 0.5, else output 0.", "level3_prompt": "Compute the Hard_Shrink kernel on GPU using CUDA."}
{"id": 125, "task_name": "Hard_Sigmoid", "task_description": "Compute the Hard_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n// HardSigmoid(x) = 0 (x <= -3), 1 (x >= 3), x/6 + 0.5 (otherwise)\n__global__ void hardsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : (x >= 3.0f) ? 1.0f : (x / 6.0f + 0.5f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Sigmoid activation function on a GPU. The input is a 2D tensor of 16 rows and 1024 columns with float32 data type. The output is a tensor of the same shape and data type. For each element in the input tensor, compute the output element as follows: if the input element is less than or equal to -3.0, set the output to 0.0; if the input element is greater than or equal to 3.0, set the output to 1.0; otherwise, set the output to the input element divided by 6.0 plus 0.5. The computation must be performed independently for each element.", "level2_prompt": "Apply the Hard Sigmoid function element-wise. The function is defined by three cases: if the input value is less than or equal to -3.0, output 0.0; if the input value is greater than or equal to 3.0, output 1.0; otherwise, output the input value divided by 6.0 plus 0.5.", "level3_prompt": "Compute the Hard_Sigmoid kernel on GPU using CUDA."}
{"id": 126, "task_name": "Hard_Sigmoid", "task_description": "Compute the Hard_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n// HardSigmoid(x) = 0 (x <= -3), 1 (x >= 3), x/6 + 0.5 (otherwise)\n__global__ void hardsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : (x >= 3.0f) ? 1.0f : (x / 6.0f + 0.5f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Sigmoid. Implement a CUDA kernel that applies the Hard Sigmoid function element-wise to a 16x4096 float32 input tensor, producing an identically shaped output tensor. The function must follow these rules: for each element x, output 0.0 if x ≤ -3.0; output 1.0 if x ≥ 3.0; otherwise output x/6.0 + 0.5. The kernel must process all elements independently.", "level2_prompt": "Hard_Sigmoid: Apply a piecewise function f(x) = { 0 if x ≤ -3, 1 if x ≥ 3, x/6 + 0.5 otherwise } to each element of a 16x4096 tensor.", "level3_prompt": "Compute the Hard_Sigmoid function element-wise."}
{"id": 127, "task_name": "Hard_Sigmoid", "task_description": "Compute the Hard_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n// HardSigmoid(x) = 0 (x <= -3), 1 (x >= 3), x/6 + 0.5 (otherwise)\n__global__ void hardsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : (x >= 3.0f) ? 1.0f : (x / 6.0f + 0.5f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Sigmoid kernel. The kernel should compute the hard sigmoid function element-wise on a 2D input tensor of shape (16, 16384) with float32 values. For each element: output 0.0 if input ≤ -3.0, output 1.0 if input ≥ 3.0, and otherwise compute (input / 6.0) + 0.5. The output tensor must have identical shape and data type as the input. All elements must be processed independently.", "level2_prompt": "Compute the hard sigmoid function for each element in a 2D float32 tensor. Apply piecewise logic: 0.0 for inputs ≤ -3.0, 1.0 for inputs ≥ 3.0, and linear interpolation (x/6 + 0.5) otherwise.", "level3_prompt": "Compute the Hard_Sigmoid kernel on GPU using CUDA."}
{"id": 128, "task_name": "Hard_Sigmoid", "task_description": "Compute the Hard_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n// HardSigmoid(x) = 0 (x <= -3), 1 (x >= 3), x/6 + 0.5 (otherwise)\n__global__ void hardsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : (x >= 3.0f) ? 1.0f : (x / 6.0f + 0.5f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Sigmoid kernel for GPU computation using CUDA. The kernel must compute a piecewise function where for each element in the input tensor: if the value is less than or equal to -3.0, output 0.0; if the value is greater than or equal to 3.0, output 1.0; otherwise, output the linear transformation (value / 6.0) + 0.5. The input is a 2D tensor of shape (16, 65536) with float32 data type, and the output must be a tensor of identical shape and data type. The kernel must process all elements independently and maintain numerical precision.", "level2_prompt": "Compute the Hard_Sigmoid function element-wise. For each input value x: if x ≤ -3, return 0; if x ≥ 3, return 1; otherwise, return (x / 6) + 0.5. Apply this transformation to every element in a 16 × 65536 float32 tensor.", "level3_prompt": "Compute the Hard_Sigmoid kernel on GPU using CUDA."}
{"id": 129, "task_name": "Hard_Sigmoid", "task_description": "Compute the Hard_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n// HardSigmoid(x) = 0 (x <= -3), 1 (x >= 3), x/6 + 0.5 (otherwise)\n__global__ void hardsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : (x >= 3.0f) ? 1.0f : (x / 6.0f + 0.5f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Sigmoid. Given an input tensor of shape (16, 262144) with float32 data type, compute an output tensor of the same shape and data type by applying the Hard Sigmoid function element-wise. The Hard Sigmoid function is defined as: for each element x, if x <= -3.0, set output to 0.0; if x >= 3.0, set output to 1.0; otherwise, set output to x/6 + 0.5. The kernel must process each element independently.", "level2_prompt": "Task: Hard_Sigmoid. Apply the Hard Sigmoid function to each element of the input tensor. The function is: if the element is less than or equal to -3.0, output 0.0; if the element is greater than or equal to 3.0, output 1.0; otherwise, output the element divided by 6 plus 0.5.", "level3_prompt": "Compute the Hard_Sigmoid kernel on GPU using CUDA."}
{"id": 130, "task_name": "Hard_Swish", "task_description": "Compute the Hard_Swish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n// HardSwish(x) = 0 (x <= -3), x (x >= 3), x * (x + 3) / 6 (-3 < x < 3)\n__global__ void hardswish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : ((x >= 3.0f) ? x : (x * (x + 3.0f) / 6.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardswish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.hardswish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Swish kernel for a 2D input tensor of shape (16, 1024) with float32 data type. The kernel should compute the Hard Swish activation function element-wise: for each input value x, output 0 if x ≤ -3, output x if x ≥ 3, and output x*(x+3)/6 for values between -3 and 3. The output tensor must have identical shape and data type as the input.", "level2_prompt": "Apply the Hard Swish function element-wise: f(x) = 0 for x ≤ -3, f(x) = x for x ≥ 3, and f(x) = x*(x+3)/6 for -3 < x < 3.", "level3_prompt": "Compute the Hard_Swish kernel."}
{"id": 131, "task_name": "Hard_Swish", "task_description": "Compute the Hard_Swish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n// HardSwish(x) = 0 (x <= -3), x (x >= 3), x * (x + 3) / 6 (-3 < x < 3)\n__global__ void hardswish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : ((x >= 3.0f) ? x : (x * (x + 3.0f) / 6.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardswish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.hardswish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Swish function as a CUDA kernel. The function computes an element-wise transformation where each output value depends on the input value: if the input value is less than or equal to -3, the output is 0; if the input value is greater than or equal to 3, the output equals the input value; otherwise, for input values between -3 and 3, the output is computed as the input multiplied by the sum of the input and 3, then divided by 6. The input is a 16x4096 tensor of float32 values, and the output must be a tensor of the same shape and data type. Each element must be processed independently.", "level2_prompt": "Compute the Hard_Swish activation function element-wise. The function is defined piecewise: for x ≤ -3, output 0; for x ≥ 3, output x; for -3 < x < 3, output x*(x+3)/6. The input is a two-dimensional float32 tensor with dimensions 16x4096, and the output must match these dimensions.", "level3_prompt": "Compute the Hard_Swish kernel on GPU using CUDA."}
{"id": 132, "task_name": "Hard_Swish", "task_description": "Compute the Hard_Swish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n// HardSwish(x) = 0 (x <= -3), x (x >= 3), x * (x + 3) / 6 (-3 < x < 3)\n__global__ void hardswish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : ((x >= 3.0f) ? x : (x * (x + 3.0f) / 6.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardswish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.hardswish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Swish kernel to compute the Hard Swish activation function element-wise on an input tensor. The input is a 16x16384 tensor of float32 values. The output must be a tensor of the same shape and data type. For each element x, the function is defined as: if x <= -3, output is 0; if x >= 3, output is x; otherwise, output is x multiplied by (x + 3) divided by 6. The kernel must process all elements independently and handle the entire input size efficiently.", "level2_prompt": "The Hard_Swish task requires applying a piecewise function to each element of a tensor. Mathematically, for an element x, compute the output as: 0 if x <= -3, x if x >= 3, and (x * (x + 3)) / 6 if -3 < x < 3.", "level3_prompt": "Compute the Hard Swish activation function."}
{"id": 133, "task_name": "Hard_Swish", "task_description": "Compute the Hard_Swish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n// HardSwish(x) = 0 (x <= -3), x (x >= 3), x * (x + 3) / 6 (-3 < x < 3)\n__global__ void hardswish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : ((x >= 3.0f) ? x : (x * (x + 3.0f) / 6.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardswish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.hardswish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Swish activation function for a 2D input tensor of shape (16, 65536) with float32 data type. The output tensor must have the same shape and data type. For each element in the input, apply the Hard Swish function: if the element is less than or equal to -3, output 0; if the element is greater than or equal to 3, output the element itself; for elements between -3 and 3, output the element multiplied by (element + 3) divided by 6. The computation must be performed independently for each element without altering the input.", "level2_prompt": "Compute the Hard_Swish activation element-wise. The function outputs 0 for inputs <= -3, the input value for inputs >= 3, and (input * (input + 3) / 6) for inputs between -3 and 3.", "level3_prompt": "Compute the Hard Swish activation function."}
{"id": 134, "task_name": "Hard_Swish", "task_description": "Compute the Hard_Swish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n// HardSwish(x) = 0 (x <= -3), x (x >= 3), x * (x + 3) / 6 (-3 < x < 3)\n__global__ void hardswish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x <= -3.0f) ? 0.0f : ((x >= 3.0f) ? x : (x * (x + 3.0f) / 6.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardswish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.hardswish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Swish. Implement a CUDA kernel that computes the Hard Swish activation function element-wise on a 2D input tensor of shape (16, 262144) with float32 data type. The output tensor must have the same shape and data type. The Hard Swish function is defined as: for each element x, if x <= -3.0, output 0.0; if x >= 3.0, output x; otherwise, output x * (x + 3.0) / 6.0.", "level2_prompt": "Task: Hard_Swish. Apply the Hard Swish activation function to each element of a tensor. The function outputs 0 for inputs <= -3, the input itself for inputs >= 3, and for inputs between -3 and 3 it outputs (input * (input + 3) / 6).", "level3_prompt": "Compute the Hard_Swish kernel on GPU using CUDA."}
{"id": 135, "task_name": "Hard_Tanh", "task_description": "Compute the Hard_Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n#define HARDTANH_MIN -1.0f\n#define HARDTANH_MAX 1.0f\n\n\n// HardTanh(x) = min(max(x, -1), 1)\n__global__ void hardtanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, HARDTANH_MIN), HARDTANH_MAX);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardtanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardtanh(input_tensor, min_val=-1.0, max_val=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Hard_Tanh task. The kernel should apply a hard tanh activation function element-wise to an input tensor of shape (16, 1024) with float32 data type. For each element, if the value is less than -1, it should be set to -1; if greater than 1, it should be set to 1; otherwise, it should remain unchanged. The output tensor must have the same shape (16, 1024) and float32 data type as the input. The kernel must process all 16,384 elements independently and efficiently.", "level2_prompt": "Implement the Hard_Tanh activation function as a CUDA kernel. For each element in a 16x1024 float32 input tensor, compute: output = min(max(x, -1), 1). The operation must be applied element-wise to produce an output tensor of identical shape and data type.", "level3_prompt": "Compute the Hard_Tanh activation function element-wise for a float32 input tensor."}
{"id": 136, "task_name": "Hard_Tanh", "task_description": "Compute the Hard_Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n#define HARDTANH_MIN -1.0f\n#define HARDTANH_MAX 1.0f\n\n\n// HardTanh(x) = min(max(x, -1), 1)\n__global__ void hardtanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, HARDTANH_MIN), HARDTANH_MAX);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardtanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardtanh(input_tensor, min_val=-1.0, max_val=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'Hard_Tanh' that applies the hard tanh activation function to each element of an input tensor. The input is a 2D tensor of shape (16, 4096) with float32 data type. The output must be a tensor of identical shape and data type. For each element, the kernel must clamp values below -1.0 to -1.0 and values above 1.0 to 1.0, leaving values between -1.0 and 1.0 unchanged. The kernel must process all elements independently and maintain numerical precision.", "level2_prompt": "Create a kernel called 'Hard_Tanh' that performs element-wise clamping on a 16x4096 float32 tensor. For each input element x, compute min(max(x, -1.0), 1.0). The output should match the input dimensions.", "level3_prompt": "Compute the Hard_Tanh kernel on GPU using CUDA."}
{"id": 137, "task_name": "Hard_Tanh", "task_description": "Compute the Hard_Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n#define HARDTANH_MIN -1.0f\n#define HARDTANH_MAX 1.0f\n\n\n// HardTanh(x) = min(max(x, -1), 1)\n__global__ void hardtanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, HARDTANH_MIN), HARDTANH_MAX);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardtanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardtanh(input_tensor, min_val=-1.0, max_val=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Hard_Tanh function for a 2D input tensor of shape (16, 16384) with float32 data type. The Hard_Tanh function is defined as: for each element, if the value is less than -1.0, set it to -1.0; if the value is greater than 1.0, set it to 1.0; otherwise, leave the value unchanged. The output tensor must have the same shape and data type as the input.", "level2_prompt": "Apply the element-wise function: output = min(max(input, -1.0), 1.0).", "level3_prompt": "Compute the Hard_Tanh kernel on GPU using CUDA."}
{"id": 138, "task_name": "Hard_Tanh", "task_description": "Compute the Hard_Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n#define HARDTANH_MIN -1.0f\n#define HARDTANH_MAX 1.0f\n\n\n// HardTanh(x) = min(max(x, -1), 1)\n__global__ void hardtanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, HARDTANH_MIN), HARDTANH_MAX);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardtanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardtanh(input_tensor, min_val=-1.0, max_val=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Tanh. Apply the Hard Tanh activation function element-wise to an input tensor of shape (16, 65536) and dtype float32. The output is a tensor of shape (1048576,) and dtype float32. The function clamps each input value to the range [-1.0, 1.0]: if the value is less than -1.0, set it to -1.0; if greater than 1.0, set it to 1.0; otherwise, leave it unchanged. Each element is processed independently.", "level2_prompt": "Task: Hard_Tanh. For each element x in the input, compute y = min(max(x, -1.0), 1.0).", "level3_prompt": "Element-wise Hard_Tanh activation."}
{"id": 139, "task_name": "Hard_Tanh", "task_description": "Compute the Hard_Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n#define HARDTANH_MIN -1.0f\n#define HARDTANH_MAX 1.0f\n\n\n// HardTanh(x) = min(max(x, -1), 1)\n__global__ void hardtanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, HARDTANH_MIN), HARDTANH_MAX);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    hardtanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.hardtanh(input_tensor, min_val=-1.0, max_val=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Hard_Tanh. Implement a CUDA kernel that computes the HardTanh activation function element-wise on a 2D input tensor of shape (16, 262144) with float32 data. For each element, clamp values below -1.0 to -1.0 and values above 1.0 to 1.0, leaving other values unchanged. The output tensor must match the input shape exactly.", "level2_prompt": "Task: Hard_Tanh. Apply an element-wise clipping function to each value in a 16x262144 float32 tensor: values less than -1 become -1, values greater than 1 become 1, and values between -1 and 1 remain unchanged.", "level3_prompt": "Compute the Hard_Tanh kernel on GPU using CUDA."}
{"id": 140, "task_name": "Huber_Loss", "task_description": "Compute the Huber_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}, {"name": "target", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n#define HUBER_DELTA 2.0f\n\n\n// Huber Loss Kernel\n// huber loss (x, y) = if |x - y| < delta: 0.5 * (x - y)^2; else: delta * (|x - y| - 0.5 * delta)\n__global__ void huber_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float y = target[idx];\n        float diff = x - y;\n        if (fabs(diff) < HUBER_DELTA) {\n            atomicAdd(output, 0.5f * diff * diff);\n        } else {\n            atomicAdd(output, HUBER_DELTA * (fabs(diff) - 0.5f * HUBER_DELTA));\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    huber_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.huber_loss(input_tensor, target_tensor, reduction='mean', delta=2.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Huber_Loss kernel. The kernel computes the Huber loss between two input tensors: 'input' and 'target', both of shape (16, 1024) and float32 data type. The output is a single float32 value representing the mean loss. The Huber loss for each element is defined as: if the absolute difference between input and target is less than 2.0, use 0.5 * (difference)^2; otherwise, use 2.0 * (absolute difference - 1.0). The kernel must compute the sum of losses across all elements and then divide by the total number of elements (16384) to obtain the mean loss.", "level2_prompt": "Implement the Huber_Loss computation. For each corresponding element in two identically shaped input tensors, calculate the loss as: when |x - y| < 2.0, loss = 0.5*(x-y)^2; otherwise, loss = 2.0*(|x-y| - 1.0). Sum all element losses and divide by the total number of elements to produce a single scalar output.", "level3_prompt": "Compute the Huber_Loss kernel on GPU using CUDA."}
{"id": 141, "task_name": "Huber_Loss", "task_description": "Compute the Huber_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}, {"name": "target", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n#define HUBER_DELTA 2.0f\n\n\n// Huber Loss Kernel\n// huber loss (x, y) = if |x - y| < delta: 0.5 * (x - y)^2; else: delta * (|x - y| - 0.5 * delta)\n__global__ void huber_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float y = target[idx];\n        float diff = x - y;\n        if (fabs(diff) < HUBER_DELTA) {\n            atomicAdd(output, 0.5f * diff * diff);\n        } else {\n            atomicAdd(output, HUBER_DELTA * (fabs(diff) - 0.5f * HUBER_DELTA));\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    huber_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.huber_loss(input_tensor, target_tensor, reduction='mean', delta=2.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Huber_Loss. Compute the mean Huber loss between two input tensors. Inputs: 'input' and 'target', both float32 tensors of shape (16, 4096). Output: a single float32 scalar representing the mean loss. For each element, if |input - target| < 2.0, compute 0.5 * (input - target)^2; otherwise, compute 2.0 * (|input - target| - 1.0). Sum all element-wise losses and divide by total elements (16*4096) to get the mean.", "level2_prompt": "Task: Huber_Loss. Calculate the mean of element-wise Huber losses between two identically shaped tensors. For each position (i,j), loss = 0.5*(input[i][j] - target[i][j])^2 if the absolute difference is less than 2.0; otherwise loss = 2.0*(|input[i][j] - target[i][j]| - 1.0). The final output is the average of all computed losses.", "level3_prompt": "Compute the Huber_Loss kernel on GPU using CUDA."}
{"id": 142, "task_name": "Huber_Loss", "task_description": "Compute the Huber_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}, {"name": "target", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n#define HUBER_DELTA 2.0f\n\n\n// Huber Loss Kernel\n// huber loss (x, y) = if |x - y| < delta: 0.5 * (x - y)^2; else: delta * (|x - y| - 0.5 * delta)\n__global__ void huber_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float y = target[idx];\n        float diff = x - y;\n        if (fabs(diff) < HUBER_DELTA) {\n            atomicAdd(output, 0.5f * diff * diff);\n        } else {\n            atomicAdd(output, HUBER_DELTA * (fabs(diff) - 0.5f * HUBER_DELTA));\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    huber_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.huber_loss(input_tensor, target_tensor, reduction='mean', delta=2.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Huber_Loss. Compute the Huber loss between two input tensors and output a single scalar value representing the mean loss. Inputs are two float32 tensors named 'input' and 'target', both with shape (16, 16384). Output is a float32 tensor named 'output' with shape (1,). The Huber loss function uses a delta value of 2.0: for each element, if |input - target| < 2.0, compute 0.5 * (input - target)^2; else compute 2.0 * (|input - target| - 1.0). The kernel must accumulate all element-wise losses and then compute the mean by dividing the sum by the total number of elements (16 * 16384).", "level2_prompt": "Task: Huber_Loss. For each element in two identically-shaped tensors, compute the Huber loss using delta=2.0: if absolute difference < 2.0, loss = 0.5 * difference squared; else loss = 2.0 * (absolute difference - 1.0). Sum all element-wise losses across both tensors, then compute the mean loss by dividing the sum by the total number of elements.", "level3_prompt": "Compute the Huber_Loss kernel on GPU using CUDA."}
{"id": 143, "task_name": "Huber_Loss", "task_description": "Compute the Huber_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}, {"name": "target", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n#define HUBER_DELTA 2.0f\n\n\n// Huber Loss Kernel\n// huber loss (x, y) = if |x - y| < delta: 0.5 * (x - y)^2; else: delta * (|x - y| - 0.5 * delta)\n__global__ void huber_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float y = target[idx];\n        float diff = x - y;\n        if (fabs(diff) < HUBER_DELTA) {\n            atomicAdd(output, 0.5f * diff * diff);\n        } else {\n            atomicAdd(output, HUBER_DELTA * (fabs(diff) - 0.5f * HUBER_DELTA));\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    huber_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.huber_loss(input_tensor, target_tensor, reduction='mean', delta=2.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Huber_Loss task. The kernel computes the Huber loss between two input tensors 'input' and 'target', both of shape (16, 65536) and dtype float32. The output is a single scalar value of dtype float32. For each element pair (x, y) in the input and target tensors, the loss is calculated as: if |x - y| < 2.0, use 0.5 * (x - y)^2; otherwise, use 2.0 * (|x - y| - 1.0). The kernel must atomically accumulate the loss values across all elements and output the sum. After kernel execution, the host code will compute the mean by dividing the sum by the total number of elements (16 * 65536).", "level2_prompt": "Compute the Huber loss between two float32 tensors of shape (16, 65536). For each element pair (x, y), calculate the loss as: if |x - y| < 2.0, loss = 0.5 * (x - y)^2; else loss = 2.0 * (|x - y| - 1.0). Sum all individual losses and output the total as a single scalar.", "level3_prompt": "Compute the Huber_Loss kernel on GPU using CUDA."}
{"id": 144, "task_name": "Huber_Loss", "task_description": "Compute the Huber_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}, {"name": "target", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n#define HUBER_DELTA 2.0f\n\n\n// Huber Loss Kernel\n// huber loss (x, y) = if |x - y| < delta: 0.5 * (x - y)^2; else: delta * (|x - y| - 0.5 * delta)\n__global__ void huber_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float y = target[idx];\n        float diff = x - y;\n        if (fabs(diff) < HUBER_DELTA) {\n            atomicAdd(output, 0.5f * diff * diff);\n        } else {\n            atomicAdd(output, HUBER_DELTA * (fabs(diff) - 0.5f * HUBER_DELTA));\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    huber_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.huber_loss(input_tensor, target_tensor, reduction='mean', delta=2.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Huber_Loss kernel to compute the mean Huber loss between two input tensors. The inputs are two float32 tensors named 'input' and 'target', each with shape (16, 262144). The output is a single float32 value in a tensor of shape (1,). For each element pair (x, y) in the input and target tensors: if |x - y| < 2.0, add 0.5 * (x - y)^2 to the total loss; otherwise, add 2.0 * (|x - y| - 1.0). Accumulate losses atomically across all elements, then divide the total loss by the number of elements (16 * 262144) to compute the mean.", "level2_prompt": "Compute the mean Huber loss between two tensors. For each corresponding element pair (x, y): if |x - y| < 2.0, use 0.5 * (x - y)^2 as the loss contribution; otherwise, use 2.0 * (|x - y| - 1.0). Sum these contributions across all elements and divide by the total number of elements to get the mean loss.", "level3_prompt": "Compute the Huber_Loss kernel on GPU using CUDA."}
{"id": 145, "task_name": "KL_Div_Loss", "task_description": "Compute the KL_Div_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(1024,)"}, {"name": "target", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n\n\n// kl_div_loss_kernel\n// KL Divergence Loss: D_KL(P || Q) = sum(P(x) * log(P(x) / Q(x)))\n__global__ void kl_div_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float loss = target[idx] * (logf(target[idx]) - pred[idx]);\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    kl_div_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.kl_div(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Compute the KL divergence loss kernel. The inputs are two one-dimensional tensors of 1024 float32 values each: pred (predicted values) and target (target values). The output is a single float32 value. For each element, compute the loss as target[i] * (log(target[i]) - pred[i]). The kernel must accumulate these computed loss values into a single output using atomic operations to avoid race conditions. The kernel must handle all 1024 elements.", "level2_prompt": "The KL_Div_Loss kernel calculates the total KL divergence loss between two vectors. For each element, multiply the target value by the difference between the natural logarithm of the target value and the predicted value. Sum all these individual loss values into a single output.", "level3_prompt": "Compute the KL_Div_Loss kernel."}
{"id": 146, "task_name": "KL_Div_Loss", "task_description": "Compute the KL_Div_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(4096,)"}, {"name": "target", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "()"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n\n\n// kl_div_loss_kernel\n// KL Divergence Loss: D_KL(P || Q) = sum(P(x) * log(P(x) / Q(x)))\n__global__ void kl_div_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float loss = target[idx] * (logf(target[idx]) - pred[idx]);\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    kl_div_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.kl_div(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named KL_Div_Loss to compute the Kullback-Leibler divergence loss between two input vectors. The kernel takes two float32 tensors as input: 'pred' with shape (4096,) and 'target' with shape (4096,). It outputs a single float32 scalar value. For each element in the vectors, compute the loss as target[i] multiplied by (log(target[i]) - pred[i]). Sum these values across all elements using atomic addition, then divide the final result by 4096 to obtain the mean loss. Ensure thread safety during accumulation.", "level2_prompt": "Create a CUDA kernel for KL_Div_Loss that calculates the mean Kullback-Leibler divergence between target and predicted distributions. For each index i in the input vectors, compute target[i] × (ln(target[i]) - pred[i]). Sum all these values and divide by the vector length (4096) to produce a single scalar output.", "level3_prompt": "Compute the KL_Div_Loss kernel on GPU using CUDA."}
{"id": 147, "task_name": "KL_Div_Loss", "task_description": "Compute the KL_Div_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(16384,)"}, {"name": "target", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16384\n\n\n// kl_div_loss_kernel\n// KL Divergence Loss: D_KL(P || Q) = sum(P(x) * log(P(x) / Q(x)))\n__global__ void kl_div_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float loss = target[idx] * (logf(target[idx]) - pred[idx]);\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    kl_div_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16384\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.kl_div(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'KL_Div_Loss' that computes the Kullback-Leibler divergence loss between two input vectors. The inputs are two float32 tensors named 'pred' and 'target', each of shape (16384,). The output should be a single float32 value representing the mean KL divergence loss. The kernel must compute the loss as the sum of target[i] * (log(target[i]) - pred[i]) for all elements i, followed by averaging over the batch size of 16384. Use atomic operations for safe accumulation.", "level2_prompt": "Compute the KL divergence loss between two vectors. For each element index i, calculate target[i] multiplied by the difference between the natural logarithm of target[i] and pred[i]. Sum these contributions across all elements and divide by the batch size (16384) to produce a single scalar output value.", "level3_prompt": "Compute the KL_Div_Loss kernel on GPU using CUDA."}
{"id": 148, "task_name": "KL_Div_Loss", "task_description": "Compute the KL_Div_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(65536,)"}, {"name": "target", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 65536\n\n\n// kl_div_loss_kernel\n// KL Divergence Loss: D_KL(P || Q) = sum(P(x) * log(P(x) / Q(x)))\n__global__ void kl_div_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float loss = target[idx] * (logf(target[idx]) - pred[idx]);\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    kl_div_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 65536\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.kl_div(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the KL divergence loss computation. The kernel takes two input vectors: 'pred' (65536 float32 elements) and 'target' (65536 float32 elements). The output is a single float32 scalar. For each element, compute target[i] × (log(target[i]) - pred[i]), then atomically add this value to the output sum. The kernel must check thread indices to avoid out-of-bounds access. The final output represents the sum of all element-wise losses, which will be averaged by host code.", "level2_prompt": "Compute the Kullback-Leibler divergence loss between two vectors. For each element i, calculate the term: target[i] × (log(target[i]) - pred[i]). Sum all these terms into a single output value.", "level3_prompt": "Compute the KL_Div_Loss kernel on GPU using CUDA."}
{"id": 149, "task_name": "KL_Div_Loss", "task_description": "Compute the KL_Div_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(262144,)"}, {"name": "target", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 262144\n\n\n// kl_div_loss_kernel\n// KL Divergence Loss: D_KL(P || Q) = sum(P(x) * log(P(x) / Q(x)))\n__global__ void kl_div_loss_kernel(const float* pred, const float* target, float* output, int batch_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    float loss = target[idx] * (logf(target[idx]) - pred[idx]);\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    float *h_target = new float[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    float *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    kl_div_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 262144\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, dtype=torch.float32) * 7.12\ntarget_tensor = torch.rand(BATCH_SIZE, dtype=torch.float32)\noutput_tensor = torch.nn.functional.kl_div(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel to compute the Kullback-Leibler divergence loss (KL_Div_Loss). The kernel should take two input vectors 'pred' and 'target', each containing 262144 float32 values. The computation involves calculating the element-wise loss as target[i] * (log(target[i]) - pred[i]), then summing these values across all elements. The final output should be a single float32 value representing the mean loss (sum divided by 262144). The kernel must use atomic operations for safe summation and include bounds checking.", "level2_prompt": "Compute the KL divergence loss between two vectors by evaluating target[i] * (log(target[i]) - pred[i]) for each element, summing these results, and returning the mean value. Input vectors have 262144 elements, output is a scalar.", "level3_prompt": "Compute the KL_Div_Loss kernel on GPU using CUDA."}
{"id": 150, "task_name": "L1_Loss", "task_description": "Compute the L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}, {"name": "target", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n// L1 loss kernel\n// L1 loss (x, y) = |x - y|\n__global__ void l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        atomicAdd(output, fabsf(input[idx] - target[idx]));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.l1_loss(input_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "L1_Loss: Compute the mean absolute error (L1 loss) between two input tensors. The inputs are two float32 tensors named 'input' and 'target', each with shape (16, 1024). The output is a single float32 scalar value representing the average absolute difference across all elements. The kernel must compute the sum of absolute differences for all corresponding elements in the tensors and then divide by the total number of elements (16 × 1024) to produce the final output.", "level2_prompt": "L1_Loss: Given two matrices A and B of dimensions 16×1024, calculate the mean of |Aᵢⱼ - Bᵢⱼ| for all elements, where |·| denotes absolute value. The result should be a single scalar representing the average absolute deviation between corresponding elements.", "level3_prompt": "Compute the L1_Loss kernel on GPU using CUDA."}
{"id": 151, "task_name": "L1_Loss", "task_description": "Compute the L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}, {"name": "target", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n// L1 loss kernel\n// L1 loss (x, y) = |x - y|\n__global__ void l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        atomicAdd(output, fabsf(input[idx] - target[idx]));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.l1_loss(input_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the L1_Loss kernel. Given two input tensors 'input' and 'target', both of shape (16, 4096) and data type float32, compute the mean absolute error (L1 loss) between them. The output is a single scalar (shape (1,)) of type float32. The L1 loss is computed by taking the absolute difference of each element in the input and target, summing these absolute differences, and then dividing by the total number of elements (16 * 4096).", "level2_prompt": "Compute the L1_Loss. The kernel should calculate the mean of the absolute differences between corresponding elements of the input and target tensors. Specifically, for each element, subtract the target from the input, take the absolute value, then average over all elements.", "level3_prompt": "Compute the L1_Loss kernel on GPU using CUDA."}
{"id": 152, "task_name": "L1_Loss", "task_description": "Compute the L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}, {"name": "target", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n// L1 loss kernel\n// L1 loss (x, y) = |x - y|\n__global__ void l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        atomicAdd(output, fabsf(input[idx] - target[idx]));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.l1_loss(input_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the L1_Loss task. The kernel should compute the mean absolute error (L1 loss) between two input tensors. Both input tensors have dimensions 16x16384 and data type float32. The output should be a single scalar value of data type float32. The computation must calculate the absolute difference for each corresponding element pair across both tensors, sum all absolute differences, and then divide the total sum by the number of elements (16*16384) to produce the mean loss.", "level2_prompt": "Implement the L1_Loss kernel. Given two matrices A and B of shape 16x16384, compute the mean of |A_ij - B_ij| for all i,j. The result should be a single scalar representing the average absolute difference between corresponding elements.", "level3_prompt": "Compute the L1_Loss kernel on GPU using CUDA."}
{"id": 153, "task_name": "L1_Loss", "task_description": "Compute the L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}, {"name": "target", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "()"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n// L1 loss kernel\n// L1 loss (x, y) = |x - y|\n__global__ void l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        atomicAdd(output, fabsf(input[idx] - target[idx]));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.l1_loss(input_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement an L1_Loss kernel that computes the mean absolute error between two input tensors. The inputs are two float32 tensors named 'input' and 'target', both with shape (16, 65536). The kernel must compute the average of absolute differences between corresponding elements across all positions. The output is a single scalar float32 value representing the mean absolute error. The kernel must process all elements (16 * 65536 total elements) and ensure atomic accumulation for thread safety.", "level2_prompt": "Implement an L1_Loss kernel to calculate the mean absolute error. For each element position in the input and target tensors, compute the absolute difference between corresponding elements. Sum all absolute differences and divide the total by the number of elements to produce a single scalar output value.", "level3_prompt": "Compute the L1_Loss kernel on GPU using CUDA."}
{"id": 154, "task_name": "L1_Loss", "task_description": "Compute the L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}, {"name": "target", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "()"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n// L1 loss kernel\n// L1 loss (x, y) = |x - y|\n__global__ void l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        atomicAdd(output, fabsf(input[idx] - target[idx]));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.l1_loss(input_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the L1_Loss kernel to compute the mean absolute error between two input tensors. The inputs are two float32 tensors named 'input' and 'target', both with shape (16, 262144). The output is a scalar float32 tensor. The kernel must compute the absolute difference for each corresponding element between input and target, sum these differences across all elements, then divide by the total number of elements (16 × 262144) to produce the mean L1 loss.", "level2_prompt": "Calculate the L1 loss between two tensors by summing the absolute differences of their corresponding elements and dividing by the total number of elements. Input tensors have dimensions 16 × 262144, and output is a single scalar value.", "level3_prompt": "Compute the L1_Loss kernel on GPU using CUDA."}
{"id": 155, "task_name": "Leaky_ReLU", "task_description": "Compute the Leaky_ReLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define LEAKY_RELU_SLOPE 0.01f\n\n\n// LeakyReLU(x) = max(0, x) + negative_slope * min(0, x)\n__global__ void leaky_relu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : LEAKY_RELU_SLOPE * x;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    leaky_relu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.leaky_relu(input_tensor, negative_slope=0.01)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Leaky ReLU activation function. The input is a 16x1024 tensor of float32 values. For each element in the input tensor, if the value is positive, output the same value; if negative, output the value multiplied by 0.01. The output tensor must have the same shape (16x1024) and data type (float32) as the input. The kernel must process all 16384 elements using the fixed negative slope of 0.01.", "level2_prompt": "Compute the Leaky ReLU activation on a tensor. For each element x, output x if x > 0, otherwise output 0.01 * x. The operation must be applied element-wise to a 16x1024 float32 tensor.", "level3_prompt": "Compute the Leaky_ReLU kernel on GPU using CUDA."}
{"id": 156, "task_name": "Leaky_ReLU", "task_description": "Compute the Leaky_ReLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define LEAKY_RELU_SLOPE 0.01f\n\n\n// LeakyReLU(x) = max(0, x) + negative_slope * min(0, x)\n__global__ void leaky_relu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : LEAKY_RELU_SLOPE * x;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    leaky_relu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.leaky_relu(input_tensor, negative_slope=0.01)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Leaky ReLU activation function for a 2D input tensor of shape (16, 4096) and dtype float32. The output should be a 1D tensor of 65536 elements with dtype float32. For each element in the input, if the element is positive, the output is the same as the input; if the element is negative or zero, the output is the input multiplied by 0.01. The computation must be performed independently for each element.", "level2_prompt": "Apply the Leaky ReLU function element-wise to a tensor. For each element x, the function is defined as f(x) = x if x > 0, otherwise f(x) = 0.01 * x.", "level3_prompt": "Compute the Leaky_ReLU kernel on GPU using CUDA."}
{"id": 157, "task_name": "Leaky_ReLU", "task_description": "Compute the Leaky_ReLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define LEAKY_RELU_SLOPE 0.01f\n\n\n// LeakyReLU(x) = max(0, x) + negative_slope * min(0, x)\n__global__ void leaky_relu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : LEAKY_RELU_SLOPE * x;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    leaky_relu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.leaky_relu(input_tensor, negative_slope=0.01)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Leaky ReLU activation function. The kernel should process a single input tensor of shape (16, 16384) with float32 data type and produce a single output tensor of shape (262144,) with float32 data type. For each element in the input tensor, apply the Leaky ReLU function defined as: output = max(0, x) + negative_slope * min(0, x), where negative_slope is fixed at 0.01. The kernel must handle all elements independently and preserve the flattened layout of the output.", "level2_prompt": "Compute the Leaky ReLU activation function element-wise. For each value x in the input tensor, apply the transformation: if x > 0, output = x; otherwise output = 0.01 * x. The input is a 16x16384 float32 tensor, and the output should be a flattened 262144-element float32 tensor.", "level3_prompt": "Compute the Leaky_ReLU kernel on GPU using CUDA."}
{"id": 158, "task_name": "Leaky_ReLU", "task_description": "Compute the Leaky_ReLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define LEAKY_RELU_SLOPE 0.01f\n\n\n// LeakyReLU(x) = max(0, x) + negative_slope * min(0, x)\n__global__ void leaky_relu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : LEAKY_RELU_SLOPE * x;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    leaky_relu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.leaky_relu(input_tensor, negative_slope=0.01)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'Leaky_ReLU' that applies the Leaky ReLU activation function to a 2D input tensor of shape (16, 65536) containing float32 values. The output tensor must have identical shape and dtype. For each element x in the input, compute: output = x if x > 0, otherwise output = 0.01 * x. The kernel must process all elements independently and maintain the input-output shape correspondence.", "level2_prompt": "Create a CUDA kernel called 'Leaky_ReLU' that performs element-wise transformation on a float32 tensor. For each value x in the input: if x is positive, preserve x; if x is non-positive, multiply x by 0.01. Input and output tensors have dimensions (16, 65536).", "level3_prompt": "Compute the Leaky_ReLU kernel on GPU using CUDA."}
{"id": 159, "task_name": "Leaky_ReLU", "task_description": "Compute the Leaky_ReLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define LEAKY_RELU_SLOPE 0.01f\n\n\n// LeakyReLU(x) = max(0, x) + negative_slope * min(0, x)\n__global__ void leaky_relu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > 0) ? x : LEAKY_RELU_SLOPE * x;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    leaky_relu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.leaky_relu(input_tensor, negative_slope=0.01)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Leaky_ReLU activation function. The kernel takes a 2D input tensor of shape (16, 262144) with float32 values. For each element in the input, compute the output as: if the element is greater than 0, keep it unchanged; otherwise, multiply it by 0.01. The output tensor must have the same shape and data type as the input. All elements must be processed independently.", "level2_prompt": "Apply the Leaky_ReLU activation function element-wise to a 2D float32 tensor of dimensions 16x262144. For positive elements, output the original value; for non-positive elements, output the value multiplied by 0.01.", "level3_prompt": "Compute the Leaky_ReLU kernel on GPU using CUDA."}
{"id": 160, "task_name": "Log_Sigmoid", "task_description": "Compute the Log_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n// LogSigmoid(x) = log(1 / (1 + exp(-x))) = x - log(1 + exp(x))\n__global__ void logsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - log1pf(expf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    logsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.logsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel to compute the log-sigmoid function element-wise on a 2D input tensor. The input tensor has dimensions 16x1024 with float32 data type. The output tensor must have the same dimensions and data type. For each element x in the input, compute the log-sigmoid value as x - log(1 + exp(x)), ensuring numerical stability.", "level2_prompt": "Compute the log-sigmoid function for each element in a 16x1024 float32 tensor. The mathematical operation is defined as: for each element x, output = x - log(1 + exp(x)).", "level3_prompt": "Compute the Log_Sigmoid kernel on GPU using CUDA."}
{"id": 161, "task_name": "Log_Sigmoid", "task_description": "Compute the Log_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n// LogSigmoid(x) = log(1 / (1 + exp(-x))) = x - log(1 + exp(x))\n__global__ void logsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - log1pf(expf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    logsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.logsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Log_Sigmoid kernel. The kernel takes a single input tensor of shape (16, 4096) with float32 elements and produces an output tensor of identical shape and data type. For each element in the input tensor, compute the logarithm of the sigmoid function: log(1/(1 + exp(-x))), which simplifies to x - log(1 + exp(x)). The computation must be performed element-wise and independently for each position in the tensor.", "level2_prompt": "Compute the Log_Sigmoid function for each element in a 16x4096 float32 tensor. For each input element x, the output is calculated as x - log(1 + exp(x)).", "level3_prompt": "Compute the Log_Sigmoid kernel on GPU using CUDA."}
{"id": 162, "task_name": "Log_Sigmoid", "task_description": "Compute the Log_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n// LogSigmoid(x) = log(1 / (1 + exp(-x))) = x - log(1 + exp(x))\n__global__ void logsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - log1pf(expf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    logsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.logsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Log_Sigmoid kernel. Given a 2D input tensor of shape (16, 16384) with float32 values, compute an output tensor of identical shape and data type. For each element x in the input, compute the Log Sigmoid function: f(x) = x - log(1 + exp(x)). The kernel must perform this computation element-wise across the entire tensor without altering dimensions or data types.", "level2_prompt": "Compute the Log Sigmoid function for each element in a tensor. For each input value x, the output is defined as x minus the natural logarithm of one plus the exponential of x. The operation applies independently to every element in a 16x16384 float32 input to produce a same-shaped float32 output.", "level3_prompt": "Compute the Log_Sigmoid kernel on GPU using CUDA."}
{"id": 163, "task_name": "Log_Sigmoid", "task_description": "Compute the Log_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n// LogSigmoid(x) = log(1 / (1 + exp(-x))) = x - log(1 + exp(x))\n__global__ void logsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - log1pf(expf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    logsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.logsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Log_Sigmoid kernel. The kernel should compute the log-sigmoid function for each element in the input tensor. The input is a 2D tensor of shape (16, 65536) with float32 data type. The output should be a 1D tensor of shape (1048576) with float32 data type, containing the flattened results. The log-sigmoid function for an element x is defined as: x - log(1 + exp(x)). The kernel must perform an element-wise operation, meaning each output element is computed solely from the corresponding input element.", "level2_prompt": "Compute the Log_Sigmoid function element-wise. For each element x in the input, calculate: x - log(1 + exp(x)).", "level3_prompt": "Compute the Log_Sigmoid kernel on GPU using CUDA."}
{"id": 164, "task_name": "Log_Sigmoid", "task_description": "Compute the Log_Sigmoid kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n// LogSigmoid(x) = log(1 / (1 + exp(-x))) = x - log(1 + exp(x))\n__global__ void logsigmoid_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - log1pf(expf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    logsigmoid_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.logsigmoid(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Log_Sigmoid kernel. The kernel takes a 2D input tensor of shape (16, 262144) with float32 values. For each element in the input, compute the Log Sigmoid function: LogSigmoid(x) = x - log(1 + exp(x)). The output tensor must have the same shape (16, 262144) and data type (float32) as the input. Each element in the output is computed independently from the corresponding element in the input.", "level2_prompt": "Compute the Log Sigmoid function for each element in a tensor. For each element x, the function is defined as: output = x - log(1 + exp(x)).", "level3_prompt": "Compute the Log_Sigmoid kernel on GPU using CUDA."}
{"id": 165, "task_name": "Log_Softmax", "task_description": "Compute the Log_Softmax kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(1024, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1024, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n#define DIM 128\n\n\n// LogSoftmax(x) = x - log(sum(exp(x)))\n__global__ void log_softmax_kernel(const float* input, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float input_val = input[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, input_val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(input_val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute log_softmax\n    for (int i = 0; i < dim; ++i) {\n        output[idx * dim + i] = input[idx * dim + i] - old_max_val - logf(sum_exp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    log_softmax_kernel<<<blocks, threads_per_block>>>(d_input, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.log_softmax(input_tensor, dim=-1)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 1024\n    DIM = 128\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Log_Softmax. The kernel must compute the Log Softmax function for each row of a 1024x128 input matrix of 32-bit floating point numbers. The Log Softmax for a row is computed as: for each element x_i in the row, output x_i minus the maximum value in the row minus the natural logarithm of the sum of exponentials of (each element in the row minus the maximum value). This ensures numerical stability. Each row is processed independently.", "level2_prompt": "Log_Softmax: For each row of the input matrix, compute the maximum value of the row. Then, for each element in the row, subtract the maximum and exponentiate, then sum these adjusted exponentials. The log softmax for each element is the element value minus the maximum value minus the logarithm of the sum.", "level3_prompt": "Compute the Log Softmax function."}
{"id": 166, "task_name": "Log_Softmax", "task_description": "Compute the Log_Softmax kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(4096, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(4096, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n#define DIM 128\n\n\n// LogSoftmax(x) = x - log(sum(exp(x)))\n__global__ void log_softmax_kernel(const float* input, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float input_val = input[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, input_val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(input_val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute log_softmax\n    for (int i = 0; i < dim; ++i) {\n        output[idx * dim + i] = input[idx * dim + i] - old_max_val - logf(sum_exp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    log_softmax_kernel<<<blocks, threads_per_block>>>(d_input, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.log_softmax(input_tensor, dim=-1)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 4096\n    DIM = 128\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'Log_Softmax' that computes the logarithmic softmax function for a 2D input tensor of shape (4096, 128) with float32 data type. For each row in the input tensor, the kernel must independently compute the log softmax values. The computation must follow this formula for each element in a row: subtract the row's maximum value and then subtract the natural logarithm of the sum of exponentials of all elements in that row (after subtracting the row's maximum for numerical stability). The output tensor must have the same shape and data type as the input. The kernel must process all 4096 rows in parallel while ensuring numerical stability.", "level2_prompt": "Implement the Log_Softmax operation where each row of the input matrix is processed independently. For each row vector x, compute the logarithmic softmax as: log_softmax(x_i) = x_i - max(x) - log(Σ exp(x_j - max(x))) for all elements j in the row. The max(x) and the sum of exponentials must be computed per-row using numerical stability techniques.", "level3_prompt": "Compute the Log_Softmax kernel on GPU using CUDA."}
{"id": 167, "task_name": "Log_Softmax", "task_description": "Compute the Log_Softmax kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16384, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16384, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16384\n#define DIM 128\n\n\n// LogSoftmax(x) = x - log(sum(exp(x)))\n__global__ void log_softmax_kernel(const float* input, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float input_val = input[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, input_val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(input_val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute log_softmax\n    for (int i = 0; i < dim; ++i) {\n        output[idx * dim + i] = input[idx * dim + i] - old_max_val - logf(sum_exp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    log_softmax_kernel<<<blocks, threads_per_block>>>(d_input, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16384\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.log_softmax(input_tensor, dim=-1)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16384\n    DIM = 128\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Log_Softmax. Implement a CUDA kernel that computes the log softmax of a 2D input tensor with shape (16384, 128) and float32 data type. The output tensor must have the same shape and data type. For each row in the input, compute the log softmax by: finding the row's maximum value, exponentiating each element after subtracting this maximum, summing these exponentiated values, taking the natural logarithm of this sum, and then subtracting both the maximum and this log-sum from each original element in the row. Ensure numerical stability and process each row independently.", "level2_prompt": "Task: Log_Softmax. For each row of the input matrix, compute the log softmax transformation. This involves determining the maximum value in the row, subtracting this maximum from each element and exponentiating the result, summing these exponentiated values, computing the natural logarithm of this sum, and then subtracting both the row maximum and this log-sum from each original element in the row.", "level3_prompt": "Compute the Log_Softmax kernel on GPU using CUDA."}
{"id": 168, "task_name": "Log_Softmax", "task_description": "Compute the Log_Softmax kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(65536, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(65536, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 65536\n#define DIM 128\n\n\n// LogSoftmax(x) = x - log(sum(exp(x)))\n__global__ void log_softmax_kernel(const float* input, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float input_val = input[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, input_val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(input_val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute log_softmax\n    for (int i = 0; i < dim; ++i) {\n        output[idx * dim + i] = input[idx * dim + i] - old_max_val - logf(sum_exp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    log_softmax_kernel<<<blocks, threads_per_block>>>(d_input, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 65536\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.log_softmax(input_tensor, dim=-1)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 65536\n    DIM = 128\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Log_Softmax kernel for a 2D input tensor of shape (65536, 128) with float32 elements. The kernel must independently process each row (65536 rows) to compute Log_Softmax values: for each element x in a row, output = x - max_val - log(sum(exp(x_i - max_val))) where max_val is the row's maximum value. Use numerically stable computation by tracking max values during exponent summation. Output must match input shape and dtype.", "level2_prompt": "Compute Log_Softmax for a 2D tensor by processing each row independently. For each row: find the maximum value, compute sum of exponentials of (element - max), then calculate each element's result as (element - max - log(sum_exp)).", "level3_prompt": "Compute the Log_Softmax kernel for a 2D float32 tensor."}
{"id": 169, "task_name": "Log_Softmax", "task_description": "Compute the Log_Softmax kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(262144, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(262144, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 262144\n#define DIM 128\n\n\n// LogSoftmax(x) = x - log(sum(exp(x)))\n__global__ void log_softmax_kernel(const float* input, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // online softmax\n    float old_max_val = -INFINITY;\n    float sum_exp = 0.0f;\n    for (int i = 0; i < dim; ++i) {\n        float input_val = input[idx * dim + i];\n        float new_max_val = fmaxf(old_max_val, input_val);\n        sum_exp = sum_exp * expf(old_max_val - new_max_val) + expf(input_val - new_max_val);\n        old_max_val = new_max_val;\n    }\n    // compute log_softmax\n    for (int i = 0; i < dim; ++i) {\n        output[idx * dim + i] = input[idx * dim + i] - old_max_val - logf(sum_exp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    log_softmax_kernel<<<blocks, threads_per_block>>>(d_input, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 262144\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.log_softmax(input_tensor, dim=-1)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 262144\n    DIM = 128\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Log_Softmax operation. The kernel should process a 2D input tensor of float32 values with dimensions (262144, 128). For each row in the tensor, compute the log softmax value for every element in that row. The log softmax for an element x_i is calculated as x_i minus the maximum value in its row, minus the natural logarithm of the sum of exponentials of all elements in the row after subtracting the row maximum. The output tensor must have identical dimensions and data type as the input. The kernel must handle large batch sizes efficiently and maintain numerical stability.", "level2_prompt": "Compute the Log_Softmax function across rows of a 2D tensor. For each row, apply the transformation: Log_Softmax(x_i) = x_i - max(x) - log(∑exp(x_j - max(x))), where max(x) is the maximum value in the row and the summation is over all elements in the row. The input is a float32 tensor of shape (262144, 128), and the output must preserve the same shape and data type.", "level3_prompt": "Perform Log_Softmax computation on a GPU using CUDA."}
{"id": 170, "task_name": "Max_Pooling_3D", "task_description": "Compute the Max_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "pool_input", "dtype": "float32", "shape": "(16, 32, 16, 16, 16)"}], "outputs": [{"name": "pool_output", "dtype": "float32", "shape": "(16, 32, 6, 6, 6)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cfloat>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define CHANNELS 32\n#define KERNEL_SIZE 3\n#define STRIDE 2\n#define PADDING 1\n#define DILATION 3\n#define D 16\n\n__global__ void max_pool3d_kernel(const float* input, float* output,\n    int in_d1, int in_d2, int in_d3,\n    int out_d1, int out_d2, int out_d3) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total_outputs = BATCH_SIZE * CHANNELS * out_d1 * out_d2 * out_d3;\n    if (idx >= total_outputs) return;\n\n    int od3 = idx % out_d3;\n    int od2 = (idx / out_d3) % out_d2;\n    int od1 = (idx / (out_d3 * out_d2)) % out_d1;\n    int c   = (idx / (out_d3 * out_d2 * out_d1)) % CHANNELS;\n    int b   = idx / (out_d3 * out_d2 * out_d1 * CHANNELS);\n\n    int id1_start = od1 * STRIDE - PADDING;\n    int id2_start = od2 * STRIDE - PADDING;\n    int id3_start = od3 * STRIDE - PADDING;\n\n    float max_val = -FLT_MAX;\n\n    for (int k1 = 0; k1 < KERNEL_SIZE; ++k1) {\n        int id1 = id1_start + k1 * DILATION;\n        if (id1 < 0 || id1 >= in_d1) continue;\n\n        for (int k2 = 0; k2 < KERNEL_SIZE; ++k2) {\n            int id2 = id2_start + k2 * DILATION;\n            if (id2 < 0 || id2 >= in_d2) continue;\n\n            for (int k3 = 0; k3 < KERNEL_SIZE; ++k3) {\n                int id3 = id3_start + k3 * DILATION;\n                if (id3 < 0 || id3 >= in_d3) continue;\n\n                int input_idx = (((b * CHANNELS + c) * in_d1 + id1) * in_d2 + id2) * in_d3 + id3;\n                max_val = fmaxf(max_val, input[input_idx]);\n            }\n        }\n    }\n\n    int output_idx = (((b * CHANNELS + c) * out_d1 + od1) * out_d2 + od2) * out_d3 + od3;\n    output[output_idx] = max_val;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint compute_out_dim(int dim) {\n    return ((dim + 2 * PADDING - DILATION * (KERNEL_SIZE - 1) - 1) / STRIDE) + 1;\n}\n\nint main() {\n    int OD = compute_out_dim(D);\n\n    size_t in_elems = BATCH_SIZE * CHANNELS * D * D * D;\n    size_t out_elems = BATCH_SIZE * CHANNELS * OD * OD * OD;\n    size_t in_bytes = in_elems * sizeof(float);\n    size_t out_bytes = out_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(in_bytes);\n    float* h_output = (float*)malloc(out_bytes);\n\n    std::string input_file = \"./data/pool_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, in_bytes);\n    cudaMalloc(&d_output, out_bytes);\n    cudaMemcpy(d_input, h_input, in_bytes, cudaMemcpyHostToDevice);\n\n    int total_outputs = out_elems;\n    int threads = 256;\n    int blocks = (total_outputs + threads - 1) / threads;\n\n    max_pool3d_kernel<<<blocks, threads>>>(d_input, d_output, D, D, D, OD, OD, OD);\n\n    cudaMemcpy(h_output, d_output, out_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/pool_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn.functional as F\nimport os\n\nseed = 42\ntorch.manual_seed(seed)\n\nB = 16\nC = 32\nD = 16\n\nx = torch.randn(B, C, D, D, D, dtype=torch.float32)\ny = F.max_pool3d(x, kernel_size=3, stride=2, padding=1, dilation=3)\n\nx.numpy().tofile(\"data/pool_input.bin\")\ny.numpy().tofile(\"data/pool_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    B = 16\n    C = 32\n    D = 16\n\n    def compute_out_dim(dim):\n        return ((dim + 2 * 1 - 3 * (3 - 1) - 1) // 2) + 1\n\n    OD = compute_out_dim(D)\n    total_size = B * C * OD * OD * OD\n\n    out_file = \"./data/pool_output.bin\"\n    ref_file = \"./data/pool_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Max_Pooling_3D kernel for 5D input tensors with shape (batch, channels, depth, height, width). The input tensor has dimensions (16, 32, 16, 16, 16) and float32 data type. The output tensor must have dimensions (16, 32, 6, 6, 6) and float32 data type. The kernel must apply max pooling with a 3x3x3 kernel size, stride of 2, padding of 1, and dilation of 3 across all spatial dimensions. For each output position, compute the maximum value within the dilated kernel window in the corresponding input region, respecting boundary conditions where out-of-bounds positions should be ignored.", "level2_prompt": "Perform 3D max pooling operation on a 5-dimensional tensor. For each element in the output tensor (batch, channel, d_out, h_out, w_out), slide a 3x3x3 kernel with dilation 3 over the input tensor's spatial dimensions. The kernel starts at position (d_out*2-1, h_out*2-1, w_out*2-1) and samples elements spaced by dilation factor 3. Compute the maximum value within the kernel window, skipping invalid positions beyond input boundaries.", "level3_prompt": "Compute the Max_Pooling_3D kernel on GPU using CUDA."}
{"id": 171, "task_name": "Max_Pooling_3D", "task_description": "Compute the Max_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "pool_input", "dtype": "float32", "shape": "(16, 32, 24, 24, 24)"}], "outputs": [{"name": "pool_output", "dtype": "float32", "shape": "(16, 32, 10, 10, 10)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cfloat>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define CHANNELS 32\n#define KERNEL_SIZE 3\n#define STRIDE 2\n#define PADDING 1\n#define DILATION 3\n#define D 24\n\n__global__ void max_pool3d_kernel(const float* input, float* output,\n    int in_d1, int in_d2, int in_d3,\n    int out_d1, int out_d2, int out_d3) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total_outputs = BATCH_SIZE * CHANNELS * out_d1 * out_d2 * out_d3;\n    if (idx >= total_outputs) return;\n\n    int od3 = idx % out_d3;\n    int od2 = (idx / out_d3) % out_d2;\n    int od1 = (idx / (out_d3 * out_d2)) % out_d1;\n    int c   = (idx / (out_d3 * out_d2 * out_d1)) % CHANNELS;\n    int b   = idx / (out_d3 * out_d2 * out_d1 * CHANNELS);\n\n    int id1_start = od1 * STRIDE - PADDING;\n    int id2_start = od2 * STRIDE - PADDING;\n    int id3_start = od3 * STRIDE - PADDING;\n\n    float max_val = -FLT_MAX;\n\n    for (int k1 = 0; k1 < KERNEL_SIZE; ++k1) {\n        int id1 = id1_start + k1 * DILATION;\n        if (id1 < 0 || id1 >= in_d1) continue;\n\n        for (int k2 = 0; k2 < KERNEL_SIZE; ++k2) {\n            int id2 = id2_start + k2 * DILATION;\n            if (id2 < 0 || id2 >= in_d2) continue;\n\n            for (int k3 = 0; k3 < KERNEL_SIZE; ++k3) {\n                int id3 = id3_start + k3 * DILATION;\n                if (id3 < 0 || id3 >= in_d3) continue;\n\n                int input_idx = (((b * CHANNELS + c) * in_d1 + id1) * in_d2 + id2) * in_d3 + id3;\n                max_val = fmaxf(max_val, input[input_idx]);\n            }\n        }\n    }\n\n    int output_idx = (((b * CHANNELS + c) * out_d1 + od1) * out_d2 + od2) * out_d3 + od3;\n    output[output_idx] = max_val;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint compute_out_dim(int dim) {\n    return ((dim + 2 * PADDING - DILATION * (KERNEL_SIZE - 1) - 1) / STRIDE) + 1;\n}\n\nint main() {\n    int OD = compute_out_dim(D);\n\n    size_t in_elems = BATCH_SIZE * CHANNELS * D * D * D;\n    size_t out_elems = BATCH_SIZE * CHANNELS * OD * OD * OD;\n    size_t in_bytes = in_elems * sizeof(float);\n    size_t out_bytes = out_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(in_bytes);\n    float* h_output = (float*)malloc(out_bytes);\n\n    std::string input_file = \"./data/pool_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, in_bytes);\n    cudaMalloc(&d_output, out_bytes);\n    cudaMemcpy(d_input, h_input, in_bytes, cudaMemcpyHostToDevice);\n\n    int total_outputs = out_elems;\n    int threads = 256;\n    int blocks = (total_outputs + threads - 1) / threads;\n\n    max_pool3d_kernel<<<blocks, threads>>>(d_input, d_output, D, D, D, OD, OD, OD);\n\n    cudaMemcpy(h_output, d_output, out_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/pool_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn.functional as F\nimport os\n\nseed = 42\ntorch.manual_seed(seed)\n\nB = 16\nC = 32\nD = 24\n\nx = torch.randn(B, C, D, D, D, dtype=torch.float32)\ny = F.max_pool3d(x, kernel_size=3, stride=2, padding=1, dilation=3)\n\nx.numpy().tofile(\"data/pool_input.bin\")\ny.numpy().tofile(\"data/pool_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    B = 16\n    C = 32\n    D = 24\n\n    def compute_out_dim(dim):\n        return ((dim + 2 * 1 - 3 * (3 - 1) - 1) // 2) + 1\n\n    OD = compute_out_dim(D)\n    total_size = B * C * OD * OD * OD\n\n    out_file = \"./data/pool_output.bin\"\n    ref_file = \"./data/pool_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a 3D max pooling operation on a GPU using CUDA. The input tensor 'pool_input' has a shape of (16, 32, 24, 24, 24) and data type float32. The output tensor 'pool_output' should have a shape of (16, 32, 10, 10, 10) and data type float32. The pooling operation uses a kernel size of 3, stride of 2, padding of 1, and dilation of 3. The kernel must slide over the input tensor's spatial dimensions (depth, height, width), compute the maximum value within each sliding window while respecting dilation and padding, and write the result to the corresponding output position. Boundary checks must ensure indices stay within input tensor limits.", "level2_prompt": "Perform 3D max pooling by iterating over each output position in a 5D tensor (batch, channels, depth_out, height_out, width_out). For each output position, calculate corresponding input start coordinates using stride and padding. Then, iterate over a 3x3x3 kernel window with dilation, compute valid input indices, find the maximum value within the window while respecting input boundaries, and assign it to the output position.", "level3_prompt": "Compute the Max_Pooling_3D kernel on GPU using CUDA."}
{"id": 172, "task_name": "Max_Pooling_3D", "task_description": "Compute the Max_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "pool_input", "dtype": "float32", "shape": "(16, 32, 32, 32, 32)"}], "outputs": [{"name": "pool_output", "dtype": "float32", "shape": "(16, 32, 14, 14, 14)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cfloat>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define CHANNELS 32\n#define KERNEL_SIZE 3\n#define STRIDE 2\n#define PADDING 1\n#define DILATION 3\n#define D 32\n\n__global__ void max_pool3d_kernel(const float* input, float* output,\n    int in_d1, int in_d2, int in_d3,\n    int out_d1, int out_d2, int out_d3) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total_outputs = BATCH_SIZE * CHANNELS * out_d1 * out_d2 * out_d3;\n    if (idx >= total_outputs) return;\n\n    int od3 = idx % out_d3;\n    int od2 = (idx / out_d3) % out_d2;\n    int od1 = (idx / (out_d3 * out_d2)) % out_d1;\n    int c   = (idx / (out_d3 * out_d2 * out_d1)) % CHANNELS;\n    int b   = idx / (out_d3 * out_d2 * out_d1 * CHANNELS);\n\n    int id1_start = od1 * STRIDE - PADDING;\n    int id2_start = od2 * STRIDE - PADDING;\n    int id3_start = od3 * STRIDE - PADDING;\n\n    float max_val = -FLT_MAX;\n\n    for (int k1 = 0; k1 < KERNEL_SIZE; ++k1) {\n        int id1 = id1_start + k1 * DILATION;\n        if (id1 < 0 || id1 >= in_d1) continue;\n\n        for (int k2 = 0; k2 < KERNEL_SIZE; ++k2) {\n            int id2 = id2_start + k2 * DILATION;\n            if (id2 < 0 || id2 >= in_d2) continue;\n\n            for (int k3 = 0; k3 < KERNEL_SIZE; ++k3) {\n                int id3 = id3_start + k3 * DILATION;\n                if (id3 < 0 || id3 >= in_d3) continue;\n\n                int input_idx = (((b * CHANNELS + c) * in_d1 + id1) * in_d2 + id2) * in_d3 + id3;\n                max_val = fmaxf(max_val, input[input_idx]);\n            }\n        }\n    }\n\n    int output_idx = (((b * CHANNELS + c) * out_d1 + od1) * out_d2 + od2) * out_d3 + od3;\n    output[output_idx] = max_val;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint compute_out_dim(int dim) {\n    return ((dim + 2 * PADDING - DILATION * (KERNEL_SIZE - 1) - 1) / STRIDE) + 1;\n}\n\nint main() {\n    int OD = compute_out_dim(D);\n\n    size_t in_elems = BATCH_SIZE * CHANNELS * D * D * D;\n    size_t out_elems = BATCH_SIZE * CHANNELS * OD * OD * OD;\n    size_t in_bytes = in_elems * sizeof(float);\n    size_t out_bytes = out_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(in_bytes);\n    float* h_output = (float*)malloc(out_bytes);\n\n    std::string input_file = \"./data/pool_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, in_bytes);\n    cudaMalloc(&d_output, out_bytes);\n    cudaMemcpy(d_input, h_input, in_bytes, cudaMemcpyHostToDevice);\n\n    int total_outputs = out_elems;\n    int threads = 256;\n    int blocks = (total_outputs + threads - 1) / threads;\n\n    max_pool3d_kernel<<<blocks, threads>>>(d_input, d_output, D, D, D, OD, OD, OD);\n\n    cudaMemcpy(h_output, d_output, out_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/pool_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn.functional as F\nimport os\n\nseed = 42\ntorch.manual_seed(seed)\n\nB = 16\nC = 32\nD = 32\n\nx = torch.randn(B, C, D, D, D, dtype=torch.float32)\ny = F.max_pool3d(x, kernel_size=3, stride=2, padding=1, dilation=3)\n\nx.numpy().tofile(\"data/pool_input.bin\")\ny.numpy().tofile(\"data/pool_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    B = 16\n    C = 32\n    D = 32\n\n    def compute_out_dim(dim):\n        return ((dim + 2 * 1 - 3 * (3 - 1) - 1) // 2) + 1\n\n    OD = compute_out_dim(D)\n    total_size = B * C * OD * OD * OD\n\n    out_file = \"./data/pool_output.bin\"\n    ref_file = \"./data/pool_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for 3D max pooling. The input is a 5D tensor of shape (16, 32, 32, 32, 32) with float32 data type representing batches, channels, depth, height, and width. The output is a 5D tensor of shape (16, 32, 14, 14, 14) with float32 data type. The pooling uses a cubic kernel of size 3, stride 2, padding 1, and dilation 3. For each output position, compute the maximum value within the corresponding dilated input window. Boundary conditions must be handled correctly by ignoring out-of-bound window positions.", "level2_prompt": "Perform 3D max pooling on a 5D input tensor. For each output element, slide a 3x3x3 kernel over the input spatial dimensions with stride 2, padding 1, and dilation 3. At each valid position, compute the maximum value within the kernel window while respecting input boundaries. The output dimensions are derived from the input dimensions using the pooling parameters.", "level3_prompt": "Compute the Max_Pooling_3D kernel on GPU using CUDA."}
{"id": 173, "task_name": "Max_Pooling_3D", "task_description": "Compute the Max_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "pool_input", "dtype": "float32", "shape": "(16, 32, 40, 40, 40)"}], "outputs": [{"name": "pool_output", "dtype": "float32", "shape": "(16, 32, 18, 18, 18)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cfloat>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define CHANNELS 32\n#define KERNEL_SIZE 3\n#define STRIDE 2\n#define PADDING 1\n#define DILATION 3\n#define D 40\n\n__global__ void max_pool3d_kernel(const float* input, float* output,\n    int in_d1, int in_d2, int in_d3,\n    int out_d1, int out_d2, int out_d3) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total_outputs = BATCH_SIZE * CHANNELS * out_d1 * out_d2 * out_d3;\n    if (idx >= total_outputs) return;\n\n    int od3 = idx % out_d3;\n    int od2 = (idx / out_d3) % out_d2;\n    int od1 = (idx / (out_d3 * out_d2)) % out_d1;\n    int c   = (idx / (out_d3 * out_d2 * out_d1)) % CHANNELS;\n    int b   = idx / (out_d3 * out_d2 * out_d1 * CHANNELS);\n\n    int id1_start = od1 * STRIDE - PADDING;\n    int id2_start = od2 * STRIDE - PADDING;\n    int id3_start = od3 * STRIDE - PADDING;\n\n    float max_val = -FLT_MAX;\n\n    for (int k1 = 0; k1 < KERNEL_SIZE; ++k1) {\n        int id1 = id1_start + k1 * DILATION;\n        if (id1 < 0 || id1 >= in_d1) continue;\n\n        for (int k2 = 0; k2 < KERNEL_SIZE; ++k2) {\n            int id2 = id2_start + k2 * DILATION;\n            if (id2 < 0 || id2 >= in_d2) continue;\n\n            for (int k3 = 0; k3 < KERNEL_SIZE; ++k3) {\n                int id3 = id3_start + k3 * DILATION;\n                if (id3 < 0 || id3 >= in_d3) continue;\n\n                int input_idx = (((b * CHANNELS + c) * in_d1 + id1) * in_d2 + id2) * in_d3 + id3;\n                max_val = fmaxf(max_val, input[input_idx]);\n            }\n        }\n    }\n\n    int output_idx = (((b * CHANNELS + c) * out_d1 + od1) * out_d2 + od2) * out_d3 + od3;\n    output[output_idx] = max_val;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint compute_out_dim(int dim) {\n    return ((dim + 2 * PADDING - DILATION * (KERNEL_SIZE - 1) - 1) / STRIDE) + 1;\n}\n\nint main() {\n    int OD = compute_out_dim(D);\n\n    size_t in_elems = BATCH_SIZE * CHANNELS * D * D * D;\n    size_t out_elems = BATCH_SIZE * CHANNELS * OD * OD * OD;\n    size_t in_bytes = in_elems * sizeof(float);\n    size_t out_bytes = out_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(in_bytes);\n    float* h_output = (float*)malloc(out_bytes);\n\n    std::string input_file = \"./data/pool_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, in_bytes);\n    cudaMalloc(&d_output, out_bytes);\n    cudaMemcpy(d_input, h_input, in_bytes, cudaMemcpyHostToDevice);\n\n    int total_outputs = out_elems;\n    int threads = 256;\n    int blocks = (total_outputs + threads - 1) / threads;\n\n    max_pool3d_kernel<<<blocks, threads>>>(d_input, d_output, D, D, D, OD, OD, OD);\n\n    cudaMemcpy(h_output, d_output, out_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/pool_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn.functional as F\nimport os\n\nseed = 42\ntorch.manual_seed(seed)\n\nB = 16\nC = 32\nD = 40\n\nx = torch.randn(B, C, D, D, D, dtype=torch.float32)\ny = F.max_pool3d(x, kernel_size=3, stride=2, padding=1, dilation=3)\n\nx.numpy().tofile(\"data/pool_input.bin\")\ny.numpy().tofile(\"data/pool_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    B = 16\n    C = 32\n    D = 40\n\n    def compute_out_dim(dim):\n        return ((dim + 2 * 1 - 3 * (3 - 1) - 1) // 2) + 1\n\n    OD = compute_out_dim(D)\n    total_size = B * C * OD * OD * OD\n\n    out_file = \"./data/pool_output.bin\"\n    ref_file = \"./data/pool_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Max_Pooling_3D. Perform 3D max pooling on a 5D input tensor of shape (16, 32, 40, 40, 40) with float32 data type. The output tensor must have shape (16, 32, 18, 18, 18) and float32 data type. The pooling uses a kernel size of 3 in all spatial dimensions, stride of 2, padding of 1, and dilation of 3. For each output position, compute the maximum value from the corresponding dilated input window, skipping out-of-bound indices.", "level2_prompt": "Task: Max_Pooling_3D. For each batch and channel, apply 3D max pooling with kernel size 3, stride 2, padding 1, and dilation 3. Compute the maximum value within the dilated window for each output spatial position, ignoring coordinates outside input boundaries.", "level3_prompt": "Compute the Max_Pooling_3D kernel on GPU using CUDA."}
{"id": 174, "task_name": "Max_Pooling_3D", "task_description": "Compute the Max_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "pool_input", "dtype": "float32", "shape": "(16, 32, 48, 48, 48)"}], "outputs": [{"name": "pool_output", "dtype": "float32", "shape": "(16, 32, 22, 22, 22)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cfloat>\n#include <fstream>\n#include <string>\n\n#define BATCH_SIZE 16\n#define CHANNELS 32\n#define KERNEL_SIZE 3\n#define STRIDE 2\n#define PADDING 1\n#define DILATION 3\n#define D 48\n\n__global__ void max_pool3d_kernel(const float* input, float* output,\n    int in_d1, int in_d2, int in_d3,\n    int out_d1, int out_d2, int out_d3) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total_outputs = BATCH_SIZE * CHANNELS * out_d1 * out_d2 * out_d3;\n    if (idx >= total_outputs) return;\n\n    int od3 = idx % out_d3;\n    int od2 = (idx / out_d3) % out_d2;\n    int od1 = (idx / (out_d3 * out_d2)) % out_d1;\n    int c   = (idx / (out_d3 * out_d2 * out_d1)) % CHANNELS;\n    int b   = idx / (out_d3 * out_d2 * out_d1 * CHANNELS);\n\n    int id1_start = od1 * STRIDE - PADDING;\n    int id2_start = od2 * STRIDE - PADDING;\n    int id3_start = od3 * STRIDE - PADDING;\n\n    float max_val = -FLT_MAX;\n\n    for (int k1 = 0; k1 < KERNEL_SIZE; ++k1) {\n        int id1 = id1_start + k1 * DILATION;\n        if (id1 < 0 || id1 >= in_d1) continue;\n\n        for (int k2 = 0; k2 < KERNEL_SIZE; ++k2) {\n            int id2 = id2_start + k2 * DILATION;\n            if (id2 < 0 || id2 >= in_d2) continue;\n\n            for (int k3 = 0; k3 < KERNEL_SIZE; ++k3) {\n                int id3 = id3_start + k3 * DILATION;\n                if (id3 < 0 || id3 >= in_d3) continue;\n\n                int input_idx = (((b * CHANNELS + c) * in_d1 + id1) * in_d2 + id2) * in_d3 + id3;\n                max_val = fmaxf(max_val, input[input_idx]);\n            }\n        }\n    }\n\n    int output_idx = (((b * CHANNELS + c) * out_d1 + od1) * out_d2 + od2) * out_d3 + od3;\n    output[output_idx] = max_val;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint compute_out_dim(int dim) {\n    return ((dim + 2 * PADDING - DILATION * (KERNEL_SIZE - 1) - 1) / STRIDE) + 1;\n}\n\nint main() {\n    int OD = compute_out_dim(D);\n\n    size_t in_elems = BATCH_SIZE * CHANNELS * D * D * D;\n    size_t out_elems = BATCH_SIZE * CHANNELS * OD * OD * OD;\n    size_t in_bytes = in_elems * sizeof(float);\n    size_t out_bytes = out_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(in_bytes);\n    float* h_output = (float*)malloc(out_bytes);\n\n    std::string input_file = \"./data/pool_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, in_bytes);\n    cudaMalloc(&d_output, out_bytes);\n    cudaMemcpy(d_input, h_input, in_bytes, cudaMemcpyHostToDevice);\n\n    int total_outputs = out_elems;\n    int threads = 256;\n    int blocks = (total_outputs + threads - 1) / threads;\n\n    max_pool3d_kernel<<<blocks, threads>>>(d_input, d_output, D, D, D, OD, OD, OD);\n\n    cudaMemcpy(h_output, d_output, out_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/pool_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn.functional as F\nimport os\n\nseed = 42\ntorch.manual_seed(seed)\n\nB = 16\nC = 32\nD = 48\n\nx = torch.randn(B, C, D, D, D, dtype=torch.float32)\ny = F.max_pool3d(x, kernel_size=3, stride=2, padding=1, dilation=3)\n\nx.numpy().tofile(\"data/pool_input.bin\")\ny.numpy().tofile(\"data/pool_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    B = 16\n    C = 32\n    D = 48\n\n    def compute_out_dim(dim):\n        return ((dim + 2 * 1 - 3 * (3 - 1) - 1) // 2) + 1\n\n    OD = compute_out_dim(D)\n    total_size = B * C * OD * OD * OD\n\n    out_file = \"./data/pool_output.bin\"\n    ref_file = \"./data/pool_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Max_Pooling_3D. Compute a 3D max pooling operation on a 5D input tensor of shape (16, 32, 48, 48, 48) and data type float32. The operation uses a kernel size of 3 in each spatial dimension, a stride of 2, padding of 1, and dilation of 3. The output tensor must have the shape (16, 32, 22, 22, 22) and data type float32. The kernel must respect the boundaries of the input tensor by skipping out-of-bound window positions. For each window, the maximum value of the elements (accounting for dilation) must be computed and placed in the corresponding output location.", "level2_prompt": "Max_Pooling_3D: For each batch and channel, slide a 3D window of size 3x3x3 over the depth, height, and width dimensions of the input tensor. The window starts at positions determined by a stride of 2 and padding of 1. The window elements are spaced by dilation of 3. For each window, compute the maximum value of the elements that fall within the window and are within the input tensor boundaries. Write the maximum value to the corresponding output location in the output tensor.", "level3_prompt": "Compute the Max_Pooling_3D kernel on GPU using CUDA."}
{"id": 175, "task_name": "Mish", "task_description": "Compute the Mish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// Mish(x) = x * Tanh(softplus(x)) = x * tanh(ln(1 + exp(x)))\n__global__ void mish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float sp = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n        output[idx] = x * tanhf(sp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    mish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.mish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Mish activation function kernel. The input is a 16x1024 tensor of 32-bit floats. The output must be a 16x1024 tensor of 32-bit floats where each element is computed as Mish(x) = x * tanh(softplus(x)). For numerical stability, when x > 20.0, use softplus(x) ≈ x; otherwise, compute softplus(x) as (1/β) * ln(1 + exp(β*x)) with β=1.0. Each element must be processed independently.", "level2_prompt": "Apply the Mish activation function element-wise: Mish(x) = x * tanh(ln(1 + exp(x))). For inputs exceeding 20.0, approximate ln(1 + exp(x)) as x to prevent overflow. Process a 16x1024 float32 input tensor into a same-shaped output.", "level3_prompt": "Compute the Mish kernel for a 16x1024 float32 tensor."}
{"id": 176, "task_name": "Mish", "task_description": "Compute the Mish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// Mish(x) = x * Tanh(softplus(x)) = x * tanh(ln(1 + exp(x)))\n__global__ void mish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float sp = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n        output[idx] = x * tanhf(sp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    mish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.mish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Mish. Compute the Mish activation function for each element in a 2D input tensor of shape (16, 4096) and data type float32. The Mish function is defined as Mish(x) = x * tanh(softplus(x)), where softplus(x) = ln(1 + exp(x)). For numerical stability, if x > 20.0, set softplus(x) = x to avoid overflow; otherwise, compute softplus(x) = log(1 + exp(x)). The output must have the same shape and data type as the input.", "level2_prompt": "Task: Mish. For each element x in the input tensor, compute y = x * tanh(softplus(x)). Define softplus(x) as x if x > 20.0, otherwise as log(1 + exp(x)).", "level3_prompt": "Compute the Mish activation function for each element of the input tensor."}
{"id": 177, "task_name": "Mish", "task_description": "Compute the Mish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// Mish(x) = x * Tanh(softplus(x)) = x * tanh(ln(1 + exp(x)))\n__global__ void mish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float sp = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n        output[idx] = x * tanhf(sp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    mish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.mish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Mish activation function for a 2D tensor on GPU. The input is a float32 tensor of shape (16, 16384), and the output should have the same shape and data type. For each element x, compute Mish(x) = x * tanh(softplus(x)), where softplus(x) = ln(1 + exp(x)). Optimize the softplus calculation: when x * beta > threshold (with beta=1.0 and threshold=20.0), use x directly instead of the full softplus calculation to prevent overflow. Each element must be processed independently.", "level2_prompt": "Compute the Mish activation function element-wise on a 2D tensor. For each element x, first compute softplus(x) as x if x > 20, otherwise as ln(1 + exp(x)). Then calculate Mish(x) = x * tanh(softplus(x)). Input and output tensors have shape (16, 16384) with float32 data type.", "level3_prompt": "Compute the Mish kernel on GPU using CUDA."}
{"id": 178, "task_name": "Mish", "task_description": "Compute the Mish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// Mish(x) = x * Tanh(softplus(x)) = x * tanh(ln(1 + exp(x)))\n__global__ void mish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float sp = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n        output[idx] = x * tanhf(sp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    mish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.mish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Mish activation function on a GPU using CUDA. The Mish function is defined as Mish(x) = x * tanh(softplus(x)), where softplus(x) = ln(1 + exp(x)). The input is a 2D tensor of shape (16, 65536) with float32 data type. The output should be a 1D tensor of shape (1048576,) with float32 data type, containing the Mish activation applied element-wise to the input. For numerical stability, if x is greater than 20.0, approximate softplus(x) as x; otherwise, compute it as (1.0 / beta) * log1pf(exp(beta * x)) with beta=1.0.", "level2_prompt": "Compute the Mish activation function element-wise. For each value x in the input tensor, calculate softplus(x) = ln(1 + exp(x)) using an approximation when x > 20 to avoid overflow. Then compute tanh of this softplus result and multiply it by the original x to get Mish(x) = x * tanh(softplus(x)).", "level3_prompt": "Compute the Mish kernel on GPU using CUDA."}
{"id": 179, "task_name": "Mish", "task_description": "Compute the Mish kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// Mish(x) = x * Tanh(softplus(x)) = x * tanh(ln(1 + exp(x)))\n__global__ void mish_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        float sp = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n        output[idx] = x * tanhf(sp);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    mish_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.mish(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Mish. Compute the Mish activation function for each element in a 2D float32 tensor of shape (16, 262144). The Mish function is defined as Mish(x) = x * tanh(softplus(x)), where softplus(x) is computed as: if x > 20.0 then softplus(x) = x, else softplus(x) = log(1 + exp(x)). The output tensor must have the same shape and data type as the input.", "level2_prompt": "Mish: For each element x in the input tensor, compute Mish(x) = x * tanh(softplus(x)), with softplus(x) = x when x > 20.0 and softplus(x) = log(1 + exp(x)) otherwise.", "level3_prompt": "Compute the Mish kernel on GPU using CUDA."}
{"id": 180, "task_name": "NLL_Loss", "task_description": "Compute the NLL_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(1024, 128)"}, {"name": "target", "dtype": "int64", "shape": "(1024,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n#define DIM 128\n\n\n// nll loss kernel\n__global__ void nll_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    int target_index = target[idx];\n    float loss = -pred[idx * dim + target_index];\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    nll_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\npred_tensor = torch.log_softmax(pred_tensor, dim=1)\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.nll_loss(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the NLL_Loss CUDA kernel. The kernel takes two inputs: a 2D float32 tensor 'pred' of shape (1024, 128) representing predicted log probabilities for each class, and a 1D int64 tensor 'target' of shape (1024,) representing the index of the true class for each sample. The kernel must compute the negative log likelihood loss for each sample: for each sample i, the loss is the negative of the predicted log probability at the class index specified by target[i]. The kernel must accumulate the sum of these losses into a single float32 output tensor of shape (1,). The kernel should be launched with enough threads to cover the entire batch (1024 samples), and atomic operations must be used to safely accumulate the loss sum due to concurrent writes to the single output value.", "level2_prompt": "The kernel computes the sum of the negative log likelihood losses for a batch of 1024 samples. For each sample i, the loss is defined as the negative of the predicted log probability at the class index specified by target[i]. The losses for all samples are summed and stored in a single output value.", "level3_prompt": "Compute the NLL_Loss kernel."}
{"id": 181, "task_name": "NLL_Loss", "task_description": "Compute the NLL_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(4096, 128)"}, {"name": "target", "dtype": "int64", "shape": "(4096,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n#define DIM 128\n\n\n// nll loss kernel\n__global__ void nll_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    int target_index = target[idx];\n    float loss = -pred[idx * dim + target_index];\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    nll_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\npred_tensor = torch.log_softmax(pred_tensor, dim=1)\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.nll_loss(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the NLL_Loss kernel to compute the negative log likelihood loss. The inputs are a 2D tensor 'pred' of float32 values with shape (4096, 128) and a 1D tensor 'target' of int64 values with shape (4096,). The output is a scalar float32 tensor with shape (1,) representing the average loss over the batch. For each sample, the loss is computed as the negative value of the predicted log probability at the target index. The kernel must accumulate these losses atomically and the host will later divide the sum by the batch size of 4096 to compute the mean loss.", "level2_prompt": "Compute the negative log likelihood loss for a batch of predictions. Given predicted log probabilities for 4096 samples across 128 classes and target indices for each sample, calculate the loss as the negative of the predicted probability at the target index. Sum these individual losses and return the average loss by dividing the sum by the batch size.", "level3_prompt": "Compute the NLL_Loss kernel on GPU using CUDA."}
{"id": 182, "task_name": "NLL_Loss", "task_description": "Compute the NLL_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(16384, 128)"}, {"name": "target", "dtype": "int64", "shape": "(16384,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16384\n#define DIM 128\n\n\n// nll loss kernel\n__global__ void nll_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    int target_index = target[idx];\n    float loss = -pred[idx * dim + target_index];\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    nll_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16384\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\npred_tensor = torch.log_softmax(pred_tensor, dim=1)\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.nll_loss(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: NLL_Loss. Compute the mean negative log likelihood loss for a batch of predictions and targets. The input 'pred' is a float32 tensor of shape (16384, 128) representing log probabilities for each sample and class. The input 'target' is an int64 tensor of shape (16384,) representing the true class indices for each sample. The output is a float32 tensor of shape (1,) containing the mean loss. Constraints: Target indices must be within [0, 127], and the kernel must accumulate losses atomically due to concurrent writes.", "level2_prompt": "Task: NLL_Loss. For each sample in a batch of 16384, extract the predicted log probability at the target class index, compute the negative value as the loss, and sum all sample losses. Divide the total loss by the batch size to get the mean loss.", "level3_prompt": "Compute the NLL_Loss kernel on GPU using CUDA."}
{"id": 183, "task_name": "NLL_Loss", "task_description": "Compute the NLL_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(65536, 128)"}, {"name": "target", "dtype": "int64", "shape": "(65536,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 65536\n#define DIM 128\n\n\n// nll loss kernel\n__global__ void nll_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    int target_index = target[idx];\n    float loss = -pred[idx * dim + target_index];\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    nll_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 65536\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\npred_tensor = torch.log_softmax(pred_tensor, dim=1)\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.nll_loss(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the NLL_Loss kernel to compute the average negative log likelihood loss for a batch of predictions and targets. The input 'pred' is a 2D float32 tensor of shape (65536, 128) representing predicted log probabilities for each class. The input 'target' is a 1D int64 tensor of shape (65536,) containing true class indices. The output is a scalar float32 tensor of shape (1,) holding the average loss. The kernel must compute the loss for each sample by taking the negative value of the predicted log probability at the target index, sum these losses across all samples, and divide by the batch size 65536 to obtain the final output. Atomic operations should be used for thread-safe accumulation.", "level2_prompt": "Compute the average negative log likelihood loss. For each of the 65536 samples, retrieve the target class index from 'target', use it to select the corresponding log probability from the 'pred' tensor's second dimension, take the negative value of this probability to get the sample loss. Sum all sample losses and divide by 65536 to produce a single scalar output value.", "level3_prompt": "Compute the NLL_Loss kernel on GPU using CUDA."}
{"id": 184, "task_name": "NLL_Loss", "task_description": "Compute the NLL_Loss kernel on GPU using CUDA.", "inputs": [{"name": "pred", "dtype": "float32", "shape": "(262144, 128)"}, {"name": "target", "dtype": "int64", "shape": "(262144,)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 262144\n#define DIM 128\n\n\n// nll loss kernel\n__global__ void nll_loss_kernel(const float* pred, const long* target, float* output, int batch_size, int dim) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= batch_size) return;\n\n    // compute loss\n    int target_index = target[idx];\n    float loss = -pred[idx * dim + target_index];\n    atomicAdd(output, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int pred_size = BATCH_SIZE * DIM;\n    int target_size = BATCH_SIZE;\n    int output_size = 1;\n\n    float *h_pred = new float[pred_size];\n    long *h_target = new long[target_size];\n    float *h_output = new float[output_size];\n\n    std::string pred_file = \"./data/pred.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(pred_file, h_pred, pred_size);\n    read_binary(target_file, h_target, target_size);\n\n    float *d_pred, *d_output;\n    long *d_target;\n    cudaMalloc(&d_pred, pred_size * sizeof(float));\n    cudaMalloc(&d_target, target_size * sizeof(long));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_pred, h_pred, pred_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, target_size * sizeof(long), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (pred_size + threads_per_block - 1) / threads_per_block;\n\n    nll_loss_kernel<<<blocks, threads_per_block>>>(d_pred, d_target, d_output, BATCH_SIZE, DIM);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= BATCH_SIZE;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_pred);\n    cudaFree(d_target);\n    cudaFree(d_output);\n    delete[] h_pred;\n    delete[] h_target;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 262144\nDIM = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npred_tensor = torch.randn(BATCH_SIZE, DIM, dtype=torch.float32) * 7.12\npred_tensor = torch.log_softmax(pred_tensor, dim=1)\ntarget_tensor = torch.randint(0, DIM, (BATCH_SIZE,), dtype=torch.int64)\noutput_tensor = torch.nn.functional.nll_loss(pred_tensor, target_tensor, reduction='mean')\n\nos.makedirs(\"./data\", exist_ok=True)\npred_tensor.numpy().tofile(\"./data/pred.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named NLL_Loss that computes the negative log likelihood loss. The kernel should take two inputs: a 2D tensor 'pred' of float32 values with shape (262144, 128) representing predicted log probabilities, and a 1D tensor 'target' of int64 values with shape (262144) representing target class indices. The output is a scalar tensor of float32 with shape (1) containing the mean loss. The kernel must compute the loss for each sample by selecting the predicted value at the target index, negate it, and accumulate these values atomically. After accumulation, the sum must be divided by the batch size (262144) to obtain the mean loss.", "level2_prompt": "Implement the NLL_Loss kernel to calculate mean negative log likelihood loss. For each sample in the batch of 262144 elements, use the target index to select the corresponding predicted log probability from the 128-dimensional vector. Negate this value and atomically add it to a global accumulator. Finally, divide the accumulated sum by the batch size to produce the mean loss output.", "level3_prompt": "Compute the NLL_Loss kernel on GPU using CUDA."}
{"id": 185, "task_name": "Pixel_Shuffle", "task_description": "Compute the Pixel_Shuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 8, 32, 32)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 2, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 8\n#define N 32\n#define UP_SCALE 2\n\n\n// Pixel Shuffle Kernel\n// B, C, N, N -> B, C/(r*r), N*r, N*r\n__global__ void pixel_shuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n * r;\n    int final_c = c / (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_bc = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || out_bc >= b * final_c) return;\n\n    int out_b = out_bc / final_c;\n    int out_c = out_bc % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int in_c = out_c * (r * r) + (out_h % r) * r + (out_w % r);\n    int in_h = out_h / r;\n    int in_w = out_w / r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N * UP_SCALE + threads.x - 1) / threads.x,\n                (N * UP_SCALE + threads.y - 1) / threads.y,\n                (B * C / (UP_SCALE * UP_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_shuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, UP_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 8\nN = 32\nUP_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_shuffle(input_tensor, UP_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 8\n    N = 32\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Pixel Shuffle operation. Given an input tensor of shape (8, 8, 32, 32) with float32 values, reorganize its elements to produce an output tensor of shape (8, 2, 64, 64). The operation must rearrange channel information into spatial dimensions using an upscaling factor of 2. Input channels must be divisible by 4 (upscale factor squared), and each output pixel must be mapped from a corresponding input channel group based on spatial position.", "level2_prompt": "Perform a pixel shuffle transformation. For each batch, redistribute the input tensor's channels into spatial dimensions using an upscaling factor of 2. Each output pixel (b, c_out, h_out, w_out) should be sourced from input channel c_in = c_out×4 + (h_out mod 2)×2 + (w_out mod 2) at spatial position (h_out//2, w_out//2).", "level3_prompt": "Compute the Pixel_Shuffle kernel on GPU using CUDA."}
{"id": 186, "task_name": "Pixel_Shuffle", "task_description": "Compute the Pixel_Shuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 8, 64, 64)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 2, 128, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 8\n#define N 64\n#define UP_SCALE 2\n\n\n// Pixel Shuffle Kernel\n// B, C, N, N -> B, C/(r*r), N*r, N*r\n__global__ void pixel_shuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n * r;\n    int final_c = c / (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_bc = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || out_bc >= b * final_c) return;\n\n    int out_b = out_bc / final_c;\n    int out_c = out_bc % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int in_c = out_c * (r * r) + (out_h % r) * r + (out_w % r);\n    int in_h = out_h / r;\n    int in_w = out_w / r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N * UP_SCALE + threads.x - 1) / threads.x,\n                (N * UP_SCALE + threads.y - 1) / threads.y,\n                (B * C / (UP_SCALE * UP_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_shuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, UP_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 8\nN = 64\nUP_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_shuffle(input_tensor, UP_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 8\n    N = 64\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Pixel_Shuffle kernel. The kernel should reorganize a 4D input tensor with shape (batch, channels, height, width) into a higher-resolution output tensor by rearranging channel data into spatial blocks. Input: float32 tensor with shape (8, 8, 64, 64). Output: float32 tensor with shape (8, 2, 128, 128). Constraints: The kernel must use an upscale factor of 2, meaning each 2x2 block in the input's channel dimension becomes spatial pixels in the output. The channel dimension must be divisible by 4 (upscale factor squared).", "level2_prompt": "Perform a pixel shuffle operation on a 4D tensor. For each output spatial position (h, w) in the upscaled image, select values from specific input channels corresponding to the relative position within the 2x2 spatial block. The output channel dimension is reduced by a factor of 4 while spatial dimensions increase by a factor of 2 in both height and width.", "level3_prompt": "Compute the Pixel_Shuffle kernel using CUDA."}
{"id": 187, "task_name": "Pixel_Shuffle", "task_description": "Compute the Pixel_Shuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 8, 128, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 2, 256, 256)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 8\n#define N 128\n#define UP_SCALE 2\n\n\n// Pixel Shuffle Kernel\n// B, C, N, N -> B, C/(r*r), N*r, N*r\n__global__ void pixel_shuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n * r;\n    int final_c = c / (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_bc = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || out_bc >= b * final_c) return;\n\n    int out_b = out_bc / final_c;\n    int out_c = out_bc % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int in_c = out_c * (r * r) + (out_h % r) * r + (out_w % r);\n    int in_h = out_h / r;\n    int in_w = out_w / r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N * UP_SCALE + threads.x - 1) / threads.x,\n                (N * UP_SCALE + threads.y - 1) / threads.y,\n                (B * C / (UP_SCALE * UP_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_shuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, UP_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 8\nN = 128\nUP_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_shuffle(input_tensor, UP_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 8\n    N = 128\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Pixel_Shuffle kernel for GPU using CUDA. The kernel should reorganize an input tensor with shape (8, 8, 128, 128) [batch, channels, height, width] into an output tensor with shape (8, 2, 256, 256). The input uses float32 data type. The kernel must rearrange elements such that the spatial dimensions (height and width) increase by a factor of 2, while reducing the channel dimension by a factor of 4. This requires mapping each output element to a specific input element based on channel and spatial position transformations.", "level2_prompt": "Implement a Pixel Shuffle operation where an input tensor of shape (B, C, H, W) is transformed to output shape (B, C/(r*r), H*r, W*r) with r=2. For each output element at (b, c_out, h_out, w_out), compute the input element at (b, c_in, h_in, w_in) where c_in = c_out * (r*r) + (h_out % r)*r + (w_out % r), h_in = h_out // r, and w_in = w_out // r.", "level3_prompt": "Compute the Pixel_Shuffle kernel to reorganize input tensor dimensions."}
{"id": 188, "task_name": "Pixel_Shuffle", "task_description": "Compute the Pixel_Shuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 8, 256, 256)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 2, 512, 512)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 8\n#define N 256\n#define UP_SCALE 2\n\n\n// Pixel Shuffle Kernel\n// B, C, N, N -> B, C/(r*r), N*r, N*r\n__global__ void pixel_shuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n * r;\n    int final_c = c / (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_bc = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || out_bc >= b * final_c) return;\n\n    int out_b = out_bc / final_c;\n    int out_c = out_bc % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int in_c = out_c * (r * r) + (out_h % r) * r + (out_w % r);\n    int in_h = out_h / r;\n    int in_w = out_w / r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N * UP_SCALE + threads.x - 1) / threads.x,\n                (N * UP_SCALE + threads.y - 1) / threads.y,\n                (B * C / (UP_SCALE * UP_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_shuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, UP_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 8\nN = 256\nUP_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_shuffle(input_tensor, UP_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 8\n    N = 256\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a Pixel_Shuffle CUDA kernel that rearranges input tensor elements to increase spatial resolution while reducing channel depth. The input is a 4D float32 tensor of shape (8, 8, 256, 256). The output must be a float32 tensor of shape (8, 2, 512, 512). Each output element at (b, c, h, w) must map to input element (b, c*(r²) + (h%r)*r + (w%r), h/r, w/r) where r=2 is the upscale factor. Batch dimension remains unchanged.", "level2_prompt": "Pixel_Shuffle kernel transforms a 4D tensor by redistributing channel dimensions into spatial dimensions. For an upscale factor r=2, each output element (b, c, h, w) corresponds to input element (b, c*r² + (h mod r)*r + (w mod r), floor(h/r), floor(w/r)). This operation increases height and width by factor r while reducing channels by factor r².", "level3_prompt": "Compute the Pixel_Shuffle kernel on GPU using CUDA."}
{"id": 189, "task_name": "Pixel_Shuffle", "task_description": "Compute the Pixel_Shuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 8, 512, 512)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 2, 1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 8\n#define N 512\n#define UP_SCALE 2\n\n\n// Pixel Shuffle Kernel\n// B, C, N, N -> B, C/(r*r), N*r, N*r\n__global__ void pixel_shuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n * r;\n    int final_c = c / (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_bc = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || out_bc >= b * final_c) return;\n\n    int out_b = out_bc / final_c;\n    int out_c = out_bc % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int in_c = out_c * (r * r) + (out_h % r) * r + (out_w % r);\n    int in_h = out_h / r;\n    int in_w = out_w / r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N * UP_SCALE + threads.x - 1) / threads.x,\n                (N * UP_SCALE + threads.y - 1) / threads.y,\n                (B * C / (UP_SCALE * UP_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_shuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, UP_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 8\nN = 512\nUP_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_shuffle(input_tensor, UP_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 8\n    N = 512\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Pixel_Shuffle operation. The input is a 4D tensor of shape (8, 8, 512, 512) with float32 data type. The output should be a 4D tensor of shape (8, 2, 1024, 1024) with float32 data type. The kernel must spatially rearrange elements from the input tensor to the output tensor using an upscale factor of 2. Specifically, each element in the output tensor must be mapped from the input tensor such that the channel dimension is reduced by a factor of 4 (since 2×2=4) while the height and width dimensions are each increased by a factor of 2. The kernel must preserve all input values without modification and ensure correct indexing for this transformation.", "level2_prompt": "Perform a Pixel_Shuffle operation with an upscale factor of 2. Given an input tensor of shape [B, C, H, W], produce an output tensor of shape [B, C/(r×r), H×r, W×r] where r=2. For each element in the output tensor at position (b, c_out, h_out, w_out), the value should be taken from the input tensor at position (b, c_in, h_in, w_in) where c_in = c_out × (r×r) + (h_out mod r) × r + (w_out mod r), h_in = h_out / r, and w_in = w_out / r.", "level3_prompt": "Compute the Pixel_Shuffle kernel on GPU using CUDA."}
{"id": 190, "task_name": "Pixel_Unshuffle", "task_description": "Compute the Pixel_Unshuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 2, 64, 64)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 8, 32, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 2\n#define N 64\n#define DOWN_SCALE 2\n\n\n// Pixel Unshuffle Kernel\n// B, C, N, N -> B, C*r*r, N/r, N/r\n__global__ void pixel_unshuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n / r;\n    int final_c = c * (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int bc_idx = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || bc_idx >= b * final_c) return;\n\n    int out_b = bc_idx / final_c;\n    int out_c = bc_idx % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int block_idx = out_c % (r * r);\n    int in_c = out_c / (r * r);\n    int in_h = out_h * r + block_idx / r;\n    int in_w = out_w * r + block_idx % r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N / DOWN_SCALE + threads.x - 1) / threads.x,\n                (N / DOWN_SCALE + threads.y - 1) / threads.y,\n                (B * C * (DOWN_SCALE * DOWN_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_unshuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, DOWN_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 2\nN = 64\nDOWN_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_unshuffle(input_tensor, DOWN_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 2\n    N = 64\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Pixel Unshuffle operation. The input is a 4D tensor with shape (8, 2, 64, 64) and float32 data type. The output should be a 4D tensor with shape (8, 8, 32, 32) and float32 data type. The kernel must rearrange the input by dividing each spatial dimension into non-overlapping 2x2 blocks, then flattening and moving these blocks to the channel dimension. This increases the channel count by a factor of 4 (from 2 to 8) while reducing spatial dimensions from 64x64 to 32x32. The batch dimension remains unchanged.", "level2_prompt": "Perform a Pixel Unshuffle operation with a downscaling factor of 2. Rearrange the input tensor such that each 2x2 block of spatial data is flattened and moved to the channel dimension. This transforms the tensor from (batch, channels, height, width) to (batch, channels × 4, height/2, width/2).", "level3_prompt": "Compute the Pixel_Unshuffle kernel on GPU using CUDA."}
{"id": 191, "task_name": "Pixel_Unshuffle", "task_description": "Compute the Pixel_Unshuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 2, 128, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 8, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 2\n#define N 128\n#define DOWN_SCALE 2\n\n\n// Pixel Unshuffle Kernel\n// B, C, N, N -> B, C*r*r, N/r, N/r\n__global__ void pixel_unshuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n / r;\n    int final_c = c * (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int bc_idx = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || bc_idx >= b * final_c) return;\n\n    int out_b = bc_idx / final_c;\n    int out_c = bc_idx % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int block_idx = out_c % (r * r);\n    int in_c = out_c / (r * r);\n    int in_h = out_h * r + block_idx / r;\n    int in_w = out_w * r + block_idx % r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N / DOWN_SCALE + threads.x - 1) / threads.x,\n                (N / DOWN_SCALE + threads.y - 1) / threads.y,\n                (B * C * (DOWN_SCALE * DOWN_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_unshuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, DOWN_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 2\nN = 128\nDOWN_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_unshuffle(input_tensor, DOWN_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 2\n    N = 128\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Pixel_Unshuffle. Transform an input tensor of shape (8, 2, 128, 128) and dtype float32 into an output tensor of shape (8, 8, 64, 64) and dtype float32. The kernel must reorganize spatial data by downscaling height and width dimensions by a factor of 2 while increasing the channel dimension. Specifically, each 2x2 spatial block in the input should be flattened into channel dimensions, where elements are mapped such that spatial positions within each block determine their new channel index. The kernel must preserve batch dimensions and ensure all input elements are correctly mapped without exceeding output boundaries.", "level2_prompt": "Task: Pixel_Unshuffle. For an input tensor [B, C, H, W], apply a spatial-to-channel transformation with downscale factor r=2. Each element at position (b, c, h, w) is mapped to output (b, c*r² + block_index, h//r, w//r), where block_index = (h % r) * r + (w % r). The output shape becomes [B, C*r², H/r, W/r].", "level3_prompt": "Compute the Pixel_Unshuffle kernel on GPU using CUDA."}
{"id": 192, "task_name": "Pixel_Unshuffle", "task_description": "Compute the Pixel_Unshuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 2, 256, 256)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 8, 128, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 2\n#define N 256\n#define DOWN_SCALE 2\n\n\n// Pixel Unshuffle Kernel\n// B, C, N, N -> B, C*r*r, N/r, N/r\n__global__ void pixel_unshuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n / r;\n    int final_c = c * (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int bc_idx = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || bc_idx >= b * final_c) return;\n\n    int out_b = bc_idx / final_c;\n    int out_c = bc_idx % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int block_idx = out_c % (r * r);\n    int in_c = out_c / (r * r);\n    int in_h = out_h * r + block_idx / r;\n    int in_w = out_w * r + block_idx % r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N / DOWN_SCALE + threads.x - 1) / threads.x,\n                (N / DOWN_SCALE + threads.y - 1) / threads.y,\n                (B * C * (DOWN_SCALE * DOWN_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_unshuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, DOWN_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 2\nN = 256\nDOWN_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_unshuffle(input_tensor, DOWN_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 2\n    N = 256\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Pixel_Unshuffle CUDA kernel. The operation reorganizes spatial data into channel data by downscaling resolution. Input is a 4D tensor with shape (8, 2, 256, 256) of float32 values representing batch, channel, height, and width dimensions. Output must be a 4D tensor with shape (8, 8, 128, 128) of float32 values. The downscale factor is 2, meaning input spatial dimensions (256x256) must be reduced by factor 2 in both height and width while increasing channel dimension by factor 4. Each output element must correspond to specific spatial positions in non-overlapping 2x2 input blocks.", "level2_prompt": "Pixel_Unshuffle operation transforms input tensor [B, C, H, W] to output [B, C×r², H/r, W/r] where r=2. For each output position [b, c_out, h_out, w_out], compute input index [b, c_in, h_in, w_in] where c_in = c_out // (r×r), block_idx = c_out % (r×r), h_in = h_out×r + block_idx // r, w_in = w_out×r + block_idx % r.", "level3_prompt": "Compute the Pixel_Unshuffle kernel on GPU using CUDA."}
{"id": 193, "task_name": "Pixel_Unshuffle", "task_description": "Compute the Pixel_Unshuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 2, 512, 512)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 8, 256, 256)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 2\n#define N 512\n#define DOWN_SCALE 2\n\n\n// Pixel Unshuffle Kernel\n// B, C, N, N -> B, C*r*r, N/r, N/r\n__global__ void pixel_unshuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n / r;\n    int final_c = c * (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int bc_idx = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || bc_idx >= b * final_c) return;\n\n    int out_b = bc_idx / final_c;\n    int out_c = bc_idx % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int block_idx = out_c % (r * r);\n    int in_c = out_c / (r * r);\n    int in_h = out_h * r + block_idx / r;\n    int in_w = out_w * r + block_idx % r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N / DOWN_SCALE + threads.x - 1) / threads.x,\n                (N / DOWN_SCALE + threads.y - 1) / threads.y,\n                (B * C * (DOWN_SCALE * DOWN_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_unshuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, DOWN_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 2\nN = 512\nDOWN_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_unshuffle(input_tensor, DOWN_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 2\n    N = 512\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Pixel_Unshuffle CUDA kernel. The input is a 4D tensor of shape (8, 2, 512, 512) with float32 data type. The kernel should rearrange spatial elements into new channels, reducing spatial dimensions by a factor of 2. Output must be a float32 tensor of shape (8, 8, 256, 256). Each output element at (b, c, h, w) maps to input at (b, c_in, h*2 + block_idx//2, w*2 + block_idx%2), where block_idx = c % 4 and c_in = c // 4.", "level2_prompt": "Perform pixel unshuffle operation. Transform input spatial dimensions (512x512) to (256x256) by rearranging 2x2 blocks into new channels. Input has 2 channels; output must have 8 channels. For each output position, compute corresponding input indices based on block index and channel mapping.", "level3_prompt": "Compute the Pixel_Unshuffle kernel on GPU using CUDA."}
{"id": 194, "task_name": "Pixel_Unshuffle", "task_description": "Compute the Pixel_Unshuffle kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(8, 2, 1024, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(8, 8, 512, 512)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define B 8\n#define C 2\n#define N 1024\n#define DOWN_SCALE 2\n\n\n// Pixel Unshuffle Kernel\n// B, C, N, N -> B, C*r*r, N/r, N/r\n__global__ void pixel_unshuffle_kernel(const float* input, float* output, int b, int c, int n, int r) {\n    int final_n = n / r;\n    int final_c = c * (r * r);\n\n    int out_w = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_h = blockIdx.y * blockDim.y + threadIdx.y;\n    int bc_idx = blockIdx.z * blockDim.z + threadIdx.z;\n\n    if (out_w >= final_n || out_h >= final_n || bc_idx >= b * final_c) return;\n\n    int out_b = bc_idx / final_c;\n    int out_c = bc_idx % final_c;\n    int out_index = out_b * (final_c * final_n * final_n) + out_c * (final_n * final_n) + out_h * final_n + out_w;\n\n    // get corresponding input indices\n    int block_idx = out_c % (r * r);\n    int in_c = out_c / (r * r);\n    int in_h = out_h * r + block_idx / r;\n    int in_w = out_w * r + block_idx % r;\n    int in_index = out_b * (c * n * n) + in_c * (n * n) + in_h * n + in_w;\n\n    output[out_index] = input[in_index];\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = B * C * N * N;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16, 1);\n    dim3 blocks((N / DOWN_SCALE + threads.x - 1) / threads.x,\n                (N / DOWN_SCALE + threads.y - 1) / threads.y,\n                (B * C * (DOWN_SCALE * DOWN_SCALE) + threads.z - 1) / threads.z);\n\n    pixel_unshuffle_kernel<<<blocks, threads>>>(d_input, d_output, B, C, N, DOWN_SCALE);\n\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nB = 8\nC = 2\nN = 1024\nDOWN_SCALE = 2\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(B, C, N, N, dtype=torch.float32)\noutput_tensor = torch.nn.functional.pixel_unshuffle(input_tensor, DOWN_SCALE)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    B = 8\n    C = 2\n    N = 1024\n    total_size = B * C * N * N\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Pixel Unshuffle operation for a 4D tensor. The input tensor has a shape of (8, 2, 1024, 1024) and data type float32. The output tensor must have a shape of (8, 8, 512, 512) and data type float32. The operation must reorganize the input by taking non-overlapping 2x2 blocks in the spatial dimensions and moving each element of the block to consecutive channels in the output, thereby reducing the spatial dimensions by a factor of 2 and increasing the channel dimension by a factor of 4.", "level2_prompt": "Perform the Pixel Unshuffle operation. The operation takes non-overlapping 2x2 blocks from the input's spatial dimensions and rearranges each block's elements into consecutive channels in the output. This results in the output having 4 times the original number of channels and half the original height and width.", "level3_prompt": "Compute the Pixel Unshuffle operation with a spatial downscaling factor of 2."}
{"id": 195, "task_name": "ReLU6", "task_description": "Compute the ReLU6 kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n// ReLU6(x) = min(max(x, 0), 6)\n__global__ void relu6_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, 0.0f), 6.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    relu6_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.relu6(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "ReLU6: Implement a CUDA kernel that applies the ReLU6 activation function to a 2D input tensor. The input is a float32 tensor of shape (16, 1024). For each element, compute min(max(x, 0), 6) where x is the input value. The output must be a float32 tensor of identical shape (16, 1024). The kernel must perform this operation element-wise with no cross-element dependencies.", "level2_prompt": "ReLU6: For each element in the input tensor, apply the function f(x) = min(max(x, 0), 6). This clamps values below 0 to 0 and above 6 to 6, while preserving values in the [0,6] range. The computation must be performed independently on all elements.", "level3_prompt": "Compute the ReLU6 kernel on a 2D tensor."}
{"id": 196, "task_name": "ReLU6", "task_description": "Compute the ReLU6 kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n// ReLU6(x) = min(max(x, 0), 6)\n__global__ void relu6_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, 0.0f), 6.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    relu6_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.relu6(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: ReLU6. Given an input tensor of shape (16, 4096) with float32 data type, compute an output tensor of the same shape and data type where each element is the ReLU6 activation of the corresponding input element. The ReLU6 function is defined as: for each element x, output = min(max(x, 0), 6). The kernel must process each element independently and handle the entire input tensor of 65536 elements.", "level2_prompt": "Task: ReLU6. Apply the function f(x) = min(max(x, 0), 6) to every element in the input tensor.", "level3_prompt": "Compute the ReLU6 kernel on GPU using CUDA."}
{"id": 197, "task_name": "ReLU6", "task_description": "Compute the ReLU6 kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n// ReLU6(x) = min(max(x, 0), 6)\n__global__ void relu6_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, 0.0f), 6.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    relu6_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.relu6(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: ReLU6. Apply the ReLU6 activation function element-wise to a 2D input tensor of shape (16, 16384) and data type float32. The ReLU6 function is defined as: for each element x, output = min(max(x, 0), 6). The output tensor must have the same shape and data type as the input. The operation must be performed independently for each element.", "level2_prompt": "Task: ReLU6. For each element in the input tensor, compute the ReLU6 function: if the element is less than 0, set it to 0; if greater than 6, set it to 6; otherwise, leave it unchanged.", "level3_prompt": "Compute the ReLU6 activation function element-wise."}
{"id": 198, "task_name": "ReLU6", "task_description": "Compute the ReLU6 kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n// ReLU6(x) = min(max(x, 0), 6)\n__global__ void relu6_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, 0.0f), 6.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    relu6_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.relu6(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the ReLU6 operation. The kernel should process a 2D input tensor of shape (16, 65536) with float32 data type. For each element, apply the ReLU6 function: clamp the value between 0 and 6 (output = min(max(input, 0), 6)). The output tensor must match the input shape (16, 65536) with float32 data type. The computation must be performed element-wise without altering the tensor dimensions.", "level2_prompt": "Compute the ReLU6 function element-wise on a 2D float32 tensor. For each value x, apply: output = min(max(x, 0), 6). The input has dimensions (16, 65536), and the output must preserve these dimensions.", "level3_prompt": "Compute the ReLU6 kernel on GPU using CUDA."}
{"id": 199, "task_name": "ReLU6", "task_description": "Compute the ReLU6 kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n// ReLU6(x) = min(max(x, 0), 6)\n__global__ void relu6_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = fminf(fmaxf(x, 0.0f), 6.0f);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    relu6_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.relu6(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the ReLU6 kernel for a 2D input tensor of shape (16, 262144) with float32 data type. The kernel must apply the ReLU6 activation function element-wise: for each input value x, compute min(max(x, 0), 6). The output tensor must have the same shape and data type as the input. The kernel must handle all elements independently and preserve the input dimensions.", "level2_prompt": "Apply the ReLU6 activation function element-wise to a 2D tensor. For each element x in the input, compute the output as min(max(x, 0), 6), clamping values below 0 to 0 and values above 6 to 6.", "level3_prompt": "Compute the ReLU6 kernel on a GPU."}
{"id": 200, "task_name": "SeLU", "task_description": "Compute the SeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define SELU_ALPHA 1.6732632423543772f\n#define SELU_SCALE 1.0507009873554805f\n\n// SELU(x) = scale * (max(0, x) + min(0, alpha * (exp(x) - 1)))\n__global__ void selu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = SELU_SCALE * ((x > 0) ? x : SELU_ALPHA * (expf(x) - 1.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    selu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.selu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named SeLU that computes the Scaled Exponential Linear Unit activation function. The input is a 2D tensor of shape (16, 1024) with float32 data type. The output must be a tensor of identical shape and data type. For each element, the kernel must compute: if the value is positive, multiply it by a constant scale (≈1.0507); if negative, apply alpha (≈1.6733) multiplied by (exponential of the value minus 1), then multiply by scale. The computation must be performed element-wise without altering the tensor dimensions.", "level2_prompt": "Implement the SeLU activation function using CUDA. For each element in a 2D float32 tensor of size (16, 1024), apply: output = scale × (x if x > 0 else alpha × (exp(x) - 1)), where alpha and scale are predefined constants. The operation must preserve the input tensor's shape.", "level3_prompt": "Compute the SeLU kernel on GPU using CUDA."}
{"id": 201, "task_name": "SeLU", "task_description": "Compute the SeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define SELU_ALPHA 1.6732632423543772f\n#define SELU_SCALE 1.0507009873554805f\n\n// SELU(x) = scale * (max(0, x) + min(0, alpha * (exp(x) - 1)))\n__global__ void selu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = SELU_SCALE * ((x > 0) ? x : SELU_ALPHA * (expf(x) - 1.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    selu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.selu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the SeLU (Scaled Exponential Linear Unit) activation function for a 2D input tensor of shape (16, 4096) with float32 data type. The function is defined as: for each element x, if x is greater than 0, output = scale * x; otherwise, output = scale * alpha * (exp(x) - 1), where scale = 1.0507009873554805 and alpha = 1.6732632423543772. The output tensor must have the same shape as the input, and the computation must be applied element-wise to all 16*4096 elements independently.", "level2_prompt": "Apply the SeLU activation function element-wise to a tensor. For each element x, compute: f(x) = scale * (x if x > 0 else alpha * (exp(x) - 1)), where scale = 1.0507009873554805 and alpha = 1.6732632423543772.", "level3_prompt": "Element-wise SeLU activation."}
{"id": 202, "task_name": "SeLU", "task_description": "Compute the SeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define SELU_ALPHA 1.6732632423543772f\n#define SELU_SCALE 1.0507009873554805f\n\n// SELU(x) = scale * (max(0, x) + min(0, alpha * (exp(x) - 1)))\n__global__ void selu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = SELU_SCALE * ((x > 0) ? x : SELU_ALPHA * (expf(x) - 1.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    selu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.selu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the SeLU activation function for a GPU using CUDA. The task requires applying the SeLU function element-wise to an input tensor of shape (16, 16384) with float32 data type. The output tensor must match the input shape and data type. The SeLU function is defined as: scale * (max(0, x) + min(0, alpha * (exp(x) - 1))), where alpha is approximately 1.673263 and scale is approximately 1.050701. The kernel must process all elements independently and preserve tensor dimensions.", "level2_prompt": "Compute the SeLU activation function for each element in a 2D tensor. For each value x, apply: scale * (x if x > 0, else alpha * (exp(x) - 1)), using predefined constants for alpha and scale. Input and output are both float32 tensors of shape (16, 16384).", "level3_prompt": "Compute the SeLU kernel on GPU using CUDA."}
{"id": 203, "task_name": "SeLU", "task_description": "Compute the SeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define SELU_ALPHA 1.6732632423543772f\n#define SELU_SCALE 1.0507009873554805f\n\n// SELU(x) = scale * (max(0, x) + min(0, alpha * (exp(x) - 1)))\n__global__ void selu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = SELU_SCALE * ((x > 0) ? x : SELU_ALPHA * (expf(x) - 1.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    selu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.selu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the SeLU activation function kernel. The input is a 2D tensor of shape (16, 65536) with float32 elements. The output must be a tensor of identical shape and data type. The SeLU function is defined as: scale * (max(0, x) + min(0, alpha * (exp(x) - 1))) where alpha = 1.6732632423543772 and scale = 1.0507009873554805. The kernel must apply this operation element-wise to all input values.", "level2_prompt": "Compute the Scaled Exponential Linear Unit (SeLU) activation. For each element x in the input tensor: if x > 0, output = scale * x; else output = scale * alpha * (exp(x) - 1). Use alpha=1.6732632423543772 and scale=1.0507009873554805.", "level3_prompt": "Compute the SeLU kernel on GPU using CUDA."}
{"id": 204, "task_name": "SeLU", "task_description": "Compute the SeLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define SELU_ALPHA 1.6732632423543772f\n#define SELU_SCALE 1.0507009873554805f\n\n// SELU(x) = scale * (max(0, x) + min(0, alpha * (exp(x) - 1)))\n__global__ void selu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = SELU_SCALE * ((x > 0) ? x : SELU_ALPHA * (expf(x) - 1.0f));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    selu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.selu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: SeLU. Compute the Scaled Exponential Linear Unit (SeLU) activation function on a 2D input tensor of shape (16, 262144) with float32 data type. For each element in the input tensor, if the element is positive, multiply it by a constant scale value; otherwise, apply the function scale * alpha * (exponential of the element minus 1). The constants alpha and scale are approximately 1.6732632423543772 and 1.0507009873554805, respectively. The output tensor must have the same shape and data type as the input, and each element must be processed independently.", "level2_prompt": "Task: SeLU. Apply the SeLU activation function element-wise to each element in the input tensor. For an element x, the output is scale * (x if x > 0, else alpha * (exp(x) - 1)), using predefined constants alpha ≈ 1.6732632423543772 and scale ≈ 1.0507009873554805.", "level3_prompt": "Compute the SeLU kernel on GPU using CUDA."}
{"id": 205, "task_name": "SiLU", "task_description": "Compute the SiLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n// SiLU(x) = x * sigmoid(x) = x / (1 + exp(-x))\n__global__ void silu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x / (1.0f + expf(-x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    silu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.silu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the SiLU activation function kernel. The input is a 2D tensor with shape (16, 1024) of float32 values. The output tensor must have the same shape and dtype as the input. For each element x in the input, compute the SiLU function: output = x / (1 + exp(-x)). The kernel must process all 16384 elements independently.", "level2_prompt": "Compute the SiLU activation function element-wise. For each value x in the input tensor, apply the transformation: x / (1 + exp(-x)). The operation must be performed independently on all tensor elements.", "level3_prompt": "Compute the SiLU kernel on the input tensor."}
{"id": 206, "task_name": "SiLU", "task_description": "Compute the SiLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n// SiLU(x) = x * sigmoid(x) = x / (1 + exp(-x))\n__global__ void silu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x / (1.0f + expf(-x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    silu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.silu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the SiLU task that computes the SiLU activation function on a 16x4096 float32 input tensor. The SiLU function is defined as x * sigmoid(x), equivalent to x / (1 + exp(-x)), and must be applied element-wise. The output should be a float32 tensor of the same shape, where each element depends solely on its corresponding input element.", "level2_prompt": "The SiLU task involves computing the SiLU activation function for each element in a tensor. Mathematically, for each input value x, the output is x multiplied by the sigmoid of x, resulting in x / (1 + exp(-x)).", "level3_prompt": "Compute the SiLU kernel on GPU using CUDA."}
{"id": 207, "task_name": "SiLU", "task_description": "Compute the SiLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n// SiLU(x) = x * sigmoid(x) = x / (1 + exp(-x))\n__global__ void silu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x / (1.0f + expf(-x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    silu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.silu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: SiLU. Apply the SiLU activation function element-wise to an input tensor of shape (16, 16384) and data type float32, producing an output tensor of shape (262144,) and data type float32. The SiLU function is defined as: output = x / (1 + exp(-x)) for each element x in the input. The kernel must process all 262144 elements without changing the order or dimensionality of the data.", "level2_prompt": "For each element in the input array, compute the SiLU activation function: output_element = x / (1 + exp(-x)), where x is the input value.", "level3_prompt": "Compute the SiLU activation function element-wise for the input tensor."}
{"id": 208, "task_name": "SiLU", "task_description": "Compute the SiLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n// SiLU(x) = x * sigmoid(x) = x / (1 + exp(-x))\n__global__ void silu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x / (1.0f + expf(-x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    silu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.silu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the SiLU (Sigmoid-weighted Linear Unit) activation function for a GPU using CUDA. The kernel should compute the element-wise transformation defined as SiLU(x) = x / (1 + exp(-x)). The input is a 2D tensor of shape (16, 65536) with float32 values, and the output must be a tensor of identical shape and data type. Each element must be processed independently without dependencies on other elements.", "level2_prompt": "Compute the SiLU activation function element-wise. For each input value x, apply the formula: output = x / (1 + exp(-x)). The operation must be performed on a 16×65536 tensor of 32-bit floats.", "level3_prompt": "Compute the SiLU kernel on GPU using CUDA."}
{"id": 209, "task_name": "SiLU", "task_description": "Compute the SiLU kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n// SiLU(x) = x * sigmoid(x) = x / (1 + exp(-x))\n__global__ void silu_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x / (1.0f + expf(-x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    silu_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.silu(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: SiLU. Compute the SiLU function element-wise on an input tensor. The SiLU function is defined as SiLU(x) = x / (1 + exp(-x)). The input tensor has a shape of (16, 262144) and data type float32. The output tensor must have the same shape and data type, and the kernel should accurately compute the function for each element without altering the tensor structure.", "level2_prompt": "Task: SiLU. Apply the SiLU function to each element in the input tensor, where SiLU(x) is mathematically represented as x multiplied by the sigmoid of x, which simplifies to x divided by (1 + exp(-x)).", "level3_prompt": "Compute the SiLU kernel."}
{"id": 210, "task_name": "Smooth_L1_Loss", "task_description": "Compute the Smooth_L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}, {"name": "target", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n#define SMOOTH_L1_BETA 1.0f\n\n\n// Smooth L1 loss\n// Smooth L1 loss (x, y) = 0.5 * (x - y)^2 / beta, if |x - y| < beta; else: |x - y| - 0.5 * beta\n__global__ void smooth_l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float diff = fabsf(input[idx] - target[idx]);\n        if (diff < SMOOTH_L1_BETA) {\n            atomicAdd(output, 0.5f * diff * diff / SMOOTH_L1_BETA);\n        } else {\n            atomicAdd(output, diff - 0.5f * SMOOTH_L1_BETA);\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    smooth_l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.smooth_l1_loss(input_tensor, target_tensor, reduction='mean', beta=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Smooth L1 Loss kernel. The inputs are two 2D tensors named 'input' and 'target', both with shape (16, 1024) and data type float32. The output is a scalar tensor (shape (1,)) of float32. For each corresponding element in the input and target tensors, compute the absolute difference. If the absolute difference is less than 1.0, calculate the loss as 0.5 times the squared difference. Otherwise, calculate the loss as the absolute difference minus 0.5. The kernel must compute the mean of these losses over all elements, resulting in a single output value. The beta parameter is fixed at 1.0.", "level2_prompt": "Compute the mean Smooth L1 Loss between two input tensors. For each element pair, if the absolute difference is less than 1.0, use 0.5 * (difference)^2; otherwise, use |difference| - 0.5. Average these individual losses across all elements to produce a scalar output.", "level3_prompt": "Compute the Smooth_L1_Loss kernel on GPU using CUDA."}
{"id": 211, "task_name": "Smooth_L1_Loss", "task_description": "Compute the Smooth_L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}, {"name": "target", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n#define SMOOTH_L1_BETA 1.0f\n\n\n// Smooth L1 loss\n// Smooth L1 loss (x, y) = 0.5 * (x - y)^2 / beta, if |x - y| < beta; else: |x - y| - 0.5 * beta\n__global__ void smooth_l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float diff = fabsf(input[idx] - target[idx]);\n        if (diff < SMOOTH_L1_BETA) {\n            atomicAdd(output, 0.5f * diff * diff / SMOOTH_L1_BETA);\n        } else {\n            atomicAdd(output, diff - 0.5f * SMOOTH_L1_BETA);\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    smooth_l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.smooth_l1_loss(input_tensor, target_tensor, reduction='mean', beta=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Smooth L1 Loss kernel. The kernel should compute the mean Smooth L1 Loss between two input tensors of shape (16, 4096) with float32 data types. The loss for each element is defined as: if the absolute difference between input and target is less than beta (1.0), use 0.5 * (difference)^2 / beta; otherwise, use |difference| - 0.5 * beta. Sum all element losses and divide by the total number of elements (16*4096) to produce a single float32 output. Use atomic operations for accumulation.", "level2_prompt": "Compute the mean Smooth L1 Loss between two float32 tensors of shape (16, 4096). For each element pair, calculate loss as: if |input - target| < beta (1.0), loss = 0.5*(difference)^2/beta; else loss = |difference| - 0.5*beta. Sum all losses and divide by total elements (65536) to produce a single scalar output.", "level3_prompt": "Compute the Smooth_L1_Loss kernel on GPU using CUDA."}
{"id": 212, "task_name": "Smooth_L1_Loss", "task_description": "Compute the Smooth_L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}, {"name": "target", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n#define SMOOTH_L1_BETA 1.0f\n\n\n// Smooth L1 loss\n// Smooth L1 loss (x, y) = 0.5 * (x - y)^2 / beta, if |x - y| < beta; else: |x - y| - 0.5 * beta\n__global__ void smooth_l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float diff = fabsf(input[idx] - target[idx]);\n        if (diff < SMOOTH_L1_BETA) {\n            atomicAdd(output, 0.5f * diff * diff / SMOOTH_L1_BETA);\n        } else {\n            atomicAdd(output, diff - 0.5f * SMOOTH_L1_BETA);\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    smooth_l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.smooth_l1_loss(input_tensor, target_tensor, reduction='mean', beta=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Smooth L1 Loss computation. The task involves calculating the mean Smooth L1 Loss between two input tensors: 'input' and 'target', both of shape (16, 16384) and float32 data type. The loss for each element is defined as: if the absolute difference between input and target is less than 1.0, compute 0.5 * (difference squared) / 1.0; otherwise, compute the absolute difference minus 0.5. The kernel must atomically accumulate these losses into a single output scalar of shape (1,) and float32 type, which will later be divided by the total number of elements (262144) to obtain the mean loss.", "level2_prompt": "Compute the Smooth L1 Loss between two float32 tensors of shape (16, 16384). For each element, calculate the absolute difference between input and target. If this difference is below 1.0, use 0.5 * (difference²) as the element loss; otherwise, use (difference - 0.5). Sum all element losses and return the mean by dividing by the total number of elements.", "level3_prompt": "Compute the Smooth_L1_Loss kernel on GPU using CUDA."}
{"id": 213, "task_name": "Smooth_L1_Loss", "task_description": "Compute the Smooth_L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}, {"name": "target", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n#define SMOOTH_L1_BETA 1.0f\n\n\n// Smooth L1 loss\n// Smooth L1 loss (x, y) = 0.5 * (x - y)^2 / beta, if |x - y| < beta; else: |x - y| - 0.5 * beta\n__global__ void smooth_l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float diff = fabsf(input[idx] - target[idx]);\n        if (diff < SMOOTH_L1_BETA) {\n            atomicAdd(output, 0.5f * diff * diff / SMOOTH_L1_BETA);\n        } else {\n            atomicAdd(output, diff - 0.5f * SMOOTH_L1_BETA);\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    smooth_l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.smooth_l1_loss(input_tensor, target_tensor, reduction='mean', beta=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Smooth_L1_Loss. Given two input tensors named 'input' and 'target', both of data type float32 and shape (16, 65536), compute a single output tensor of shape (1,) and data type float32 representing the mean smooth L1 loss over all elements. The smooth L1 loss for each element is defined with a beta parameter of 1.0. For each element, if the absolute difference between the input and target is less than beta, the loss is 0.5 times the square of the difference divided by beta. Otherwise, the loss is the absolute difference minus 0.5 times beta. The mean loss is computed by summing the losses of all elements and then dividing by the total number of elements (16 * 65536).", "level2_prompt": "Smooth_L1_Loss: Compute the mean of the smooth L1 loss between two tensors of shape (16, 65536). For each element, the loss is defined as: if |input[i] - target[i]| < beta (1.0), then loss_i = 0.5 * (|input[i] - target[i]|)^2 / beta; else loss_i = |input[i] - target[i]| - 0.5 * beta. The output is the average of all loss_i values.", "level3_prompt": "Compute the Smooth_L1_Loss kernel on GPU using CUDA."}
{"id": 214, "task_name": "Smooth_L1_Loss", "task_description": "Compute the Smooth_L1_Loss kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}, {"name": "target", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n#define SMOOTH_L1_BETA 1.0f\n\n\n// Smooth L1 loss\n// Smooth L1 loss (x, y) = 0.5 * (x - y)^2 / beta, if |x - y| < beta; else: |x - y| - 0.5 * beta\n__global__ void smooth_l1_loss_kernel(const float* input, const float* target, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float diff = fabsf(input[idx] - target[idx]);\n        if (diff < SMOOTH_L1_BETA) {\n            atomicAdd(output, 0.5f * diff * diff / SMOOTH_L1_BETA);\n        } else {\n            atomicAdd(output, diff - 0.5f * SMOOTH_L1_BETA);\n        }\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n    int output_size = 1;\n\n    float *h_input = new float[total_size];\n    float *h_target = new float[total_size];\n    float *h_output = new float[output_size];\n\n    std::string input_file = \"./data/input.bin\";\n    std::string target_file = \"./data/target.bin\";\n    read_binary(input_file, h_input, total_size);\n    read_binary(target_file, h_target, total_size);\n\n    float *d_input, *d_target, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_target, total_size * sizeof(float));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_target, h_target, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    smooth_l1_loss_kernel<<<blocks, threads_per_block>>>(d_input, d_target, d_output, total_size);\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // mean\n    *h_output /= total_size;\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, output_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\ntarget_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 7.12\noutput_tensor = torch.nn.functional.smooth_l1_loss(input_tensor, target_tensor, reduction='mean', beta=1.0)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\ntarget_tensor.numpy().tofile(\"./data/target.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    # print(\"Max difference:\", np.max(diff))\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, 1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Smooth_L1_Loss kernel for GPU using CUDA. The kernel computes the mean Smooth L1 Loss between two input float32 tensors of shape (16, 262144) and outputs a single float32 scalar. For each element, calculate the absolute difference between input and target. If the difference is less than 1.0, compute 0.5 * (difference)^2 / 1.0; otherwise compute (difference - 0.5). Accumulate all element losses atomically and divide the total by the number of elements (16 * 262144) to produce the mean loss.", "level2_prompt": "Compute the Smooth L1 Loss between two float32 tensors of shape (16, 262144). For each element, take the absolute difference between input and target values. Apply the Smooth L1 function: if the difference is below 1.0, use 0.5 * (difference)^2; else use (difference - 0.5). Sum all element losses and divide by the total number of elements to obtain the mean loss output.", "level3_prompt": "Compute the Smooth_L1_Loss kernel on GPU using CUDA."}
{"id": 215, "task_name": "Soft_Plus", "task_description": "Compute the Soft_Plus kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// SoftPlus(x) = 1/beta * log(1 + exp(beta * x))\n__global__ void softplus_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softplus_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softplus(input_tensor, beta=1, threshold=20)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Soft_Plus kernel for CUDA. The kernel must apply the SoftPlus activation function to each element in a 16x1024 input tensor of float32 values. The output should be a float32 tensor of identical shape. The SoftPlus function is defined as SoftPlus(x) = (1/β) * log(1 + exp(β*x)), with β=1.0. For numerical stability, when β*x exceeds a threshold of 20.0, the output should default to x instead of computing the full formula.", "level2_prompt": "Compute the SoftPlus activation function element-wise on a 2D tensor. For each input value x, apply: if β*x > threshold (where β=1.0 and threshold=20.0), output x; otherwise output (1/β)*log(1 + exp(β*x)).", "level3_prompt": "Compute the Soft_Plus kernel on GPU using CUDA."}
{"id": 216, "task_name": "Soft_Plus", "task_description": "Compute the Soft_Plus kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// SoftPlus(x) = 1/beta * log(1 + exp(beta * x))\n__global__ void softplus_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softplus_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softplus(input_tensor, beta=1, threshold=20)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Soft_Plus. Implement a CUDA kernel that computes the SoftPlus activation function element-wise on a 2D input tensor of shape (16, 4096) with float32 data type. The SoftPlus function is defined as: for each element x, if (beta * x) > threshold (with beta=1.0 and threshold=20.0), then output x; otherwise, output (1/beta) * log(1 + exp(beta * x)). The output must be a tensor of the same shape and type. The kernel must handle each element independently and use the threshold to avoid numerical overflow.", "level2_prompt": "Task: Soft_Plus. For each element x in a 2D float32 tensor of shape (16, 4096), compute: if x > 20.0, then output x; else output log(1 + exp(x)).", "level3_prompt": "Apply the SoftPlus activation function element-wise to the input tensor."}
{"id": 217, "task_name": "Soft_Plus", "task_description": "Compute the Soft_Plus kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// SoftPlus(x) = 1/beta * log(1 + exp(beta * x))\n__global__ void softplus_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softplus_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softplus(input_tensor, beta=1, threshold=20)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Soft_Plus function. The input is a 2D tensor of float32 values with shape (16, 16384). The output should be a 1D tensor of float32 values with 262144 elements. For each element in the input, compute the SoftPlus activation: if the element multiplied by 1.0 exceeds 20.0, output the element directly; otherwise, apply the formula log(1 + exp(1.0 * element)). The kernel must process all elements independently.", "level2_prompt": "Apply the SoftPlus activation element-wise to an input tensor. For each element x, if x > 20.0, output x; otherwise, output log(1 + exp(x)).", "level3_prompt": "Compute the Soft_Plus kernel on GPU using CUDA."}
{"id": 218, "task_name": "Soft_Plus", "task_description": "Compute the Soft_Plus kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// SoftPlus(x) = 1/beta * log(1 + exp(beta * x))\n__global__ void softplus_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softplus_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softplus(input_tensor, beta=1, threshold=20)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Soft_Plus kernel for GPU computation. The kernel should compute the SoftPlus function for each element in a 16x65536 input tensor of 32-bit floating-point values. The SoftPlus function is defined as: when beta*x exceeds the threshold (20.0), output x; otherwise, output (1/beta) * log(1 + exp(beta*x)), where beta is 1.0. The output must be a tensor of identical shape and data type as the input.", "level2_prompt": "Perform element-wise SoftPlus transformation on a 16x65536 float32 tensor. For each element x, if beta*x > threshold (20.0), return x; else return (1/beta)*log(1+exp(beta*x)) using beta=1.0.", "level3_prompt": "Compute the Soft_Plus kernel on GPU using CUDA."}
{"id": 219, "task_name": "Soft_Plus", "task_description": "Compute the Soft_Plus kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define SOFTPLUS_BETA 1.0f\n#define SOFTPLUS_THRESHOLD 20.0f\n\n// SoftPlus(x) = 1/beta * log(1 + exp(beta * x))\n__global__ void softplus_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x * SOFTPLUS_BETA > SOFTPLUS_THRESHOLD) ? x : (1.0f / SOFTPLUS_BETA * log1pf(expf(SOFTPLUS_BETA * x)));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softplus_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softplus(input_tensor, beta=1, threshold=20)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Soft_Plus. Implement a GPU kernel that computes the SoftPlus activation function element-wise on a 2D input tensor of shape (16, 262144) containing float32 values. The output must have identical shape and data type as the input. For each element x, if β*x exceeds 20.0 (with β=1.0), output x directly; otherwise compute (1/β)*log(1 + exp(β*x)). The kernel must handle all 4,194,304 elements independently.", "level2_prompt": "Task: Soft_Plus. For each element x in a float32 tensor of shape (16, 262144), compute y = x if βx > 20.0, else y = (1/β)ln(1 + exp(βx)), where β=1.0. Output results to a tensor matching input dimensions.", "level3_prompt": "Compute the Soft_Plus activation function element-wise on an input tensor."}
{"id": 220, "task_name": "Soft_Shrink", "task_description": "Compute the Soft_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n#define SOFTSHRINK_LAMBDA 0.5f\n\n// SoftShrink(x) = x - lambda (x > lambda), x + lambda (x < -lambda), 0 (otherwise)\n__global__ void softshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > SOFTSHRINK_LAMBDA) ? (x - SOFTSHRINK_LAMBDA) :\n                      (x < -SOFTSHRINK_LAMBDA) ? (x + SOFTSHRINK_LAMBDA) : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Soft_Shrink kernel. For each element in a 16x1024 float32 input tensor, apply the SoftShrink function with lambda=0.5: output = (input - 0.5) if input > 0.5, (input + 0.5) if input < -0.5, and 0 otherwise. Output must be a 16x1024 float32 tensor with results computed independently for each element.", "level2_prompt": "Apply element-wise SoftShrink transformation. For each value x in the input tensor, compute: if x > 0.5, output x - 0.5; if x < -0.5, output x + 0.5; else output 0.", "level3_prompt": "Compute the Soft_Shrink function on the input tensor."}
{"id": 221, "task_name": "Soft_Shrink", "task_description": "Compute the Soft_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n#define SOFTSHRINK_LAMBDA 0.5f\n\n// SoftShrink(x) = x - lambda (x > lambda), x + lambda (x < -lambda), 0 (otherwise)\n__global__ void softshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > SOFTSHRINK_LAMBDA) ? (x - SOFTSHRINK_LAMBDA) :\n                      (x < -SOFTSHRINK_LAMBDA) ? (x + SOFTSHRINK_LAMBDA) : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Soft_Shrink operation on a GPU using CUDA. The kernel should process a 2D input tensor of shape (16, 4096) with float32 data type. For each element, if the value is greater than 0.5, subtract 0.5 from it; if the value is less than -0.5, add 0.5 to it; otherwise, output 0. The output must be a tensor of identical shape and data type as the input. All operations must be element-wise and independent.", "level2_prompt": "Apply the Soft Shrink function element-wise to a tensor. For each value x: output = (x - 0.5) if x > 0.5, (x + 0.5) if x < -0.5, and 0 otherwise.", "level3_prompt": "Implement the Soft Shrink operation."}
{"id": 222, "task_name": "Soft_Shrink", "task_description": "Compute the Soft_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n#define SOFTSHRINK_LAMBDA 0.5f\n\n// SoftShrink(x) = x - lambda (x > lambda), x + lambda (x < -lambda), 0 (otherwise)\n__global__ void softshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > SOFTSHRINK_LAMBDA) ? (x - SOFTSHRINK_LAMBDA) :\n                      (x < -SOFTSHRINK_LAMBDA) ? (x + SOFTSHRINK_LAMBDA) : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Soft_Shrink. The kernel should apply the SoftShrink function element-wise to the input tensor. For each element x, if x is greater than 0.5, output x minus 0.5; if x is less than -0.5, output x plus 0.5; otherwise, output 0.0. The input is a tensor of shape (16, 16384) with float32 data type, and the output must have the same shape and data type. Constraints: the lambda parameter is fixed at 0.5, the computation must be independent for each element, and the output tensor must match the input dimensions exactly.", "level2_prompt": "Task: Soft_Shrink. The algorithm applies the SoftShrink function to each element of the input tensor. Mathematically, for a scalar x, the function is defined as: f(x) = x - λ if x > λ, f(x) = x + λ if x < -λ, and f(x) = 0 otherwise, where λ = 0.5. This is performed element-wise across the entire tensor.", "level3_prompt": "Task: Soft_Shrink. Apply the SoftShrink function to the input tensor."}
{"id": 223, "task_name": "Soft_Shrink", "task_description": "Compute the Soft_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n#define SOFTSHRINK_LAMBDA 0.5f\n\n// SoftShrink(x) = x - lambda (x > lambda), x + lambda (x < -lambda), 0 (otherwise)\n__global__ void softshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > SOFTSHRINK_LAMBDA) ? (x - SOFTSHRINK_LAMBDA) :\n                      (x < -SOFTSHRINK_LAMBDA) ? (x + SOFTSHRINK_LAMBDA) : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Soft_Shrink kernel for GPU computation. The kernel processes a 2D input tensor of shape (16, 65536) with float32 data type, applying the SoftShrink function element-wise. For each element x, if x > 0.5, output x - 0.5; if x < -0.5, output x + 0.5; otherwise output 0. The output must be a float32 tensor of identical shape (16, 65536), with each element transformed independently.", "level2_prompt": "Perform the SoftShrink operation on each element of a 2D tensor. For element x, output = (x - 0.5) if x > 0.5, (x + 0.5) if x < -0.5, and 0 otherwise. The input and output tensors have dimensions 16×65536 and float32 datatype.", "level3_prompt": "Compute the Soft_Shrink kernel on GPU using CUDA."}
{"id": 224, "task_name": "Soft_Shrink", "task_description": "Compute the Soft_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n#define SOFTSHRINK_LAMBDA 0.5f\n\n// SoftShrink(x) = x - lambda (x > lambda), x + lambda (x < -lambda), 0 (otherwise)\n__global__ void softshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = (x > SOFTSHRINK_LAMBDA) ? (x - SOFTSHRINK_LAMBDA) :\n                      (x < -SOFTSHRINK_LAMBDA) ? (x + SOFTSHRINK_LAMBDA) : 0.0f;\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    softshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.softshrink(input_tensor, lambd=0.5)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Soft_Shrink kernel for a 2D tensor of shape (16, 262144) with float32 data type. For each element in the input tensor, apply the Soft Shrink function: if the element value exceeds 0.5, subtract 0.5; if less than -0.5, add 0.5; otherwise output zero. The lambda parameter is fixed at 0.5, and each element must be processed independently.", "level2_prompt": "Apply element-wise Soft Shrink transformation: for each value x, output x-0.5 when x>0.5, x+0.5 when x<-0.5, and 0 otherwise.", "level3_prompt": "Compute the Soft_Shrink kernel on GPU using CUDA."}
{"id": 225, "task_name": "LayerNorm", "task_description": "Compute the LayerNorm kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4, 64, 64)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define BATCH_SIZE 16\n#define FEATURES 4\n#define EPS 1e-5f\n#define DIM 64\n\n__global__ void layer_norm_kernel(float* input, float* output, int dim1, int dim2) {\n    int batch = blockIdx.x;\n    int d1 = blockIdx.y;\n    int d2 = blockIdx.z;\n    int feature = threadIdx.x;\n\n    __shared__ float mean_shared;\n    __shared__ float var_shared;\n\n    // Step 1: compute mean\n    float sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        sum += input[idx];\n    }\n    float mean = sum / FEATURES;\n    if (feature == 0) mean_shared = mean;\n    __syncthreads();\n\n    // Step 2: compute variance\n    float sq_sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        float diff = input[idx] - mean_shared;\n        sq_sum += diff * diff;\n    }\n    float var = sq_sum / FEATURES;\n    if (feature == 0) var_shared = var;\n    __syncthreads();\n\n    // Step 3: normalize\n    int idx = ((batch * FEATURES + feature) * dim1 + d1) * dim2 + d2;\n    float x = input[idx];\n    output[idx] = (x - mean_shared) / sqrtf(var_shared + EPS);\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int size = BATCH_SIZE * FEATURES * DIM * DIM;\n    size_t bytes = size * sizeof(float);\n\n    float* h_input = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"data/input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    dim3 grid(BATCH_SIZE, DIM, DIM);\n    dim3 block(FEATURES);\n    layer_norm_kernel<<<grid, block>>>(d_input, d_output, DIM, DIM);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/output.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn as nn\nimport os\n\nbatch_size = 16\nfeatures = 4\ndim = 64\n\nseed = 45\ntorch.manual_seed(seed)\n\nx = torch.randn(batch_size, features, dim, dim, dtype=torch.float32)  # shape: [B, C, H, W]\nx_perm = x.permute(0, 2, 3, 1).contiguous()  # shape: [B, H, W, C]\n\nln = nn.LayerNorm(normalized_shape=features, eps=1e-5)\ny_perm = ln(x_perm)  # same shape\n\ny = y_perm.permute(0, 3, 1, 2).contiguous()  # back to [B, C, H, W]\n\nos.makedirs(\"data\", exist_ok=True)\nx.detach().cpu().numpy().astype('float32').tofile(\"data/input.bin\")\ny.detach().cpu().numpy().astype('float32').tofile(\"data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    FEATURES = 4\n    DIM = 64\n\n    size = BATCH_SIZE * FEATURES * DIM * DIM\n    out_file = \"data/output.bin\"\n    ref_file = \"data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for Layer Normalization. The kernel should normalize input tensor values across the feature dimension for each spatial location independently. Input is a 4D tensor of shape (16, 4, 64, 64) with float32 data type, representing batch size, features, height, and width dimensions. Output must have identical shape and data type. The kernel must compute mean and variance across the feature dimension for each spatial location, then normalize each value using (x - mean) / sqrt(variance + 1e-5). Shared memory should be used for mean and variance synchronization between threads.", "level2_prompt": "Perform Layer Normalization on a 4D tensor. For each spatial position (height and width) in every batch element, calculate the mean and variance across all features. Then normalize each feature value at that position using the formula: normalized_value = (value - mean) / sqrt(variance + epsilon) where epsilon is 1e-5. The computation requires synchronization for mean and variance values across threads processing the same spatial position.", "level3_prompt": "Compute the LayerNorm kernel on GPU using CUDA."}
{"id": 226, "task_name": "LayerNorm", "task_description": "Compute the LayerNorm kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4, 128, 128)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4, 128, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define BATCH_SIZE 16\n#define FEATURES 4\n#define EPS 1e-5f\n#define DIM 128\n\n__global__ void layer_norm_kernel(float* input, float* output, int dim1, int dim2) {\n    int batch = blockIdx.x;\n    int d1 = blockIdx.y;\n    int d2 = blockIdx.z;\n    int feature = threadIdx.x;\n\n    __shared__ float mean_shared;\n    __shared__ float var_shared;\n\n    // Step 1: compute mean\n    float sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        sum += input[idx];\n    }\n    float mean = sum / FEATURES;\n    if (feature == 0) mean_shared = mean;\n    __syncthreads();\n\n    // Step 2: compute variance\n    float sq_sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        float diff = input[idx] - mean_shared;\n        sq_sum += diff * diff;\n    }\n    float var = sq_sum / FEATURES;\n    if (feature == 0) var_shared = var;\n    __syncthreads();\n\n    // Step 3: normalize\n    int idx = ((batch * FEATURES + feature) * dim1 + d1) * dim2 + d2;\n    float x = input[idx];\n    output[idx] = (x - mean_shared) / sqrtf(var_shared + EPS);\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int size = BATCH_SIZE * FEATURES * DIM * DIM;\n    size_t bytes = size * sizeof(float);\n\n    float* h_input = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"data/input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    dim3 grid(BATCH_SIZE, DIM, DIM);\n    dim3 block(FEATURES);\n    layer_norm_kernel<<<grid, block>>>(d_input, d_output, DIM, DIM);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/output.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn as nn\nimport os\n\nbatch_size = 16\nfeatures = 4\ndim = 128\n\nseed = 45\ntorch.manual_seed(seed)\n\nx = torch.randn(batch_size, features, dim, dim, dtype=torch.float32)  # shape: [B, C, H, W]\nx_perm = x.permute(0, 2, 3, 1).contiguous()  # shape: [B, H, W, C]\n\nln = nn.LayerNorm(normalized_shape=features, eps=1e-5)\ny_perm = ln(x_perm)  # same shape\n\ny = y_perm.permute(0, 3, 1, 2).contiguous()  # back to [B, C, H, W]\n\nos.makedirs(\"data\", exist_ok=True)\nx.detach().cpu().numpy().astype('float32').tofile(\"data/input.bin\")\ny.detach().cpu().numpy().astype('float32').tofile(\"data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    FEATURES = 4\n    DIM = 128\n\n    size = BATCH_SIZE * FEATURES * DIM * DIM\n    out_file = \"data/output.bin\"\n    ref_file = \"data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for Layer Normalization (LayerNorm). The kernel should normalize each spatial position across the feature dimension. The input is a 4D tensor with dimensions (batch_size, features, height, width) = (16, 4, 128, 128) and data type float32. The output must have the same shape and data type as the input. The kernel must compute the mean and variance across the feature dimension for each spatial position (height, width) and batch index, then apply normalization using the formula (x - mean) / sqrt(variance + epsilon), where epsilon is 1e-5. All operations must preserve the input's structure and maintain numerical stability.", "level2_prompt": "Design a LayerNorm CUDA kernel that performs normalization across the feature dimension. For each spatial position (height, width) and batch index, calculate the mean and variance of all feature values. Then normalize each feature value using the formula: normalized_value = (value - mean) / sqrt(variance + epsilon), where epsilon is 1e-5. The input and output are 4D tensors with dimensions (16, 4, 128, 128) and float32 data type.", "level3_prompt": "Compute the LayerNorm kernel on GPU using CUDA."}
{"id": 227, "task_name": "LayerNorm", "task_description": "Compute the LayerNorm kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4, 256, 256)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4, 256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define BATCH_SIZE 16\n#define FEATURES 4\n#define EPS 1e-5f\n#define DIM 256\n\n__global__ void layer_norm_kernel(float* input, float* output, int dim1, int dim2) {\n    int batch = blockIdx.x;\n    int d1 = blockIdx.y;\n    int d2 = blockIdx.z;\n    int feature = threadIdx.x;\n\n    __shared__ float mean_shared;\n    __shared__ float var_shared;\n\n    // Step 1: compute mean\n    float sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        sum += input[idx];\n    }\n    float mean = sum / FEATURES;\n    if (feature == 0) mean_shared = mean;\n    __syncthreads();\n\n    // Step 2: compute variance\n    float sq_sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        float diff = input[idx] - mean_shared;\n        sq_sum += diff * diff;\n    }\n    float var = sq_sum / FEATURES;\n    if (feature == 0) var_shared = var;\n    __syncthreads();\n\n    // Step 3: normalize\n    int idx = ((batch * FEATURES + feature) * dim1 + d1) * dim2 + d2;\n    float x = input[idx];\n    output[idx] = (x - mean_shared) / sqrtf(var_shared + EPS);\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int size = BATCH_SIZE * FEATURES * DIM * DIM;\n    size_t bytes = size * sizeof(float);\n\n    float* h_input = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"data/input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    dim3 grid(BATCH_SIZE, DIM, DIM);\n    dim3 block(FEATURES);\n    layer_norm_kernel<<<grid, block>>>(d_input, d_output, DIM, DIM);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/output.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn as nn\nimport os\n\nbatch_size = 16\nfeatures = 4\ndim = 256\n\nseed = 45\ntorch.manual_seed(seed)\n\nx = torch.randn(batch_size, features, dim, dim, dtype=torch.float32)  # shape: [B, C, H, W]\nx_perm = x.permute(0, 2, 3, 1).contiguous()  # shape: [B, H, W, C]\n\nln = nn.LayerNorm(normalized_shape=features, eps=1e-5)\ny_perm = ln(x_perm)  # same shape\n\ny = y_perm.permute(0, 3, 1, 2).contiguous()  # back to [B, C, H, W]\n\nos.makedirs(\"data\", exist_ok=True)\nx.detach().cpu().numpy().astype('float32').tofile(\"data/input.bin\")\ny.detach().cpu().numpy().astype('float32').tofile(\"data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    FEATURES = 4\n    DIM = 256\n\n    size = BATCH_SIZE * FEATURES * DIM * DIM\n    out_file = \"data/output.bin\"\n    ref_file = \"data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: LayerNorm. Compute layer normalization for a 4D input tensor with shape (16, 4, 256, 256) and float32 data type. The kernel should normalize over the feature dimension (size 4) for each batch and each spatial position (height and width). Specifically, for each batch, height, and width index, compute the mean and variance of the features at that position, then apply the normalization formula: (input - mean) / sqrt(variance + epsilon), where epsilon is 1e-5 for numerical stability. The output must have the same shape (16, 4, 256, 256) and float32 data type as the input.", "level2_prompt": "Task name: LayerNorm. The algorithm involves, for each batch index, height index, and width index, calculating the mean and variance of the feature values at that coordinate. Each feature value is then normalized by subtracting the mean and dividing by the square root of the variance plus a small epsilon to achieve zero mean and unit variance per spatial location.", "level3_prompt": "Compute the LayerNorm kernel on GPU using CUDA."}
{"id": 228, "task_name": "LayerNorm", "task_description": "Compute the LayerNorm kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4, 512, 512)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4, 512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define BATCH_SIZE 16\n#define FEATURES 4\n#define EPS 1e-5f\n#define DIM 512\n\n__global__ void layer_norm_kernel(float* input, float* output, int dim1, int dim2) {\n    int batch = blockIdx.x;\n    int d1 = blockIdx.y;\n    int d2 = blockIdx.z;\n    int feature = threadIdx.x;\n\n    __shared__ float mean_shared;\n    __shared__ float var_shared;\n\n    // Step 1: compute mean\n    float sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        sum += input[idx];\n    }\n    float mean = sum / FEATURES;\n    if (feature == 0) mean_shared = mean;\n    __syncthreads();\n\n    // Step 2: compute variance\n    float sq_sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        float diff = input[idx] - mean_shared;\n        sq_sum += diff * diff;\n    }\n    float var = sq_sum / FEATURES;\n    if (feature == 0) var_shared = var;\n    __syncthreads();\n\n    // Step 3: normalize\n    int idx = ((batch * FEATURES + feature) * dim1 + d1) * dim2 + d2;\n    float x = input[idx];\n    output[idx] = (x - mean_shared) / sqrtf(var_shared + EPS);\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int size = BATCH_SIZE * FEATURES * DIM * DIM;\n    size_t bytes = size * sizeof(float);\n\n    float* h_input = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"data/input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    dim3 grid(BATCH_SIZE, DIM, DIM);\n    dim3 block(FEATURES);\n    layer_norm_kernel<<<grid, block>>>(d_input, d_output, DIM, DIM);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/output.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn as nn\nimport os\n\nbatch_size = 16\nfeatures = 4\ndim = 512\n\nseed = 45\ntorch.manual_seed(seed)\n\nx = torch.randn(batch_size, features, dim, dim, dtype=torch.float32)  # shape: [B, C, H, W]\nx_perm = x.permute(0, 2, 3, 1).contiguous()  # shape: [B, H, W, C]\n\nln = nn.LayerNorm(normalized_shape=features, eps=1e-5)\ny_perm = ln(x_perm)  # same shape\n\ny = y_perm.permute(0, 3, 1, 2).contiguous()  # back to [B, C, H, W]\n\nos.makedirs(\"data\", exist_ok=True)\nx.detach().cpu().numpy().astype('float32').tofile(\"data/input.bin\")\ny.detach().cpu().numpy().astype('float32').tofile(\"data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    FEATURES = 4\n    DIM = 512\n\n    size = BATCH_SIZE * FEATURES * DIM * DIM\n    out_file = \"data/output.bin\"\n    ref_file = \"data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a LayerNorm kernel for GPU using CUDA. The kernel processes a 4D input tensor of shape (16, 4, 512, 512) with float32 values. For each spatial position (height and width) across all batches, independently compute the mean and variance across the feature dimension (size 4). Normalize each feature value by subtracting the mean and dividing by the square root of the variance plus a small epsilon (1e-5) to prevent division by zero. The output tensor must have identical shape and data type as the input. Ensure thread synchronization when sharing computed mean and variance values across threads processing the same spatial position.", "level2_prompt": "Perform layer normalization on a 4D tensor. For every batch, height, and width index, calculate the mean μ and variance σ² of the 4 features at that spatial position. Normalize each feature value x using (x - μ) / √(σ² + ε), where ε=1e-5. Input and output tensors have dimensions (16, 4, 512, 512) with float32 precision.", "level3_prompt": "Compute the LayerNorm kernel on GPU using CUDA."}
{"id": 229, "task_name": "LayerNorm", "task_description": "Compute the LayerNorm kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4, 1024, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4, 1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define BATCH_SIZE 16\n#define FEATURES 4\n#define EPS 1e-5f\n#define DIM 1024\n\n__global__ void layer_norm_kernel(float* input, float* output, int dim1, int dim2) {\n    int batch = blockIdx.x;\n    int d1 = blockIdx.y;\n    int d2 = blockIdx.z;\n    int feature = threadIdx.x;\n\n    __shared__ float mean_shared;\n    __shared__ float var_shared;\n\n    // Step 1: compute mean\n    float sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        sum += input[idx];\n    }\n    float mean = sum / FEATURES;\n    if (feature == 0) mean_shared = mean;\n    __syncthreads();\n\n    // Step 2: compute variance\n    float sq_sum = 0.0f;\n    for (int f = 0; f < FEATURES; ++f) {\n        int idx = ((batch * FEATURES + f) * dim1 + d1) * dim2 + d2;\n        float diff = input[idx] - mean_shared;\n        sq_sum += diff * diff;\n    }\n    float var = sq_sum / FEATURES;\n    if (feature == 0) var_shared = var;\n    __syncthreads();\n\n    // Step 3: normalize\n    int idx = ((batch * FEATURES + feature) * dim1 + d1) * dim2 + d2;\n    float x = input[idx];\n    output[idx] = (x - mean_shared) / sqrtf(var_shared + EPS);\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int size = BATCH_SIZE * FEATURES * DIM * DIM;\n    size_t bytes = size * sizeof(float);\n\n    float* h_input = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"data/input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n\n    dim3 grid(BATCH_SIZE, DIM, DIM);\n    dim3 block(FEATURES);\n    layer_norm_kernel<<<grid, block>>>(d_input, d_output, DIM, DIM);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/output.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport torch.nn as nn\nimport os\n\nbatch_size = 16\nfeatures = 4\ndim = 1024\n\nseed = 45\ntorch.manual_seed(seed)\n\nx = torch.randn(batch_size, features, dim, dim, dtype=torch.float32)  # shape: [B, C, H, W]\nx_perm = x.permute(0, 2, 3, 1).contiguous()  # shape: [B, H, W, C]\n\nln = nn.LayerNorm(normalized_shape=features, eps=1e-5)\ny_perm = ln(x_perm)  # same shape\n\ny = y_perm.permute(0, 3, 1, 2).contiguous()  # back to [B, C, H, W]\n\nos.makedirs(\"data\", exist_ok=True)\nx.detach().cpu().numpy().astype('float32').tofile(\"data/input.bin\")\ny.detach().cpu().numpy().astype('float32').tofile(\"data/reference.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    FEATURES = 4\n    DIM = 1024\n\n    size = BATCH_SIZE * FEATURES * DIM * DIM\n    out_file = \"data/output.bin\"\n    ref_file = \"data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a LayerNorm CUDA kernel. The kernel should perform layer normalization across the feature dimension for a 4D input tensor with shape (16, 4, 1024, 1024) of float32 values. For each spatial position (height and width) in every batch element, compute the mean and variance across the 4 feature channels. Normalize each feature value using the formula (x - mean) / sqrt(variance + 1e-5). The output must have the same shape and dtype as the input. The kernel must handle batch and spatial dimensions independently.", "level2_prompt": "Implement Layer Normalization. For each batch element and spatial location (H, W), compute the mean and variance across the feature channels (C=4). Then normalize each feature value at that spatial location using: normalized_value = (value - mean) / sqrt(variance + epsilon) where epsilon=1e-5.", "level3_prompt": "Compute the LayerNorm kernel on GPU using CUDA."}
{"id": 230, "task_name": "Tanh", "task_description": "Compute the Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n__global__ void tanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = tanhf(x);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanh(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a GPU kernel to compute the hyperbolic tangent function (tanh) for each element in a 2D input tensor. The input tensor has dimensions (16, 1024) with float32 data type. The output tensor must have identical dimensions (16, 1024) and float32 data type. Each output element should be the tanh of the corresponding input element, computed as tanh(x) = sinh(x)/cosh(x). The computation must be performed element-wise with no dependencies between different elements.", "level2_prompt": "Compute the hyperbolic tangent function for each element in a 16x1024 float32 matrix. The operation should be applied independently to every element, where each output element is the tanh of its corresponding input element.", "level3_prompt": "Compute the Tanh kernel on GPU using CUDA."}
{"id": 231, "task_name": "Tanh", "task_description": "Compute the Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n__global__ void tanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = tanhf(x);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanh(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Tanh task. The kernel should compute the hyperbolic tangent function element-wise on a 2D input tensor of shape (16, 4096) with float32 data type. The output tensor must have identical shape and data type, where each element is tanh(input_element). All elements must be processed independently and maintain mathematical precision.", "level2_prompt": "Compute the hyperbolic tangent function for each element in a (16, 4096) float32 tensor. For every input value x, output tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}). The operation is applied independently to all elements in the tensor.", "level3_prompt": "Compute the Tanh kernel on GPU using CUDA."}
{"id": 232, "task_name": "Tanh", "task_description": "Compute the Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n__global__ void tanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = tanhf(x);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanh(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Tanh function. The kernel should compute the hyperbolic tangent for each element of an input tensor with shape (16, 16384) and data type float32. The output tensor must have identical shape and data type. Each output element must be the tanh of the corresponding input element, satisfying the mathematical definition tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}). The kernel must process all 262,144 elements independently.", "level2_prompt": "Create a CUDA implementation for element-wise hyperbolic tangent computation. Given an input tensor of size 16×16384, compute tanh(x) for each element x, producing an output tensor of the same dimensions. The tanh function must be accurately implemented using its standard mathematical formula.", "level3_prompt": "Compute the Tanh kernel on GPU using CUDA."}
{"id": 233, "task_name": "Tanh", "task_description": "Compute the Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n__global__ void tanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = tanhf(x);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanh(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Tanh. Compute the element-wise hyperbolic tangent (tanh) function for a 2D input tensor of shape (16, 65536) containing 32-bit floating-point values. The output tensor must have the same shape and data type as the input, with each element transformed independently. The output values must be constrained to the range [-1, 1].", "level2_prompt": "Task: Tanh. For each element in the input tensor, apply the hyperbolic tangent function, defined as tanh(x) = (e^{2x} - 1)/(e^{2x} + 1). The operation must be performed independently on every element without altering the tensor's dimensions.", "level3_prompt": "Compute the Tanh kernel on GPU using CUDA."}
{"id": 234, "task_name": "Tanh", "task_description": "Compute the Tanh kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 262144)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n__global__ void tanh_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = tanhf(x);\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanh_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanh(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel to compute the hyperbolic tangent (Tanh) function. The kernel must process a 2D input tensor of shape (16, 262144) with float32 data type. The output tensor must have the same shape and data type as the input. Each element in the output tensor should be the Tanh of the corresponding element in the input tensor. The kernel must be thread-safe, with no dependencies between threads, and achieve numerical accuracy within a tolerance of 1e-5 compared to a reference implementation.", "level2_prompt": "Compute the Tanh function element-wise on a float32 tensor of dimensions 16x262144. For each element x in the input tensor, the output element is defined mathematically as tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}). The computation must be performed independently for each element.", "level3_prompt": "Compute the Tanh kernel on GPU using CUDA."}
{"id": 235, "task_name": "Tanh_Shrink", "task_description": "Compute the Tanh_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 1024)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 1024)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 1024\n\n\n// TanhShrink(x) = x - tanh(x)\n__global__ void tanhshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - (tanhf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanhshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 1024\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanhshrink(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 1024\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Tanh_Shrink task. The kernel must compute the Tanh Shrink function element-wise for each value in a 2D input tensor of shape (16, 1024) and data type float32. The Tanh Shrink function is defined as output = input - tanh(input), where tanh is the hyperbolic tangent function applied to each input element. The output must be a tensor of the same shape (16, 1024) and float32 data type. Constraints include processing all elements of the input tensor without altering the shape, ensuring each output element depends only on the corresponding input element, and handling the data efficiently.", "level2_prompt": "Tanh_Shrink: For each element in the input tensor, compute the result as the element value minus the hyperbolic tangent of that element. This is a pointwise operation applied independently to every element in the tensor.", "level3_prompt": "Compute the Tanh_Shrink kernel on GPU using CUDA."}
{"id": 236, "task_name": "Tanh_Shrink", "task_description": "Compute the Tanh_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 4096)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 4096)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 4096\n\n\n// TanhShrink(x) = x - tanh(x)\n__global__ void tanhshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - (tanhf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanhshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 4096\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanhshrink(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 4096\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named Tanh_Shrink that computes the Tanh Shrink function for each element in a 2D input tensor. The input tensor has dimensions (16, 4096) and uses float32 data type. The output tensor must have identical shape (16, 4096) and data type. The Tanh Shrink function is defined as output = x - tanh(x), where x is an element from the input tensor. Each element must be processed independently with no data dependencies between computations.", "level2_prompt": "Create a Tanh_Shrink operation where every element in a 2D tensor undergoes the transformation: element - tanh(element). The input tensor has dimensions (16, 4096) and float32 data type. The output must maintain the same shape and data type. This is a pointwise operation with no inter-element dependencies.", "level3_prompt": "Compute the Tanh_Shrink kernel on GPU using CUDA."}
{"id": 237, "task_name": "Tanh_Shrink", "task_description": "Compute the Tanh_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 16384)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 16384\n\n\n// TanhShrink(x) = x - tanh(x)\n__global__ void tanhshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - (tanhf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanhshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 16384\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanhshrink(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 16384\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Tanh_Shrink operation. The kernel should compute the Tanh Shrink function, defined as output = x - tanh(x), for each element in a 2D input tensor of shape (16, 16384) containing float32 values. The output tensor must have identical shape and data type. The kernel must process all 262144 elements independently without changing input dimensions.", "level2_prompt": "Compute the Tanh Shrink function element-wise for a 2D float32 tensor. Each output element is calculated as the input element minus its hyperbolic tangent.", "level3_prompt": "Compute the Tanh_Shrink kernel on GPU using CUDA."}
{"id": 238, "task_name": "Tanh_Shrink", "task_description": "Compute the Tanh_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 65536)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(16, 65536)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 65536\n\n\n// TanhShrink(x) = x - tanh(x)\n__global__ void tanhshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - (tanhf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanhshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 65536\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanhshrink(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 65536\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Tanh_Shrink CUDA kernel. The kernel should compute the Tanh Shrink function for each element in a 2D input tensor of shape (16, 65536) with float32 data type. The output tensor must have the same shape and data type, with each element calculated as the input value minus the hyperbolic tangent of the input value. The kernel must process all elements independently and efficiently on GPU.", "level2_prompt": "Compute the Tanh Shrink function element-wise. For each element x in the input tensor, the output element is defined as y = x - tanh(x).", "level3_prompt": "Compute the Tanh_Shrink kernel on GPU."}
{"id": 239, "task_name": "Tanh_Shrink", "task_description": "Compute the Tanh_Shrink kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "float32", "shape": "(16, 262144)"}], "outputs": [{"name": "output", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define DIM 262144\n\n\n// TanhShrink(x) = x - tanh(x)\n__global__ void tanhshrink_kernel(const float* input, float* output, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        float x = input[idx];\n        output[idx] = x - (tanhf(x));\n    }\n}\n\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n\nint main() {\n    int total_size = BATCH_SIZE * DIM;\n\n    float *h_input = new float[total_size];\n    float *h_output = new float[total_size];\n\n    std::string input_file = \"./data/input.bin\";\n    read_binary(input_file, h_input, total_size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, total_size * sizeof(float));\n    cudaMalloc(&d_output, total_size * sizeof(float));\n    cudaMemcpy(d_input, h_input, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n\n    tanhshrink_kernel<<<blocks, threads_per_block>>>(d_input, d_output, total_size);\n    cudaMemcpy(h_output, d_output, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/output.bin\";\n    write_binary(out_file, h_output, total_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nM = 262144\nBATCH_SIZE = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\ninput_tensor = torch.randn(BATCH_SIZE, M, dtype=torch.float32) * 71.2\noutput_tensor = torch.nn.functional.tanhshrink(input_tensor)\n\nos.makedirs(\"./data\", exist_ok=True)\ninput_tensor.numpy().tofile(\"./data/input.bin\")\noutput_tensor.numpy().tofile(\"./data/reference.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n    \nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    DIM = 262144\n    total_size = BATCH_SIZE * DIM\n\n    out_file = \"./data/output.bin\"\n    ref_file = \"./data/reference.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Tanh_Shrink function as a CUDA kernel. The input is a 2D tensor of 16 rows and 262144 columns, with float32 data type. The output is a 1D tensor of 4194304 float32 elements. The Tanh_Shrink function is defined as f(x) = x - tanh(x). This operation must be applied element-wise, meaning each output element depends solely on the corresponding input element. The kernel must process all 4194304 elements independently.", "level2_prompt": "Apply the Tanh_Shrink function, defined as f(x) = x - tanh(x), to every element of the input tensor independently.", "level3_prompt": "Compute the Tanh_Shrink kernel."}
{"id": 240, "task_name": "Nearest_Neighbor", "task_description": "Compute the Nearest_Neighbor kernel on GPU using CUDA.", "inputs": [{"name": "points", "dtype": "float32", "shape": "(512, 3)"}], "outputs": [{"name": "indices_out", "dtype": "int32", "shape": "(512,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define N 512\n#define DIM 3\n\n__global__ void nearest_kernel(const float* pts, int* indices, int n) {\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= n) return;\n\n    float xi = pts[i * DIM + 0];\n    float yi = pts[i * DIM + 1];\n    float zi = pts[i * DIM + 2];\n\n    float best = 1e30f;\n    int best_j = -1;\n\n    for (int j = 0; j < n; ++j) {\n        if (j == i) continue;\n        float dx = xi - pts[j * DIM + 0];\n        float dy = yi - pts[j * DIM + 1];\n        float dz = zi - pts[j * DIM + 2];\n        float d = dx * dx + dy * dy + dz * dz;\n        if (d < best) {\n            best = d;\n            best_j = j;\n        }\n    }\n\n    indices[i] = best_j;\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t pts_bytes = N * DIM * sizeof(float);\n    size_t idx_bytes = N * sizeof(int);\n\n    float* h_pts = new float[N * DIM];\n    int* h_idx = new int[N];\n\n    read_binary(\"data/points.bin\", h_pts, pts_bytes);\n\n    float* d_pts;\n    int* d_idx;\n    cudaMalloc(&d_pts, pts_bytes);\n    cudaMalloc(&d_idx, idx_bytes);\n\n    cudaMemcpy(d_pts, h_pts, pts_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    nearest_kernel<<<blocks, threads>>>(d_pts, d_idx, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_idx, d_idx, idx_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/indices_out.bin\", h_idx, idx_bytes);\n\n    cudaFree(d_pts);\n    cudaFree(d_idx);\n    delete[] h_pts;\n    delete[] h_idx;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 512\nnp.random.seed(42)\n\npoints = np.random.randn(N, 3).astype(np.float32)\n\nref = np.zeros(N, dtype=np.int32)\nfor i in range(N):\n    dmin = np.inf\n    idx = -1\n    for j in range(N):\n        if i == j:\n            continue\n        dx = points[i, 0] - points[j, 0]\n        dy = points[i, 1] - points[j, 1]\n        dz = points[i, 2] - points[j, 2]\n        d = dx * dx + dy * dy + dz * dz\n        if d < dmin:\n            dmin = d\n            idx = j\n    ref[i] = idx\n\npoints.tofile(\"data/points.bin\")\nref.tofile(\"data/indices_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 512\n\nout = np.fromfile(\"data/indices_out.bin\", dtype=np.int32, count=N)\nref = np.fromfile(\"data/indices_ref.bin\", dtype=np.int32, count=N)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif np.all(out == ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement the Nearest_Neighbor kernel. Given an input tensor `points` with shape (512, 3) containing float32 3D point coordinates, compute for each point the index of its nearest neighbor (excluding itself). The output tensor `indices_out` must have shape (512,) with int32 values representing neighbor indices. The kernel must find the closest point based on squared Euclidean distance (dx² + dy² + dz²) and ensure no point selects itself.", "level2_prompt": "Nearest_Neighbor computation: For each point in a set of 512 3D points, determine the index of the closest other point by minimizing the squared Euclidean distance. The output is an integer index array mapping each point to its nearest neighbor.", "level3_prompt": "Compute the Nearest_Neighbor kernel on GPU using CUDA."}
{"id": 241, "task_name": "Nearest_Neighbor", "task_description": "Compute the Nearest_Neighbor kernel on GPU using CUDA.", "inputs": [{"name": "points", "dtype": "float32", "shape": "(1024, 3)"}], "outputs": [{"name": "indices_out", "dtype": "int32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define N 1024\n#define DIM 3\n\n__global__ void nearest_kernel(const float* pts, int* indices, int n) {\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= n) return;\n\n    float xi = pts[i * DIM + 0];\n    float yi = pts[i * DIM + 1];\n    float zi = pts[i * DIM + 2];\n\n    float best = 1e30f;\n    int best_j = -1;\n\n    for (int j = 0; j < n; ++j) {\n        if (j == i) continue;\n        float dx = xi - pts[j * DIM + 0];\n        float dy = yi - pts[j * DIM + 1];\n        float dz = zi - pts[j * DIM + 2];\n        float d = dx * dx + dy * dy + dz * dz;\n        if (d < best) {\n            best = d;\n            best_j = j;\n        }\n    }\n\n    indices[i] = best_j;\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t pts_bytes = N * DIM * sizeof(float);\n    size_t idx_bytes = N * sizeof(int);\n\n    float* h_pts = new float[N * DIM];\n    int* h_idx = new int[N];\n\n    read_binary(\"data/points.bin\", h_pts, pts_bytes);\n\n    float* d_pts;\n    int* d_idx;\n    cudaMalloc(&d_pts, pts_bytes);\n    cudaMalloc(&d_idx, idx_bytes);\n\n    cudaMemcpy(d_pts, h_pts, pts_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    nearest_kernel<<<blocks, threads>>>(d_pts, d_idx, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_idx, d_idx, idx_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/indices_out.bin\", h_idx, idx_bytes);\n\n    cudaFree(d_pts);\n    cudaFree(d_idx);\n    delete[] h_pts;\n    delete[] h_idx;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1024\nnp.random.seed(42)\n\npoints = np.random.randn(N, 3).astype(np.float32)\n\nref = np.zeros(N, dtype=np.int32)\nfor i in range(N):\n    dmin = np.inf\n    idx = -1\n    for j in range(N):\n        if i == j:\n            continue\n        dx = points[i, 0] - points[j, 0]\n        dy = points[i, 1] - points[j, 1]\n        dz = points[i, 2] - points[j, 2]\n        d = dx * dx + dy * dy + dz * dz\n        if d < dmin:\n            dmin = d\n            idx = j\n    ref[i] = idx\n\npoints.tofile(\"data/points.bin\")\nref.tofile(\"data/indices_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 1024\n\nout = np.fromfile(\"data/indices_out.bin\", dtype=np.int32, count=N)\nref = np.fromfile(\"data/indices_ref.bin\", dtype=np.int32, count=N)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif np.all(out == ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement the Nearest_Neighbor kernel. Given a 1024x3 float32 tensor representing 3D points, compute for each point the index of its closest neighbor (excluding itself) based on Euclidean distance squared. Output a 1024-length int32 tensor where each element is the index of the nearest neighbor to the corresponding point. The kernel must avoid self-comparisons and efficiently compute pairwise distances without square roots.", "level2_prompt": "For each of 1024 points in 3D space, find the index of the nearest distinct point by minimizing squared Euclidean distance. The solution requires computing all pairwise distances between points, excluding self-comparisons, and selecting the minimum distance neighbor index for each point.", "level3_prompt": "Compute nearest neighbor indices for a set of 3D points."}
{"id": 242, "task_name": "Nearest_Neighbor", "task_description": "Compute the Nearest_Neighbor kernel on GPU using CUDA.", "inputs": [{"name": "points", "dtype": "float32", "shape": "(2048, 3)"}], "outputs": [{"name": "indices_out", "dtype": "int32", "shape": "(2048,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define N 2048\n#define DIM 3\n\n__global__ void nearest_kernel(const float* pts, int* indices, int n) {\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= n) return;\n\n    float xi = pts[i * DIM + 0];\n    float yi = pts[i * DIM + 1];\n    float zi = pts[i * DIM + 2];\n\n    float best = 1e30f;\n    int best_j = -1;\n\n    for (int j = 0; j < n; ++j) {\n        if (j == i) continue;\n        float dx = xi - pts[j * DIM + 0];\n        float dy = yi - pts[j * DIM + 1];\n        float dz = zi - pts[j * DIM + 2];\n        float d = dx * dx + dy * dy + dz * dz;\n        if (d < best) {\n            best = d;\n            best_j = j;\n        }\n    }\n\n    indices[i] = best_j;\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t pts_bytes = N * DIM * sizeof(float);\n    size_t idx_bytes = N * sizeof(int);\n\n    float* h_pts = new float[N * DIM];\n    int* h_idx = new int[N];\n\n    read_binary(\"data/points.bin\", h_pts, pts_bytes);\n\n    float* d_pts;\n    int* d_idx;\n    cudaMalloc(&d_pts, pts_bytes);\n    cudaMalloc(&d_idx, idx_bytes);\n\n    cudaMemcpy(d_pts, h_pts, pts_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    nearest_kernel<<<blocks, threads>>>(d_pts, d_idx, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_idx, d_idx, idx_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/indices_out.bin\", h_idx, idx_bytes);\n\n    cudaFree(d_pts);\n    cudaFree(d_idx);\n    delete[] h_pts;\n    delete[] h_idx;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 2048\nnp.random.seed(42)\n\npoints = np.random.randn(N, 3).astype(np.float32)\n\nref = np.zeros(N, dtype=np.int32)\nfor i in range(N):\n    dmin = np.inf\n    idx = -1\n    for j in range(N):\n        if i == j:\n            continue\n        dx = points[i, 0] - points[j, 0]\n        dy = points[i, 1] - points[j, 1]\n        dz = points[i, 2] - points[j, 2]\n        d = dx * dx + dy * dy + dz * dz\n        if d < dmin:\n            dmin = d\n            idx = j\n    ref[i] = idx\n\npoints.tofile(\"data/points.bin\")\nref.tofile(\"data/indices_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 2048\n\nout = np.fromfile(\"data/indices_out.bin\", dtype=np.int32, count=N)\nref = np.fromfile(\"data/indices_ref.bin\", dtype=np.int32, count=N)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif np.all(out == ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement the Nearest_Neighbor kernel to compute nearest neighbor indices for 3D points. The input is a 2048x3 float32 tensor representing point coordinates. The output should be a 2048-element int32 tensor where each element contains the index of the nearest neighbor for the corresponding point (excluding self). The kernel must compute squared Euclidean distances and select the closest neighbor index for each point.", "level2_prompt": "Nearest_Neighbor task: For each point in a 3D space, find the index of the nearest neighbor by calculating squared Euclidean distances to all other points and selecting the minimum distance index while excluding self.", "level3_prompt": "Compute nearest neighbor indices for 2048 points in 3D space."}
{"id": 243, "task_name": "Nearest_Neighbor", "task_description": "Compute the Nearest_Neighbor kernel on GPU using CUDA.", "inputs": [{"name": "points", "dtype": "float32", "shape": "(4096, 3)"}], "outputs": [{"name": "indices_out", "dtype": "int32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define N 4096\n#define DIM 3\n\n__global__ void nearest_kernel(const float* pts, int* indices, int n) {\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= n) return;\n\n    float xi = pts[i * DIM + 0];\n    float yi = pts[i * DIM + 1];\n    float zi = pts[i * DIM + 2];\n\n    float best = 1e30f;\n    int best_j = -1;\n\n    for (int j = 0; j < n; ++j) {\n        if (j == i) continue;\n        float dx = xi - pts[j * DIM + 0];\n        float dy = yi - pts[j * DIM + 1];\n        float dz = zi - pts[j * DIM + 2];\n        float d = dx * dx + dy * dy + dz * dz;\n        if (d < best) {\n            best = d;\n            best_j = j;\n        }\n    }\n\n    indices[i] = best_j;\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t pts_bytes = N * DIM * sizeof(float);\n    size_t idx_bytes = N * sizeof(int);\n\n    float* h_pts = new float[N * DIM];\n    int* h_idx = new int[N];\n\n    read_binary(\"data/points.bin\", h_pts, pts_bytes);\n\n    float* d_pts;\n    int* d_idx;\n    cudaMalloc(&d_pts, pts_bytes);\n    cudaMalloc(&d_idx, idx_bytes);\n\n    cudaMemcpy(d_pts, h_pts, pts_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    nearest_kernel<<<blocks, threads>>>(d_pts, d_idx, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_idx, d_idx, idx_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/indices_out.bin\", h_idx, idx_bytes);\n\n    cudaFree(d_pts);\n    cudaFree(d_idx);\n    delete[] h_pts;\n    delete[] h_idx;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 4096\nnp.random.seed(42)\n\npoints = np.random.randn(N, 3).astype(np.float32)\n\nref = np.zeros(N, dtype=np.int32)\nfor i in range(N):\n    dmin = np.inf\n    idx = -1\n    for j in range(N):\n        if i == j:\n            continue\n        dx = points[i, 0] - points[j, 0]\n        dy = points[i, 1] - points[j, 1]\n        dz = points[i, 2] - points[j, 2]\n        d = dx * dx + dy * dy + dz * dz\n        if d < dmin:\n            dmin = d\n            idx = j\n    ref[i] = idx\n\npoints.tofile(\"data/points.bin\")\nref.tofile(\"data/indices_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 4096\n\nout = np.fromfile(\"data/indices_out.bin\", dtype=np.int32, count=N)\nref = np.fromfile(\"data/indices_ref.bin\", dtype=np.int32, count=N)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif np.all(out == ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Nearest_Neighbor' that processes 4096 points in 3D space. Each point is represented by three float32 coordinates. For every point, find the index of its nearest neighbor (excluding itself) based on squared Euclidean distance. The output should be an int32 tensor of 4096 elements where each element represents the index of the nearest neighbor for the corresponding point. The kernel must skip self-comparisons and correctly handle floating-point comparisons.", "level2_prompt": "Create a 'Nearest_Neighbor' algorithm where each point in a set of 4096 3D points searches all other points to identify the one with minimum squared Euclidean distance. The squared distance is computed as the sum of squared differences in each coordinate dimension. Output the index of the closest point for each input point, ensuring no point considers itself as a neighbor.", "level3_prompt": "Compute nearest neighbors for 4096 3D points."}
{"id": 244, "task_name": "Nearest_Neighbor", "task_description": "Compute the Nearest_Neighbor kernel on GPU using CUDA.", "inputs": [{"name": "points", "dtype": "float32", "shape": "(8192, 3)"}], "outputs": [{"name": "indices_out", "dtype": "int32", "shape": "(8192,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define N 8192\n#define DIM 3\n\n__global__ void nearest_kernel(const float* pts, int* indices, int n) {\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= n) return;\n\n    float xi = pts[i * DIM + 0];\n    float yi = pts[i * DIM + 1];\n    float zi = pts[i * DIM + 2];\n\n    float best = 1e30f;\n    int best_j = -1;\n\n    for (int j = 0; j < n; ++j) {\n        if (j == i) continue;\n        float dx = xi - pts[j * DIM + 0];\n        float dy = yi - pts[j * DIM + 1];\n        float dz = zi - pts[j * DIM + 2];\n        float d = dx * dx + dy * dy + dz * dz;\n        if (d < best) {\n            best = d;\n            best_j = j;\n        }\n    }\n\n    indices[i] = best_j;\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t pts_bytes = N * DIM * sizeof(float);\n    size_t idx_bytes = N * sizeof(int);\n\n    float* h_pts = new float[N * DIM];\n    int* h_idx = new int[N];\n\n    read_binary(\"data/points.bin\", h_pts, pts_bytes);\n\n    float* d_pts;\n    int* d_idx;\n    cudaMalloc(&d_pts, pts_bytes);\n    cudaMalloc(&d_idx, idx_bytes);\n\n    cudaMemcpy(d_pts, h_pts, pts_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    nearest_kernel<<<blocks, threads>>>(d_pts, d_idx, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_idx, d_idx, idx_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/indices_out.bin\", h_idx, idx_bytes);\n\n    cudaFree(d_pts);\n    cudaFree(d_idx);\n    delete[] h_pts;\n    delete[] h_idx;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 8192\nnp.random.seed(42)\n\npoints = np.random.randn(N, 3).astype(np.float32)\n\nref = np.zeros(N, dtype=np.int32)\nfor i in range(N):\n    dmin = np.inf\n    idx = -1\n    for j in range(N):\n        if i == j:\n            continue\n        dx = points[i, 0] - points[j, 0]\n        dy = points[i, 1] - points[j, 1]\n        dz = points[i, 2] - points[j, 2]\n        d = dx * dx + dy * dy + dz * dz\n        if d < dmin:\n            dmin = d\n            idx = j\n    ref[i] = idx\n\npoints.tofile(\"data/points.bin\")\nref.tofile(\"data/indices_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 8192\n\nout = np.fromfile(\"data/indices_out.bin\", dtype=np.int32, count=N)\nref = np.fromfile(\"data/indices_ref.bin\", dtype=np.int32, count=N)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif np.all(out == ref):\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Nearest_Neighbor. Compute the nearest neighbor for each point in a 3D point cloud. Input is a float32 tensor of shape (8192, 3) representing 8192 points with XYZ coordinates. Output must be an int32 tensor of shape (8192,) where each element is the index of the nearest neighbor point for the corresponding input point, excluding itself. The nearest neighbor is determined by minimizing the squared Euclidean distance. Each point must have a distinct neighbor (no self-matches allowed).", "level2_prompt": "Task: Nearest_Neighbor. For each point in a set of 8192 points in 3D space, find the index of the closest distinct point by calculating the squared Euclidean distance to all other points and selecting the one with the smallest distance. The result is an array of 8192 indices.", "level3_prompt": "Compute the Nearest_Neighbor kernel for 3D points."}
{"id": 245, "task_name": "Max_Subarray_Sum", "task_description": "Compute the Max_Subarray_Sum kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "int32", "shape": "(2048,)"}], "outputs": [{"name": "output", "dtype": "int64", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <climits>\n\n#define N 2048\n#define WINDOW 64\n\n__global__ void window_sum_kernel(const int* input, long long* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx > n - WINDOW) return;\n\n    long long s = 0;\n    for (int i = 0; i < WINDOW; ++i) {\n        s += input[idx + i];\n    }\n\n    atomicMax(result, s);\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(int);\n    size_t out_bytes = sizeof(long long);\n\n    int* h_data = new int[N];\n    long long h_result;\n\n    read_binary(\"data/input.bin\", h_data, data_bytes);\n\n    int* d_data;\n    long long* d_result;\n\n    cudaMalloc(&d_data, data_bytes);\n    cudaMalloc(&d_result, out_bytes);\n\n    cudaMemcpy(d_data, h_data, data_bytes, cudaMemcpyHostToDevice);\n\n    long long init = LLONG_MIN;\n    cudaMemcpy(d_result, &init, out_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    window_sum_kernel<<<blocks, threads>>>(d_data, d_result, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(&h_result, d_result, out_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", &h_result, out_bytes);\n\n    cudaFree(d_data);\n    cudaFree(d_result);\n    delete[] h_data;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 2048\nWINDOW = 64\n\nnp.random.seed(42)\n\ndata = np.random.randint(-100, 100, size=N, dtype=np.int32)\n\nbest = -2**63\nfor i in range(N - WINDOW + 1):\n    s = data[i:i+WINDOW].sum()\n    if s > best:\n        best = s\n\nnp.array([best], dtype=np.int64).tofile(\"data/ref.bin\")\ndata.tofile(\"data/input.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nout = np.fromfile(\"data/output.bin\", dtype=np.int64, count=1)\nref = np.fromfile(\"data/ref.bin\", dtype=np.int64, count=1)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif out[0] == ref[0]:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task name: Max_Subarray_Sum. Given an input array of 2048 integers (int32), compute the maximum sum of any contiguous subarray of length 64. The output is a single integer (int64) representing this maximum sum. The kernel must consider every possible starting index for the window of 64 consecutive elements and determine the maximum sum.", "level2_prompt": "Max_Subarray_Sum: For an array of 2048 integers, compute the maximum sum of any contiguous subarray of fixed length 64.", "level3_prompt": "Compute the maximum sum of a contiguous subarray of 64 integers."}
{"id": 246, "task_name": "Max_Subarray_Sum", "task_description": "Compute the Max_Subarray_Sum kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "int32", "shape": "(4096,)"}], "outputs": [{"name": "output", "dtype": "int64", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <climits>\n\n#define N 4096\n#define WINDOW 128\n\n__global__ void window_sum_kernel(const int* input, long long* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx > n - WINDOW) return;\n\n    long long s = 0;\n    for (int i = 0; i < WINDOW; ++i) {\n        s += input[idx + i];\n    }\n\n    atomicMax(result, s);\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(int);\n    size_t out_bytes = sizeof(long long);\n\n    int* h_data = new int[N];\n    long long h_result;\n\n    read_binary(\"data/input.bin\", h_data, data_bytes);\n\n    int* d_data;\n    long long* d_result;\n\n    cudaMalloc(&d_data, data_bytes);\n    cudaMalloc(&d_result, out_bytes);\n\n    cudaMemcpy(d_data, h_data, data_bytes, cudaMemcpyHostToDevice);\n\n    long long init = LLONG_MIN;\n    cudaMemcpy(d_result, &init, out_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    window_sum_kernel<<<blocks, threads>>>(d_data, d_result, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(&h_result, d_result, out_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", &h_result, out_bytes);\n\n    cudaFree(d_data);\n    cudaFree(d_result);\n    delete[] h_data;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 4096\nWINDOW = 128\n\nnp.random.seed(42)\n\ndata = np.random.randint(-100, 100, size=N, dtype=np.int32)\n\nbest = -2**63\nfor i in range(N - WINDOW + 1):\n    s = data[i:i+WINDOW].sum()\n    if s > best:\n        best = s\n\nnp.array([best], dtype=np.int64).tofile(\"data/ref.bin\")\ndata.tofile(\"data/input.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nout = np.fromfile(\"data/output.bin\", dtype=np.int64, count=1)\nref = np.fromfile(\"data/ref.bin\", dtype=np.int64, count=1)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif out[0] == ref[0]:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Implement the Max_Subarray_Sum kernel to find the maximum sum of any contiguous subarray with a fixed window size of 128 elements in a 1D integer array. The input is a tensor of shape (4096,) with int32 values. The output should be a single int64 value representing the maximum sum found. Ensure the kernel handles array bounds correctly by skipping invalid window positions beyond index 4096 - 128. The computation must consider all possible contiguous windows of size 128 within the array.", "level2_prompt": "Compute the maximum sum of all possible contiguous subarrays of length 128 in a given integer array. For each starting index from 0 to (array_length - 128), calculate the sum of elements within the window defined by [index, index + window_size - 1]. Track and return the maximum sum encountered across all valid windows.", "level3_prompt": "Compute the Max_Subarray_Sum kernel on GPU using CUDA."}
{"id": 247, "task_name": "Max_Subarray_Sum", "task_description": "Compute the Max_Subarray_Sum kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "int32", "shape": "(8192,)"}], "outputs": [{"name": "output", "dtype": "int64", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <climits>\n\n#define N 8192\n#define WINDOW 256\n\n__global__ void window_sum_kernel(const int* input, long long* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx > n - WINDOW) return;\n\n    long long s = 0;\n    for (int i = 0; i < WINDOW; ++i) {\n        s += input[idx + i];\n    }\n\n    atomicMax(result, s);\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(int);\n    size_t out_bytes = sizeof(long long);\n\n    int* h_data = new int[N];\n    long long h_result;\n\n    read_binary(\"data/input.bin\", h_data, data_bytes);\n\n    int* d_data;\n    long long* d_result;\n\n    cudaMalloc(&d_data, data_bytes);\n    cudaMalloc(&d_result, out_bytes);\n\n    cudaMemcpy(d_data, h_data, data_bytes, cudaMemcpyHostToDevice);\n\n    long long init = LLONG_MIN;\n    cudaMemcpy(d_result, &init, out_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    window_sum_kernel<<<blocks, threads>>>(d_data, d_result, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(&h_result, d_result, out_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", &h_result, out_bytes);\n\n    cudaFree(d_data);\n    cudaFree(d_result);\n    delete[] h_data;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 8192\nWINDOW = 256\n\nnp.random.seed(42)\n\ndata = np.random.randint(-100, 100, size=N, dtype=np.int32)\n\nbest = -2**63\nfor i in range(N - WINDOW + 1):\n    s = data[i:i+WINDOW].sum()\n    if s > best:\n        best = s\n\nnp.array([best], dtype=np.int64).tofile(\"data/ref.bin\")\ndata.tofile(\"data/input.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nout = np.fromfile(\"data/output.bin\", dtype=np.int64, count=1)\nref = np.fromfile(\"data/ref.bin\", dtype=np.int64, count=1)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif out[0] == ref[0]:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Max_Subarray_Sum. Implement a CUDA kernel to compute the maximum sum of any contiguous subarray of length 256 in an input array of 8192 integers. The input tensor is a 1D array of int32 with shape (8192,). The output is a single int64 value representing the maximum sum. The kernel must handle all possible contiguous windows of length 256 within the array bounds.", "level2_prompt": "Task: Max_Subarray_Sum. For an integer array of length 8192, calculate the sum of every contiguous subarray of fixed length 256, then determine and return the maximum value among these sums.", "level3_prompt": "Compute the maximum sum of any contiguous subarray of fixed length 256 in an array of 8192 integers."}
{"id": 248, "task_name": "Max_Subarray_Sum", "task_description": "Compute the Max_Subarray_Sum kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "int32", "shape": "(16384,)"}], "outputs": [{"name": "output", "dtype": "int64", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <climits>\n\n#define N 16384\n#define WINDOW 512\n\n__global__ void window_sum_kernel(const int* input, long long* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx > n - WINDOW) return;\n\n    long long s = 0;\n    for (int i = 0; i < WINDOW; ++i) {\n        s += input[idx + i];\n    }\n\n    atomicMax(result, s);\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(int);\n    size_t out_bytes = sizeof(long long);\n\n    int* h_data = new int[N];\n    long long h_result;\n\n    read_binary(\"data/input.bin\", h_data, data_bytes);\n\n    int* d_data;\n    long long* d_result;\n\n    cudaMalloc(&d_data, data_bytes);\n    cudaMalloc(&d_result, out_bytes);\n\n    cudaMemcpy(d_data, h_data, data_bytes, cudaMemcpyHostToDevice);\n\n    long long init = LLONG_MIN;\n    cudaMemcpy(d_result, &init, out_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    window_sum_kernel<<<blocks, threads>>>(d_data, d_result, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(&h_result, d_result, out_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", &h_result, out_bytes);\n\n    cudaFree(d_data);\n    cudaFree(d_result);\n    delete[] h_data;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 16384\nWINDOW = 512\n\nnp.random.seed(42)\n\ndata = np.random.randint(-100, 100, size=N, dtype=np.int32)\n\nbest = -2**63\nfor i in range(N - WINDOW + 1):\n    s = data[i:i+WINDOW].sum()\n    if s > best:\n        best = s\n\nnp.array([best], dtype=np.int64).tofile(\"data/ref.bin\")\ndata.tofile(\"data/input.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nout = np.fromfile(\"data/output.bin\", dtype=np.int64, count=1)\nref = np.fromfile(\"data/ref.bin\", dtype=np.int64, count=1)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif out[0] == ref[0]:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Task: Max_Subarray_Sum. Compute the maximum sum of any contiguous subarray of fixed length 512 from a one-dimensional input array of 16384 integers. The input array consists of int32 values. The output should be a single int64 value representing this maximum sum. The kernel must respect the window size of 512 and handle the array bounds correctly, ensuring that all possible window starting positions are considered. Parallel execution should use atomic operations to update the global maximum sum safely.", "level2_prompt": "Task: Max_Subarray_Sum. For an array of size 16384, find the maximum sum among all contiguous subarrays of fixed length 512. This involves sliding a window of size 512 across the array, computing the sum for each window, and tracking the largest sum encountered.", "level3_prompt": "Compute the maximum sum of any contiguous subarray of fixed length in a given array."}
{"id": 249, "task_name": "Max_Subarray_Sum", "task_description": "Compute the Max_Subarray_Sum kernel on GPU using CUDA.", "inputs": [{"name": "input", "dtype": "int32", "shape": "(32768,)"}], "outputs": [{"name": "output", "dtype": "int64", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <climits>\n\n#define N 32768\n#define WINDOW 1024\n\n__global__ void window_sum_kernel(const int* input, long long* result, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx > n - WINDOW) return;\n\n    long long s = 0;\n    for (int i = 0; i < WINDOW; ++i) {\n        s += input[idx + i];\n    }\n\n    atomicMax(result, s);\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    size_t data_bytes = N * sizeof(int);\n    size_t out_bytes = sizeof(long long);\n\n    int* h_data = new int[N];\n    long long h_result;\n\n    read_binary(\"data/input.bin\", h_data, data_bytes);\n\n    int* d_data;\n    long long* d_result;\n\n    cudaMalloc(&d_data, data_bytes);\n    cudaMalloc(&d_result, out_bytes);\n\n    cudaMemcpy(d_data, h_data, data_bytes, cudaMemcpyHostToDevice);\n\n    long long init = LLONG_MIN;\n    cudaMemcpy(d_result, &init, out_bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    window_sum_kernel<<<blocks, threads>>>(d_data, d_result, N);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(&h_result, d_result, out_bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/output.bin\", &h_result, out_bytes);\n\n    cudaFree(d_data);\n    cudaFree(d_result);\n    delete[] h_data;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 32768\nWINDOW = 1024\n\nnp.random.seed(42)\n\ndata = np.random.randint(-100, 100, size=N, dtype=np.int32)\n\nbest = -2**63\nfor i in range(N - WINDOW + 1):\n    s = data[i:i+WINDOW].sum()\n    if s > best:\n        best = s\n\nnp.array([best], dtype=np.int64).tofile(\"data/ref.bin\")\ndata.tofile(\"data/input.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nout = np.fromfile(\"data/output.bin\", dtype=np.int64, count=1)\nref = np.fromfile(\"data/ref.bin\", dtype=np.int64, count=1)\n\nif out.shape != ref.shape:\n    print(\"F\")\nelif out[0] == ref[0]:\n    print(\"T\")\nelse:\n    print(\"F\")\n", "level1_prompt": "Max_Subarray_Sum: Compute the maximum sum of any contiguous subarray of fixed length 1024 in an array of 32768 integers. Input is a single int32 tensor of shape (32768,). Output is a single int64 value representing the maximum subarray sum. The kernel must consider all possible contiguous windows of length 1024 within the array bounds.", "level2_prompt": "Max_Subarray_Sum: For an array of 32768 integers, calculate the maximum sum among all contiguous subarrays of length 1024.", "level3_prompt": "Compute the maximum contiguous subarray sum for a fixed window size."}
{"id": 250, "task_name": "AdamW", "task_description": "Compute the AdamW kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 3072)"}, {"name": "matB", "dtype": "float32", "shape": "(3072, 3072)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024, 3072)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 3072\n#define N 3072\n#define TILE_WIDTH 32\nconst int M = 1024;\n\n__global__ void AdamW_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long P = (long)M * (long)N / 3;\n        long pos = (long)row * (long)N + (long)col;\n        float p = A[pos];\n        float out = p;\n        if (pos < P) {\n            float g = B[pos];\n            float m = B[P + pos];\n            float v = B[2*P + pos];\n            float b1 = 9.00000000e-01f; float b2 = 9.99000000e-01f; float lr = 1.00000000e-03f;\n            float eps = 1.00000000e-08f; float wd  = 1.00000000e-02f; float tt  = 1.00000000e+01f;\n            float m_t = b1 * m + (1.0f - b1) * g;\n            float v_t = b2 * v + (1.0f - b2) * g * g;\n            float m_hat = m_t / (1.0f - powf(b1, tt));\n            float v_hat = v_t / (1.0f - powf(b2, tt));\n            float upd = m_hat / (sqrtf(v_hat) + eps) + wd * p;\n            out = p - lr * upd;\n        }\n        C[pos] = out;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AdamW_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1024\nK = 3072\nN = 3072\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nP = M * N // 3\nparams = A.view(-1)[:P].clone()\ngrads = torch.randn(P, dtype=torch.float32)\nm = torch.randn(P, dtype=torch.float32) * 0.1\nv = (torch.randn(P, dtype=torch.float32) ** 2) * 0.01\nm_t = 0.9*m + (1.0-0.9)*grads\nv_t = 0.999*v + (1.0-0.999)*(grads*grads)\nm_hat = m_t / (1.0 - (0.9**10.0))\nv_hat = v_t / (1.0 - (0.999**10.0))\nupdate = m_hat / (torch.sqrt(v_hat) + 1e-08) + 0.01 * params\nC = A.clone()\nC.view(-1)[:P] = params - 0.001 * update\nBf = B.view(-1)\nBf[:P] = grads\nBf[P:2*P] = m\nBf[2*P:3*P] = v\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 3072\n    N = 3072\n    M = 1024\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the AdamW optimization kernel. The input matrix matA (1024x3072) contains parameters to be updated. The input matrix matB (3072x3072) stores the gradients, first moments, and second moments in its first 3145728 elements (flattened), divided into three equal segments. The output matrix matC_out (1024x3072) will contain the updated parameters. For each element in the output, if its linear index (row-major) is less than 1048576 (one-third of the total elements in matA), update it using the AdamW formula with fixed hyperparameters: beta1=0.9, beta2=0.999, learning_rate=0.001, weight_decay=0.01, epsilon=1e-8, and time step=10. Otherwise, copy the corresponding element from matA. The hyperparameters are constants and must not be changed.", "level2_prompt": "Perform an AdamW optimization step. For each element in the output matrix (1024x3072), if its linear index is in the first one-third of the total elements, then update the parameter using the AdamW algorithm. The AdamW update uses the parameter value, gradient, first moment, and second moment. The gradient, first moment, and second moment are stored in the input matrix matB at positions corresponding to the same linear index in the first, second, and third segments of the first 3145728 elements of matB respectively. The update equations are: m_t = beta1 * m + (1 - beta1) * g; v_t = beta2 * v + (1 - beta2) * g^2; m_hat = m_t / (1 - beta1^time_step); v_hat = v_t / (1 - beta2^time_step); update = m_hat / (sqrt(v_hat) + epsilon) + weight_decay * parameter; new_parameter = parameter - learning_rate * update. The hyperparameters are fixed: beta1=0.9, beta2=0.999, learning_rate=0.001, weight_decay=0.01, epsilon=1e-8, time_step=10. For elements beyond the first one-third, copy the parameter from the input matrix matA.", "level3_prompt": "Compute the AdamW kernel on GPU using CUDA."}
{"id": 251, "task_name": "AdamW", "task_description": "Compute the AdamW kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 3072)"}, {"name": "matB", "dtype": "float32", "shape": "(3072, 3072)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024, 3072)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 3072\n#define N 3072\n#define TILE_WIDTH 32\nconst int M = 1024;\n\n__global__ void AdamW_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long P = (long)M * (long)N / 3;\n        long pos = (long)row * (long)N + (long)col;\n        float p = A[pos];\n        float out = p;\n        if (pos < P) {\n            float g = B[pos];\n            float m = B[P + pos];\n            float v = B[2*P + pos];\n            float b1 = 9.00000000e-01f; float b2 = 9.99000000e-01f; float lr = 5.00000000e-04f;\n            float eps = 1.00000000e-08f; float wd  = 1.00000000e-02f; float tt  = 5.00000000e+00f;\n            float m_t = b1 * m + (1.0f - b1) * g;\n            float v_t = b2 * v + (1.0f - b2) * g * g;\n            float m_hat = m_t / (1.0f - powf(b1, tt));\n            float v_hat = v_t / (1.0f - powf(b2, tt));\n            float upd = m_hat / (sqrtf(v_hat) + eps) + wd * p;\n            out = p - lr * upd;\n        }\n        C[pos] = out;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AdamW_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1024\nK = 3072\nN = 3072\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nP = M * N // 3\nparams = A.view(-1)[:P].clone()\ngrads  = torch.randn(P, dtype=torch.float32)\nm = torch.randn(P, dtype=torch.float32) * 0.1\nv = (torch.randn(P, dtype=torch.float32) ** 2) * 0.01\nm_t = 0.9*m + (1.0-0.9)*grads\nv_t = 0.999*v + (1.0-0.999)*(grads*grads)\nm_hat = m_t / (1.0 - (0.9**5.0))\nv_hat = v_t / (1.0 - (0.999**5.0))\nupdate = m_hat / (torch.sqrt(v_hat) + 1e-08) + 0.01 * params\nC = A.clone()\nC.view(-1)[:P] = params - 0.0005 * update\nBf = B.view(-1)\nBf[:P] = grads\nBf[P:2*P] = m\nBf[2*P:3*P] = v\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 3072\n    N = 3072\n    M = 1024\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the AdamW kernel for updating parameters in a matrix using gradient, first moment, and second moment data. The input tensor matA is a float32 matrix of shape (1024, 3072) containing parameters and other values. The input tensor matB is a float32 matrix of shape (3072, 3072) storing gradients in its first third, first moments in the next third, and second moments in the final third. The output tensor matC_out is a float32 matrix of shape (1024, 3072) where only the first third of elements (in row-major order) are updated via AdamW. The kernel must use fixed hyperparameters: beta1=0.9, beta2=0.999, learning rate=0.0005, epsilon=1e-8, weight decay=0.01, and time step=5.0. Elements beyond the first third should remain unchanged.", "level2_prompt": "Apply the AdamW optimization algorithm to update parameters. For each element in the output matrix, if its linear index falls within the first third of total elements, compute the updated parameter using the AdamW formula with gradient, first moment, and second moment data from the input matrices. Otherwise, retain the original value from the input matrix. Use fixed hyperparameters: beta1=0.9, beta2=0.999, learning rate=0.0005, epsilon=1e-8, weight decay=0.01, and time step=5.0.", "level3_prompt": "Compute the AdamW kernel for parameter updates."}
{"id": 252, "task_name": "AdamW", "task_description": "Compute the AdamW kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1536, 4608)"}, {"name": "matB", "dtype": "float32", "shape": "(4608, 4608)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(7077888,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 4608\n#define N 4608\n#define TILE_WIDTH 32\nconst int M = 1536;\n\n__global__ void AdamW_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long P = (long)M * (long)N / 3;\n        long pos = (long)row * (long)N + (long)col;\n        float p = A[pos];\n        float out = p;\n        if (pos < P) {\n            float g = B[pos];\n            float m = B[P + pos];\n            float v = B[2*P + pos];\n            float b1 = 9.00000000e-01f; float b2 = 9.80000000e-01f; float lr = 2.00000000e-03f;\n            float eps = 1.00000000e-08f; float wd  = 0.00000000e+00f; float tt  = 2.00000000e+01f;\n            float m_t = b1 * m + (1.0f - b1) * g;\n            float v_t = b2 * v + (1.0f - b2) * g * g;\n            float m_hat = m_t / (1.0f - powf(b1, tt));\n            float v_hat = v_t / (1.0f - powf(b2, tt));\n            float upd = m_hat / (sqrtf(v_hat) + eps) + wd * p;\n            out = p - lr * upd;\n        }\n        C[pos] = out;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AdamW_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1536\nK = 4608\nN = 4608\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nP = M * N // 3\nparams = A.view(-1)[:P].clone()\ngrads  = torch.randn(P, dtype=torch.float32)\nm = torch.randn(P, dtype=torch.float32) * 0.1\nv = (torch.randn(P, dtype=torch.float32) ** 2) * 0.01\nm_t = 0.9*m + (1.0-0.9)*grads\nv_t = 0.98*v + (1.0-0.98)*(grads*grads)\nm_hat = m_t / (1.0 - (0.9**20.0))\nv_hat = v_t / (1.0 - (0.98**20.0))\nupdate = m_hat / (torch.sqrt(v_hat) + 1e-08) + 0.0 * params\nC = A.clone()\nC.view(-1)[:P] = params - 0.002 * update\nBf = B.view(-1)\nBf[:P] = grads\nBf[P:2*P] = m\nBf[2*P:3*P] = v\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4608\n    N = 4608\n    M = 1536\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the AdamW optimization algorithm for updating parameters stored in a flattened tensor. The input includes two matrices: matA (1536x4608, float32) containing parameters, and matB (4608x4608, float32) containing gradients, first moments, and second moments. The output is a flattened tensor matC_out (7077888 elements, float32) with updated parameters. Only update the first third of parameters using the AdamW algorithm with fixed hyperparameters: beta1=0.9, beta2=0.98, learning_rate=0.002, epsilon=1e-8, weight_decay=0.0, and timestep=20. The remaining two-thirds of parameters should be copied unchanged from matA.", "level2_prompt": "Perform the AdamW optimization step on parameters. For each element in the first third of the flattened parameter tensor, compute: m_t = beta1 * m + (1 - beta1) * g, v_t = beta2 * v + (1 - beta2) * g^2, m_hat = m_t / (1 - beta1^t), v_hat = v_t / (1 - beta2^t), update = m_hat / (sqrt(v_hat) + eps) + wd * p, then output = p - lr * update. Use fixed hyperparameters: beta1=0.9, beta2=0.98, lr=0.002, eps=1e-8, wd=0.0, t=20. Leave the remaining two-thirds of parameters unchanged.", "level3_prompt": "Compute the AdamW optimization kernel for parameter updates."}
{"id": 253, "task_name": "AdamW", "task_description": "Compute the AdamW kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1792, 5376)"}, {"name": "matB", "dtype": "float32", "shape": "(5376, 5376)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1792, 5376)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 5376\n#define N 5376\n#define TILE_WIDTH 32\nconst int M = 1792;\n\n__global__ void AdamW_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long P = (long)M * (long)N / 3;\n        long pos = (long)row * (long)N + (long)col;\n        float p = A[pos];\n        float out = p;\n        if (pos < P) {\n            float g = B[pos];\n            float m = B[P + pos];\n            float v = B[2*P + pos];\n            float b1 = 8.00000000e-01f; float b2 = 9.90000000e-01f; float lr = 1.00000000e-03f;\n            float eps = 1.00000000e-08f; float wd  = 5.00000000e-02f; float tt  = 7.00000000e+00f;\n            float m_t = b1 * m + (1.0f - b1) * g;\n            float v_t = b2 * v + (1.0f - b2) * g * g;\n            float m_hat = m_t / (1.0f - powf(b1, tt));\n            float v_hat = v_t / (1.0f - powf(b2, tt));\n            float upd = m_hat / (sqrtf(v_hat) + eps) + wd * p;\n            out = p - lr * upd;\n        }\n        C[pos] = out;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AdamW_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1792\nK = 5376\nN = 5376\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nP = M * N // 3\nparams = A.view(-1)[:P].clone()\ngrads  = torch.randn(P, dtype=torch.float32)\nm      = torch.randn(P, dtype=torch.float32) * 0.1\nv      = (torch.randn(P, dtype=torch.float32) ** 2) * 0.01\nm_t = 0.8*m + (1.0-0.8)*grads\nv_t = 0.99*v + (1.0-0.99)*(grads*grads)\nm_hat = m_t / (1.0 - (0.8**7.0))\nv_hat = v_t / (1.0 - (0.99**7.0))\nupdate = m_hat / (torch.sqrt(v_hat) + 1e-08) + 0.05 * params\nC = A.clone()\nC.view(-1)[:P] = params - 0.001 * update\nBf = B.view(-1)\nBf[:P] = grads\nBf[P:2*P] = m\nBf[2*P:3*P] = v\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 5376\n    N = 5376\n    M = 1792\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: AdamW. The kernel updates parameters using the AdamW optimization algorithm. Input matA (shape: 1792x5376, dtype: float32) contains parameters and other values. Input matB (shape: 5376x5376, dtype: float32) provides gradients, first moments, and second moments. Output matC_out (shape: 1792x5376, dtype: float32) stores updated parameters for the first third of elements (in row-major order) and unchanged values for the rest. Hyperparameters are fixed: beta1=0.8, beta2=0.99, learning_rate=0.001, epsilon=1e-8, weight_decay=0.05, time_step=7.0. The kernel must leave the last two-thirds of elements unmodified.", "level2_prompt": "Task: AdamW. For the first third of elements in the flattened input matrix matA, update each parameter using the AdamW algorithm. Retrieve corresponding gradients, first moments, and second moments from matB. Apply AdamW update equations with fixed hyperparameters (beta1=0.8, beta2=0.99, learning_rate=0.001, epsilon=1e-8, weight_decay=0.05, time_step=7.0). For the remaining elements, copy values directly from matA to the output.", "level3_prompt": "Compute the AdamW kernel on GPU using CUDA."}
{"id": 254, "task_name": "AdamW", "task_description": "Compute the AdamW kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(2048, 6144)"}, {"name": "matB", "dtype": "float32", "shape": "(6144, 6144)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(12582912,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 6144\n#define N 6144\n#define TILE_WIDTH 32\nconst int M = 2048;\n\n__global__ void AdamW_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long P = (long)M * (long)N / 3;\n        long pos = (long)row * (long)N + (long)col;\n        float p = A[pos];\n        float out = p;\n        if (pos < P) {\n            float g = B[pos];\n            float m = B[P + pos];\n            float v = B[2*P + pos];\n            float b1 = 9.00000000e-01f; float b2 = 9.99000000e-01f; float lr = 3.00000000e-04f;\n            float eps = 1.00000000e-08f; float wd  = 1.00000000e-01f; float tt  = 3.00000000e+00f;\n            float m_t = b1 * m + (1.0f - b1) * g;\n            float v_t = b2 * v + (1.0f - b2) * g * g;\n            float m_hat = m_t / (1.0f - powf(b1, tt));\n            float v_hat = v_t / (1.0f - powf(b2, tt));\n            float upd = m_hat / (sqrtf(v_hat) + eps) + wd * p;\n            out = p - lr * upd;\n        }\n        C[pos] = out;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AdamW_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2048\nK = 6144\nN = 6144\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nP = M * N // 3\nparams = A.view(-1)[:P].clone()\ngrads  = torch.randn(P, dtype=torch.float32)\nm = torch.randn(P, dtype=torch.float32) * 0.1\nv = (torch.randn(P, dtype=torch.float32) ** 2) * 0.01\nm_t = 0.9*m + (1.0-0.9)*grads\nv_t = 0.999*v + (1.0-0.999)*(grads*grads)\nm_hat = m_t / (1.0 - (0.9**3.0))\nv_hat = v_t / (1.0 - (0.999**3.0))\nupdate = m_hat / (torch.sqrt(v_hat) + 1e-08) + 0.1 * params\nC = A.clone()\nC.view(-1)[:P] = params - 0.0003 * update\nBf = B.view(-1)\nBf[:P] = grads\nBf[P:2*P] = m\nBf[2*P:3*P] = v\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 6144\n    N = 6144\n    M = 2048\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: AdamW. The kernel performs the AdamW optimization step on parameters. The input tensor matA (float32, shape 2048x6144) contains parameters and other data. The input tensor matB (float32, shape 6144x6144) provides gradients, first moments, and second moments in its flattened segments. The output tensor matC_out (float32, shape 12582912) contains updated parameters. Only the first third of parameters (by linear index) are updated using fixed hyperparameters: beta1=0.9, beta2=0.999, learning rate=0.0003, weight decay=0.1, time step=3.0, and epsilon=1e-8. Unmodified elements from matA are copied to matC_out for indices beyond the first third.", "level2_prompt": "Task: AdamW. For each element in the output tensor, if its linear index is less than (2048*6144)/3, update the parameter using AdamW optimization. Retrieve the parameter p from matA, gradient g from matB's first segment, first moment m from the second segment, and second moment v from the third segment. Compute: m_t = β1·m + (1-β1)·g, v_t = β2·v + (1-β2)·g², m̂ = m_t/(1-β1^t), v̂ = v_t/(1-β2^t), update = m̂/(√v̂ + ε) + weight_decay·p, then output p - learning_rate·update. For other indices, output the original value from matA. Hyperparameters are fixed as specified.", "level3_prompt": "AdamW optimization step for a subset of parameters."}
{"id": 255, "task_name": "Avg_Pooling_2D", "task_description": "Compute the Avg_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "avgpool2d_X", "dtype": "float32", "shape": "(16,64,128,128)"}], "outputs": [{"name": "avgpool2d_Y_out", "dtype": "float32", "shape": "(16,64,64,64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#define N 16\n#define C 64\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n\n__global__ void avgpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float sum=0.0f;\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        sum += xptr[h*W + w];\n    }\n    Y[idx] = sum / (float)(K*K);\n}\n\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\n\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\n\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/avgpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    avgpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/avgpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\n\nN,C,H,W=16,64,128,128\ntorch.manual_seed(2001)\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.avg_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False,count_include_pad=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/avgpool2d_X.bin\")\nY.numpy().tofile(\"./data/avgpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef main():\n    size = 16*64*64*64\n    if not (os.path.exists(\"./data/avgpool2d_Y_out.bin\") and os.path.exists(\"./data/avgpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/avgpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/avgpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\n\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task: Avg_Pooling_2D. Perform 2D average pooling on an input tensor with shape (16, 64, 128, 128) and data type float32. The output should be a tensor of shape (16, 64, 64, 64) with float32 values. Use a fixed kernel size of 2x2 and stride of 2 in both height and width dimensions. The pooling must be applied independently for each batch and channel, computing the average of elements in each non-overlapping 2x2 window without any padding.", "level2_prompt": "Task: Avg_Pooling_2D. For each output element corresponding to a batch, channel, and reduced spatial position, compute the average value over a 2x2 window in the input height and width dimensions. The stride of 2 ensures non-overlapping windows, resulting in output spatial dimensions that are half the input dimensions.", "level3_prompt": "Compute the Avg_Pooling_2D kernel on GPU using CUDA."}
{"id": 256, "task_name": "Avg_Pooling_2D", "task_description": "Compute the Avg_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "avgpool2d_X", "dtype": "float32", "shape": "(16, 128, 128, 128)"}], "outputs": [{"name": "avgpool2d_Y_out", "dtype": "float32", "shape": "(16, 128, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#define N 16\n#define C 128\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n\n__global__ void avgpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float sum=0.0f;\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        sum += xptr[h*W + w];\n    }\n    Y[idx] = sum / (float)(K*K);\n}\n\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\n\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\n\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/avgpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    avgpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/avgpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\n\nN,C,H,W=16,128,128,128\ntorch.manual_seed(2002)\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.avg_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False,count_include_pad=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/avgpool2d_X.bin\")\nY.numpy().tofile(\"./data/avgpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef main():\n    size = 16*128*64*64\n    if not (os.path.exists(\"./data/avgpool2d_Y_out.bin\") and os.path.exists(\"./data/avgpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/avgpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/avgpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\n\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task name: Avg_Pooling_2D. Implement a CUDA kernel that computes 2D average pooling on a 4-dimensional input tensor of shape (16, 128, 128, 128) with float32 data type. The output tensor should have shape (16, 128, 64, 64) and float32 data type. The kernel must use a 2x2 pooling window with stride 2, sliding non-overlappingly across the height and width dimensions. For each window, compute the average of the four elements. Batch and channel dimensions should be preserved. The kernel must handle no-padding conditions and maintain data type consistency.", "level2_prompt": "Task name: Avg_Pooling_2D. Implement a kernel that slides a 2x2 window over each channel of every input sample, moving with step size 2 along both height and width dimensions. For each window position, compute the arithmetic mean of the four elements within the window. The batch and channel dimensions remain unchanged, while spatial dimensions reduce by half.", "level3_prompt": "Compute the Avg_Pooling_2D kernel on GPU using CUDA."}
{"id": 257, "task_name": "Avg_Pooling_2D", "task_description": "Compute the Avg_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "avgpool2d_X", "dtype": "float32", "shape": "(32, 64, 128, 128)"}], "outputs": [{"name": "avgpool2d_Y_out", "dtype": "float32", "shape": "(32, 64, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#define N 32\n#define C 64\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n\n__global__ void avgpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float sum=0.0f;\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        sum += xptr[h*W + w];\n    }\n    Y[idx] = sum / (float)(K*K);\n}\n\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\n\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\n\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/avgpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    avgpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/avgpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\n\nN,C,H,W=32,64,128,128\ntorch.manual_seed(2003)\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.avg_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False,count_include_pad=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/avgpool2d_X.bin\")\nY.numpy().tofile(\"./data/avgpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef main():\n    size = 32*64*64*64\n    if not (os.path.exists(\"./data/avgpool2d_Y_out.bin\") and os.path.exists(\"./data/avgpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/avgpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/avgpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\n\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Implement the Avg_Pooling_2D kernel. Given a 4D input tensor of shape (32, 64, 128, 128) with float32 data type, compute average pooling using a 2x2 kernel with stride 2. For each non-overlapping 2x2 window in the spatial dimensions (height and width), calculate the average of the four elements. The output should be a 4D tensor of shape (32, 64, 64, 64) with float32 data type, where each element represents the average of its corresponding input window.", "level2_prompt": "Perform 2D average pooling. For each batch and channel, divide the input spatial dimensions (128x128) into non-overlapping 2x2 blocks. Compute the average value for each block and store it in the corresponding output position, reducing the spatial dimensions to 64x64.", "level3_prompt": "Compute the 2D average pooling operation."}
{"id": 258, "task_name": "Avg_Pooling_2D", "task_description": "Compute the Avg_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "avgpool2d_X", "dtype": "float32", "shape": "(32, 128, 128, 128)"}], "outputs": [{"name": "avgpool2d_Y_out", "dtype": "float32", "shape": "(32, 128, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#define N 32\n#define C 128\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n\n__global__ void avgpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float sum=0.0f;\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        sum += xptr[h*W + w];\n    }\n    Y[idx] = sum / (float)(K*K);\n}\n\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\n\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\n\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/avgpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    avgpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/avgpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\n\nN,C,H,W=32,128,128,128\ntorch.manual_seed(2004)\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.avg_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False,count_include_pad=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/avgpool2d_X.bin\")\nY.numpy().tofile(\"./data/avgpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef main():\n    size = 32*128*64*64\n    if not (os.path.exists(\"./data/avgpool2d_Y_out.bin\") and os.path.exists(\"./data/avgpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/avgpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/avgpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\n\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Implement the Avg_Pooling_2D CUDA kernel. The kernel should perform 2D average pooling on a 4D input tensor with shape (32, 128, 128, 128) of float32 values. The output tensor should have shape (32, 128, 64, 64) of float32 values. The pooling uses a 2x2 window with stride 2 in both height and width dimensions, covering non-overlapping regions. For each window, compute the average of all four elements and store it in the corresponding output position. The kernel must preserve batch and channel dimensions while reducing spatial dimensions by half.", "level2_prompt": "Avg_Pooling_2D: Given a 4D input tensor of shape (N, C, H, W), reduce spatial dimensions using 2x2 average pooling with stride 2. For each output position (n, c, i, j), compute the mean of input elements at positions (n, c, 2*i, 2*j), (n, c, 2*i+1, 2*j), (n, c, 2*i, 2*j+1), and (n, c, 2*i+1, 2*j+1). The output tensor should have shape (N, C, H/2, W/2).", "level3_prompt": "Compute the Avg_Pooling_2D kernel on GPU using CUDA."}
{"id": 259, "task_name": "Avg_Pooling_2D", "task_description": "Compute the Avg_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "avgpool2d_X", "dtype": "float32", "shape": "(64, 64, 128, 128)"}], "outputs": [{"name": "avgpool2d_Y_out", "dtype": "float32", "shape": "(64, 64, 64, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#define N 64\n#define C 64\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n\n__global__ void avgpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float sum=0.0f;\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        sum += xptr[h*W + w];\n    }\n    Y[idx] = sum / (float)(K*K);\n}\n\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\n\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\n\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/avgpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    avgpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/avgpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\n\nN,C,H,W=64,64,128,128\ntorch.manual_seed(2005)\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.avg_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False,count_include_pad=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/avgpool2d_X.bin\")\nY.numpy().tofile(\"./data/avgpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef main():\n    size = 64*64*64*64\n    if not (os.path.exists(\"./data/avgpool2d_Y_out.bin\") and os.path.exists(\"./data/avgpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/avgpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/avgpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\n\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task: Avg_Pooling_2D. Implement a CUDA kernel for 2D average pooling. The input is a 4D tensor named 'avgpool2d_X' with shape (64, 64, 128, 128) and float32 dtype. The output tensor 'avgpool2d_Y_out' must have shape (64, 64, 64, 64) and float32 dtype. The kernel should use a 2x2 pooling window with stride 2, computing the average of each non-overlapping window without padding. The input tensor dimensions represent batch, channels, height, and width respectively.", "level2_prompt": "Task: Avg_Pooling_2D. For each 2x2 window in the input tensor, compute the average of the four elements and store it in the output tensor. The windows are non-overlapping with stride 2, starting from the top-left corner of each channel in every batch. Input dimensions are batch (64), channels (64), height (128), width (128). Output dimensions are batch (64), channels (64), reduced height (64), reduced width (64).", "level3_prompt": "Compute the Avg_Pooling_2D kernel on GPU using CUDA."}
{"id": 260, "task_name": "Avg_Pooling_3D", "task_description": "Compute the Avg_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 1)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 1\n#define TILE_WIDTH 32\nconst int M = 262144;\n\n__global__ void AvgPool3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)32 * (long)32 * (long)32;\n        long ch_o = (long)8 * spatial_o;\n        int n = (int)(out_idx / ch_o);\n        long rem = out_idx % ch_o;\n        int c = (int)(rem / spatial_o);\n        long rem2 = rem % spatial_o;\n        int od = (int)(rem2 / (32 * 32));\n        int rem3 = (int)(rem2 % (32 * 32));\n        int oh = rem3 / 32;\n        int ow = rem3 % 32;\n        int ds = od * 2 - 1;\n        int hs = oh * 2 - 1;\n        int ws = ow * 2 - 1;\n        float acc = 0.0f;\n        for (int kd = 0; kd < 3; ++kd) {\n            int id = ds + kd;\n            for (int kh = 0; kh < 3; ++kh) {\n                int ih = hs + kh;\n                for (int kw = 0; kw < 3; ++kw) {\n                    int iw = ws + kw;\n                    float v = 0.0f;\n                    if (!(id < 0 || id >= 64 || ih < 0 || ih >= 64 || iw < 0 || iw >= 64)) {\n                        long in_idx = ((((long)n * 8 + c) * 64 + id) * 64 + ih) * 64 + iw;\n                        v = A[in_idx];\n                    }\n                    acc += v;\n                }\n            }\n        }\n        C[out_idx] = acc / 27.00000000f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AvgPool3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 262144\nK = 8\nN = 1\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 8, 64, 64, 64)\nC = torch.nn.functional.avg_pool3d(X, (3, 3, 3), (2, 2, 2), (1, 1, 1), ceil_mode=False, count_include_pad=True)\nC = C.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 1\n    M = 262144\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Avg_Pooling_3D. The kernel must perform 3D average pooling. The input is a tensor 'matA' of shape (262144, 8) and data type float32, which represents a 5D tensor of shape (1, 8, 64, 64, 64) in row-major order. The second input 'matB' of shape (8, 1) and float32 is provided but not used. The output 'matC_out' is a vector of shape (262144,) and float32, which is the flattened version of the 5D output tensor of shape (1, 8, 32, 32, 32). The pooling operation uses a kernel size of 3x3x3, stride of 2x2x2, and padding of 1x1x1. For each output element, the kernel must average 27 input elements from the corresponding window in the input. When the window extends beyond the input boundaries (due to padding), the out-of-bound elements should be treated as zero. The kernel must be implemented for the GPU using CUDA.", "level2_prompt": "Task: Avg_Pooling_3D. The kernel computes a 3D average pooling on a 5D input tensor of shape (1, 8, 64, 64, 64) to produce a 5D output tensor of shape (1, 8, 32, 32, 32). The pooling uses a 3x3x3 kernel, stride 2 in each spatial dimension, and padding 1. Each output element is the average of the 27 elements in the corresponding input window, with out-of-bound elements treated as zero.", "level3_prompt": "Compute the Avg_Pooling_3D kernel on GPU using CUDA."}
{"id": 261, "task_name": "Avg_Pooling_3D", "task_description": "Compute the Avg_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(393216, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 1)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(393216, 1)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 1\n#define TILE_WIDTH 32\nconst int M = 393216;\n\n__global__ void AvgPool3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)32 * (long)48 * (long)32;\n        long ch_o = (long)4 * spatial_o;\n        int n = (int)(out_idx / ch_o);\n        long rem = out_idx % ch_o;\n        int c = (int)(rem / spatial_o);\n        long rem2 = rem % spatial_o;\n        int od = (int)(rem2 / (48 * 32));\n        int rem3 = (int)(rem2 % (48 * 32));\n        int oh = rem3 / 32;\n        int ow = rem3 % 32;\n        int ds = od * 2 - 1;\n        int hs = oh * 2 - 1;\n        int ws = ow * 2 - 1;\n        float acc = 0.0f;\n        for (int kd = 0; kd < 3; ++kd) {\n            int id = ds + kd;\n            for (int kh = 0; kh < 3; ++kh) {\n                int ih = hs + kh;\n                for (int kw = 0; kw < 3; ++kw) {\n                    int iw = ws + kw;\n                    float v = 0.0f;\n                    if (!(id < 0 || id >= 64 || ih < 0 || ih >= 96 || iw < 0 || iw >= 64)) {\n                        long in_idx = ((((long)n * 4 + c) * 64 + id) * 96 + ih) * 64 + iw;\n                        v = A[in_idx];\n                    }\n                    acc += v;\n                }\n            }\n        }\n        C[out_idx] = acc / 27.00000000f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AvgPool3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 393216\nK = 8\nN = 1\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(2, 4, 64, 96, 64)\nC = torch.nn.functional.avg_pool3d(X, (3, 3, 3), (2, 2, 2), (1, 1, 1), ceil_mode=False, count_include_pad=True)\nC = C.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 1\n    M = 393216\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Avg_Pooling_3D\nDescription: Implement a 3D average pooling operation on the input tensor A, which is provided as a 2D matrix of shape (393216, 8). This tensor must be interpreted as a 5D tensor of shape (2, 4, 64, 96, 64) in row-major order. Apply a 3x3x3 pooling kernel with stride 2 in each spatial dimension and padding 1. For each output position, compute the average of all valid elements within the 3x3x3 window (treating out-of-bound elements as zero) and divide the sum by 27.0. The result should be a 5D tensor of shape (2, 4, 32, 48, 32), flattened into the output matrix of shape (393216, 1). The input matrix B of shape (8, 1) is provided but not used in the computation.", "level2_prompt": "Task: Avg_Pooling_3D\nAlgorithm: Reshape the input matrix A into a 5D tensor with dimensions (2, 4, 64, 96, 64). Apply 3D average pooling using a 3x3x3 kernel with stride 2 and padding 1. For each pooling window, compute the average of all elements (with out-of-bound elements treated as zero) and scale by 1/27. The resulting tensor of shape (2, 4, 32, 48, 32) is then flattened into the output matrix. Input matrix B is unused.", "level3_prompt": "Compute the 3D average pooling of the input tensor."}
{"id": 262, "task_name": "Avg_Pooling_3D", "task_description": "Compute the Avg_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(524288, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 1)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(524288,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 1\n#define TILE_WIDTH 32\nconst int M = 524288;\n\n__global__ void AvgPool3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)64 * (long)32 * (long)16;\n        long ch_o = (long)16 * spatial_o;\n        int n = (int)(out_idx / ch_o);\n        long rem = out_idx % ch_o;\n        int c = (int)(rem / spatial_o);\n        long rem2 = rem % spatial_o;\n        int od = (int)(rem2 / (32 * 16));\n        int rem3 = (int)(rem2 % (32 * 16));\n        int oh = rem3 / 16;\n        int ow = rem3 % 16;\n        int ds = od * 2 - 1;\n        int hs = oh * 2 - 1;\n        int ws = ow * 2 - 1;\n        float acc = 0.0f;\n        for (int kd = 0; kd < 3; ++kd) {\n            int id = ds + kd;\n            for (int kh = 0; kh < 3; ++kh) {\n                int ih = hs + kh;\n                for (int kw = 0; kw < 3; ++kw) {\n                    int iw = ws + kw;\n                    float v = 0.0f;\n                    if (!(id < 0 || id >= 128 || ih < 0 || ih >= 64 || iw < 0 || iw >= 32)) {\n                        long in_idx = ((((long)n * 16 + c) * 128 + id) * 64 + ih) * 32 + iw;\n                        v = A[in_idx];\n                    }\n                    acc += v;\n                }\n            }\n        }\n        C[out_idx] = acc / 27.00000000f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AvgPool3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 524288\nK = 8\nN = 1\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 16, 128, 64, 32)\nC = torch.nn.functional.avg_pool3d(X, (3, 3, 3), (2, 2, 2), (1, 1, 1), ceil_mode=False, count_include_pad=True)\nC = C.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 1\n    M = 524288\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: Avg_Pooling_3D. Implement a CUDA kernel that performs 3D average pooling on a 5D tensor. The input tensor matA (float32, shape: 524288x8) must be interpreted as a reshaped 5D tensor with dimensions (1, 16, 128, 64, 32). The pooling uses a 3x3x3 kernel, stride 2x2x2, and padding 1x1x1. Output positions correspond to a flattened 5D tensor of shape (1, 16, 64, 32, 16) stored in matC_out (float32, shape: 524288). For each output element, average all valid elements in the 3x3x3 input window (out-of-bound elements count as zero), then divide by 27. The input matB (float32, shape: 8x1) is unused.", "level2_prompt": "Task name: Avg_Pooling_3D. Reshape input matA (524288x8) into a 5D tensor (1, 16, 128, 64, 32). For each output element at position (c, od, oh, ow) in the resulting 5D grid (1, 16, 64, 32, 16): compute the sum of elements in a 3x3x3 input window centered at (od*2-1, oh*2-1, ow*2-1) in the depth-height-width dimensions. Treat out-of-bound accesses as zero. Divide the sum by 27 to get the average, then flatten results into a 524288-element vector. Input matB is ignored.", "level3_prompt": "Compute the Avg_Pooling_3D kernel on GPU using CUDA."}
{"id": 263, "task_name": "Avg_Pooling_3D", "task_description": "Compute the Avg_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(884736, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 1)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(884736,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 1\n#define TILE_WIDTH 32\nconst int M = 884736;\n\n__global__ void AvgPool3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)48 * (long)24 * (long)48;\n        long ch_o = (long)8 * spatial_o;\n        int n = (int)(out_idx / ch_o);\n        long rem = out_idx % ch_o;\n        int c = (int)(rem / spatial_o);\n        long rem2 = rem % spatial_o;\n        int od = (int)(rem2 / (24 * 48));\n        int rem3 = (int)(rem2 % (24 * 48));\n        int oh = rem3 / 48;\n        int ow = rem3 % 48;\n        int ds = od * 2 - 1;\n        int hs = oh * 2 - 1;\n        int ws = ow * 2 - 1;\n        float acc = 0.0f;\n        for (int kd = 0; kd < 3; ++kd) {\n            int id = ds + kd;\n            for (int kh = 0; kh < 3; ++kh) {\n                int ih = hs + kh;\n                for (int kw = 0; kw < 3; ++kw) {\n                    int iw = ws + kw;\n                    float v = 0.0f;\n                    if (!(id < 0 || id >= 96 || ih < 0 || ih >= 48 || iw < 0 || iw >= 96)) {\n                        long in_idx = ((((long)n * 8 + c) * 96 + id) * 48 + ih) * 96 + iw;\n                        v = A[in_idx];\n                    }\n                    acc += v;\n                }\n            }\n        }\n        C[out_idx] = acc / 27.00000000f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AvgPool3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 884736\nK = 8\nN = 1\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(2, 8, 96, 48, 96)\nC = torch.nn.functional.avg_pool3d(X, (3, 3, 3), (2, 2, 2), (1, 1, 1), ceil_mode=False, count_include_pad=True)\nC = C.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 1\n    M = 884736\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Avg_Pooling_3D. Compute a 3D average pooling operation on the input tensor matA. Inputs: matA (float32, shape (884736, 8)) and matB (float32, shape (8, 1)). The kernel must interpret matA as a 5D tensor with dimensions (batch=2, channels=8, depth=96, height=48, width=96). Output: matC_out (float32, shape (884736,)), representing a flattened 5D tensor of shape (2, 8, 48, 24, 48). Use a 3x3x3 pooling window with stride 2x2x2 and padding 1x1x1. For each output element, average all valid elements in the corresponding input window, treating out-of-bound elements as zero. Divide the sum by 27 to compute the average. Constraints: The kernel must ignore matB, handle boundary conditions via padding, and preserve input-output mapping invariants.", "level2_prompt": "Task: Avg_Pooling_3D. For each output element at position (n, c, od, oh, ow) in the (2,8,48,24,48) tensor, compute the average of a 3x3x3 window centered at input position (n, c, od*2-1, oh*2-1, ow*2-1) in the (2,8,96,48,96) input tensor. Sum elements within the window bounds, treat out-of-bound accesses as zero, and divide the total by 27. The kernel takes matA and matB as inputs but only uses matA for computation.", "level3_prompt": "Compute the 3D average pooling of input tensor matA with kernel size 3, stride 2, and padding 1."}
{"id": 264, "task_name": "Avg_Pooling_3D", "task_description": "Compute the Avg_Pooling_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(524288, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 1)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(524288, 1)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 1\n#define TILE_WIDTH 32\nconst int M = 524288;\n\n__global__ void AvgPool3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)64 * (long)64 * (long)32;\n        long ch_o = (long)4 * spatial_o;\n        int n = (int)(out_idx / ch_o);\n        long rem = out_idx % ch_o;\n        int c = (int)(rem / spatial_o);\n        long rem2 = rem % spatial_o;\n        int od = (int)(rem2 / (64 * 32));\n        int rem3 = (int)(rem2 % (64 * 32));\n        int oh = rem3 / 32;\n        int ow = rem3 % 32;\n        int ds = od * 2 - 1;\n        int hs = oh * 2 - 1;\n        int ws = ow * 2 - 1;\n        float acc = 0.0f;\n        for (int kd = 0; kd < 3; ++kd) {\n            int id = ds + kd;\n            for (int kh = 0; kh < 3; ++kh) {\n                int ih = hs + kh;\n                for (int kw = 0; kw < 3; ++kw) {\n                    int iw = ws + kw;\n                    float v = 0.0f;\n                    if (!(id < 0 || id >= 128 || ih < 0 || ih >= 128 || iw < 0 || iw >= 64)) {\n                        long in_idx = ((((long)n * 4 + c) * 128 + id) * 128 + ih) * 64 + iw;\n                        v = A[in_idx];\n                    }\n                    acc += v;\n                }\n            }\n        }\n        C[out_idx] = acc / 27.00000000f;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    AvgPool3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 524288\nK = 8\nN = 1\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 4, 128, 128, 64)\nC = torch.nn.functional.avg_pool3d(X, (3, 3, 3), (2, 2, 2), (1, 1, 1), ceil_mode=False, count_include_pad=True)\nC = C.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 1\n    M = 524288\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Avg_Pooling_3D. Given an input tensor matA of shape (524288, 8) and dtype float32, which represents a reshaped 5D tensor of dimensions (1, 4, 128, 128, 64), perform a 3D average pooling operation with a kernel size of 3x3x3, stride of 2x2x2, and padding of 1x1x1. The second input tensor matB of shape (8, 1) and dtype float32 is provided but not used. The output tensor matC_out should be of shape (524288, 1) and dtype float32, which is the flattened result of the pooled tensor of shape (1, 4, 64, 64, 32). The pooling must account for the padding by including zero-padded values only when the window extends beyond the input boundaries, and the average is computed by summing the valid elements in the window and dividing by 27 (the total number of elements in the kernel).", "level2_prompt": "Task: Avg_Pooling_3D. Reshape the input tensor A (524288x8) into a 5D tensor (1,4,128,128,64). Apply 3D average pooling with a 3x3x3 kernel, stride of 2 in each spatial dimension, and padding of 1. The pooling operation averages the elements in each 3x3x3 window, including padded zeros for out-of-bound positions. The output is a 5D tensor (1,4,64,64,32) which is then flattened to a 2D tensor of shape (524288,1).", "level3_prompt": "Compute the Avg_Pooling_3D kernel on GPU using CUDA."}
{"id": 265, "task_name": "BatchNorm", "task_description": "Compute the BatchNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 4096;\n\n__global__ void BatchNorm2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        int r = row; int c = col;\n        if (r >= M || c >= N) return;\n        double sum = 0.0, sumsq = 0.0;\n        for (int i = 0; i < M; ++i) {\n            float v = A[i * K + c];\n            sum += (double)v; sumsq += (double)v * (double)v;\n        }\n        double mean = sum / (double)M;\n        double var = sumsq / (double)M - mean * mean;\n        float gamma = B[c];\n        float beta  = B[N + c];\n        float x = A[r * K + c];\n        float y = (x - (float)mean) * rsqrtf((float)var + 1e-5f) * gamma + beta;\n        C[r * N + c] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    BatchNorm2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 4096\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\n\nX = A.clone()\ngamma = torch.randn(N, dtype=torch.float32)\nbeta = torch.randn(N, dtype=torch.float32)\nmean = X.mean(dim=0)\nvar = X.var(dim=0, unbiased=False)\nY = (X - mean) / torch.sqrt(var + 1e-5) * gamma + beta\nC = Y\nBf = B.view(-1)\nBf[:N] = gamma\nBf[N:2*N] = beta\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 4096\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: BatchNorm. Compute batch normalization on a 2D input tensor. The input tensor matA is a float32 matrix of shape (4096, 1024). The second input matB is a float32 matrix of shape (1024, 1024), but only the first 2048 elements (in row-major order) are used: the first 1024 elements are the gamma parameters (one per column of matA) and the next 1024 elements are the beta parameters (one per column of matA). The output is a float32 matrix of shape (4096, 1024). For each column of matA, compute the mean and variance of the elements in that column. Then, for each element in the column, compute: (element - mean) * rsqrt(variance + 1e-5) * gamma + beta, where gamma and beta are the parameters for that column. The kernel must use an epsilon value of 1e-5.", "level2_prompt": "Task: BatchNorm. For each column in the input matrix, calculate the mean and variance of the values in that column. Then, normalize each element in the column by subtracting the mean and dividing by the square root of the variance plus a small epsilon (1e-5). Scale the normalized value by a gamma parameter and shift by a beta parameter, both specific to the column.", "level3_prompt": "Apply batch normalization to the input matrix."}
{"id": 266, "task_name": "BatchNorm", "task_description": "Compute the BatchNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void BatchNorm2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        int r = row; int c = col;\n        if (r >= M || c >= N) return;\n        double sum = 0.0, sumsq = 0.0;\n        for (int i = 0; i < M; ++i) {\n            float v = A[i * K + c];\n            sum += (double)v; sumsq += (double)v * (double)v;\n        }\n        double mean = sum / (double)M;\n        double var = sumsq / (double)M - mean * mean;\n        float gamma = B[c];\n        float beta  = B[N + c];\n        float x = A[r * K + c];\n        float y = (x - (float)mean) * rsqrtf((float)var + 1e-5f) * gamma + beta;\n        C[r * N + c] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    BatchNorm2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\n\nX = A.clone()\ngamma = torch.randn(N, dtype=torch.float32)\nbeta = torch.randn(N, dtype=torch.float32)\nmean = X.mean(dim=0)\nvar = X.var(dim=0, unbiased=False)\nY = (X - mean) / torch.sqrt(var + 1e-5) * gamma + beta\nC = Y\nBf = B.view(-1)\nBf[:N] = gamma\nBf[N:2*N] = beta\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: BatchNorm. Implement a CUDA kernel for batch normalization. The kernel takes two input tensors: matA of shape (8192, 2048) and matB of shape (2048, 2048), both of float32 type. The output tensor matC_out has shape (8192, 2048) and float32 type. For each column of matA, compute the mean and variance of all elements in that column. Then, for each element in the column, normalize it by subtracting the mean and dividing by the square root of the variance plus 1e-5. Then, scale the normalized value by a gamma parameter and add a beta parameter. The gamma and beta parameters for column index j are stored in matB: gamma at the j-th element of the first 2048 elements (flattened) of matB, and beta at the j-th element of the next 2048 elements (flattened) of matB. The kernel must be implemented to handle the given tensor dimensions.", "level2_prompt": "Task name: BatchNorm. Given a matrix A of size M x K and a matrix B (which provides gamma and beta vectors), compute a matrix C of size M x K. For each column j (0 <= j < K), compute the mean (mean_j) and variance (var_j) of the j-th column of A. Then, for each element A[i][j], compute C[i][j] = (A[i][j] - mean_j) / sqrt(var_j + 1e-5) * gamma_j + beta_j, where gamma_j is the j-th element of the first 2048 elements of the flattened B, and beta_j is the j-th element of the next 2048 elements of the flattened B. Here, M=8192 and K=2048.", "level3_prompt": "Compute the BatchNorm kernel on GPU using CUDA."}
{"id": 267, "task_name": "BatchNorm", "task_description": "Compute the BatchNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 3072)"}, {"name": "matB", "dtype": "float32", "shape": "(3072, 3072)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096, 3072)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 3072\n#define N 3072\n#define TILE_WIDTH 32\nconst int M = 4096;\n\n__global__ void BatchNorm2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        int r = row; int c = col;\n        if (r >= M || c >= N) return;\n        double sum = 0.0, sumsq = 0.0;\n        for (int i = 0; i < M; ++i) {\n            float v = A[i * K + c];\n            sum += (double)v; sumsq += (double)v * (double)v;\n        }\n        double mean = sum / (double)M;\n        double var = sumsq / (double)M - mean * mean;\n        float gamma = B[c];\n        float beta  = B[N + c];\n        float x = A[r * K + c];\n        float y = (x - (float)mean) * rsqrtf((float)var + 1e-5f) * gamma + beta;\n        C[r * N + c] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    BatchNorm2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 4096\nK = 3072\nN = 3072\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\n\nX = A.clone()\ngamma = torch.randn(N, dtype=torch.float32)\nbeta = torch.randn(N, dtype=torch.float32)\nmean = X.mean(dim=0)\nvar = X.var(dim=0, unbiased=False)\nY = (X - mean) / torch.sqrt(var + 1e-5) * gamma + beta\nC = Y\nBf = B.view(-1)\nBf[:N] = gamma\nBf[N:2*N] = beta\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 3072\n    N = 3072\n    M = 4096\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: BatchNorm. Implement a kernel to perform batch normalization on a 2D input matrix. The input matrix matA has dimensions 4096x3072 (float32) representing a batch of 4096 samples with 3072 features each. The second input matB (3072x3072, float32) contains gamma parameters in its first 3072 elements and beta parameters in its next 3072 elements when flattened. For each feature column in matA, compute the mean and variance across all samples. Then normalize each element using: (value - mean) * gamma / sqrt(variance + 1e-5) + beta. The output matC_out must have the same dimensions 4096x3072 (float32) as matA. Ensure numerical stability by including the 1e-5 epsilon term in variance calculations.", "level2_prompt": "Task: BatchNorm. Given matrix A (4096x3072) and parameter matrix B (3072x3072), compute output matrix C (4096x3072). For each column j in A, calculate mean μ_j and variance σ_j² using all rows. Then for each element A[i][j], compute C[i][j] = (A[i][j] - μ_j) × γ_j ÷ √(σ_j² + 10⁻⁵) + β_j, where γ_j is the j-th element of B's first 3072 elements and β_j is the (j+3072)-th element of B.", "level3_prompt": "Compute batch normalization for a 2D input matrix."}
{"id": 268, "task_name": "BatchNorm", "task_description": "Compute the BatchNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void BatchNorm2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        int r = row; int c = col;\n        if (r >= M || c >= N) return;\n        double sum = 0.0, sumsq = 0.0;\n        for (int i = 0; i < M; ++i) {\n            float v = A[i * K + c];\n            sum += (double)v; sumsq += (double)v * (double)v;\n        }\n        double mean = sum / (double)M;\n        double var = sumsq / (double)M - mean * mean;\n        float gamma = B[c];\n        float beta  = B[N + c];\n        float x = A[r * K + c];\n        float y = (x - (float)mean) * rsqrtf((float)var + 1e-5f) * gamma + beta;\n        C[r * N + c] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    BatchNorm2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\n\nX = A.clone()\ngamma = torch.randn(N, dtype=torch.float32)\nbeta = torch.randn(N, dtype=torch.float32)\nmean = X.mean(dim=0)\nvar = X.var(dim=0, unbiased=False)\nY = (X - mean) / torch.sqrt(var + 1e-5) * gamma + beta\nC = Y\nBf = B.view(-1)\nBf[:N] = gamma\nBf[N:2*N] = beta\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: BatchNorm. The kernel should compute batch normalization on a 2D matrix. Input matA is a float32 matrix of shape (16384, 1024). Input matB is a float32 matrix of shape (1024, 1024), where the first 1024 elements represent gamma (scale) parameters and the next 1024 elements represent beta (shift) parameters. The output matC_out is a float32 matrix of shape (16384, 1024). For each element, compute the mean and variance of its entire column in matA, then normalize the element using these statistics: subtract the mean, divide by the square root of variance plus 1e-5, scale by gamma, and add beta. Each column's statistics must be computed independently.", "level2_prompt": "BatchNorm: For each column j, compute the mean μ_j and variance σ_j² of all elements in column j of matrix A. For each element A[i,j] in the output, compute: (A[i,j] - μ_j) * gamma_j / sqrt(σ_j² + 1e-5) + beta_j, where gamma_j and beta_j are the j-th elements of the gamma and beta vectors stored in matrix B (gamma in first 1024 elements, beta in next 1024 elements).", "level3_prompt": "Compute batch normalization for each element using column-wise statistics and provided gamma/beta parameters."}
{"id": 269, "task_name": "BatchNorm", "task_description": "Compute the BatchNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1536)"}, {"name": "matB", "dtype": "float32", "shape": "(1536, 1536)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1536)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1536\n#define N 1536\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void BatchNorm2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        int r = row; int c = col;\n        if (r >= M || c >= N) return;\n        double sum = 0.0, sumsq = 0.0;\n        for (int i = 0; i < M; ++i) {\n            float v = A[i * K + c];\n            sum += (double)v; sumsq += (double)v * (double)v;\n        }\n        double mean = sum / (double)M;\n        double var = sumsq / (double)M - mean * mean;\n        float gamma = B[c];\n        float beta  = B[N + c];\n        float x = A[r * K + c];\n        float y = (x - (float)mean) * rsqrtf((float)var + 1e-5f) * gamma + beta;\n        C[r * N + c] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    BatchNorm2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1536\nN = 1536\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\n\nX = A.clone()\ngamma = torch.randn(N, dtype=torch.float32)\nbeta = torch.randn(N, dtype=torch.float32)\nmean = X.mean(dim=0)\nvar = X.var(dim=0, unbiased=False)\nY = (X - mean) / torch.sqrt(var + 1e-5) * gamma + beta\nC = Y\nBf = B.view(-1)\nBf[:N] = gamma\nBf[N:2*N] = beta\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1536\n    N = 1536\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a Batch Normalization kernel for a 2D matrix. The input matrix matA has dimensions (8192, 1536) and data type float32. The second input matB has dimensions (1536, 1536) and contains gamma parameters in its first 1536 elements and beta parameters in its next 1536 elements. The output matrix matC_out must have dimensions (8192, 1536) and data type float32. For each column, compute the mean and variance across all rows. Then normalize each element using: normalized_value = (element - column_mean) * rsqrtf(column_variance + 1e-5) * gamma_j + beta_j, where gamma_j and beta_j correspond to the column index.", "level2_prompt": "Perform batch normalization per column. For each column j, calculate the mean as the average of all elements in column j and the variance as the average of squared elements minus the square of the mean. Then transform each element in column j by subtracting the mean, dividing by the square root of variance plus 1e-5, multiplying by gamma_j, and adding beta_j.", "level3_prompt": "Compute batch normalization for a 2D input matrix using gamma and beta parameters."}
{"id": 270, "task_name": "Conv_Transposed_2D", "task_description": "Compute the Conv_Transposed_2D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 64)"}, {"name": "matB", "dtype": "float32", "shape": "(64, 256)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(65536, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 64\n#define N 256\n#define TILE_WIDTH 32\nconst int M = 65536;\n\n__global__ void ConvTransposed2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)64 * (long)512 * (long)512;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (512 * 512));\n        int rem = (int)(tmp % (512 * 512));\n        int oh = rem / 512;\n        int ow = rem % 512;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 64; ++ic) {\n            for (int kh = 0; kh < 2; ++kh) {\n                int ih = (oh - kh);\n                if (ih % 2 != 0) continue;\n                ih /= 2;\n                if (ih < 0 || ih >= 256) continue;\n                for (int kw = 0; kw < 2; ++kw) {\n                    int iw = (ow - kw);\n                    if (iw % 2 != 0) continue;\n                    iw /= 2;\n                    if (iw < 0 || iw >= 256) continue;\n                    long in_idx = (((long)n * 64 + ic) * 256 + ih) * 256 + iw;\n                    long w_idx  = (((long)ic * 64 + oc) * 2 + kh) * 2 + kw;\n                    float x = A[in_idx];\n                    float w = B[w_idx];\n                    acc += x * w;\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 65536\nK = 64\nN = 256\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 64, 256, 256)\nWt = torch.randn(64, 64, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose2d(X, Wt, bias=None, stride=(2,2), padding=(0,0), output_padding=(0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 64\n    N = 256\n    M = 65536\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for a 2D transposed convolution (deconvolution) operation. The input consists of two matrices: 'matA' of shape (65536, 64) and 'matB' of shape (64, 256), both with float32 data type. The kernel must compute an output matrix 'matC_out' of shape (65536, 256) with float32 data type. The operation reverses a convolution with a 2x2 kernel and stride 2: for each output spatial position (oh, ow) and output channel, accumulate contributions from input channels and kernel positions. Specifically, map each output element to input positions via ih = (oh - kh)/2 and iw = (ow - kw)/2 only when (oh - kh) and (ow - kw) are even, and ensure ih ∈ [0, 255] and iw ∈ [0, 255]. Skip invalid positions during accumulation.", "level2_prompt": "Perform a 2D transposed convolution with a 2x2 kernel and stride 2. Transform an input tensor of shape (1, 64, 256, 256) using weights of shape (64, 64, 2, 2) into an output tensor of shape (1, 64, 512, 512). For each output location (n, oc, oh, ow), sum over input channels (ic) and kernel offsets (kh, kw) the product of the input element at (n, ic, ih, iw) and the weight at (ic, oc, kh, kw), where ih = (oh - kh)/2 and iw = (ow - kw)/2, subject to even differences and spatial boundary constraints.", "level3_prompt": "Compute the Conv_Transposed_2D kernel on GPU using CUDA."}
{"id": 271, "task_name": "Conv_Transposed_2D", "task_description": "Compute the Conv_Transposed_2D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(131072, 64)"}, {"name": "matB", "dtype": "float32", "shape": "(64, 256)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(131072, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 64\n#define N 256\n#define TILE_WIDTH 32\nconst int M = 131072;\n\n__global__ void ConvTransposed2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)64 * (long)512 * (long)512;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (512 * 512));\n        int rem = (int)(tmp % (512 * 512));\n        int oh = rem / 512;\n        int ow = rem % 512;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 64; ++ic) {\n            for (int kh = 0; kh < 2; ++kh) {\n                int ih = (oh - kh);\n                if (ih % 2 != 0) continue;\n                ih /= 2;\n                if (ih < 0 || ih >= 256) continue;\n                for (int kw = 0; kw < 2; ++kw) {\n                    int iw = (ow - kw);\n                    if (iw % 2 != 0) continue;\n                    iw /= 2;\n                    if (iw < 0 || iw >= 256) continue;\n                    long in_idx = (((long)n * 64 + ic) * 256 + ih) * 256 + iw;\n                    long w_idx  = (((long)ic * 64 + oc) * 2 + kh) * 2 + kw;\n                    float x = A[in_idx];\n                    float w = B[w_idx];\n                    acc += x * w;\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 131072\nK = 64\nN = 256\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(2, 64, 256, 256)\nWt = torch.randn(64, 64, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose2d(X, Wt, bias=None, stride=(2,2), padding=(0,0), output_padding=(0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 64\n    N = 256\n    M = 131072\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: Conv_Transposed_2D. Compute a 2D transposed convolution operation. The input matrix `matA` has shape (131072, 64) and data type float32. The input matrix `matB` has shape (64, 256) and data type float32. The output matrix `matC_out` must have shape (131072, 256) and data type float32. The kernel must reshape `matA` to (2, 64, 256, 256) and use the first 8192 elements of `matB` (reshaped to (64, 64, 2, 2)) as convolution weights. The transposed convolution uses stride 2 with no padding. For each output position (n, oc, oh, ow), compute the sum over input channels (ic) and kernel positions (kh, kw) where valid input positions (ih, iw) are derived as ih = (oh - kh)/2 and iw = (ow - kw)/2, requiring (oh - kh) and (ow - kw) to be non-negative, even, and within input spatial bounds (0-255).", "level2_prompt": "Task name: Conv_Transposed_2D. Reshape input A (131072x64) to (2, 64, 256, 256) and B's first 8192 elements (64x256) to (64, 64, 2, 2). Compute output tensor (2, 64, 512, 512) via transposed convolution with stride 2. For each output element (n, oc, oh, ow), sum over ic (0-63), kh (0-1), kw (0-1): if (oh-kh) ≥0, even, and (oh-kh)/2 ∈ [0,255], and similarly for width, multiply A[n, ic, (oh-kh)/2, (ow-kw)/2] by B[ic, oc, kh, kw]. Reshape result to (131072, 256).", "level3_prompt": "Compute the Conv_Transposed_2D kernel on GPU using CUDA."}
{"id": 272, "task_name": "Conv_Transposed_2D", "task_description": "Compute the Conv_Transposed_2D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(49152, 128)"}, {"name": "matB", "dtype": "float32", "shape": "(128, 512)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(49152, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 128\n#define N 512\n#define TILE_WIDTH 32\nconst int M = 49152;\n\n__global__ void ConvTransposed2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)128 * (long)512 * (long)384;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (512 * 384));\n        int rem = (int)(tmp % (512 * 384));\n        int oh = rem / 384;\n        int ow = rem % 384;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 128; ++ic) {\n            for (int kh = 0; kh < 2; ++kh) {\n                int ih = (oh - kh);\n                if (ih % 2 != 0) continue;\n                ih /= 2;\n                if (ih < 0 || ih >= 256) continue;\n                for (int kw = 0; kw < 2; ++kw) {\n                    int iw = (ow - kw);\n                    if (iw % 2 != 0) continue;\n                    iw /= 2;\n                    if (iw < 0 || iw >= 192) continue;\n                    long in_idx = (((long)n * 128 + ic) * 256 + ih) * 192 + iw;\n                    long w_idx  = (((long)ic * 128 + oc) * 2 + kh) * 2 + kw;\n                    float x = A[in_idx];\n                    float w = B[w_idx];\n                    acc += x * w;\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 49152\nK = 128\nN = 512\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 128, 256, 192)\nWt = torch.randn(128, 128, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose2d(X, Wt, bias=None, stride=(2,2), padding=(0,0), output_padding=(0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 128\n    N = 512\n    M = 49152\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Perform a 2D transposed convolution on an input tensor stored in matrix A (shape: [49152, 128]), which represents a 4D tensor of dimensions [1, 128, 256, 192]. The weights are stored in the first 65536 elements of matrix B (shape: [128, 512]) and represent a 4D tensor of dimensions [128, 128, 2, 2]. The convolution uses a stride of 2 in both height and width with no padding. The output tensor has dimensions [1, 128, 512, 384] and must be stored in matrix C (shape: [49152, 512]). For each output element at position (oc, oh, ow) (with batch index 0), compute the sum over input channels (ic) and kernel indices (kh, kw) of the product of the input element at (ic, ih, iw) and the weight at (ic, oc, kh, kw), where ih = (oh - kh) / 2 and iw = (ow - kw) / 2. Only include terms where (oh - kh) and (ow - kw) are even, and ih is in [0, 256) and iw is in [0, 192).", "level2_prompt": "Compute a 2D transposed convolution with a 2x2 kernel and stride 2. The input is a tensor of shape [1, 128, 256, 192] and the weights are a tensor of shape [128, 128, 2, 2]. The output is a tensor of shape [1, 128, 512, 384]. Each output element at (0, oc, oh, ow) is the sum over input channels ic and kernel indices kh, kw of the product between the input element at (0, ic, ih, iw) and the weight at (ic, oc, kh, kw), where ih = (oh - kh) / 2 and iw = (ow - kw) / 2. The term is included only if (oh-kh) and (ow-kw) are even and ih in [0,256) and iw in [0,192).", "level3_prompt": "Compute the Conv_Transposed_2D kernel on GPU using CUDA."}
{"id": 273, "task_name": "Conv_Transposed_2D", "task_description": "Compute the Conv_Transposed_2D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(131072, 32)"}, {"name": "matB", "dtype": "float32", "shape": "(32, 128)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 32\n#define N 128\n#define TILE_WIDTH 32\nconst int M = 131072;\n\n__global__ void ConvTransposed2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)32 * (long)1024 * (long)512;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (1024 * 512));\n        int rem = (int)(tmp % (1024 * 512));\n        int oh = rem / 512;\n        int ow = rem % 512;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 32; ++ic) {\n            for (int kh = 0; kh < 2; ++kh) {\n                int ih = (oh - kh);\n                if (ih % 2 != 0) continue;\n                ih /= 2;\n                if (ih < 0 || ih >= 512) continue;\n                for (int kw = 0; kw < 2; ++kw) {\n                    int iw = (ow - kw);\n                    if (iw % 2 != 0) continue;\n                    iw /= 2;\n                    if (iw < 0 || iw >= 256) continue;\n                    long in_idx = (((long)n * 32 + ic) * 512 + ih) * 256 + iw;\n                    long w_idx  = (((long)ic * 32 + oc) * 2 + kh) * 2 + kw;\n                    float x = A[in_idx];\n                    float w = B[w_idx];\n                    acc += x * w;\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 131072\nK = 32\nN = 128\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 32, 512, 256)\nWt = torch.randn(32, 32, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose2d(X, Wt, bias=None, stride=(2,2), padding=(0,0), output_padding=(0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 32\n    N = 128\n    M = 131072\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for a transposed 2D convolution (Conv_Transposed_2D). The input tensor matA (float32, shape [131072, 32]) represents a 4D tensor of shape [1, 32, 512, 256]. The weight tensor matB (float32, shape [32, 128]) contains a 4D weight tensor of shape [32, 32, 2, 2] in its first 4096 elements. The output tensor matC_out (float32, shape [16777216]) is the flattened result of the transposed convolution, which has the 4D shape [1, 32, 1024, 512]. The convolution uses a 2x2 kernel, stride 2, and no padding. For each output element at [0, oc, oh, ow], the kernel must sum over input channels (ic) and kernel positions (kh, kw) the product of the input element at [0, ic, ih, iw] and the weight at [ic, oc, kh, kw], where ih = (oh - kh) / 2 (only if (oh - kh) is even and ih is in [0, 511]) and iw = (ow - kw) / 2 (only if (ow - kw) is even and iw is in [0, 255]).", "level2_prompt": "Implement the Conv_Transposed_2D kernel. The operation is a transposed convolution: given an input tensor of shape [1, 32, 512, 256] and a weight tensor of shape [32, 32, 2, 2], produce an output tensor of shape [1, 32, 1024, 512]. For each output element (indexed by output channel oc, and spatial positions oh, ow), compute the sum over input channels ic and kernel indices kh, kw (each from 0 to 1) of the product of the input element at [0, ic, ih, iw] and the weight element at [ic, oc, kh, kw], where ih = (oh - kh) / 2 (if (oh - kh) is even and 0≤ih<512) and iw = (ow - kw) / 2 (if (ow - kw) is even and 0≤iw<256).", "level3_prompt": "Compute the transposed 2D convolution."}
{"id": 274, "task_name": "Conv_Transposed_2D", "task_description": "Compute the Conv_Transposed_2D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(147456, 64)"}, {"name": "matB", "dtype": "float32", "shape": "(64, 256)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(147456, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 64\n#define N 256\n#define TILE_WIDTH 32\nconst int M = 147456;\n\n__global__ void ConvTransposed2D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)64 * (long)768 * (long)768;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (768 * 768));\n        int rem = (int)(tmp % (768 * 768));\n        int oh = rem / 768;\n        int ow = rem % 768;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 64; ++ic) {\n            for (int kh = 0; kh < 2; ++kh) {\n                int ih = (oh - kh);\n                if (ih % 2 != 0) continue;\n                ih /= 2;\n                if (ih < 0 || ih >= 384) continue;\n                for (int kw = 0; kw < 2; ++kw) {\n                    int iw = (ow - kw);\n                    if (iw % 2 != 0) continue;\n                    iw /= 2;\n                    if (iw < 0 || iw >= 384) continue;\n                    long in_idx = (((long)n * 64 + ic) * 384 + ih) * 384 + iw;\n                    long w_idx  = (((long)ic * 64 + oc) * 2 + kh) * 2 + kw;\n                    float x = A[in_idx];\n                    float w = B[w_idx];\n                    acc += x * w;\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed2D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 147456\nK = 64\nN = 256\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 64, 384, 384)\nWt = torch.randn(64, 64, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose2d(X, Wt, bias=None, stride=(2,2), padding=(0,0), output_padding=(0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 64\n    N = 256\n    M = 147456\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Conv_Transposed_2D. Implement a CUDA kernel for 2D transposed convolution. Inputs: matA of shape (147456, 64) and dtype float32, representing a tensor reshaped to (1, 64, 384, 384); matB of shape (64, 256) and dtype float32, representing weights reshaped to (64, 64, 2, 2). Output: matC_out of shape (147456, 256) and dtype float32, equivalent to reshaped (1, 64, 768, 768). The kernel must compute each output element by accumulating over input channels and a 2x2 kernel: for each output channel, height, and width, sum contributions from valid input positions where input height and width are derived as (output height - kernel height offset) divided by 2, and similarly for width, ensuring the result is an integer within [0, 383]. Only positions where the subtraction is even and non-negative are considered.", "level2_prompt": "Task: Conv_Transposed_2D. Perform a 2D transposed convolution operation. The output tensor has dimensions 1 batch, 64 channels, 768 height, and 768 width. For each output element at (c_out, h_out, w_out), compute the sum over input channels c_in from 0 to 63 and kernel offsets kh, kw from 0 to 1: if (h_out - kh) is divisible by 2 and (w_out - kw) is divisible by 2, then let h_in = (h_out - kh) / 2 and w_in = (w_out - kw) / 2. If h_in is between 0 and 383 inclusive and w_in similarly, then add the product of input at (c_in, h_in, w_in) and weight at (c_in, c_out, kh, kw) to the accumulator.", "level3_prompt": "Compute the Conv_Transposed_2D kernel on GPU using CUDA."}
{"id": 275, "task_name": "Conv_Transposed_3D", "task_description": "Compute the Conv_Transposed_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 64)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 64\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void ConvTransposed3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)8 * (long)64 * (long)64 * (long)64;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (64 * 64 * 64));\n        int rem2 = (int)(tmp % (64 * 64 * 64));\n        int od = rem2 / (64 * 64);\n        int rem3 = rem2 % (64 * 64);\n        int oh = rem3 / 64;\n        int ow = rem3 % 64;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 8; ++ic) {\n            for (int kd = 0; kd < 2; ++kd) {\n                int id = (od - kd);\n                if (id % 2 != 0) continue;\n                id /= 2;\n                if (id < 0 || id >= 32) continue;\n                for (int kh = 0; kh < 2; ++kh) {\n                    int ih = (oh - kh);\n                    if (ih % 2 != 0) continue;\n                    ih /= 2;\n                    if (ih < 0 || ih >= 32) continue;\n                    for (int kw = 0; kw < 2; ++kw) {\n                        int iw = (ow - kw);\n                        if (iw % 2 != 0) continue;\n                        iw /= 2;\n                        if (iw < 0 || iw >= 32) continue;\n                        long in_idx = ((((long)n * 8 + ic) * 32 + id) * 32 + ih) * 32 + iw;\n                        long w_idx  = (((((long)ic * 8 + oc) * 2 + kd) * 2 + kh) * 2 + kw);\n                        float x = A[in_idx];\n                        float w = B[w_idx];\n                        acc += x * w;\n                    }\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 8\nN = 64\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 8, 32, 32, 32)\nWt = torch.randn(8, 8, 2, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose3d(X, Wt, bias=None, stride=(2,2,2), padding=(0,0,0), output_padding=(0,0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 64\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for a 3D Transposed Convolution operation. The kernel takes two input tensors: matA of shape (32768, 8) and matB of shape (8, 64), both with float32 data type. It produces an output tensor matC_out of shape (32768, 64) with float32 data type. The operation involves reconstructing a higher-resolution 3D volume from a lower-resolution input using learned filters. Input spatial dimensions are 32×32×32, and output spatial dimensions are 64×64×64 after applying a 2×2×2 kernel with stride 2 in all dimensions. Constraints include checking valid spatial indices and handling only even-index positions during the upsampling process.", "level2_prompt": "Perform a 3D transposed convolution where input features are upsampled using a 2×2×2 kernel with stride 2. The operation reconstructs a 64×64×64 output volume from a 32×32×32 input volume. For each output position, accumulate contributions from valid input positions and kernel weights where spatial indices satisfy stride and boundary constraints.", "level3_prompt": "Compute the Conv_Transposed_3D kernel on GPU using CUDA."}
{"id": 276, "task_name": "Conv_Transposed_3D", "task_description": "Compute the Conv_Transposed_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(131072, 16)"}, {"name": "matB", "dtype": "float32", "shape": "(16, 128)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(131072, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 16\n#define N 128\n#define TILE_WIDTH 32\nconst int M = 131072;\n\n__global__ void ConvTransposed3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)16 * (long)64 * (long)128 * (long)128;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (64 * 128 * 128));\n        int rem2 = (int)(tmp % (64 * 128 * 128));\n        int od = rem2 / (128 * 128);\n        int rem3 = rem2 % (128 * 128);\n        int oh = rem3 / 128;\n        int ow = rem3 % 128;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 16; ++ic) {\n            for (int kd = 0; kd < 2; ++kd) {\n                int id = (od - kd);\n                if (id % 2 != 0) continue;\n                id /= 2;\n                if (id < 0 || id >= 32) continue;\n                for (int kh = 0; kh < 2; ++kh) {\n                    int ih = (oh - kh);\n                    if (ih % 2 != 0) continue;\n                    ih /= 2;\n                    if (ih < 0 || ih >= 64) continue;\n                    for (int kw = 0; kw < 2; ++kw) {\n                        int iw = (ow - kw);\n                        if (iw % 2 != 0) continue;\n                        iw /= 2;\n                        if (iw < 0 || iw >= 64) continue;\n                        long in_idx = ((((long)n * 16 + ic) * 32 + id) * 64 + ih) * 64 + iw;\n                        long w_idx  = (((((long)ic * 16 + oc) * 2 + kd) * 2 + kh) * 2 + kw);\n                        float x = A[in_idx];\n                        float w = B[w_idx];\n                        acc += x * w;\n                    }\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 131072\nK = 16\nN = 128\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 16, 32, 64, 64)\nWt = torch.randn(16, 16, 2, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose3d(X, Wt, bias=None, stride=(2,2,2), padding=(0,0,0), output_padding=(0,0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 16\n    N = 128\n    M = 131072\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Conv_Transposed_3D. Compute a 3D transposed convolution operation. The input tensor 'matA' has data type float32 and shape (131072, 16), representing a 5D tensor with dimensions [1, 16, 32, 64, 64] when reshaped. The weight tensor 'matB' has data type float32 and shape (16, 128), but only the first 1024 elements are used, representing a 5D weight tensor with dimensions [16, 16, 2, 2, 2]. The output tensor 'matC_out' has data type float32 and shape (131072, 128), representing a 5D output tensor with dimensions [1, 16, 64, 128, 128] when reshaped. The kernel must compute each output element by iterating over input channels and kernel dimensions (depth=2, height=2, width=2). For each output position (n, output_channel, output_depth, output_height, output_width), contributions are gathered from input positions (n, input_channel, input_depth, input_height, input_width) where input_depth = (output_depth - kernel_depth) / 2 (and similarly for height/width), only when the subtraction yields an even result and the computed input position is within bounds. The kernel must avoid out-of-bounds accesses and correctly decompose linear indices into 5D coordinates.", "level2_prompt": "Task: Conv_Transposed_3D. Compute a 3D transposed convolution. For each output element at position (batch, output_channel, output_depth, output_height, output_width), accumulate contributions from input elements across all input channels and kernel positions. For kernel depth, height, and width offsets, compute corresponding input positions by reversing the transposed convolution stride: input_position = (output_position - kernel_offset) / 2. Only include contributions when the input_position is an integer within valid bounds. Multiply each valid input element by the corresponding weight and sum the products to form the output element.", "level3_prompt": "Compute a 3D transposed convolution operation."}
{"id": 277, "task_name": "Conv_Transposed_3D", "task_description": "Compute the Conv_Transposed_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(221184, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 64)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(221184, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 64\n#define TILE_WIDTH 32\nconst int M = 221184;\n\n__global__ void ConvTransposed3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)8 * (long)96 * (long)96 * (long)96;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (96 * 96 * 96));\n        int rem2 = (int)(tmp % (96 * 96 * 96));\n        int od = rem2 / (96 * 96);\n        int rem3 = rem2 % (96 * 96);\n        int oh = rem3 / 96;\n        int ow = rem3 % 96;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 8; ++ic) {\n            for (int kd = 0; kd < 2; ++kd) {\n                int id = (od - kd);\n                if (id % 2 != 0) continue;\n                id /= 2;\n                if (id < 0 || id >= 48) continue;\n                for (int kh = 0; kh < 2; ++kh) {\n                    int ih = (oh - kh);\n                    if (ih % 2 != 0) continue;\n                    ih /= 2;\n                    if (ih < 0 || ih >= 48) continue;\n                    for (int kw = 0; kw < 2; ++kw) {\n                        int iw = (ow - kw);\n                        if (iw % 2 != 0) continue;\n                        iw /= 2;\n                        if (iw < 0 || iw >= 48) continue;\n                        long in_idx = ((((long)n * 8 + ic) * 48 + id) * 48 + ih) * 48 + iw;\n                        long w_idx  = (((((long)ic * 8 + oc) * 2 + kd) * 2 + kh) * 2 + kw);\n                        float x = A[in_idx];\n                        float w = B[w_idx];\n                        acc += x * w;\n                    }\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 221184\nK = 8\nN = 64\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(2, 8, 48, 48, 48)\nWt = torch.randn(8, 8, 2, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose3d(X, Wt, bias=None, stride=(2,2,2), padding=(0,0,0), output_padding=(0,0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 64\n    M = 221184\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for 3D transposed convolution. The input matrix 'matA' (float32, 221184x8) represents a 5D tensor reshaped to 2D with dimensions (2, 8, 48, 48, 48). The weight matrix 'matB' (float32, 8x64) represents a 5D kernel reshaped to 2D with dimensions (8, 8, 2, 2, 2). The output 'matC_out' (float32, 221184x64) must be a 5D tensor reshaped to 2D with dimensions (2, 8, 96, 96, 96). For each output element at position (n, oc, od, oh, ow), compute the sum over input channels (ic) and kernel indices (kd, kh, kw) of the product between input element (n, ic, (od-kd)/2, (oh-kh)/2, (ow-kw)/2) and weight element (ic, oc, kd, kh, kw), only if (od-kd), (oh-kh), and (ow-kw) are even and the computed input spatial indices are within [0,47]. Skip contributions where input indices are invalid.", "level2_prompt": "Perform a 3D transposed convolution with 2x2x2 kernel and stride 2. Input has shape (2, 8, 48, 48, 48), weights have shape (8, 8, 2, 2, 2), and output has shape (2, 8, 96, 96, 96). For each output element (n, oc, od, oh, ow), accumulate products of input elements (n, ic, id, ih, iw) and weights (ic, oc, kd, kh, kw), where id=(od-kd)/2, ih=(oh-kh)/2, iw=(ow-kw)/2, and id, ih, iw must be integers within [0,47].", "level3_prompt": "Compute the Conv_Transposed_3D kernel on GPU using CUDA."}
{"id": 278, "task_name": "Conv_Transposed_3D", "task_description": "Compute the Conv_Transposed_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(55296, 16)"}, {"name": "matB", "dtype": "float32", "shape": "(16, 128)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(55296, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 16\n#define N 128\n#define TILE_WIDTH 32\nconst int M = 55296;\n\n__global__ void ConvTransposed3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)16 * (long)48 * (long)96 * (long)96;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (48 * 96 * 96));\n        int rem2 = (int)(tmp % (48 * 96 * 96));\n        int od = rem2 / (96 * 96);\n        int rem3 = rem2 % (96 * 96);\n        int oh = rem3 / 96;\n        int ow = rem3 % 96;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 16; ++ic) {\n            for (int kd = 0; kd < 2; ++kd) {\n                int id = (od - kd);\n                if (id % 2 != 0) continue;\n                id /= 2;\n                if (id < 0 || id >= 24) continue;\n                for (int kh = 0; kh < 2; ++kh) {\n                    int ih = (oh - kh);\n                    if (ih % 2 != 0) continue;\n                    ih /= 2;\n                    if (ih < 0 || ih >= 48) continue;\n                    for (int kw = 0; kw < 2; ++kw) {\n                        int iw = (ow - kw);\n                        if (iw % 2 != 0) continue;\n                        iw /= 2;\n                        if (iw < 0 || iw >= 48) continue;\n                        long in_idx = ((((long)n * 16 + ic) * 24 + id) * 48 + ih) * 48 + iw;\n                        long w_idx  = (((((long)ic * 16 + oc) * 2 + kd) * 2 + kh) * 2 + kw);\n                        float x = A[in_idx];\n                        float w = B[w_idx];\n                        acc += x * w;\n                    }\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 55296\nK = 16\nN = 128\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 16, 24, 48, 48)\nWt = torch.randn(16, 16, 2, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose3d(X, Wt, bias=None, stride=(2,2,2), padding=(0,0,0), output_padding=(0,0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 16\n    N = 128\n    M = 55296\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Conv_Transposed_3D. Perform a 3D transposed convolution operation. Input matA is a float32 tensor of shape (55296, 16), representing a 5D tensor with dimensions (1, 16, 24, 48, 48). Input matB is a float32 tensor of shape (16, 128), representing a 5D weight tensor with dimensions (16, 16, 2, 2, 2). Output matC_out must be a float32 tensor of shape (55296, 128), corresponding to a 5D output tensor of shape (1, 16, 48, 96, 96). The kernel must compute each output element by summing over input channels and kernel positions (depth, height, width) with stride 2 in all spatial dimensions. Input spatial indices must be derived from output indices by reversing the transposed convolution operation, ensuring indices are integers (via even difference checks) and within valid spatial bounds (0-23 for depth, 0-47 for height/width).", "level2_prompt": "Task: Conv_Transposed_3D. For each output element (batch, output channel, output depth, output height, output width), compute the sum over all input channels and kernel positions (kd, kh, kw). Each term is the product of an input element (at calculated spatial indices: id = (od - kd)/2, ih = (oh - kh)/2, iw = (ow - kw)/2) and the corresponding weight. Input indices must satisfy: (od - kd), (oh - kh), (ow - kw) are even, and id ∈ [0,23], ih ∈ [0,47], iw ∈ [0,47].", "level3_prompt": "Compute the Conv_Transposed_3D kernel on GPU using CUDA."}
{"id": 279, "task_name": "Conv_Transposed_3D", "task_description": "Compute the Conv_Transposed_3D kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(131072, 8)"}, {"name": "matB", "dtype": "float32", "shape": "(8, 64)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(131072, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8\n#define N 64\n#define TILE_WIDTH 32\nconst int M = 131072;\n\n__global__ void ConvTransposed3D_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        long out_idx = (long)row * (long)N + (long)col;\n        long spatial_o = (long)8 * (long)128 * (long)128 * (long)64;\n        long tmp = out_idx;\n        int n = (int)(tmp / spatial_o);\n        tmp = tmp % spatial_o;\n        int oc = (int)(tmp / (128 * 128 * 64));\n        int rem2 = (int)(tmp % (128 * 128 * 64));\n        int od = rem2 / (128 * 64);\n        int rem3 = rem2 % (128 * 64);\n        int oh = rem3 / 64;\n        int ow = rem3 % 64;\n        float acc = 0.0f;\n        for (int ic = 0; ic < 8; ++ic) {\n            for (int kd = 0; kd < 2; ++kd) {\n                int id = (od - kd);\n                if (id % 2 != 0) continue;\n                id /= 2;\n                if (id < 0 || id >= 64) continue;\n                for (int kh = 0; kh < 2; ++kh) {\n                    int ih = (oh - kh);\n                    if (ih % 2 != 0) continue;\n                    ih /= 2;\n                    if (ih < 0 || ih >= 64) continue;\n                    for (int kw = 0; kw < 2; ++kw) {\n                        int iw = (ow - kw);\n                        if (iw % 2 != 0) continue;\n                        iw /= 2;\n                        if (iw < 0 || iw >= 32) continue;\n                        long in_idx = ((((long)n * 8 + ic) * 64 + id) * 64 + ih) * 32 + iw;\n                        long w_idx  = (((((long)ic * 8 + oc) * 2 + kd) * 2 + kh) * 2 + kw);\n                        float x = A[in_idx];\n                        float w = B[w_idx];\n                        acc += x * w;\n                    }\n                }\n            }\n        }\n        C[out_idx] = acc;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    ConvTransposed3D_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 131072\nK = 8\nN = 64\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nX = A.view(-1).view(1, 8, 64, 64, 32)\nWt = torch.randn(8, 8, 2, 2, 2, dtype=torch.float32)\nY = torch.nn.functional.conv_transpose3d(X, Wt, bias=None, stride=(2,2,2), padding=(0,0,0), output_padding=(0,0,0))\nB.view(-1)[:Wt.numel()] = Wt.view(-1)\nC = Y.contiguous().view(M, N)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8\n    N = 64\n    M = 131072\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Conv_Transposed_3D. Compute a 3D transposed convolution (deconvolution) operation. The input tensor matA has shape (131072, 8) and dtype float32, representing a flattened tensor of shape [batch=1, input_channels=8, depth=64, height=64, width=32]. The weight tensor matB has shape (8, 64) and dtype float32, representing a flattened kernel of shape [input_channels=8, output_channels=8, kernel_depth=2, kernel_height=2, kernel_width=2]. The output tensor matC_out has shape (131072, 64) and dtype float32, representing a flattened output of shape [1, 8, 128, 128, 64]. The convolution uses stride 2 in all spatial dimensions with no padding. For each output element, iterate over input channels and kernel dimensions, compute input indices by subtracting kernel offsets and dividing by stride (only when differences are even), and accumulate products of input elements and weights. Skip computations where derived input indices are out-of-bounds.", "level2_prompt": "Task: Conv_Transposed_3D. Perform a 3D transposed convolution. For each output position (batch, output_channel, output_depth, output_height, output_width), compute the sum over input channels and kernel dimensions. Input indices are derived as: depth = (output_depth - kernel_depth_offset)/2, height = (output_height - kernel_height_offset)/2, width = (output_width - kernel_width_offset)/2. Include terms only when differences are even and derived indices fall within input spatial bounds [0-64 for depth/height, 0-32 for width]. Multiply input elements at derived indices by corresponding kernel weights and accumulate.", "level3_prompt": "Compute the Conv_Transposed_3D kernel on GPU using CUDA."}
{"id": 280, "task_name": "2D_Convolution", "task_description": "Compute the 2D_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "conv_input", "dtype": "float32", "shape": "(16384,)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(576,)"}], "outputs": [{"name": "conv_output", "dtype": "float32", "shape": "(11025,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 128;\nconst int K_ROWS = 24;\nconst int K_COLS = 24;\n\n__global__ void conv2d_kernel(const float* input, const float* kernel, float* output,\n                              int in_rows, int in_cols, int k_rows, int k_cols) {\n    int out_row = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_col = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_rows = in_rows - k_rows + 1;\n    int out_cols = in_cols - k_cols + 1;\n\n    if (out_row >= out_rows || out_col >= out_cols) return;\n\n    float acc = 0.0f;\n    for (int i = 0; i < k_rows; ++i) {\n        for (int j = 0; j < k_cols; ++j) {\n            int in_r = out_row + i;\n            int in_c = out_col + j;\n            acc += input[in_r * in_cols + in_c] * kernel[i * k_cols + j];\n        }\n    }\n\n    output[out_row * out_cols + out_col] = acc;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int in_rows = N;\n    int in_cols = N;\n    int out_rows = in_rows - K_ROWS + 1;\n    int out_cols = in_cols - K_COLS + 1;\n\n    size_t in_size = in_rows * in_cols;\n    size_t k_size = K_ROWS * K_COLS;\n    size_t out_size = out_rows * out_cols;\n\n    float* h_input = new float[in_size];\n    float* h_kernel = new float[k_size];\n    float* h_output = new float[out_size];\n\n    read_binary_float(\"data/conv_input.bin\", h_input, in_size);\n    read_binary_float(\"data/conv_kernel.bin\", h_kernel, k_size);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input, in_size * sizeof(float));\n    cudaMalloc(&d_kernel, k_size * sizeof(float));\n    cudaMalloc(&d_output, out_size * sizeof(float));\n\n    cudaMemcpy(d_input, h_input, in_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, k_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((out_cols + threads.x - 1) / threads.x,\n                (out_rows + threads.y - 1) / threads.y);\n\n    conv2d_kernel<<<blocks, threads>>>(d_input, d_kernel, d_output, in_rows, in_cols, K_ROWS, K_COLS);\n    cudaMemcpy(h_output, d_output, out_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/conv_output.bin\", h_output, out_size);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nnp.random.seed(42)\n\nN = 128 \nk_rows, k_cols = 24, 24\n\ndef conv2d_valid(input_mat, kernel):\n    in_rows, in_cols = input_mat.shape\n    k_rows, k_cols = kernel.shape\n    out_rows = in_rows - k_rows + 1\n    out_cols = in_cols - k_cols + 1\n    output = np.zeros((out_rows, out_cols), dtype=np.float32)\n\n    for i in range(out_rows):\n        for j in range(out_cols):\n            patch = input_mat[i:i+k_rows, j:j+k_cols]\n            output[i, j] = np.sum(patch * kernel)\n    return output\n\nos.makedirs(\"data\", exist_ok=True)\n\ninput_mat = np.random.randn(N, N).astype(np.float32)\nkernel = np.random.randn(k_rows, k_cols).astype(np.float32)\noutput = conv2d_valid(input_mat, kernel)\n\ninput_mat.ravel().tofile(\"data/conv_input.bin\")\nkernel.ravel().tofile(\"data/conv_kernel.bin\")\noutput.ravel().tofile(\"data/conv_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 128\n    K_ROWS, K_COLS = 24, 24\n    out_rows = N - K_ROWS + 1\n    out_cols = N - K_COLS + 1\n    size_out = out_rows * out_cols\n\n    out_file = \"data/conv_output.bin\"\n    ref_file = \"data/conv_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_out):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: 2D Convolution. Compute a 2D convolution of a 128x128 input matrix with a 24x24 kernel matrix, producing a 105x105 output matrix. The convolution is performed without padding (valid convolution). Inputs are provided as 1D arrays: conv_input (16384 float32 elements) represents the flattened 128x128 matrix, and conv_kernel (576 float32 elements) represents the flattened 24x24 kernel. Output conv_output must be a 1D array of 11025 float32 elements representing the flattened 105x105 result. Each output element is computed as the sum of element-wise products between the kernel and a corresponding 24x24 input patch.", "level2_prompt": "Task: 2D Convolution. For each position (i,j) in a 105x105 output matrix, compute the inner product between a 24x24 kernel matrix and a 24x24 input patch starting at (i,j) in the 128x128 input matrix.", "level3_prompt": "Compute the 2D convolution."}
{"id": 281, "task_name": "2D_Convolution", "task_description": "Compute the 2D_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "conv_input", "dtype": "float32", "shape": "(65536,)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(576,)"}], "outputs": [{"name": "conv_output", "dtype": "float32", "shape": "(54289,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 256;\nconst int K_ROWS = 24;\nconst int K_COLS = 24;\n\n__global__ void conv2d_kernel(const float* input, const float* kernel, float* output,\n                              int in_rows, int in_cols, int k_rows, int k_cols) {\n    int out_row = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_col = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_rows = in_rows - k_rows + 1;\n    int out_cols = in_cols - k_cols + 1;\n\n    if (out_row >= out_rows || out_col >= out_cols) return;\n\n    float acc = 0.0f;\n    for (int i = 0; i < k_rows; ++i) {\n        for (int j = 0; j < k_cols; ++j) {\n            int in_r = out_row + i;\n            int in_c = out_col + j;\n            acc += input[in_r * in_cols + in_c] * kernel[i * k_cols + j];\n        }\n    }\n\n    output[out_row * out_cols + out_col] = acc;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int in_rows = N;\n    int in_cols = N;\n    int out_rows = in_rows - K_ROWS + 1;\n    int out_cols = in_cols - K_COLS + 1;\n\n    size_t in_size = in_rows * in_cols;\n    size_t k_size = K_ROWS * K_COLS;\n    size_t out_size = out_rows * out_cols;\n\n    float* h_input = new float[in_size];\n    float* h_kernel = new float[k_size];\n    float* h_output = new float[out_size];\n\n    read_binary_float(\"data/conv_input.bin\", h_input, in_size);\n    read_binary_float(\"data/conv_kernel.bin\", h_kernel, k_size);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input, in_size * sizeof(float));\n    cudaMalloc(&d_kernel, k_size * sizeof(float));\n    cudaMalloc(&d_output, out_size * sizeof(float));\n\n    cudaMemcpy(d_input, h_input, in_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, k_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((out_cols + threads.x - 1) / threads.x,\n                (out_rows + threads.y - 1) / threads.y);\n\n    conv2d_kernel<<<blocks, threads>>>(d_input, d_kernel, d_output, in_rows, in_cols, K_ROWS, K_COLS);\n    cudaMemcpy(h_output, d_output, out_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/conv_output.bin\", h_output, out_size);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nnp.random.seed(42)\n\nN = 256 \nk_rows, k_cols = 24, 24\n\ndef conv2d_valid(input_mat, kernel):\n    in_rows, in_cols = input_mat.shape\n    k_rows, k_cols = kernel.shape\n    out_rows = in_rows - k_rows + 1\n    out_cols = in_cols - k_cols + 1\n    output = np.zeros((out_rows, out_cols), dtype=np.float32)\n\n    for i in range(out_rows):\n        for j in range(out_cols):\n            patch = input_mat[i:i+k_rows, j:j+k_cols]\n            output[i, j] = np.sum(patch * kernel)\n    return output\n\nos.makedirs(\"data\", exist_ok=True)\n\ninput_mat = np.random.randn(N, N).astype(np.float32)\nkernel = np.random.randn(k_rows, k_cols).astype(np.float32)\noutput = conv2d_valid(input_mat, kernel)\n\ninput_mat.ravel().tofile(\"data/conv_input.bin\")\nkernel.ravel().tofile(\"data/conv_kernel.bin\")\noutput.ravel().tofile(\"data/conv_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 256\n    K_ROWS, K_COLS = 24, 24\n    out_rows = N - K_ROWS + 1\n    out_cols = N - K_COLS + 1\n    size_out = out_rows * out_cols\n\n    out_file = \"data/conv_output.bin\"\n    ref_file = \"data/conv_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_out):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: 2D_Convolution. Implement a CUDA kernel for 2D convolution without padding (valid convolution). The input is a 256x256 matrix stored as a flattened float32 array of length 65536. The kernel is a 24x24 matrix stored as a flattened float32 array of length 576. The output is a 233x233 matrix stored as a flattened float32 array of length 54289. For each output position (i,j), compute the sum of element-wise products between the input submatrix starting at (i,j) with dimensions 24x24 and the kernel matrix.", "level2_prompt": "Task: 2D_Convolution. For each output element at position (i,j), compute the dot product between a 24x24 kernel matrix and the corresponding 24x24 input submatrix starting at (i,j) in the 256x256 input matrix. The output matrix dimensions are (256-24+1) x (256-24+1).", "level3_prompt": "Compute the 2D_Convolution kernel on GPU using CUDA."}
{"id": 282, "task_name": "2D_Convolution", "task_description": "Compute the 2D_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "conv_input", "dtype": "float32", "shape": "(262144,)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(576,)"}], "outputs": [{"name": "conv_output", "dtype": "float32", "shape": "(239121,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 512;\nconst int K_ROWS = 24;\nconst int K_COLS = 24;\n\n__global__ void conv2d_kernel(const float* input, const float* kernel, float* output,\n                              int in_rows, int in_cols, int k_rows, int k_cols) {\n    int out_row = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_col = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_rows = in_rows - k_rows + 1;\n    int out_cols = in_cols - k_cols + 1;\n\n    if (out_row >= out_rows || out_col >= out_cols) return;\n\n    float acc = 0.0f;\n    for (int i = 0; i < k_rows; ++i) {\n        for (int j = 0; j < k_cols; ++j) {\n            int in_r = out_row + i;\n            int in_c = out_col + j;\n            acc += input[in_r * in_cols + in_c] * kernel[i * k_cols + j];\n        }\n    }\n\n    output[out_row * out_cols + out_col] = acc;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int in_rows = N;\n    int in_cols = N;\n    int out_rows = in_rows - K_ROWS + 1;\n    int out_cols = in_cols - K_COLS + 1;\n\n    size_t in_size = in_rows * in_cols;\n    size_t k_size = K_ROWS * K_COLS;\n    size_t out_size = out_rows * out_cols;\n\n    float* h_input = new float[in_size];\n    float* h_kernel = new float[k_size];\n    float* h_output = new float[out_size];\n\n    read_binary_float(\"data/conv_input.bin\", h_input, in_size);\n    read_binary_float(\"data/conv_kernel.bin\", h_kernel, k_size);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input, in_size * sizeof(float));\n    cudaMalloc(&d_kernel, k_size * sizeof(float));\n    cudaMalloc(&d_output, out_size * sizeof(float));\n\n    cudaMemcpy(d_input, h_input, in_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, k_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((out_cols + threads.x - 1) / threads.x,\n                (out_rows + threads.y - 1) / threads.y);\n\n    conv2d_kernel<<<blocks, threads>>>(d_input, d_kernel, d_output, in_rows, in_cols, K_ROWS, K_COLS);\n    cudaMemcpy(h_output, d_output, out_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/conv_output.bin\", h_output, out_size);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nnp.random.seed(42)\n\nN = 512 \nk_rows, k_cols = 24, 24\n\ndef conv2d_valid(input_mat, kernel):\n    in_rows, in_cols = input_mat.shape\n    k_rows, k_cols = kernel.shape\n    out_rows = in_rows - k_rows + 1\n    out_cols = in_cols - k_cols + 1\n    output = np.zeros((out_rows, out_cols), dtype=np.float32)\n\n    for i in range(out_rows):\n        for j in range(out_cols):\n            patch = input_mat[i:i+k_rows, j:j+k_cols]\n            output[i, j] = np.sum(patch * kernel)\n    return output\n\nos.makedirs(\"data\", exist_ok=True)\n\ninput_mat = np.random.randn(N, N).astype(np.float32)\nkernel = np.random.randn(k_rows, k_cols).astype(np.float32)\noutput = conv2d_valid(input_mat, kernel)\n\ninput_mat.ravel().tofile(\"data/conv_input.bin\")\nkernel.ravel().tofile(\"data/conv_kernel.bin\")\noutput.ravel().tofile(\"data/conv_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 512\n    K_ROWS, K_COLS = 24, 24\n    out_rows = N - K_ROWS + 1\n    out_cols = N - K_COLS + 1\n    size_out = out_rows * out_cols\n\n    out_file = \"data/conv_output.bin\"\n    ref_file = \"data/conv_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_out):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a 2D convolution kernel where the input is a 512x512 matrix stored as a 262144-element float32 vector. The convolution kernel is a 24x24 matrix stored as a 576-element float32 vector. The output must be a float32 vector of size 239121, corresponding to the valid convolution result without padding. The kernel should compute each output element as the sum of element-wise products between the corresponding input patch and the kernel matrix. Input patches must be slid across the input matrix with a stride of 1 and no padding.", "level2_prompt": "Perform a 2D convolution operation between an input matrix of size 512x512 and a kernel matrix of size 24x24. The output matrix dimensions should be (512-24+1) by (512-24+1). Each element in the output matrix is calculated as the dot product between a 24x24 window of the input matrix centered at the output element's position and the kernel matrix.", "level3_prompt": "Compute the 2D_Convolution kernel on GPU using CUDA."}
{"id": 283, "task_name": "2D_Convolution", "task_description": "Compute the 2D_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "conv_input", "dtype": "float32", "shape": "(1024, 1024)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(24, 24)"}], "outputs": [{"name": "conv_output", "dtype": "float32", "shape": "(1001, 1001)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 1024;\nconst int K_ROWS = 24;\nconst int K_COLS = 24;\n\n__global__ void conv2d_kernel(const float* input, const float* kernel, float* output,\n                              int in_rows, int in_cols, int k_rows, int k_cols) {\n    int out_row = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_col = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_rows = in_rows - k_rows + 1;\n    int out_cols = in_cols - k_cols + 1;\n\n    if (out_row >= out_rows || out_col >= out_cols) return;\n\n    float acc = 0.0f;\n    for (int i = 0; i < k_rows; ++i) {\n        for (int j = 0; j < k_cols; ++j) {\n            int in_r = out_row + i;\n            int in_c = out_col + j;\n            acc += input[in_r * in_cols + in_c] * kernel[i * k_cols + j];\n        }\n    }\n\n    output[out_row * out_cols + out_col] = acc;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int in_rows = N;\n    int in_cols = N;\n    int out_rows = in_rows - K_ROWS + 1;\n    int out_cols = in_cols - K_COLS + 1;\n\n    size_t in_size = in_rows * in_cols;\n    size_t k_size = K_ROWS * K_COLS;\n    size_t out_size = out_rows * out_cols;\n\n    float* h_input = new float[in_size];\n    float* h_kernel = new float[k_size];\n    float* h_output = new float[out_size];\n\n    read_binary_float(\"data/conv_input.bin\", h_input, in_size);\n    read_binary_float(\"data/conv_kernel.bin\", h_kernel, k_size);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input, in_size * sizeof(float));\n    cudaMalloc(&d_kernel, k_size * sizeof(float));\n    cudaMalloc(&d_output, out_size * sizeof(float));\n\n    cudaMemcpy(d_input, h_input, in_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, k_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((out_cols + threads.x - 1) / threads.x,\n                (out_rows + threads.y - 1) / threads.y);\n\n    conv2d_kernel<<<blocks, threads>>>(d_input, d_kernel, d_output, in_rows, in_cols, K_ROWS, K_COLS);\n    cudaMemcpy(h_output, d_output, out_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/conv_output.bin\", h_output, out_size);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nnp.random.seed(42)\n\nN = 1024 \nk_rows, k_cols = 24, 24\n\ndef conv2d_valid(input_mat, kernel):\n    in_rows, in_cols = input_mat.shape\n    k_rows, k_cols = kernel.shape\n    out_rows = in_rows - k_rows + 1\n    out_cols = in_cols - k_cols + 1\n    output = np.zeros((out_rows, out_cols), dtype=np.float32)\n\n    for i in range(out_rows):\n        for j in range(out_cols):\n            patch = input_mat[i:i+k_rows, j:j+k_cols]\n            output[i, j] = np.sum(patch * kernel)\n    return output\n\nos.makedirs(\"data\", exist_ok=True)\n\ninput_mat = np.random.randn(N, N).astype(np.float32)\nkernel = np.random.randn(k_rows, k_cols).astype(np.float32)\noutput = conv2d_valid(input_mat, kernel)\n\ninput_mat.ravel().tofile(\"data/conv_input.bin\")\nkernel.ravel().tofile(\"data/conv_kernel.bin\")\noutput.ravel().tofile(\"data/conv_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 1024\n    K_ROWS, K_COLS = 24, 24\n    out_rows = N - K_ROWS + 1\n    out_cols = N - K_COLS + 1\n    size_out = out_rows * out_cols\n\n    out_file = \"data/conv_output.bin\"\n    ref_file = \"data/conv_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_out):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a 2D convolution kernel that processes a 1024x1024 input matrix using a 24x24 kernel. The input tensors are conv_input (float32, 1024x1024) and conv_kernel (float32, 24x24). The output tensor conv_output must be float32 with dimensions 1001x1001. For each output element at position (i, j), compute the sum of element-wise products between the kernel and the corresponding input patch starting at (i, j), ensuring the kernel never exceeds input boundaries. The kernel must handle all valid positions where the kernel fully overlaps the input without padding.", "level2_prompt": "Perform a 2D convolution where each element of the output matrix is computed by sliding a 24x24 kernel over a 1024x1024 input matrix. The output dimensions are (1024 - 24 + 1) x (1024 - 24 + 1) = 1001x1001. For every valid position (i, j) in the output, calculate the dot product between the kernel and the input submatrix starting at (i, j) with dimensions matching the kernel.", "level3_prompt": "Compute the 2D convolution kernel on GPU using CUDA for a 1024x1024 input and 24x24 kernel."}
{"id": 284, "task_name": "2D_Convolution", "task_description": "Compute the 2D_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "conv_input", "dtype": "float32", "shape": "(4194304,)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(576,)"}], "outputs": [{"name": "conv_output", "dtype": "float32", "shape": "(4100625,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <cmath>\n#include <fstream>\n#include <string>\n\nconst int N = 2048;\nconst int K_ROWS = 24;\nconst int K_COLS = 24;\n\n__global__ void conv2d_kernel(const float* input, const float* kernel, float* output,\n                              int in_rows, int in_cols, int k_rows, int k_cols) {\n    int out_row = blockIdx.y * blockDim.y + threadIdx.y;\n    int out_col = blockIdx.x * blockDim.x + threadIdx.x;\n    int out_rows = in_rows - k_rows + 1;\n    int out_cols = in_cols - k_cols + 1;\n\n    if (out_row >= out_rows || out_col >= out_cols) return;\n\n    float acc = 0.0f;\n    for (int i = 0; i < k_rows; ++i) {\n        for (int j = 0; j < k_cols; ++j) {\n            int in_r = out_row + i;\n            int in_c = out_col + j;\n            acc += input[in_r * in_cols + in_c] * kernel[i * k_cols + j];\n        }\n    }\n\n    output[out_row * out_cols + out_col] = acc;\n}\n\nvoid read_binary_float(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int in_rows = N;\n    int in_cols = N;\n    int out_rows = in_rows - K_ROWS + 1;\n    int out_cols = in_cols - K_COLS + 1;\n\n    size_t in_size = in_rows * in_cols;\n    size_t k_size = K_ROWS * K_COLS;\n    size_t out_size = out_rows * out_cols;\n\n    float* h_input = new float[in_size];\n    float* h_kernel = new float[k_size];\n    float* h_output = new float[out_size];\n\n    read_binary_float(\"data/conv_input.bin\", h_input, in_size);\n    read_binary_float(\"data/conv_kernel.bin\", h_kernel, k_size);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input, in_size * sizeof(float));\n    cudaMalloc(&d_kernel, k_size * sizeof(float));\n    cudaMalloc(&d_output, out_size * sizeof(float));\n\n    cudaMemcpy(d_input, h_input, in_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, k_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((out_cols + threads.x - 1) / threads.x,\n                (out_rows + threads.y - 1) / threads.y);\n\n    conv2d_kernel<<<blocks, threads>>>(d_input, d_kernel, d_output, in_rows, in_cols, K_ROWS, K_COLS);\n    cudaMemcpy(h_output, d_output, out_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/conv_output.bin\", h_output, out_size);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nnp.random.seed(42)\n\nN = 2048 \nk_rows, k_cols = 24, 24\n\ndef conv2d_valid(input_mat, kernel):\n    in_rows, in_cols = input_mat.shape\n    k_rows, k_cols = kernel.shape\n    out_rows = in_rows - k_rows + 1\n    out_cols = in_cols - k_cols + 1\n    output = np.zeros((out_rows, out_cols), dtype=np.float32)\n\n    for i in range(out_rows):\n        for j in range(out_cols):\n            patch = input_mat[i:i+k_rows, j:j+k_cols]\n            output[i, j] = np.sum(patch * kernel)\n    return output\n\nos.makedirs(\"data\", exist_ok=True)\n\ninput_mat = np.random.randn(N, N).astype(np.float32)\nkernel = np.random.randn(k_rows, k_cols).astype(np.float32)\noutput = conv2d_valid(input_mat, kernel)\n\ninput_mat.ravel().tofile(\"data/conv_input.bin\")\nkernel.ravel().tofile(\"data/conv_kernel.bin\")\noutput.ravel().tofile(\"data/conv_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 2048\n    K_ROWS, K_COLS = 24, 24\n    out_rows = N - K_ROWS + 1\n    out_cols = N - K_COLS + 1\n    size_out = out_rows * out_cols\n\n    out_file = \"data/conv_output.bin\"\n    ref_file = \"data/conv_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_out):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Perform a 2D convolution operation on a 2048x2048 input matrix using a 24x24 kernel. The input matrix is provided as a flattened array of 4194304 float32 elements. The kernel is provided as a flattened array of 576 float32 elements. The output should be a 2025x2025 matrix (flattened to 4100625 float32 elements), computed by sliding the kernel over the input matrix without padding (valid convolution). At each position, the output element is the sum of the element-wise product between the kernel and the overlapping input patch.", "level2_prompt": "Given an input matrix of size 2048x2048 and a kernel matrix of size 24x24, compute the 2D convolution. The convolution operation involves sliding the kernel over the input matrix and computing the inner product at each valid position (where the kernel fully overlaps the input). The output matrix has dimensions 2025x2025.", "level3_prompt": "Compute the 2D convolution."}
{"id": 285, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void GELU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float k = 0.7978845608f;\n        float c = 0.044715f;\n        float y = 0.5f * x * (1.0f + tanhf(k * (x + c * x * x * x)));\n        C[row * N + col] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    GELU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.nn.functional.gelu(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: GELU. Compute the Gaussian Error Linear Unit (GELU) activation function for each element of the input matrix matA. The input matrix matA has dimensions 8192 x 1024 and data type float32. The input matrix matB has dimensions 1024 x 1024 and data type float32 but is not used in the computation. The output matrix matC_out must have the same dimensions (8192 x 1024) and data type float32. The GELU function is defined by the formula: y = 0.5 * x * (1 + tanh(0.7978845608 * (x + 0.044715 * x^3))). The kernel must be implemented to handle the given matrix dimensions.", "level2_prompt": "Task name: GELU. For each element in the input matrix matA (8192 x 1024), compute the GELU activation function: y = 0.5 * x * (1 + tanh(0.7978845608 * (x + 0.044715 * x^3))). The output matrix matC_out has the same dimensions as matA. The input matrix matB is provided but not used.", "level3_prompt": "Compute the GELU activation function for each element of the input matrix."}
{"id": 286, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void GELU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float k = 0.7978845608f;\n        float c = 0.044715f;\n        float y = 0.5f * x * (1.0f + tanhf(k * (x + c * x * x * x)));\n        C[row * N + col] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    GELU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.nn.functional.gelu(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the GELU activation function as a CUDA kernel. The kernel must accept two input tensors: 'matA' of shape (16384, 1024) and 'matB' of shape (1024, 1024), both of float32 data type. Note that only 'matA' is used in the computation. The output tensor 'matC_out' must be of shape (16384, 1024) and float32 data type. For each element in 'matA', compute the GELU activation using the formula: y = 0.5 * x * (1.0 + tanh(0.7978845608 * (x + 0.044715 * x * x * x))). The kernel must be applied element-wise and must handle the provided tensor dimensions.", "level2_prompt": "Compute the GELU activation function element-wise for each value in a 16384x1024 matrix. The GELU function is defined as: output = 0.5 * input * (1 + tanh(0.7978845608 * (input + 0.044715 * input^3))).", "level3_prompt": "Element-wise GELU activation computation."}
{"id": 287, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void GELU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float k = 0.7978845608f;\n        float c = 0.044715f;\n        float y = 0.5f * x * (1.0f + tanhf(k * (x + c * x * x * x)));\n        C[row * N + col] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    GELU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.nn.functional.gelu(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named GELU to compute the Gaussian Error Linear Unit activation function. The kernel takes two input matrices: matA (float32, 16384x2048) and matB (float32, 2048x2048). However, only matA is used in the computation, while matB is ignored. For each element x in matA, compute y = 0.5 * x * (1 + tanh(0.7978845608 * (x + 0.044715 * x^3))). The output matrix matC_out (float32, 16384x2048) must contain these computed values. The kernel should be grid-stride based and handle arbitrary matrix dimensions via thread indexing.", "level2_prompt": "Compute the GELU activation function element-wise on a matrix. For each element x in input matrix A, apply the formula y = 0.5 * x * (1 + tanh(k*(x + c*x^3))) where k=0.7978845608 and c=0.044715. The output matrix should have identical dimensions to input matrix A. A second input matrix B is provided but unused.", "level3_prompt": "Compute the GELU activation function for each element in a matrix."}
{"id": 288, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void GELU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float k = 0.7978845608f;\n        float c = 0.044715f;\n        float y = 0.5f * x * (1.0f + tanhf(k * (x + c * x * x * x)));\n        C[row * N + col] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    GELU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.nn.functional.gelu(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task Name: GELU. Compute the Gaussian Error Linear Unit (GELU) activation function for each element of input matrix A, ignoring input matrix B. Matrix A is a float32 tensor with dimensions 32768 rows by 1024 columns. Matrix B is a float32 tensor with dimensions 1024 rows by 1024 columns but is unused in the computation. The output must be a float32 tensor of shape (32768, 1024) containing the GELU activation result for each element of A. The GELU function is defined as: 0.5 * x * (1 + tanh(0.7978845608 * (x + 0.044715 * x^3))). The kernel must respect matrix boundaries to avoid out-of-bounds memory accesses.", "level2_prompt": "Task Name: GELU. For each element in matrix A (size 32768x1024), compute the Gaussian Error Linear Unit activation function. The computation involves applying the formula: 0.5 * x * (1 + tanh(0.7978845608 * (x + 0.044715 * x^3))) where x is the element value. Store the results in an output matrix of the same dimensions as A. Matrix B is provided but not used in the calculation.", "level3_prompt": "Compute the GELU activation function for each element of a matrix."}
{"id": 289, "task_name": "GELU", "task_description": "Compute the GELU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void GELU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float k = 0.7978845608f;\n        float c = 0.044715f;\n        float y = 0.5f * x * (1.0f + tanhf(k * (x + c * x * x * x)));\n        C[row * N + col] = y;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    GELU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.nn.functional.gelu(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the GELU activation function. The kernel must take two input matrices: matA of shape (32768, 2048) and matB of shape (2048, 2048), both of data type float32. The kernel should compute the GELU function element-wise on each element of matA, ignoring matB. The output matrix matC_out must have the same shape as matA (32768, 2048) and data type float32. The GELU function is defined by the formula: y = 0.5 * x * (1.0 + tanh(0.7978845608 * (x + 0.044715 * x * x * x))).", "level2_prompt": "Compute the GELU activation function for each element of the input matrix matA. The output matrix has the same dimensions as matA. The GELU function is: y = 0.5 * x * (1 + tanh(0.7978845608 * (x + 0.044715 * x^3))).", "level3_prompt": "Compute the GELU activation function element-wise on the input matrix matA."}
{"id": 290, "task_name": "PReLU", "task_description": "Compute the PReLU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void PReLU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float alpha = B[0];\n        C[row * N + col] = (x >= 0.0f) ? x : (alpha * x);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    PReLU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nalpha = torch.randn((), dtype=torch.float32).item()\nC = torch.where(A >= 0, A, alpha * A)\nB.view(-1)[0] = alpha\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: PReLU. Apply the Parametric Rectified Linear Unit (PReLU) activation function to each element of input matrix matA (shape: 8192x1024, dtype: float32). The alpha parameter for PReLU is stored as the first element of input matrix matB (shape: 1024x1024, dtype: float32). For each element in matA: if the element is greater than or equal to zero, output the element unchanged; otherwise, output the element multiplied by alpha. The output matrix matC_out must have shape 8192x1024 and dtype float32. Constraints: Only the first element of matB is used; all other elements in matB are ignored. The kernel must handle the fixed input dimensions.", "level2_prompt": "Task: PReLU. For each element in a 8192x1024 float32 matrix A, output the element if non-negative, or multiply the element by scalar alpha (from first position of a 1024x1024 float32 matrix B) if negative.", "level3_prompt": "Compute the PReLU kernel on GPU using CUDA."}
{"id": 291, "task_name": "PReLU", "task_description": "Compute the PReLU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void PReLU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float alpha = B[0];\n        C[row * N + col] = (x >= 0.0f) ? x : (alpha * x);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    PReLU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nalpha = torch.randn((), dtype=torch.float32).item()\nC = torch.where(A >= 0, A, alpha * A)\nB.view(-1)[0] = alpha\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the PReLU kernel on GPU. Given two input matrices: matA (16384x1024, float32) and matB (1024x1024, float32), compute an output matrix matC_out (16384x1024, float32) where each element is calculated as: if the element in matA is non-negative, output the same element; if negative, multiply the element by the scalar value stored in the first position of matB (matB[0]). The kernel must process all elements independently and preserve input shapes.", "level2_prompt": "Compute a matrix where each element equals the corresponding element in matA if non-negative, or multiplied by the first element of matB if negative. Inputs are matA (16384x1024) and matB (1024x1024), output is matC_out (16384x1024). Only matB[0] is used as a scalar parameter.", "level3_prompt": "Compute the PReLU kernel on GPU using CUDA."}
{"id": 292, "task_name": "PReLU", "task_description": "Compute the PReLU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void PReLU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float alpha = B[0];\n        C[row * N + col] = (x >= 0.0f) ? x : (alpha * x);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    PReLU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nalpha = torch.randn((), dtype=torch.float32).item()\nC = torch.where(A >= 0, A, alpha * A)\nB.view(-1)[0] = alpha\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: PReLU. Apply the PReLU activation function element-wise to each element of input matrix matA (shape: 16384x2048, dtype: float32). The activation function is defined as: for each element x, output = x if x >= 0, and output = alpha * x if x < 0. The parameter alpha is a scalar taken from the first element (at index [0,0]) of input matrix matB (shape: 2048x2048, dtype: float32). The output matrix matC_out must have the same shape and data type as matA. Constraints: The kernel must use the same alpha (from matB[0][0]) for every element. The computation must be done independently for each element.", "level2_prompt": "Task: PReLU. For each element x in the input matrix matA, compute the output element as: output = x if x >= 0, else output = alpha * x, where alpha is the first element of matrix matB (i.e., the element at the first row and first column).", "level3_prompt": "Compute the PReLU activation function."}
{"id": 293, "task_name": "PReLU", "task_description": "Compute the PReLU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(33554432,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void PReLU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float alpha = B[0];\n        C[row * N + col] = (x >= 0.0f) ? x : (alpha * x);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    PReLU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nalpha = torch.randn((), dtype=torch.float32).item()\nC = torch.where(A >= 0, A, alpha * A)\nB.view(-1)[0] = alpha\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task Name: PReLU\nDescription: Compute the element-wise Parametric Rectified Linear Unit (PReLU) activation function on a 32768x1024 input matrix of float32 values. The activation function uses a scalar parameter alpha, which is the first element of a second input matrix of shape 1024x1024 and dtype float32. The output is a float32 vector of 33554432 elements, which is the flattened result of the activation applied to each element of the input matrix. For each element, if the element is non-negative, the output is the element itself; if negative, the output is the product of alpha and the element. The kernel must process each element independently and use the provided alpha from the first element of the second input matrix.", "level2_prompt": "Task Name: PReLU\nDescription: Apply the PReLU function element-wise to an input matrix. The function is defined as: for each element x, if x is non-negative, the output is x; otherwise, the output is alpha multiplied by x. The scalar alpha is the first element of a second input matrix. The output matrix has the same dimensions as the input matrix.", "level3_prompt": "Task Name: PReLU\nDescription: Compute the element-wise PReLU activation function."}
{"id": 294, "task_name": "PReLU", "task_description": "Compute the PReLU kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void PReLU_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        float alpha = B[0];\n        C[row * N + col] = (x >= 0.0f) ? x : (alpha * x);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    PReLU_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nalpha = torch.randn((), dtype=torch.float32).item()\nC = torch.where(A >= 0, A, alpha * A)\nB.view(-1)[0] = alpha\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: PReLU. Given an input matrix matA of shape (32768, 2048) of float32 values and another matrix matB of shape (2048, 2048) of float32 values, compute an output matrix matC_out of shape (32768, 2048). For each element in matA, if the element is greater than or equal to zero, the corresponding element in matC_out is the same as the element in matA. If the element is negative, the corresponding element in matC_out is the product of the element in matA and the first element of matB (i.e., matB[0][0]). The computation must be performed element-wise and independently for each element.", "level2_prompt": "Task: PReLU. For a matrix A of dimensions 32768 by 2048 and a matrix B of dimensions 2048 by 2048, compute a matrix C of the same dimensions as A. Each element C[i][j] is defined as: if A[i][j] >= 0, then C[i][j] = A[i][j]; otherwise, C[i][j] = alpha * A[i][j], where alpha is the element at the first position of matrix B (B[0][0]).", "level3_prompt": "Apply the PReLU activation function element-wise to a matrix using a scalar parameter taken from the first element of a second matrix."}
{"id": 295, "task_name": "RMSNorm", "task_description": "Compute the RMSNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void RMSNorm_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float ss = 0.0f;\n        for (int j = 0; j < N; ++j) { float v = A[row * K + j]; ss += v * v; }\n        float rms = sqrtf(ss / (float)N + 1e-6f);\n        float gamma = B[col];\n        float x = A[row * K + col];\n        C[row * N + col] = (x / rms) * gamma;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    RMSNorm_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\ngamma = torch.randn(N, dtype=torch.float32)\nrms = torch.sqrt((A * A).mean(dim=1, keepdim=True) + 1e-6)\nC = (A / rms) * gamma.view(1, N)\nB.view(-1)[:N] = gamma\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: RMSNorm. Compute the RMS normalization for each row of the input matrix matA. The RMS for a row is computed as the square root of the average of the squares of the elements in that row, plus a small epsilon (1e-6). Then, each element in the row is divided by the RMS and multiplied by a corresponding element from the gamma vector. The gamma vector is taken from the first row of the input matrix matB. The input matA is a float32 matrix of shape (8192, 1024). The input matB is a float32 matrix of shape (1024, 1024), but only the first row is used as gamma. The output is a float32 matrix of shape (8192, 1024). The kernel must respect the matrix dimensions and avoid out-of-bound accesses.", "level2_prompt": "For each row i in the range [0, 8191], compute the sum of squares of the 1024 elements in that row. Then, compute the RMS value for the row as the square root of (sum of squares divided by 1024 plus 1e-6). For each element in the row (i, j) where j in [0, 1023], set the output element (i, j) to (input element (i, j) divided by the row's RMS) multiplied by the j-th element of the gamma vector (which is the first row of matB).", "level3_prompt": "Compute the RMSNorm kernel on GPU using CUDA."}
{"id": 296, "task_name": "RMSNorm", "task_description": "Compute the RMSNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void RMSNorm_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float ss = 0.0f;\n        for (int j = 0; j < N; ++j) { float v = A[row * K + j]; ss += v * v; }\n        float rms = sqrtf(ss / (float)N + 1e-6f);\n        float gamma = B[col];\n        float x = A[row * K + col];\n        C[row * N + col] = (x / rms) * gamma;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    RMSNorm_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\ngamma = torch.randn(N, dtype=torch.float32)\nrms = torch.sqrt((A * A).mean(dim=1, keepdim=True) + 1e-6)\nC = (A / rms) * gamma.view(1, N)\nB.view(-1)[:N] = gamma\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the RMSNorm kernel. The kernel takes two input matrices: matA of shape (16384, 1024) and matB of shape (1024, 1024), both of float32 data type. The kernel must produce an output matrix matC_out of shape (16384, 1024) and float32 data type. For each row in matA, compute the root mean square (RMS) over the 1024 elements in that row, adding 1e-6 to the mean of squares to avoid division by zero. The RMS value for a row is the square root of (the sum of squares of the row elements divided by 1024 plus 1e-6). Then, for each element in the row, normalize the element by dividing it by the row's RMS and multiply by the corresponding element from the gamma vector. The gamma vector is the first row of matB (i.e., the first 1024 elements of matB). Each row of matA must be processed independently.", "level2_prompt": "Perform RMS normalization on a matrix. For each row of the input matrix matA (size 16384x1024), compute the RMS value over the row. Then, for each element in the row, normalize the element by the row's RMS and scale by a gamma value from a vector (which is stored in the first row of matB). The output matrix has the same dimensions as matA.", "level3_prompt": "Compute the RMSNorm kernel on GPU using CUDA."}
{"id": 297, "task_name": "RMSNorm", "task_description": "Compute the RMSNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void RMSNorm_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float ss = 0.0f;\n        for (int j = 0; j < N; ++j) { float v = A[row * K + j]; ss += v * v; }\n        float rms = sqrtf(ss / (float)N + 1e-6f);\n        float gamma = B[col];\n        float x = A[row * K + col];\n        C[row * N + col] = (x / rms) * gamma;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    RMSNorm_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\ngamma = torch.randn(N, dtype=torch.float32)\nrms = torch.sqrt((A * A).mean(dim=1, keepdim=True) + 1e-6)\nC = (A / rms) * gamma.view(1, N)\nB.view(-1)[:N] = gamma\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the RMSNorm kernel. Given two input matrices: matA (float32, shape 16384x2048) and matB (float32, shape 2048x2048). For each row in matA, compute the root mean square (RMS) across all 2048 elements. The RMS for row i is calculated as sqrt( sum(matA[i,j]²) / 2048 + 1e-6 ). Then, for each element (i,j) in the output matrix matC_out (float32, shape 16384x2048), compute (matA[i,j] / RMS_i) * gamma_j, where gamma_j is the j-th element from the first 2048 values of matB (treated as a vector). Ensure all computations respect tensor boundaries and numerical stability.", "level2_prompt": "RMSNorm computation. For each row i in 16384 rows: first calculate RMS_i = sqrt( average of squared elements in row i + 1e-6 ). Then for each column j in 2048 columns: output element (i,j) = (input element matA[i,j] / RMS_i) multiplied by gamma_j, where gamma_j is the j-th element of a gamma vector stored in the first 2048 elements of matB.", "level3_prompt": "Compute the RMSNorm kernel on GPU using CUDA."}
{"id": 298, "task_name": "RMSNorm", "task_description": "Compute the RMSNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void RMSNorm_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float ss = 0.0f;\n        for (int j = 0; j < N; ++j) { float v = A[row * K + j]; ss += v * v; }\n        float rms = sqrtf(ss / (float)N + 1e-6f);\n        float gamma = B[col];\n        float x = A[row * K + col];\n        C[row * N + col] = (x / rms) * gamma;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    RMSNorm_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\ngamma = torch.randn(N, dtype=torch.float32)\nrms = torch.sqrt((A * A).mean(dim=1, keepdim=True) + 1e-6)\nC = (A / rms) * gamma.view(1, N)\nB.view(-1)[:N] = gamma\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: RMSNorm. Compute RMS normalization for a matrix. Input matA is a float32 tensor of shape (32768, 1024), and matB is a float32 tensor of shape (1024, 1024). Only the first 1024 elements of matB (treated as a vector) are used as gamma weights. Output matC_out is a float32 tensor of shape (32768, 1024). For each row in matA, compute the root mean square (RMS) with an epsilon of 1e-6 added inside the square root. Then normalize each element in the row by dividing it by its row's RMS and multiply by the corresponding gamma weight from matB. Ensure computations respect matrix boundaries and the inner dimension of 1024.", "level2_prompt": "Task: RMSNorm. For each row i in the output matrix (size 32768x1024), compute the RMS of row i in input matrix A as sqrt(mean of squared elements in row i + 1e-6). Then for each element (i,j), compute output as (A[i][j] / RMS_i) * gamma[j], where gamma is the first 1024 elements of input matrix B.", "level3_prompt": "Compute the RMSNorm operation."}
{"id": 299, "task_name": "RMSNorm", "task_description": "Compute the RMSNorm kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void RMSNorm_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float ss = 0.0f;\n        for (int j = 0; j < N; ++j) { float v = A[row * K + j]; ss += v * v; }\n        float rms = sqrtf(ss / (float)N + 1e-6f);\n        float gamma = B[col];\n        float x = A[row * K + col];\n        C[row * N + col] = (x / rms) * gamma;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    RMSNorm_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\ngamma = torch.randn(N, dtype=torch.float32)\nrms = torch.sqrt((A * A).mean(dim=1, keepdim=True) + 1e-6)\nC = (A / rms) * gamma.view(1, N)\nB.view(-1)[:N] = gamma\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: RMSNorm. The kernel computes RMS normalization on an input matrix. Given a float32 input matrix matA of shape (32768, 2048) and a float32 weight matrix matB of shape (2048, 2048), produce an output matrix matC_out of shape (32768, 2048). For each row in matA, compute the root mean square (RMS) of all elements in that row, add a small epsilon (1e-6) to avoid division by zero, and normalize each element in the row by dividing it by this RMS value. Then, multiply each normalized element by a corresponding weight from the first row of matB. Specifically, for element (i, j) in the output, the weight is taken from matB[0, j]. The kernel must handle all rows independently and respect the fixed dimensions of the matrices.", "level2_prompt": "Task: RMSNorm. For each row i in the range [0, 32767], compute the RMS of the i-th row of matrix A (size 32768x2048) as the square root of the average of the squares of all elements in the row plus 1e-6. Then, for each column j in the range [0, 2047], the output element at (i, j) is (A[i, j] / row_i_RMS) multiplied by the weight from the j-th position of the first row of matrix B.", "level3_prompt": "Compute the RMSNorm kernel on GPU using CUDA."}
{"id": 300, "task_name": "SGD", "task_description": "Compute the SGD kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 1024;\n\n__global__ void SGD_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float p = A[row * K + col]; float g = B[row * N + col]; C[row * N + col] = p - 1.00000000e-01f * g;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    SGD_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1024\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A - 0.1 * B\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 1024\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the SGD task. The kernel should take two input matrices, matA and matB, both of shape 1024x1024 and data type float32. For each element at position (i, j), compute the output as matA[i][j] minus 0.1 times matB[i][j]. The output matrix matC_out must have the same shape and data type as the inputs. Ensure the kernel only processes valid indices within the 1024x1024 boundaries.", "level2_prompt": "Create a kernel for the SGD task that performs element-wise operations on two 1024x1024 matrices. For each element position (i, j), the output value is derived by subtracting 0.1 times the element from the second matrix from the corresponding element in the first matrix.", "level3_prompt": "Compute the SGD kernel on GPU using CUDA."}
{"id": 301, "task_name": "SGD", "task_description": "Compute the SGD kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(2048, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 2048;\n\n__global__ void SGD_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float p = A[row * K + col]; float g = B[row * N + col]; C[row * N + col] = p - 1.00000000e-02f * g;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    SGD_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2048\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A - 0.01 * B\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 2048\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: SGD. Compute an output matrix where each element is calculated as the corresponding element from the first input matrix minus 0.01 times the corresponding element from the second input matrix. The inputs are two float32 matrices of shape 2048x2048. The output is a float32 matrix of the same shape. Each output element must be computed independently from its corresponding input elements at the same position.", "level2_prompt": "Task: SGD. For each element position (i, j) in the output matrix, compute: output[i, j] = matA[i, j] - 0.01 * matB[i, j], where matA and matB are input matrices.", "level3_prompt": "Compute the SGD kernel on GPU using CUDA."}
{"id": 302, "task_name": "SGD", "task_description": "Compute the SGD kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 4096)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096, 4096)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 4096\n#define N 4096\n#define TILE_WIDTH 32\nconst int M = 4096;\n\n__global__ void SGD_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float p = A[row * K + col]; float g = B[row * N + col]; C[row * N + col] = p - 1.00000000e-03f * g;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    SGD_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 4096\nK = 4096\nN = 4096\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A - 0.001 * B\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 4096\n    M = 4096\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: SGD. The kernel should compute an element-wise operation between two input matrices of size 4096x4096 and type float32. The operation for each element (i, j) is: output[i, j] = input1[i, j] - 0.001 * input2[i, j]. The output matrix must be of the same dimensions and type as the inputs. The kernel must respect the matrix dimensions and compute every element independently.", "level2_prompt": "Task name: SGD. For each element position (i, j) in a 4096x4096 matrix, compute the value as: C[i, j] = A[i, j] - 0.001 * B[i, j], where A and B are the input matrices.", "level3_prompt": "Compute the SGD kernel on GPU using CUDA."}
{"id": 303, "task_name": "SGD", "task_description": "Compute the SGD kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(2304, 2304)"}, {"name": "matB", "dtype": "float32", "shape": "(2304, 2304)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(2304, 2304)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2304\n#define N 2304\n#define TILE_WIDTH 32\nconst int M = 2304;\n\n__global__ void SGD_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float p = A[row * K + col]; float g = B[row * N + col]; C[row * N + col] = p - 5.00000000e-02f * g;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    SGD_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2304\nK = 2304\nN = 2304\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A - 0.05 * B\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2304\n    N = 2304\n    M = 2304\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the SGD kernel for updating parameters. The kernel takes two matrices, matA and matB, both of dimensions 2304x2304 and data type float32. The output matrix matC_out, also 2304x2304 and float32, is computed by performing an element-wise operation: each element at position (i, j) in matC_out is equal to the element from matA at (i, j) minus 0.05 times the element from matB at (i, j). The kernel must handle the fixed matrix size and perform the operation independently for each element.", "level2_prompt": "The SGD kernel performs an element-wise operation on two matrices. For each element at (i, j), the output is computed as: matA[i][j] - 0.05 * matB[i][j].", "level3_prompt": "Element-wise SGD update."}
{"id": 304, "task_name": "SGD", "task_description": "Compute the SGD kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(3072, 3072)"}, {"name": "matB", "dtype": "float32", "shape": "(3072, 3072)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(3072, 3072)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 3072\n#define N 3072\n#define TILE_WIDTH 32\nconst int M = 3072;\n\n__global__ void SGD_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float p = A[row * K + col]; float g = B[row * N + col]; C[row * N + col] = p - 5.00000000e-03f * g;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    SGD_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 3072\nK = 3072\nN = 3072\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A - 0.005 * B\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 3072\n    N = 3072\n    M = 3072\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an SGD kernel that performs an element-wise operation on two input matrices. The kernel should compute each element of the output matrix as: output[i][j] = matA[i][j] - (0.005 * matB[i][j]). Input matrices matA and matB are both float32 with dimensions 3072x3072. The output matrix matC_out must be float32 with dimensions 3072x3072. The kernel must process all elements in the matrices and maintain dimensional consistency.", "level2_prompt": "Implement SGD kernel that computes an output matrix where each element is a linear combination of corresponding elements from two input matrices: C[i][j] = A[i][j] - 0.005 * B[i][j]. The matrices are square with dimensions 3072x3072.", "level3_prompt": "Compute the SGD kernel on GPU using CUDA."}
{"id": 305, "task_name": "Softmax", "task_description": "Compute the Softmax kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(2048, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 2048;\n\n__global__ void Softmax_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmax_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2048\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 2048\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task Name: Softmax. Implement a CUDA kernel that computes the softmax function for each row of the input matrix matA. For each row, find the maximum value, subtract it from each element to avoid numerical instability, compute exponentials, sum them, and then divide each exponential by the sum to normalize. The kernel takes two input matrices: matA and matB, both 2048x2048 float32 matrices. Note that matB is unused in the computation. The output is a single matrix matC_out of size 2048x2048 float32, where each row represents a valid probability distribution (sums to 1).", "level2_prompt": "Task Name: Softmax. Apply the softmax function independently to each row of the input matrix. For each row, compute y_i = exp(x_i - max(x)) / sum(exp(x_j - max(x))) for all elements j in the row, where x is the row vector.", "level3_prompt": "Compute the Softmax kernel on GPU using CUDA."}
{"id": 306, "task_name": "Softmax", "task_description": "Compute the Softmax kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 4096)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024, 4096)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 4096\n#define N 4096\n#define TILE_WIDTH 32\nconst int M = 1024;\n\n__global__ void Softmax_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmax_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1024\nK = 4096\nN = 4096\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 4096\n    M = 1024\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Softmax. Compute the softmax of each row in input matrix A, which is a 1024x4096 float32 matrix. The kernel receives an unused second input matrix B (4096x4096 float32). The output is a 1024x4096 float32 matrix C. For each row, find the maximum value first, then compute exponentials of each element minus this max, sum these exponentials, and divide each exponential by the sum to produce the softmax output. Rows must be processed independently.", "level2_prompt": "Task: Softmax. For each row of matrix A, compute softmax values. For element (i,j), calculate: numerator = exp(A[i][j] - max_row_i), denominator = sum_{k}(exp(A[i][k] - max_row_i)), then output = numerator / denominator. Matrix B is provided but unused.", "level3_prompt": "Compute the softmax of each row of a given matrix."}
{"id": 307, "task_name": "Softmax", "task_description": "Compute the Softmax kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(512, 8192)"}, {"name": "matB", "dtype": "float32", "shape": "(8192, 8192)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(512, 8192)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8192\n#define N 8192\n#define TILE_WIDTH 32\nconst int M = 512;\n\n__global__ void Softmax_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmax_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 512\nK = 8192\nN = 8192\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8192\n    N = 8192\n    M = 512\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Softmax. Compute the row-wise softmax of input matrix matA (shape: 512x8192, dtype: float32), ignoring input matrix matB. For each row, find the maximum value, subtract it from all elements, exponentiate each value, then divide by the sum of exponentiated values in that row. Output matrix matC_out (shape: 512x8192, dtype: float32) must have normalized values per row where each row sums to 1. Kernel must process rows independently and ensure numerical stability.", "level2_prompt": "Task: Softmax. For each row of the input matrix, calculate the maximum element. Subtract this maximum from every element in the row, exponentiate the results, sum these exponentiated values, then normalize each element by dividing it by this sum.", "level3_prompt": "Compute the Softmax kernel on GPU using CUDA."}
{"id": 308, "task_name": "Softmax", "task_description": "Compute the Softmax kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 4096;\n\n__global__ void Softmax_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmax_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 4096\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 4096\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Softmax that computes the softmax activation for each row of input matrix matA. The input matA is a float32 tensor of shape (4096, 1024), and matB is a float32 tensor of shape (1024, 1024) that should be ignored. The output matC_out is a float32 tensor of shape (4096, 1024) where each element (i, j) equals exp(matA[i,j] - max_i) / sum_{k}(exp(matA[i,k] - max_i)), with max_i being the maximum value in row i. The kernel must process rows independently and avoid using matB.", "level2_prompt": "For each row in matrix matA, compute the maximum value in that row. Subtract this maximum from every element in the row, exponentiate the results, then divide each exponentiated value by the sum of all exponentiated values in the row to produce the output matrix matC_out.", "level3_prompt": "Compute the Softmax kernel on GPU using CUDA."}
{"id": 309, "task_name": "Softmax", "task_description": "Compute the Softmax kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void Softmax_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmax_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the Softmax kernel. The kernel takes two input matrices: matA of shape (8192, 1024) and matB of shape (1024, 1024), both of float32 data type. The kernel must ignore matB and only use matA. The output matrix matC_out must be of shape (8192, 1024) and float32. For each row in matA, compute the maximum value in that row. Then, for each element in the row, subtract the row maximum and compute the exponential. The softmax value for each element is the exponential of the element minus the row maximum, divided by the sum of the exponentials of all elements in the row (after subtracting the row maximum). Each thread should compute one output element. The kernel must avoid numerical overflow by using the row maximum.", "level2_prompt": "For each row i from 0 to 8191 and each column j from 0 to 1023: find the maximum value in row i of matA, then compute the sum of exponentials of each element in row i minus the maximum. The output at (i, j) is the exponential of matA[i][j] minus the row maximum, divided by the sum of exponentials for row i. The input matrix matB is not used.", "level3_prompt": "Compute the Softmax kernel on GPU using CUDA."}
{"id": 310, "task_name": "Softmin", "task_description": "Compute the Softmin kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(2048, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 2048;\n\n__global__ void Softmin_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmin_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2048\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(-A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 2048\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Softmin kernel for CUDA. Given two input matrices matA and matB, both of shape 2048x2048 with float32 data type, compute an output matrix matC_out of the same shape and type. The kernel should compute the Softmin function for each row of matA, where each element matC_out[i][j] equals the softmin of matA[i] at position j. Specifically, for each row i, compute the maximum value of -matA[i][k] across k, then calculate exponentials of (-matA[i][k] - max_value), sum them, and set matC_out[i][j] as the exponential of (-matA[i][j] - max_value) divided by the sum. The kernel must handle 2048x2048 matrices efficiently and ensure numerical stability.", "level2_prompt": "Perform the Softmin operation on a matrix. For each row in the input matrix, compute the softmin value for every element in that row. This involves finding the maximum of the negative values in the row, exponentiating the difference between each negative element and this maximum, summing these exponentials, and then normalizing each exponentiated value by this sum to produce the output matrix.", "level3_prompt": "Compute the Softmin kernel on GPU using CUDA."}
{"id": 311, "task_name": "Softmin", "task_description": "Compute the Softmin kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 4096)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 4096)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024, 4096)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 4096\n#define N 4096\n#define TILE_WIDTH 32\nconst int M = 1024;\n\n__global__ void Softmin_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmin_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 1024\nK = 4096\nN = 4096\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(-A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 4096\n    N = 4096\n    M = 1024\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Softmin kernel. The kernel should compute the softmin of each row in input matrix matA (shape: 1024x4096, float32). The softmin is defined as the softmax of the negative values. For each row, first find the maximum value of the negatives (equivalent to the minimum of the original row) for numerical stability. Then compute exponentials of each negative element minus this maximum, sum these exponentials across the row, and output each exponential divided by the sum. Input matrix matB (4096x4096, float32) should be ignored. Output matrix matC_out must match matA's shape (1024x4096, float32).", "level2_prompt": "Compute the softmin for each row of matrix matA. For a given row, the softmin of element j is computed as: exponentiate the negative of the element value minus the row's maximum negative value, then divide by the sum of all exponentiated values in the row. matB is unused in this computation.", "level3_prompt": "Compute the softmin of each row in matA."}
{"id": 312, "task_name": "Softmin", "task_description": "Compute the Softmin kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(512, 8192)"}, {"name": "matB", "dtype": "float32", "shape": "(8192, 8192)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 8192\n#define N 8192\n#define TILE_WIDTH 32\nconst int M = 512;\n\n__global__ void Softmin_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmin_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 512\nK = 8192\nN = 8192\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(-A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 8192\n    N = 8192\n    M = 512\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "The task is named 'Softmin'. The kernel must compute the softmin of each row in the input matrix matA (shape: 512 rows by 8192 columns, dtype: float32), producing an output matrix matC_out as a flattened 1D array of 4194304 float32 elements. The second input matrix matB (shape: 8192x8192, dtype: float32) must be ignored. The computation involves: for each row, finding the maximum value among the negatives of its elements, then computing exponentials of each negative element adjusted by this maximum, summing these exponentials, and finally calculating each output element as the ratio of its exponential to the sum. Each row must be processed independently.", "level2_prompt": "Softmin: Given a matrix A (512x8192) and a matrix B (8192x8192, unused), compute a matrix C (512x8192) where for each row i, and for each column j, C[i,j] = exp(-A[i,j] - max_k(-A[i,k])) / (sum_{k=0}^{8191} exp(-A[i,k] - max_k(-A[i,k]))).", "level3_prompt": "Compute the Softmin kernel on GPU using CUDA."}
{"id": 313, "task_name": "Softmin", "task_description": "Compute the Softmin kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 4096;\n\n__global__ void Softmin_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmin_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 4096\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(-A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 4096\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Softmin. Compute the softmin of each row in the input matrix matA (shape: 4096x1024, dtype: float32), ignoring the second input matB (shape: 1024x1024, dtype: float32). The output matrix matC_out (shape: 4096x1024, dtype: float32) must be computed per row where each element (i,j) equals exp(-matA[i,j]) divided by the sum of exp(-matA[i,k]) for all k in the same row. For numerical stability, first compute the maximum value of -matA[i,:] and subtract it from each -matA[i,j] before exponentiation. Each row must be processed independently.", "level2_prompt": "Task: Softmin. For each row i of matrix matA, compute the softmin of the row vector. For element j in row i: calculate max_val = max_k(-matA[i,k]); compute exponent = exp(-matA[i,j] - max_val); then output[i,j] = exponent / sum_k(exp(-matA[i,k] - max_val)). The input matB is unused.", "level3_prompt": "Compute the Softmin kernel on GPU using CUDA."}
{"id": 314, "task_name": "Softmin", "task_description": "Compute the Softmin kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void Softmin_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float mx = -INFINITY;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            if (v > mx) mx = v;\n        }\n        float s = 0.0f;\n        float num = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float v = -A[row * K + j];\n            float e = expf(v - mx);\n            if (j == col) num = e;\n            s += e;\n        }\n        C[row * N + col] = num / s;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softmin_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = torch.softmax(-A, dim=1)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the Softmin kernel. The inputs are two matrices: matA of size 8192x1024 and matB of size 1024x1024, both of float32 data type. The output is a matrix matC_out of size 8192x1024 and float32 data type. The kernel must compute the softmin of each row of matA independently, ignoring matB. The softmin of a row is computed by taking the negative of each element in the row, then applying the softmax function to the resulting vector. To ensure numerical stability, the kernel must subtract the maximum value of the negative row elements from each exponent. The output for each row must be a valid probability distribution (non-negative and summing to 1).", "level2_prompt": "Given a matrix matA of size 8192x1024, compute the softmin of each row. For each row, take the negative of each element, find the maximum value in the resulting vector, then compute exponentials of (negative element - maximum) for all elements. Normalize each element by the sum of these exponentials across the row to produce the output matrix.", "level3_prompt": "Compute the Softmin kernel on GPU using CUDA."}
{"id": 315, "task_name": "Softsign", "task_description": "Compute the Softsign kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void Softsign_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + fabsf(x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softsign_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A / (1.0 + torch.abs(A))\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: Softsign. Compute the Softsign function element-wise on the input matrix matA. The Softsign function for an element x is defined as x / (1.0 + |x|). Input matrices are matA (float32, 8192x1024) and matB (float32, 1024x1024), though only matA is used in the computation. Output matrix matC_out (float32, 8192x1024) must have the same shape as matA. The kernel must process each element independently and only compute for valid indices within the matrix dimensions.", "level2_prompt": "Softsign: For each element x in the input matrix A, compute the output element as x divided by (1 plus the absolute value of x).", "level3_prompt": "Compute the Softsign kernel on GPU using CUDA."}
{"id": 316, "task_name": "Softsign", "task_description": "Compute the Softsign kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void Softsign_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + fabsf(x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softsign_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A / (1.0 + torch.abs(A))\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Softsign. Implement a CUDA kernel that computes the Softsign activation function element-wise on the input matrix `matA`. The Softsign function is defined as: for each element x in `matA`, compute x / (1 + absolute value of x). The kernel should ignore the second input matrix `matB`. The input `matA` is a 2D tensor of 16384 rows and 1024 columns with float32 data type. The input `matB` is a 2D tensor of 1024 rows and 1024 columns with float32 data type. The output `matC_out` is a 2D tensor of 16384 rows and 1024 columns with float32 data type. The kernel must compute each output element independently and the output must have the same shape as `matA`.", "level2_prompt": "Apply the Softsign function element-wise to the input matrix `matA`. The Softsign function for an element x is x / (1 + |x|). The input matrix `matB` is provided but not used. The output matrix has the same dimensions as `matA`.", "level3_prompt": "Compute the Softsign activation function element-wise on the input matrix."}
{"id": 317, "task_name": "Softsign", "task_description": "Compute the Softsign kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void Softsign_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + fabsf(x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softsign_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A / (1.0 + torch.abs(A))\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Softsign: Compute the element-wise Softsign function for a 16384x2048 input matrix of float32 values. The Softsign operation is defined as x / (1.0 + |x|) for each element x in the input matrix. The output matrix must have identical dimensions (16384x2048) and data type (float32) as the input. The kernel must process each element independently without altering adjacent elements.", "level2_prompt": "Softsign: Apply the Softsign function element-wise to a matrix. For each element x, compute the output as x divided by (1 plus the absolute value of x). The operation is independent for each matrix element.", "level3_prompt": "Element-wise Softsign of a matrix."}
{"id": 318, "task_name": "Softsign", "task_description": "Compute the Softsign kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void Softsign_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + fabsf(x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softsign_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A / (1.0 + torch.abs(A))\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Softsign. The kernel must compute the softsign function for each element of the input matrix matA. The softsign function is defined as f(x) = x / (1 + absolute_value(x)). The input matrix matA has dimensions 32768 rows by 1024 columns and is of data type float32. The input matrix matB has dimensions 1024 by 1024 and float32 type but is not used in the computation. The output matrix matC_out must have the same dimensions as matA (32768, 1024) and float32 type. The kernel must handle the entire matrix and compute each element independently.", "level2_prompt": "Softsign: For each element x in the input matrix matA, compute the function f(x) = x / (1 + |x|). The result is stored in the output matrix matC_out, which has the same dimensions as matA.", "level3_prompt": "Compute the Softsign kernel on GPU using CUDA."}
{"id": 319, "task_name": "Softsign", "task_description": "Compute the Softsign kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void Softsign_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + fabsf(x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Softsign_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A / (1.0 + torch.abs(A))\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Softsign. Compute the Softsign function element-wise on the input matrix matA. The Softsign function for an element x is defined as x / (1.0 + absolute_value(x)). Input matA is a float32 tensor of shape (32768, 2048), and matB is a float32 tensor of shape (2048, 2048) which is not used in this computation. Output matC_out must be a float32 tensor of shape (32768, 2048) containing the Softsign result for each element of matA. The kernel must process every element of matA independently and ignore matB.", "level2_prompt": "Task: Softsign. For each element x in the input matrix matA, compute the function f(x) = x / (1 + |x|). The result is stored in an output matrix matC_out of the same dimensions as matA. The second input matrix matB is provided but not used in the computation.", "level3_prompt": "Compute the Softsign kernel on GPU using CUDA."}
{"id": 320, "task_name": "Swish", "task_description": "Compute the Swish kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(8192, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(8192, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 8192;\n\n__global__ void Swish_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + expf(-x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Swish_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 8192\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A * torch.sigmoid(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 8192\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Swish. Given two input matrices: matA of size 8192x1024 and matB of size 1024x1024, both of float32 data type. Compute the Swish activation function element-wise on matA, ignoring matB. The Swish function is defined as: for each element x in matA, output x * sigmoid(x), where sigmoid(x) = 1/(1+exp(-x)). The output matrix matC_out must have the same shape as matA (8192x1024) and float32 data type. The kernel must be implemented in CUDA for a GPU and handle the entire matrix.", "level2_prompt": "Task: Swish. Compute the element-wise Swish activation of the matrix matA, which is defined as each element multiplied by its sigmoid. The input matB should be ignored. The output matrix must have the same dimensions as matA.", "level3_prompt": "Compute the Swish kernel on GPU using CUDA."}
{"id": 321, "task_name": "Swish", "task_description": "Compute the Swish kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void Swish_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + expf(-x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Swish_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A * torch.sigmoid(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Swish. Compute the Swish activation function for each element of the input matrix matA (16384x1024 of float32). The Swish function is defined as: output = x * sigmoid(x), where x is the input element and sigmoid(x) = 1 / (1 + exp(-x)). The input matrix matB (1024x1024 of float32) is provided but not used in the computation. The output matrix matC_out (16384x1024 of float32) must contain the Swish activation result for each corresponding element in matA. The kernel must process all elements independently and handle the exact matrix dimensions provided.", "level2_prompt": "Task: Swish. Apply the Swish activation function element-wise to a 16384x1024 input matrix matA. For each element x, compute x divided by (1 + exp(-x)). The result should be stored in an output matrix matC_out of identical dimensions. The second input matrix matB is unused.", "level3_prompt": "Compute the Swish kernel on GPU using CUDA."}
{"id": 322, "task_name": "Swish", "task_description": "Compute the Swish kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 16384;\n\n__global__ void Swish_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + expf(-x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Swish_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 16384\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A * torch.sigmoid(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 16384\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Swish. Compute the element-wise Swish activation function on a 16384x2048 input matrix matA of float32 values. The Swish function is defined as x * sigmoid(x), where sigmoid(x) = 1 / (1 + exp(-x)). The output matrix matC_out must have the same shape (16384x2048) and float32 datatype as matA. Note that matB is provided but not used in the computation.", "level2_prompt": "Swish: Apply the element-wise Swish activation function to each element of the input matrix. For each element x, compute x * (1 / (1 + exp(-x))) and store the result in the corresponding position of the output matrix.", "level3_prompt": "Compute the Swish kernel on GPU using CUDA."}
{"id": 323, "task_name": "Swish", "task_description": "Compute the Swish kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 1024\n#define N 1024\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void Swish_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + expf(-x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Swish_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 1024\nN = 1024\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A * torch.sigmoid(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 1024\n    N = 1024\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Swish. Compute the Swish activation function element-wise on the input matrix matA, ignoring the input matrix matB. The Swish function is defined as: for each element x in matA, compute x * sigmoid(x), where sigmoid(x) = 1 / (1 + exp(-x)). Inputs: matA is a float32 tensor of shape (32768, 1024), and matB is a float32 tensor of shape (1024, 1024) but unused. Output: matC_out is a float32 tensor of shape (32768, 1024) containing the Swish activation of each element in matA. Constraints: The computation must be element-wise and not use matB.", "level2_prompt": "Task: Swish. Apply the Swish activation function to each element of the input matrix matA. The Swish function for an element x is x multiplied by the sigmoid of x. The input matrix matB is not used in the computation.", "level3_prompt": "Compute the Swish activation function element-wise for each element of the input matrix."}
{"id": 324, "task_name": "Swish", "task_description": "Compute the Swish kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(32768, 2048)"}, {"name": "matB", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(32768, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define K 2048\n#define N 2048\n#define TILE_WIDTH 32\nconst int M = 32768;\n\n__global__ void Swish_Kernel(const float* A, const float* B, float* C, int M_arg) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < M && col < N) {\n        float x = A[row * K + col];\n        C[row * N + col] = x / (1.0f + expf(-x));\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t size_A = (size_t)M * (size_t)K;\n    size_t size_B = (size_t)K * (size_t)N;\n    size_t size_C = (size_t)M * (size_t)N;\n\n    float *h_A = new float[size_A];\n    float *h_B = new float[size_B];\n    float *h_C = new float[size_C];\n\n    std::string A_file = \"./data/matA.bin\";\n    std::string B_file = \"./data/matB.bin\";\n\n    read_binary(A_file, h_A, size_A);\n    read_binary(B_file, h_B, size_B);\n\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, size_A * sizeof(float));\n    cudaMalloc(&d_B, size_B * sizeof(float));\n    cudaMalloc(&d_C, size_C * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, size_A * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, size_B * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 dimBlock(TILE_WIDTH, TILE_WIDTH);\n    dim3 dimGrid((N + TILE_WIDTH - 1) / TILE_WIDTH, (M + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    Swish_Kernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, M);\n    cudaMemcpy(h_C, d_C, size_C * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_C, size_C);\n\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 32768\nK = 2048\nN = 2048\n\nseed = int.from_bytes(os.urandom(4), 'little')\ntorch.manual_seed(seed)\n\nA = torch.randn(M, K, dtype=torch.float32)\nB = torch.randn(K, N, dtype=torch.float32)\nC = A * torch.sigmoid(A)\n\nos.makedirs(\"data\", exist_ok=True)\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nC.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    K = 2048\n    N = 2048\n    M = 32768\n\n    size_C = M * N\n    out_file = \"./data/matC_out.bin\"\n    ref_file = \"./data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_C):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "The task is named Swish. The kernel must compute the Swish activation function for each element of the first input matrix matA. The input consists of two matrices: matA of shape (32768, 2048) and matB of shape (2048, 2048), both of data type float32. The kernel should ignore the second input matrix matB. The output is a matrix matC_out of shape (32768, 2048) and float32. The Swish function is defined as: f(x) = x * sigmoid(x) = x / (1 + exp(-x)). The kernel must be applied element-wise, meaning each element in the output is computed solely from the corresponding element in matA.", "level2_prompt": "Swish: For each element in the first input matrix, compute the Swish function: output = input * (1 / (1 + exp(-input))). The second input matrix is not used.", "level3_prompt": "Compute the Swish kernel on GPU using CUDA."}
{"id": 325, "task_name": "Multi-Head_Self-Attention", "task_description": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA.", "inputs": [{"name": "Q", "dtype": "float32", "shape": "(64, 32)"}, {"name": "K", "dtype": "float32", "shape": "(64, 32)"}, {"name": "V", "dtype": "float32", "shape": "(64, 32)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(64, 32)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\nconst int N = 64;\nconst int D_MODEL = 32;\nconst int H = 4;\n\n__global__ void multihead_attention_kernel(\n    const float* Q, const float* K, const float* V,\n    float* output, int N, int d_model, int h)\n{\n    int i = blockIdx.x;       // index over N\n    int j = threadIdx.x;      // index over d_model\n\n    int dk = d_model / h;\n    if (j >= d_model || i >= N) return;\n\n    int head_id = j / dk;\n    int local_j = j % dk;\n\n    const float* Q_i = Q;\n    const float* K_i = K;\n    const float* V_i = V;\n\n    float scores[1024];\n    for (int k = 0; k < N; ++k) {\n        float dot = 0.0f;\n        for (int d = 0; d < dk; ++d) {\n            float q = Q_i[i * d_model + head_id * dk + d];\n            float k_val = K_i[k * d_model + head_id * dk + d];\n            dot += q * k_val;\n        }\n        scores[k] = dot / sqrtf((float)dk);\n    }\n\n    float max_score = -1e9f;\n    for (int k = 0; k < N; ++k)\n        max_score = fmaxf(max_score, scores[k]);\n\n    float sum = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        scores[k] = expf(scores[k] - max_score);\n        sum += scores[k];\n    }\n    for (int k = 0; k < N; ++k)\n        scores[k] /= sum;\n\n    float out = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        float val = V_i[k * d_model + head_id * dk + local_j];\n        out += scores[k] * val;\n    }\n\n    output[i * d_model + j] = out;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total = N * D_MODEL;\n\n    float *h_Q = new float[total];\n    float *h_K = new float[total];\n    float *h_V = new float[total];\n    float *h_out = new float[total];\n\n    read_binary(\"data/Q.bin\", h_Q, total);\n    read_binary(\"data/K.bin\", h_K, total);\n    read_binary(\"data/V.bin\", h_V, total);\n\n    float *d_Q, *d_K, *d_V, *d_out;\n    cudaMalloc(&d_Q, total * sizeof(float));\n    cudaMalloc(&d_K, total * sizeof(float));\n    cudaMalloc(&d_V, total * sizeof(float));\n    cudaMalloc(&d_out, total * sizeof(float));\n\n    cudaMemcpy(d_Q, h_Q, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_K, h_K, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_V, h_V, total * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 grid(N);\n    dim3 block(D_MODEL);\n    multihead_attention_kernel<<<grid, block>>>(d_Q, d_K, d_V, d_out, N, D_MODEL, H);\n\n    cudaMemcpy(h_out, d_out, total * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/out.bin\", h_out, total);\n\n    cudaFree(d_Q);\n    cudaFree(d_K);\n    cudaFree(d_V);\n    cudaFree(d_out);\n    delete[] h_Q;\n    delete[] h_K;\n    delete[] h_V;\n    delete[] h_out;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nN, d_model, h = 64, 32, 4\n\ntorch.manual_seed(42)\n\ndef multihead_attention(Q, K, V, h):\n    N, d_model = Q.shape\n    d_k = d_model // h\n    heads = []\n    for i in range(h):\n        Q_i = Q[:, i*d_k:(i+1)*d_k]\n        K_i = K[:, i*d_k:(i+1)*d_k]\n        V_i = V[:, i*d_k:(i+1)*d_k]\n        attn_weights = torch.matmul(Q_i, K_i.T) / d_k**0.5\n        attn_weights = torch.softmax(attn_weights, dim=-1)\n        head = torch.matmul(attn_weights, V_i)\n        heads.append(head)\n    return torch.cat(heads, dim=-1)\n\nQ = torch.randn(N, d_model, dtype=torch.float32)\nK = torch.randn(N, d_model, dtype=torch.float32)\nV = torch.randn(N, d_model, dtype=torch.float32)\n\nref_out = multihead_attention(Q, K, V, h)\n\nos.makedirs(\"data\", exist_ok=True)\nQ.numpy().tofile(\"data/Q.bin\")\nK.numpy().tofile(\"data/K.bin\")\nV.numpy().tofile(\"data/V.bin\")\nref_out.numpy().tofile(\"data/ref_out.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 64\n    D_MODEL = 32\n    size = N * D_MODEL\n\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref_out.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Multi-Head Self-Attention operation. The inputs are three tensors: Q, K, and V, each of shape (64, 32) and data type float32. The output is a tensor of shape (64, 32) and data type float32. The operation must split the 32-dimensional model into 4 heads, each of 8 dimensions. For each head, compute the scaled dot-product attention: for each row in Q (corresponding to a token), compute attention scores by taking the dot product of the row's query vector (from Q) and all key vectors (from K) in the same head, then scale each score by 1 divided by the square root of 8. Apply softmax over the attention scores for each row to get probabilities. Then, for each row, compute a weighted sum of the value vectors (from V) in the same head using these probabilities. Concatenate the outputs from all 4 heads to form the final output. The kernel must respect the constraint that the model dimension (32) is divisible by the number of heads (4).", "level2_prompt": "Compute multi-head self-attention with 4 heads. The input tensors Q, K, and V each have shape (64, 32). The model dimension (32) is split equally into 4 heads, each of 8 dimensions. For each head, compute the scaled dot product attention: for each token i (row in Q), compute the dot product between the i-th token's query vector (for the head) and every token's key vector (for the same head), then scale by 1/sqrt(8). Apply softmax over these scores for the i-th token to get attention probabilities. Then, for the i-th token, compute the weighted sum of the value vectors (from the same head) using these probabilities. Concatenate the outputs of all heads to form the output of shape (64, 32).", "level3_prompt": "Compute the Multi-Head Self-Attention."}
{"id": 326, "task_name": "Multi-Head_Self-Attention", "task_description": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA.", "inputs": [{"name": "Q", "dtype": "float32", "shape": "(128, 64)"}, {"name": "K", "dtype": "float32", "shape": "(128, 64)"}, {"name": "V", "dtype": "float32", "shape": "(128, 64)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(128, 64)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\nconst int N = 128;\nconst int D_MODEL = 64;\nconst int H = 8;\n\n__global__ void multihead_attention_kernel(\n    const float* Q, const float* K, const float* V,\n    float* output, int N, int d_model, int h)\n{\n    int i = blockIdx.x;       // index over N\n    int j = threadIdx.x;      // index over d_model\n\n    int dk = d_model / h;\n    if (j >= d_model || i >= N) return;\n\n    int head_id = j / dk;\n    int local_j = j % dk;\n\n    const float* Q_i = Q;\n    const float* K_i = K;\n    const float* V_i = V;\n\n    float scores[1024];\n    for (int k = 0; k < N; ++k) {\n        float dot = 0.0f;\n        for (int d = 0; d < dk; ++d) {\n            float q = Q_i[i * d_model + head_id * dk + d];\n            float k_val = K_i[k * d_model + head_id * dk + d];\n            dot += q * k_val;\n        }\n        scores[k] = dot / sqrtf((float)dk);\n    }\n\n    float max_score = -1e9f;\n    for (int k = 0; k < N; ++k)\n        max_score = fmaxf(max_score, scores[k]);\n\n    float sum = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        scores[k] = expf(scores[k] - max_score);\n        sum += scores[k];\n    }\n    for (int k = 0; k < N; ++k)\n        scores[k] /= sum;\n\n    float out = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        float val = V_i[k * d_model + head_id * dk + local_j];\n        out += scores[k] * val;\n    }\n\n    output[i * d_model + j] = out;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total = N * D_MODEL;\n\n    float *h_Q = new float[total];\n    float *h_K = new float[total];\n    float *h_V = new float[total];\n    float *h_out = new float[total];\n\n    read_binary(\"data/Q.bin\", h_Q, total);\n    read_binary(\"data/K.bin\", h_K, total);\n    read_binary(\"data/V.bin\", h_V, total);\n\n    float *d_Q, *d_K, *d_V, *d_out;\n    cudaMalloc(&d_Q, total * sizeof(float));\n    cudaMalloc(&d_K, total * sizeof(float));\n    cudaMalloc(&d_V, total * sizeof(float));\n    cudaMalloc(&d_out, total * sizeof(float));\n\n    cudaMemcpy(d_Q, h_Q, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_K, h_K, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_V, h_V, total * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 grid(N);\n    dim3 block(D_MODEL);\n    multihead_attention_kernel<<<grid, block>>>(d_Q, d_K, d_V, d_out, N, D_MODEL, H);\n\n    cudaMemcpy(h_out, d_out, total * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/out.bin\", h_out, total);\n\n    cudaFree(d_Q);\n    cudaFree(d_K);\n    cudaFree(d_V);\n    cudaFree(d_out);\n    delete[] h_Q;\n    delete[] h_K;\n    delete[] h_V;\n    delete[] h_out;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nN, d_model, h = 128, 64, 8\n\ntorch.manual_seed(42)\n\ndef multihead_attention(Q, K, V, h):\n    N, d_model = Q.shape\n    d_k = d_model // h\n    heads = []\n    for i in range(h):\n        Q_i = Q[:, i*d_k:(i+1)*d_k]\n        K_i = K[:, i*d_k:(i+1)*d_k]\n        V_i = V[:, i*d_k:(i+1)*d_k]\n        attn_weights = torch.matmul(Q_i, K_i.T) / d_k**0.5\n        attn_weights = torch.softmax(attn_weights, dim=-1)\n        head = torch.matmul(attn_weights, V_i)\n        heads.append(head)\n    return torch.cat(heads, dim=-1)\n\nQ = torch.randn(N, d_model, dtype=torch.float32)\nK = torch.randn(N, d_model, dtype=torch.float32)\nV = torch.randn(N, d_model, dtype=torch.float32)\n\nref_out = multihead_attention(Q, K, V, h)\n\nos.makedirs(\"data\", exist_ok=True)\nQ.numpy().tofile(\"data/Q.bin\")\nK.numpy().tofile(\"data/K.bin\")\nV.numpy().tofile(\"data/V.bin\")\nref_out.numpy().tofile(\"data/ref_out.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 128\n    D_MODEL = 64\n    size = N * D_MODEL\n\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref_out.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Multi-Head Self-Attention: Implement a CUDA kernel that computes multi-head self-attention using input tensors Q, K, and V, each of shape (128, 64) and float32 data type. The output tensor must be of shape (128, 64) and float32 data type. The computation must split the input tensors into 8 heads, compute scaled dot-product attention scores for each head, apply row-wise softmax normalization, and combine the results. Constraints include: fixed head count (8), head dimension (8), and attention score scaling by 1/sqrt(8).", "level2_prompt": "Multi-Head Self-Attention: For each of 8 heads, extract corresponding slices from Q, K, and V tensors. Compute pairwise dot products between all query and key vectors within each head, scale results by 1/sqrt(8), then apply softmax row-wise to create attention weights. Multiply these weights with value vectors to produce head-specific outputs, then concatenate all head outputs along the feature dimension.", "level3_prompt": "Compute the Multi-Head Self-Attention kernel on GPU using CUDA."}
{"id": 327, "task_name": "Multi-Head_Self-Attention", "task_description": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA.", "inputs": [{"name": "Q", "dtype": "float32", "shape": "(256, 128)"}, {"name": "K", "dtype": "float32", "shape": "(256, 128)"}, {"name": "V", "dtype": "float32", "shape": "(256, 128)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(256, 128)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\nconst int N = 256;\nconst int D_MODEL = 128;\nconst int H = 8;\n\n__global__ void multihead_attention_kernel(\n    const float* Q, const float* K, const float* V,\n    float* output, int N, int d_model, int h)\n{\n    int i = blockIdx.x;       // index over N\n    int j = threadIdx.x;      // index over d_model\n\n    int dk = d_model / h;\n    if (j >= d_model || i >= N) return;\n\n    int head_id = j / dk;\n    int local_j = j % dk;\n\n    const float* Q_i = Q;\n    const float* K_i = K;\n    const float* V_i = V;\n\n    float scores[1024];\n    for (int k = 0; k < N; ++k) {\n        float dot = 0.0f;\n        for (int d = 0; d < dk; ++d) {\n            float q = Q_i[i * d_model + head_id * dk + d];\n            float k_val = K_i[k * d_model + head_id * dk + d];\n            dot += q * k_val;\n        }\n        scores[k] = dot / sqrtf((float)dk);\n    }\n\n    float max_score = -1e9f;\n    for (int k = 0; k < N; ++k)\n        max_score = fmaxf(max_score, scores[k]);\n\n    float sum = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        scores[k] = expf(scores[k] - max_score);\n        sum += scores[k];\n    }\n    for (int k = 0; k < N; ++k)\n        scores[k] /= sum;\n\n    float out = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        float val = V_i[k * d_model + head_id * dk + local_j];\n        out += scores[k] * val;\n    }\n\n    output[i * d_model + j] = out;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total = N * D_MODEL;\n\n    float *h_Q = new float[total];\n    float *h_K = new float[total];\n    float *h_V = new float[total];\n    float *h_out = new float[total];\n\n    read_binary(\"data/Q.bin\", h_Q, total);\n    read_binary(\"data/K.bin\", h_K, total);\n    read_binary(\"data/V.bin\", h_V, total);\n\n    float *d_Q, *d_K, *d_V, *d_out;\n    cudaMalloc(&d_Q, total * sizeof(float));\n    cudaMalloc(&d_K, total * sizeof(float));\n    cudaMalloc(&d_V, total * sizeof(float));\n    cudaMalloc(&d_out, total * sizeof(float));\n\n    cudaMemcpy(d_Q, h_Q, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_K, h_K, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_V, h_V, total * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 grid(N);\n    dim3 block(D_MODEL);\n    multihead_attention_kernel<<<grid, block>>>(d_Q, d_K, d_V, d_out, N, D_MODEL, H);\n\n    cudaMemcpy(h_out, d_out, total * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/out.bin\", h_out, total);\n\n    cudaFree(d_Q);\n    cudaFree(d_K);\n    cudaFree(d_V);\n    cudaFree(d_out);\n    delete[] h_Q;\n    delete[] h_K;\n    delete[] h_V;\n    delete[] h_out;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nN, d_model, h = 256, 128, 8\n\ntorch.manual_seed(42)\n\ndef multihead_attention(Q, K, V, h):\n    N, d_model = Q.shape\n    d_k = d_model // h\n    heads = []\n    for i in range(h):\n        Q_i = Q[:, i*d_k:(i+1)*d_k]\n        K_i = K[:, i*d_k:(i+1)*d_k]\n        V_i = V[:, i*d_k:(i+1)*d_k]\n        attn_weights = torch.matmul(Q_i, K_i.T) / d_k**0.5\n        attn_weights = torch.softmax(attn_weights, dim=-1)\n        head = torch.matmul(attn_weights, V_i)\n        heads.append(head)\n    return torch.cat(heads, dim=-1)\n\nQ = torch.randn(N, d_model, dtype=torch.float32)\nK = torch.randn(N, d_model, dtype=torch.float32)\nV = torch.randn(N, d_model, dtype=torch.float32)\n\nref_out = multihead_attention(Q, K, V, h)\n\nos.makedirs(\"data\", exist_ok=True)\nQ.numpy().tofile(\"data/Q.bin\")\nK.numpy().tofile(\"data/K.bin\")\nV.numpy().tofile(\"data/V.bin\")\nref_out.numpy().tofile(\"data/ref_out.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 256\n    D_MODEL = 128\n    size = N * D_MODEL\n\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref_out.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Multi-Head Self-Attention: Given three input tensors Q, K, and V, each with shape (256, 128) and float32 data type, compute the multi-head self-attention output. The model dimension (128) must be divided into 8 heads, each with 16 features. For each token (256 tokens) and each head, compute attention scores by taking the dot product between the token's query vector and all tokens' key vectors for that head, scaled by the inverse square root of the head dimension (16). Apply softmax to normalize the scores, then compute a weighted sum of all tokens' value vectors using these weights. Concatenate the outputs from all heads to form the final output tensor of shape (256, 128). The kernel must respect the fixed head count (8) and head dimension (16).", "level2_prompt": "Multi-Head Self-Attention: Split the input tensors Q, K, and V into h heads along the feature dimension. For each head, compute attention scores between every token pair by taking the dot product of query and key vectors, scaled by 1/sqrt(d_k). Apply softmax to convert scores to probabilities. Compute the output for each head as a weighted sum of value vectors using these probabilities. Concatenate all head outputs along the feature dimension to produce the final result.", "level3_prompt": "Compute the Multi-Head Self-Attention kernel on GPU using CUDA."}
{"id": 328, "task_name": "Multi-Head_Self-Attention", "task_description": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA.", "inputs": [{"name": "Q", "dtype": "float32", "shape": "(384, 256)"}, {"name": "K", "dtype": "float32", "shape": "(384, 256)"}, {"name": "V", "dtype": "float32", "shape": "(384, 256)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(384, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\nconst int N = 384;\nconst int D_MODEL = 256;\nconst int H = 16;\n\n__global__ void multihead_attention_kernel(\n    const float* Q, const float* K, const float* V,\n    float* output, int N, int d_model, int h)\n{\n    int i = blockIdx.x;       // index over N\n    int j = threadIdx.x;      // index over d_model\n\n    int dk = d_model / h;\n    if (j >= d_model || i >= N) return;\n\n    int head_id = j / dk;\n    int local_j = j % dk;\n\n    const float* Q_i = Q;\n    const float* K_i = K;\n    const float* V_i = V;\n\n    float scores[1024];\n    for (int k = 0; k < N; ++k) {\n        float dot = 0.0f;\n        for (int d = 0; d < dk; ++d) {\n            float q = Q_i[i * d_model + head_id * dk + d];\n            float k_val = K_i[k * d_model + head_id * dk + d];\n            dot += q * k_val;\n        }\n        scores[k] = dot / sqrtf((float)dk);\n    }\n\n    float max_score = -1e9f;\n    for (int k = 0; k < N; ++k)\n        max_score = fmaxf(max_score, scores[k]);\n\n    float sum = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        scores[k] = expf(scores[k] - max_score);\n        sum += scores[k];\n    }\n    for (int k = 0; k < N; ++k)\n        scores[k] /= sum;\n\n    float out = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        float val = V_i[k * d_model + head_id * dk + local_j];\n        out += scores[k] * val;\n    }\n\n    output[i * d_model + j] = out;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total = N * D_MODEL;\n\n    float *h_Q = new float[total];\n    float *h_K = new float[total];\n    float *h_V = new float[total];\n    float *h_out = new float[total];\n\n    read_binary(\"data/Q.bin\", h_Q, total);\n    read_binary(\"data/K.bin\", h_K, total);\n    read_binary(\"data/V.bin\", h_V, total);\n\n    float *d_Q, *d_K, *d_V, *d_out;\n    cudaMalloc(&d_Q, total * sizeof(float));\n    cudaMalloc(&d_K, total * sizeof(float));\n    cudaMalloc(&d_V, total * sizeof(float));\n    cudaMalloc(&d_out, total * sizeof(float));\n\n    cudaMemcpy(d_Q, h_Q, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_K, h_K, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_V, h_V, total * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 grid(N);\n    dim3 block(D_MODEL);\n    multihead_attention_kernel<<<grid, block>>>(d_Q, d_K, d_V, d_out, N, D_MODEL, H);\n\n    cudaMemcpy(h_out, d_out, total * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/out.bin\", h_out, total);\n\n    cudaFree(d_Q);\n    cudaFree(d_K);\n    cudaFree(d_V);\n    cudaFree(d_out);\n    delete[] h_Q;\n    delete[] h_K;\n    delete[] h_V;\n    delete[] h_out;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nN, d_model, h = 384, 256, 16\n\ntorch.manual_seed(42)\n\ndef multihead_attention(Q, K, V, h):\n    N, d_model = Q.shape\n    d_k = d_model // h\n    heads = []\n    for i in range(h):\n        Q_i = Q[:, i*d_k:(i+1)*d_k]\n        K_i = K[:, i*d_k:(i+1)*d_k]\n        V_i = V[:, i*d_k:(i+1)*d_k]\n        attn_weights = torch.matmul(Q_i, K_i.T) / d_k**0.5\n        attn_weights = torch.softmax(attn_weights, dim=-1)\n        head = torch.matmul(attn_weights, V_i)\n        heads.append(head)\n    return torch.cat(heads, dim=-1)\n\nQ = torch.randn(N, d_model, dtype=torch.float32)\nK = torch.randn(N, d_model, dtype=torch.float32)\nV = torch.randn(N, d_model, dtype=torch.float32)\n\nref_out = multihead_attention(Q, K, V, h)\n\nos.makedirs(\"data\", exist_ok=True)\nQ.numpy().tofile(\"data/Q.bin\")\nK.numpy().tofile(\"data/K.bin\")\nV.numpy().tofile(\"data/V.bin\")\nref_out.numpy().tofile(\"data/ref_out.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 384\n    D_MODEL = 256\n    size = N * D_MODEL\n\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref_out.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Multi-Head_Self-Attention: Given three input tensors Q, K, and V, each with shape (384, 256) and float32 data type, compute the output tensor with the same shape and data type. The kernel must split the feature dimension into 16 heads, compute scaled dot-product attention scores for each head, apply softmax normalization, and compute a weighted sum of value vectors. The feature dimension (256) must be divisible by the number of heads (16), and attention scores must be scaled by 1/sqrt(16).", "level2_prompt": "Multi-Head_Self-Attention: Split input tensors Q, K, V into 16 heads along the feature dimension. For each head, compute pairwise attention scores by dot products between query and key vectors, scaled by 1/sqrt(head_dimension). Apply softmax to normalize scores across keys for each query, then compute weighted sums of value vectors using the normalized scores. Concatenate all head outputs to form the final result.", "level3_prompt": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA."}
{"id": 329, "task_name": "Multi-Head_Self-Attention", "task_description": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA.", "inputs": [{"name": "Q", "dtype": "float32", "shape": "(512, 512)"}, {"name": "K", "dtype": "float32", "shape": "(512, 512)"}, {"name": "V", "dtype": "float32", "shape": "(512, 512)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\nconst int N = 512;\nconst int D_MODEL = 512;\nconst int H = 16;\n\n__global__ void multihead_attention_kernel(\n    const float* Q, const float* K, const float* V,\n    float* output, int N, int d_model, int h)\n{\n    int i = blockIdx.x;       // index over N\n    int j = threadIdx.x;      // index over d_model\n\n    int dk = d_model / h;\n    if (j >= d_model || i >= N) return;\n\n    int head_id = j / dk;\n    int local_j = j % dk;\n\n    const float* Q_i = Q;\n    const float* K_i = K;\n    const float* V_i = V;\n\n    float scores[1024];\n    for (int k = 0; k < N; ++k) {\n        float dot = 0.0f;\n        for (int d = 0; d < dk; ++d) {\n            float q = Q_i[i * d_model + head_id * dk + d];\n            float k_val = K_i[k * d_model + head_id * dk + d];\n            dot += q * k_val;\n        }\n        scores[k] = dot / sqrtf((float)dk);\n    }\n\n    float max_score = -1e9f;\n    for (int k = 0; k < N; ++k)\n        max_score = fmaxf(max_score, scores[k]);\n\n    float sum = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        scores[k] = expf(scores[k] - max_score);\n        sum += scores[k];\n    }\n    for (int k = 0; k < N; ++k)\n        scores[k] /= sum;\n\n    float out = 0.0f;\n    for (int k = 0; k < N; ++k) {\n        float val = V_i[k * d_model + head_id * dk + local_j];\n        out += scores[k] * val;\n    }\n\n    output[i * d_model + j] = out;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total = N * D_MODEL;\n\n    float *h_Q = new float[total];\n    float *h_K = new float[total];\n    float *h_V = new float[total];\n    float *h_out = new float[total];\n\n    read_binary(\"data/Q.bin\", h_Q, total);\n    read_binary(\"data/K.bin\", h_K, total);\n    read_binary(\"data/V.bin\", h_V, total);\n\n    float *d_Q, *d_K, *d_V, *d_out;\n    cudaMalloc(&d_Q, total * sizeof(float));\n    cudaMalloc(&d_K, total * sizeof(float));\n    cudaMalloc(&d_V, total * sizeof(float));\n    cudaMalloc(&d_out, total * sizeof(float));\n\n    cudaMemcpy(d_Q, h_Q, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_K, h_K, total * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_V, h_V, total * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 grid(N);\n    dim3 block(D_MODEL);\n    multihead_attention_kernel<<<grid, block>>>(d_Q, d_K, d_V, d_out, N, D_MODEL, H);\n\n    cudaMemcpy(h_out, d_out, total * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/out.bin\", h_out, total);\n\n    cudaFree(d_Q);\n    cudaFree(d_K);\n    cudaFree(d_V);\n    cudaFree(d_out);\n    delete[] h_Q;\n    delete[] h_K;\n    delete[] h_V;\n    delete[] h_out;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nN, d_model, h = 512, 512, 16\n\ntorch.manual_seed(42)\n\ndef multihead_attention(Q, K, V, h):\n    N, d_model = Q.shape\n    d_k = d_model // h\n    heads = []\n    for i in range(h):\n        Q_i = Q[:, i*d_k:(i+1)*d_k]\n        K_i = K[:, i*d_k:(i+1)*d_k]\n        V_i = V[:, i*d_k:(i+1)*d_k]\n        attn_weights = torch.matmul(Q_i, K_i.T) / d_k**0.5\n        attn_weights = torch.softmax(attn_weights, dim=-1)\n        head = torch.matmul(attn_weights, V_i)\n        heads.append(head)\n    return torch.cat(heads, dim=-1)\n\nQ = torch.randn(N, d_model, dtype=torch.float32)\nK = torch.randn(N, d_model, dtype=torch.float32)\nV = torch.randn(N, d_model, dtype=torch.float32)\n\nref_out = multihead_attention(Q, K, V, h)\n\nos.makedirs(\"data\", exist_ok=True)\nQ.numpy().tofile(\"data/Q.bin\")\nK.numpy().tofile(\"data/K.bin\")\nV.numpy().tofile(\"data/V.bin\")\nref_out.numpy().tofile(\"data/ref_out.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 512\n    D_MODEL = 512\n    size = N * D_MODEL\n\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref_out.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute multi-head self-attention. The inputs are three 512x512 float32 tensors: Q (queries), K (keys), and V (values). The output is a 512x512 float32 tensor. Split the inputs into 16 heads along the feature dimension (each head has 32 features). For each head, compute attention scores by taking the scaled dot product of queries and keys (scale factor: 1/sqrt(32)), apply softmax to the scores, and compute a weighted sum of values using these weights. Concatenate the outputs from all heads. The kernel must process 512 rows and 512 columns.", "level2_prompt": "The task is to compute multi-head self-attention. Split input tensors Q, K, and V into 16 heads along the feature dimension. For each head, compute scaled dot products between queries and keys, apply softmax normalization, then compute weighted sums of values. Concatenate the results from all heads.", "level3_prompt": "Compute the Multi-Head_Self-Attention kernel on GPU using CUDA."}
{"id": 330, "task_name": "Cosine_Similarity", "task_description": "Compute the Cosine_Similarity kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 10) // 2**10 rows\n#define N 1024      // 1024 columns\n#define TOLERANCE 1e-5f\n\n// CUDA kernel: compute cosine similarity along rows\n__global__ void cosine_similarity_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float dot = 0.0f;\n        float normA = 0.0f;\n        float normB = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float a = A[row * Q + j];\n            float b = B[row * Q + j];\n            dot += a * b;\n            normA += a * a;\n            normB += b * b;\n        }\n        Y[row] = dot / (sqrtf(normA) * sqrtf(normB) + 1e-8f); // add small epsilon to prevent divide by zero\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Host memory\n    float *h_A = new float[M * N];\n    float *h_B = new float[M * N];\n    float *h_Y = new float[M];\n\n    read_binary(\"data/matA.bin\", h_A, M * N);\n    read_binary(\"data/matB.bin\", h_B, M * N);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, M * N * sizeof(float));\n    cudaMalloc(&d_B, M * N * sizeof(float));\n    cudaMalloc(&d_Y, M * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, M * N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, M * N * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    cosine_similarity_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_Y, d_Y, M * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/matC_cuda.bin\", h_Y, M);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\n\nM = 2**10  \nN = 1024   # 1024 columns\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set deterministic seed for reproducibility\ntorch.manual_seed(47)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Compute cosine similarity along rows\nY = torch.nn.functional.cosine_similarity(A, B, dim=1)\n\n# Save to binary files\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**10  # number of rows\n    total_size = M  # cosine similarity result is one value per row\n\n    out_file = \"data/matC_cuda.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Cosine_Similarity. Compute cosine similarity between corresponding rows of two matrices. Inputs: matA and matB, both float32 matrices of shape (1024, 1024). Output: matC_cuda, a float32 vector of shape (1024,). For each row i, compute dot product between matA[i] and matB[i], then divide by the product of their L2 norms. Add 1e-8 to denominator to prevent division by zero. Each row must be processed independently.", "level2_prompt": "Task: Cosine_Similarity. For each row index i, calculate: dot_product = Σ(matA[i,j] * matB[i,j]), normA = sqrt(Σ(matA[i,j]^2)), normB = sqrt(Σ(matB[i,j]^2)), then output[i] = dot_product / (normA * normB + ε) where ε is a small constant.", "level3_prompt": "Compute the Cosine_Similarity kernel on GPU using CUDA."}
{"id": 331, "task_name": "Cosine_Similarity", "task_description": "Compute the Cosine_Similarity kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 12) // 2**12 rows\n#define N 1024      // 1024 columns\n#define TOLERANCE 1e-5f\n\n// CUDA kernel: compute cosine similarity along rows\n__global__ void cosine_similarity_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float dot = 0.0f;\n        float normA = 0.0f;\n        float normB = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float a = A[row * Q + j];\n            float b = B[row * Q + j];\n            dot += a * b;\n            normA += a * a;\n            normB += b * b;\n        }\n        Y[row] = dot / (sqrtf(normA) * sqrtf(normB) + 1e-8f); // add small epsilon to prevent divide by zero\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Host memory\n    float *h_A = new float[M * N];\n    float *h_B = new float[M * N];\n    float *h_Y = new float[M];\n\n    read_binary(\"data/matA.bin\", h_A, M * N);\n    read_binary(\"data/matB.bin\", h_B, M * N);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, M * N * sizeof(float));\n    cudaMalloc(&d_B, M * N * sizeof(float));\n    cudaMalloc(&d_Y, M * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, M * N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, M * N * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    cosine_similarity_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_Y, d_Y, M * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/matC_cuda.bin\", h_Y, M);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\n\nM = 2**12  \nN = 1024   # 1024 columns\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set deterministic seed for reproducibility\ntorch.manual_seed(47)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Compute cosine similarity along rows\nY = torch.nn.functional.cosine_similarity(A, B, dim=1)\n\n# Save to binary files\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**12  # number of rows\n    total_size = M  # cosine similarity result is one value per row\n\n    out_file = \"data/matC_cuda.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Cosine_Similarity kernel for GPU using CUDA. The kernel computes cosine similarity row-wise between two input matrices: matA and matB, both of shape (4096, 1024) and data type float32. The output is a vector matC_cuda with shape (4096,) and float32 data type, where each element represents the cosine similarity of corresponding rows from matA and matB. The kernel must handle large matrices efficiently, avoid division by zero by adding a small epsilon (1e-8) during normalization, and compute each row independently.", "level2_prompt": "Compute the cosine similarity between corresponding rows of two matrices. For each row, calculate the dot product of the row vectors from matA and matB, the squared norm of each row vector, and then derive the cosine similarity as the dot product divided by the product of the norms of the two vectors, with a small epsilon added to the denominator to prevent division by zero.", "level3_prompt": "Compute the Cosine_Similarity kernel on GPU using CUDA."}
{"id": 332, "task_name": "Cosine_Similarity", "task_description": "Compute the Cosine_Similarity kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(16384, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 14) // 2**14 rows\n#define N 1024      // 1024 columns\n#define TOLERANCE 1e-5f\n\n// CUDA kernel: compute cosine similarity along rows\n__global__ void cosine_similarity_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float dot = 0.0f;\n        float normA = 0.0f;\n        float normB = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float a = A[row * Q + j];\n            float b = B[row * Q + j];\n            dot += a * b;\n            normA += a * a;\n            normB += b * b;\n        }\n        Y[row] = dot / (sqrtf(normA) * sqrtf(normB) + 1e-8f); // add small epsilon to prevent divide by zero\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Host memory\n    float *h_A = new float[M * N];\n    float *h_B = new float[M * N];\n    float *h_Y = new float[M];\n\n    read_binary(\"data/matA.bin\", h_A, M * N);\n    read_binary(\"data/matB.bin\", h_B, M * N);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, M * N * sizeof(float));\n    cudaMalloc(&d_B, M * N * sizeof(float));\n    cudaMalloc(&d_Y, M * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, M * N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, M * N * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    cosine_similarity_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_Y, d_Y, M * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/matC_cuda.bin\", h_Y, M);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\n\nM = 2**14\nN = 1024   # 1024 columns\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set deterministic seed for reproducibility\ntorch.manual_seed(47)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Compute cosine similarity along rows\nY = torch.nn.functional.cosine_similarity(A, B, dim=1)\n\n# Save to binary files\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**14  # number of rows\n    total_size = M  # cosine similarity result is one value per row\n\n    out_file = \"data/matC_cuda.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel called Cosine_Similarity that computes the cosine similarity between corresponding rows of two input matrices. The inputs are matA and matB, both float32 matrices of shape (16384, 1024). The output should be matC_cuda, a float32 vector of length 16384, where each element represents the cosine similarity between the corresponding rows of matA and matB. The computation must avoid division by zero by adding a small epsilon (1e-8) to the denominator. Each row should be processed independently, and the kernel must handle all 16384 rows.", "level2_prompt": "Compute the cosine similarity between corresponding rows of two matrices. For each row index i, calculate the dot product of row i from matA and matB, the L2 norm of row i from matA, and the L2 norm of row i from matB. The cosine similarity for row i is the dot product divided by the product of the two norms, with a small epsilon added to the denominator to prevent division by zero.", "level3_prompt": "Compute the Cosine_Similarity kernel on GPU using CUDA."}
{"id": 333, "task_name": "Cosine_Similarity", "task_description": "Compute the Cosine_Similarity kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(65536, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 16) // 2**16 rows\n#define N 1024      // 1024 columns\n#define TOLERANCE 1e-5f\n\n// CUDA kernel: compute cosine similarity along rows\n__global__ void cosine_similarity_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float dot = 0.0f;\n        float normA = 0.0f;\n        float normB = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float a = A[row * Q + j];\n            float b = B[row * Q + j];\n            dot += a * b;\n            normA += a * a;\n            normB += b * b;\n        }\n        Y[row] = dot / (sqrtf(normA) * sqrtf(normB) + 1e-8f); // add small epsilon to prevent divide by zero\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Host memory\n    float *h_A = new float[M * N];\n    float *h_B = new float[M * N];\n    float *h_Y = new float[M];\n\n    read_binary(\"data/matA.bin\", h_A, M * N);\n    read_binary(\"data/matB.bin\", h_B, M * N);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, M * N * sizeof(float));\n    cudaMalloc(&d_B, M * N * sizeof(float));\n    cudaMalloc(&d_Y, M * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, M * N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, M * N * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    cosine_similarity_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_Y, d_Y, M * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/matC_cuda.bin\", h_Y, M);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\n\nM = 2**16  \nN = 1024   # 1024 columns\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set deterministic seed for reproducibility\ntorch.manual_seed(47)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Compute cosine similarity along rows\nY = torch.nn.functional.cosine_similarity(A, B, dim=1)\n\n# Save to binary files\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**16  # number of rows\n    total_size = M  # cosine similarity result is one value per row\n\n    out_file = \"data/matC_cuda.bin\"  # CUDA output\n    ref_file = \"data/matC_ref.bin\"  # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Cosine_Similarity. Given two input matrices matA and matB, both of shape (65536, 1024) and data type float32, compute the cosine similarity for each corresponding row. The output is a vector of shape (65536,) and data type float32. For each row i, the cosine similarity is computed as the dot product of the i-th row of matA and the i-th row of matB, divided by the product of their L2 norms. To avoid division by zero, add a small epsilon (1e-8) to the denominator.", "level2_prompt": "Task: Cosine_Similarity. For each row index i, compute the dot product between the i-th row of matrix A and the i-th row of matrix B. Then compute the L2 norm of the i-th row of A and the L2 norm of the i-th row of B. The result for row i is the dot product divided by the product of the two norms, with a small epsilon added to the denominator.", "level3_prompt": "Compute the cosine similarity between corresponding rows of two matrices."}
{"id": 334, "task_name": "Cosine_Similarity", "task_description": "Compute the Cosine_Similarity kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(262144, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 18) // 2**18 rows\n#define N 1024      // 1024 columns\n#define TOLERANCE 1e-5f\n\n// CUDA kernel: compute cosine similarity along rows\n__global__ void cosine_similarity_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float dot = 0.0f;\n        float normA = 0.0f;\n        float normB = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float a = A[row * Q + j];\n            float b = B[row * Q + j];\n            dot += a * b;\n            normA += a * a;\n            normB += b * b;\n        }\n        Y[row] = dot / (sqrtf(normA) * sqrtf(normB) + 1e-8f); // add small epsilon to prevent divide by zero\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Host memory\n    float *h_A = new float[M * N];\n    float *h_B = new float[M * N];\n    float *h_Y = new float[M];\n\n    read_binary(\"data/matA.bin\", h_A, M * N);\n    read_binary(\"data/matB.bin\", h_B, M * N);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, M * N * sizeof(float));\n    cudaMalloc(&d_B, M * N * sizeof(float));\n    cudaMalloc(&d_Y, M * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, M * N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, M * N * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    cosine_similarity_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_Y, d_Y, M * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/matC_cuda.bin\", h_Y, M);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\n\nM = 2**18  \nN = 1024   # 1024 columns\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set deterministic seed for reproducibility\ntorch.manual_seed(47)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Compute cosine similarity along rows\nY = torch.nn.functional.cosine_similarity(A, B, dim=1)\n\n# Save to binary files\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**18  # number of rows\n    total_size = M  # cosine similarity result is one value per row\n\n    out_file = \"data/matC_cuda.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Cosine_Similarity that computes the cosine similarity between corresponding rows of two input matrices. The input matrices matA and matB have dimensions (262144, 1024) and data type float32. The output vector matC_cuda should have dimensions (262144,) and data type float32. For each row index, compute the cosine similarity as the dot product of the row vectors divided by the product of their L2 norms, with a small epsilon added to the denominator to prevent division by zero.", "level2_prompt": "Implement a CUDA kernel to compute cosine similarity between row vectors. For each row index i, calculate the dot product of row i from matA and matB, then divide it by the product of the Euclidean norms of both rows, adding epsilon to the denominator for numerical stability.", "level3_prompt": "Compute cosine similarity between corresponding rows of two matrices."}
{"id": 335, "task_name": "Elementwise_Addition", "task_description": "Compute the Elementwise_Addition kernel on GPU using CUDA.", "inputs": [{"name": "addA", "dtype": "float32", "shape": "(1024, 2048)"}, {"name": "addB", "dtype": "float32", "shape": "(1024, 2048)"}], "outputs": [{"name": "addC_cuda", "dtype": "float32", "shape": "(1024, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 10)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise addition\n__global__ void add_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/addA.bin\", h_A, total_size);\n    read_binary(\"data/addB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    add_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/addC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(44)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise addition\nC = A + B\n\nA.numpy().tofile(\"data/addA.bin\")\nB.numpy().tofile(\"data/addB.bin\")\nC.numpy().tofile(\"data/addC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**10\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/addC_cuda.bin\"    # CUDA output\n    ref_file = \"data/addC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the Elementwise_Addition task. The kernel must perform element-wise addition between two input tensors: addA and addB, both of dtype float32 and shape (1024, 2048). The output tensor addC_cuda must have the same shape and dtype as the inputs. For each element at position (i, j), the output should be the sum of the corresponding elements from addA and addB. The kernel must handle exactly 1024 × 2048 elements.", "level2_prompt": "Perform element-wise addition for the Elementwise_Addition task. Given two 2D tensors A and B of dimensions M×N where M=1024 and N=2048, compute output tensor C such that C[i][j] = A[i][j] + B[i][j] for all valid indices i and j.", "level3_prompt": "Compute the Elementwise_Addition kernel on GPU using CUDA."}
{"id": 336, "task_name": "Elementwise_Addition", "task_description": "Compute the Elementwise_Addition kernel on GPU using CUDA.", "inputs": [{"name": "addA", "dtype": "float32", "shape": "(4096, 2048)"}, {"name": "addB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "addC_cuda", "dtype": "float32", "shape": "(4096, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 12)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise addition\n__global__ void add_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/addA.bin\", h_A, total_size);\n    read_binary(\"data/addB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    add_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/addC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(44)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise addition\nC = A + B\n\nA.numpy().tofile(\"data/addA.bin\")\nB.numpy().tofile(\"data/addB.bin\")\nC.numpy().tofile(\"data/addC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**12\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/addC_cuda.bin\"    # CUDA output\n    ref_file = \"data/addC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an elementwise addition kernel for GPU computation. The task involves adding two input tensors, addA and addB, each of type float32 and shape (4096, 2048), to produce an output tensor addC_cuda with identical shape and data type. The kernel must compute the sum of corresponding elements from both input tensors, ensuring that every output element C[i][j] equals A[i][j] + B[i][j]. The input tensors are guaranteed to have matching dimensions.", "level2_prompt": "Perform elementwise addition of two matrices. Given two input matrices A and B of dimensions 4096x2048, compute an output matrix C where each element C[i][j] is the sum of A[i][j] and B[i][j]. The matrices have identical shapes, and the operation must be applied uniformly across all elements.", "level3_prompt": "Compute the element-wise addition of two tensors."}
{"id": 337, "task_name": "Elementwise_Addition", "task_description": "Compute the Elementwise_Addition kernel on GPU using CUDA.", "inputs": [{"name": "addA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "addB", "dtype": "float32", "shape": "(16384, 2048)"}], "outputs": [{"name": "addC_cuda", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 14)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise addition\n__global__ void add_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/addA.bin\", h_A, total_size);\n    read_binary(\"data/addB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    add_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/addC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(44)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise addition\nC = A + B\n\nA.numpy().tofile(\"data/addA.bin\")\nB.numpy().tofile(\"data/addB.bin\")\nC.numpy().tofile(\"data/addC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**14\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/addC_cuda.bin\"    # CUDA output\n    ref_file = \"data/addC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an elementwise addition kernel for CUDA. The kernel should take two input tensors, addA and addB, both of data type float32 and shape (16384, 2048). The output tensor addC_cuda must have the same shape and data type. Each element in the output tensor should be the sum of the corresponding elements in the input tensors. The kernel must efficiently handle the entire tensor size of 16384 x 2048 elements.", "level2_prompt": "Perform elementwise addition of two matrices A and B of dimensions M x N, where M=16384 and N=2048. For each element position (i,j), compute C[i,j] = A[i,j] + B[i,j]. The result must be stored in a new matrix C with identical dimensions.", "level3_prompt": "Compute the Elementwise_Addition kernel on GPU using CUDA."}
{"id": 338, "task_name": "Elementwise_Addition", "task_description": "Compute the Elementwise_Addition kernel on GPU using CUDA.", "inputs": [{"name": "addA", "dtype": "float32", "shape": "(65536, 2048)"}, {"name": "addB", "dtype": "float32", "shape": "(65536, 2048)"}], "outputs": [{"name": "addC_cuda", "dtype": "float32", "shape": "(65536, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 16)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise addition\n__global__ void add_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/addA.bin\", h_A, total_size);\n    read_binary(\"data/addB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    add_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/addC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(44)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise addition\nC = A + B\n\nA.numpy().tofile(\"data/addA.bin\")\nB.numpy().tofile(\"data/addB.bin\")\nC.numpy().tofile(\"data/addC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**16\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/addC_cuda.bin\"    # CUDA output\n    ref_file = \"data/addC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an Elementwise_Addition CUDA kernel. The kernel takes two input tensors, addA and addB, both of data type float32 and shape (65536, 2048). It must produce an output tensor addC_cuda of the same shape and data type. The kernel should add corresponding elements from the two input tensors, meaning each element in the output is the sum of the corresponding elements in addA and addB. The kernel must be designed to handle the entire array of 65536 * 2048 elements.", "level2_prompt": "Implement the Elementwise_Addition operation for two matrices. Given two input matrices A and B of size 65536x2048, compute the output matrix C where each element C[i][j] is the sum of A[i][j] and B[i][j] for all valid indices i and j.", "level3_prompt": "Compute the element-wise addition of two tensors."}
{"id": 339, "task_name": "Elementwise_Addition", "task_description": "Compute the Elementwise_Addition kernel on GPU using CUDA.", "inputs": [{"name": "addA", "dtype": "float32", "shape": "(262144, 2048)"}, {"name": "addB", "dtype": "float32", "shape": "(262144, 2048)"}], "outputs": [{"name": "addC_cuda", "dtype": "float32", "shape": "(262144, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 18)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise addition\n__global__ void add_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/addA.bin\", h_A, total_size);\n    read_binary(\"data/addB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    add_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/addC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(44)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise addition\nC = A + B\n\nA.numpy().tofile(\"data/addA.bin\")\nB.numpy().tofile(\"data/addB.bin\")\nC.numpy().tofile(\"data/addC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**18\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/addC_cuda.bin\"    # CUDA output\n    ref_file = \"data/addC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Elementwise_Addition. Compute the elementwise addition of two input tensors. Inputs are tensors addA and addB, both with data type float32 and shape (262144, 2048). The output tensor addC_cuda must have identical shape and data type. Each element in the output must be the sum of corresponding elements from addA and addB. The kernel must process all elements without altering shapes or data types.", "level2_prompt": "Task: Elementwise_Addition. Given two matrices A and B of dimensions 262144 by 2048, compute matrix C where each element C[i][j] equals A[i][j] + B[i][j]. Output must preserve input dimensions and data types.", "level3_prompt": "Elementwise addition of two tensors."}
{"id": 340, "task_name": "Elementwise_Multiplication", "task_description": "Compute the Elementwise_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mulA", "dtype": "float32", "shape": "(1024, 2048)"}, {"name": "mulB", "dtype": "float32", "shape": "(1024, 2048)"}], "outputs": [{"name": "mulC_cuda", "dtype": "float32", "shape": "(2097152,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 10)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise multiplication\n__global__ void mul_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] * B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/mulA.bin\", h_A, total_size);\n    read_binary(\"data/mulB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    mul_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/mulC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(45)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise multiplication\nC = A * B\n\nA.numpy().tofile(\"data/mulA.bin\")\nB.numpy().tofile(\"data/mulB.bin\")\nC.numpy().tofile(\"data/mulC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**10\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/mulC_cuda.bin\"    # CUDA output\n    ref_file = \"data/mulC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an elementwise multiplication kernel named Elementwise_Multiplication. The kernel must multiply corresponding elements from two input tensors: mulA and mulB, both float32 arrays of shape (1024, 2048). The output tensor mulC_cuda must be a flattened float32 array of length 2097152 containing the elementwise products. The kernel must handle all elements in the input tensors and maintain strict numerical correspondence between input positions and output values.", "level2_prompt": "Perform elementwise multiplication for two identically shaped float32 tensors. For each corresponding element pair in the input tensors, compute their product and store it in the output tensor. The operation must cover all positions in the input tensors.", "level3_prompt": "Compute the Elementwise_Multiplication kernel on GPU using CUDA."}
{"id": 341, "task_name": "Elementwise_Multiplication", "task_description": "Compute the Elementwise_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mulA", "dtype": "float32", "shape": "(4096, 2048)"}, {"name": "mulB", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "mulC_cuda", "dtype": "float32", "shape": "(8388608,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 12)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise multiplication\n__global__ void mul_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] * B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/mulA.bin\", h_A, total_size);\n    read_binary(\"data/mulB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    mul_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/mulC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(45)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise multiplication\nC = A * B\n\nA.numpy().tofile(\"data/mulA.bin\")\nB.numpy().tofile(\"data/mulB.bin\")\nC.numpy().tofile(\"data/mulC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**12\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/mulC_cuda.bin\"    # CUDA output\n    ref_file = \"data/mulC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an Elementwise_Multiplication CUDA kernel. The kernel must multiply corresponding elements from two input tensors: mulA and mulB. Both inputs are float32 tensors with shape (4096, 2048). The output tensor mulC_cuda must be a float32 tensor of shape (8388608,) containing element-wise products. The kernel must handle all 8,388,608 elements independently without altering input data.", "level2_prompt": "Perform element-wise multiplication of two identically shaped matrices. For each position (i,j) in both input matrices, compute the product and store it in the corresponding position of a flattened output array. The operation must preserve input data integrity.", "level3_prompt": "Compute the Elementwise_Multiplication kernel on GPU using CUDA."}
{"id": 342, "task_name": "Elementwise_Multiplication", "task_description": "Compute the Elementwise_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mulA", "dtype": "float32", "shape": "(16384, 2048)"}, {"name": "mulB", "dtype": "float32", "shape": "(16384, 2048)"}], "outputs": [{"name": "mulC_cuda", "dtype": "float32", "shape": "(16384, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 14)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise multiplication\n__global__ void mul_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] * B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/mulA.bin\", h_A, total_size);\n    read_binary(\"data/mulB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    mul_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/mulC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(45)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise multiplication\nC = A * B\n\nA.numpy().tofile(\"data/mulA.bin\")\nB.numpy().tofile(\"data/mulB.bin\")\nC.numpy().tofile(\"data/mulC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**14\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/mulC_cuda.bin\"    # CUDA output\n    ref_file = \"data/mulC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Elementwise_Multiplication. Compute an output tensor by multiplying two input tensors element-wise. The inputs are two tensors named mulA and mulB, both of shape (16384, 2048) and data type float32. The output tensor mulC_cuda must have the same shape (16384, 2048) and data type float32. Each element in the output is the product of the corresponding elements in mulA and mulB. The kernel must handle exactly 16384 * 2048 elements.", "level2_prompt": "Task: Elementwise_Multiplication. For each element position in a 2D grid of size 16384 by 2048, multiply the corresponding elements from two input tensors to produce the output tensor.", "level3_prompt": "Compute the Elementwise_Multiplication kernel on GPU using CUDA."}
{"id": 343, "task_name": "Elementwise_Multiplication", "task_description": "Compute the Elementwise_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mulA", "dtype": "float32", "shape": "(65536, 2048)"}, {"name": "mulB", "dtype": "float32", "shape": "(65536, 2048)"}], "outputs": [{"name": "mulC_cuda", "dtype": "float32", "shape": "(65536, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 16)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise multiplication\n__global__ void mul_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] * B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/mulA.bin\", h_A, total_size);\n    read_binary(\"data/mulB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    mul_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/mulC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(45)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise multiplication\nC = A * B\n\nA.numpy().tofile(\"data/mulA.bin\")\nB.numpy().tofile(\"data/mulB.bin\")\nC.numpy().tofile(\"data/mulC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**16\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/mulC_cuda.bin\"    # CUDA output\n    ref_file = \"data/mulC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an Elementwise_Multiplication CUDA kernel. The kernel takes two input tensors, mulA and mulB, each of shape (65536, 2048) and data type float32. The output tensor, mulC_cuda, must have the same shape (65536, 2048) and data type float32. The kernel must compute the element-wise product: each element in mulC_cuda is the product of the corresponding elements in mulA and mulB. The kernel must handle the entire tensor and respect the memory layout.", "level2_prompt": "Perform element-wise multiplication of two matrices. Given two input matrices A and B of dimensions 65536 by 2048, compute an output matrix C of the same dimensions such that each element C[i][j] equals A[i][j] multiplied by B[i][j].", "level3_prompt": "Compute the Elementwise_Multiplication kernel on GPU using CUDA."}
{"id": 344, "task_name": "Elementwise_Multiplication", "task_description": "Compute the Elementwise_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mulA", "dtype": "float32", "shape": "(262144, 2048)"}, {"name": "mulB", "dtype": "float32", "shape": "(262144, 2048)"}], "outputs": [{"name": "mulC_cuda", "dtype": "float32", "shape": "(262144, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 18)\n#define N 2048       // 2048 columns\n\n// CUDA kernel: elementwise multiplication\n__global__ void mul_kernel(const float* A, const float* B, float* C, int total_size) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < total_size) {\n        C[idx] = A[idx] * B[idx];\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_size = M * N;\n\n    // Host memory\n    float* h_A = new float[total_size];\n    float* h_B = new float[total_size];\n    float* h_C = new float[total_size];\n\n    read_binary(\"data/mulA.bin\", h_A, total_size);\n    read_binary(\"data/mulB.bin\", h_B, total_size);\n\n    // Device memory\n    float *d_A, *d_B, *d_C;\n    cudaMalloc(&d_A, total_size * sizeof(float));\n    cudaMalloc(&d_B, total_size * sizeof(float));\n    cudaMalloc(&d_C, total_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, total_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, total_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Launch kernel\n    int threads_per_block = 256;\n    int blocks = (total_size + threads_per_block - 1) / threads_per_block;\n    mul_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_C, total_size);\n    cudaDeviceSynchronize();\n\n    // Copy back\n    cudaMemcpy(h_C, d_C, total_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save result\n    write_binary(\"data/mulC_cuda.bin\", h_C, total_size);\n\n    // Cleanup\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_C);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_C;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nN = 2048\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Set seed for reproducibility\ntorch.manual_seed(45)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\n\n# Elementwise multiplication\nC = A * B\n\nA.numpy().tofile(\"data/mulA.bin\")\nB.numpy().tofile(\"data/mulB.bin\")\nC.numpy().tofile(\"data/mulC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read a binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a specified tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**18\n    N = 2048\n    total_size = M * N\n\n    out_file = \"data/mulC_cuda.bin\"    # CUDA output\n    ref_file = \"data/mulC_ref.bin\"     # PyTorch reference\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Elementwise_Multiplication. Perform element-wise multiplication of two input tensors. Inputs are two tensors named 'mulA' and 'mulB', both of data type float32 and shape (262144, 2048). Output is a tensor named 'mulC_cuda' with the same shape and data type. Each element in the output tensor must be the product of the corresponding elements in the input tensors. The kernel must handle the entire tensor and respect the shape and data type constraints.", "level2_prompt": "Task: Elementwise_Multiplication. For every element in the two input tensors, multiply the corresponding elements to produce an output tensor of the same shape. Specifically, for each position (i, j) in the tensors, output[i, j] = input1[i, j] * input2[i, j].", "level3_prompt": "Compute the Elementwise_Multiplication kernel on GPU using CUDA."}
{"id": 345, "task_name": "Matrix_Vector_Multiplication", "task_description": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mvA_10", "dtype": "float32", "shape": "(1024, 4096)"}, {"name": "mvv_10", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "mvy_cuda_10", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 10)   // 2^10 = 1024 rows\n#define K 4096        // vector length\n#define TOLERANCE 1e-5f\n\n__global__ void matvec_kernel(const float* A, const float* v, float* y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < K; ++j) {\n            sum += A[row * Q + j] * v[j];\n        }\n        y[row] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    std::string A_file = \"data/mvA_10.bin\";\n    std::string v_file = \"data/mvv_10.bin\";\n    std::string y_out_file = \"data/mvy_cuda_10.bin\";\n\n    size_t A_size = M * K;\n    size_t v_size = K;\n    size_t y_size = M;\n\n    float *h_A = new float[A_size];\n    float *h_v = new float[v_size];\n    float *h_y = new float[y_size];\n\n    read_binary(A_file, h_A, A_size);\n    read_binary(v_file, h_v, v_size);\n\n    float *d_A, *d_v, *d_y;\n    cudaMalloc(&d_A, A_size * sizeof(float));\n    cudaMalloc(&d_v, v_size * sizeof(float));\n    cudaMalloc(&d_y, y_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, A_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_v, h_v, v_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    matvec_kernel<<<blocks, threads_per_block>>>(d_A, d_v, d_y, M, K);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_y, d_y, y_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(y_out_file, h_y, y_size);\n\n    cudaFree(d_A);\n    cudaFree(d_v);\n    cudaFree(d_y);\n    delete[] h_A;\n    delete[] h_v;\n    delete[] h_y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nK = 4096\n\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(43)\n\nA = torch.randn(M, K, dtype=torch.float32)\nv = torch.randn(K, dtype=torch.float32)\ny = A @ v\n\nA.numpy().tofile(\"data/mvA_10.bin\")\nv.numpy().tofile(\"data/mvv_10.bin\")\ny.numpy().tofile(\"data/mvy_ref_10.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file(s): {output_file if not os.path.exists(output_file) else ''} {ref_file if not os.path.exists(ref_file) else ''}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        print(\"Shape mismatch:\", output.shape, reference.shape)\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**10   # 1024\n    K = 4096\n    total_size = M\n\n    out_file = \"data/mvy_cuda_10.bin\"  # CUDA result\n    ref_file = \"data/mvy_ref_10.bin\"  # Reference result from PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Matrix_Vector_Multiplication. Compute the product of a matrix and a vector. The input matrix has dimensions 1024 rows by 4096 columns and data type float32. The input vector has 4096 elements and data type float32. The output must be a vector of 1024 elements and data type float32. Each element of the output vector is the dot product of the corresponding row of the matrix and the input vector.", "level2_prompt": "Matrix_Vector_Multiplication: For each row index i from 0 to 1023, compute the inner product of the i-th row of the matrix and the vector, and assign the result to the i-th element of the output vector.", "level3_prompt": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA."}
{"id": 346, "task_name": "Matrix_Vector_Multiplication", "task_description": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mvA_12", "dtype": "float32", "shape": "(4096, 4096)"}, {"name": "mvv_12", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "mvy_cuda_12", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 12)   // 2^12\n#define K 4096        // vector length\n#define TOLERANCE 1e-5f\n\n__global__ void matvec_kernel(const float* A, const float* v, float* y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < K; ++j) {\n            sum += A[row * Q + j] * v[j];\n        }\n        y[row] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    std::string A_file = \"data/mvA_12.bin\";\n    std::string v_file = \"data/mvv_12.bin\";\n    std::string y_out_file = \"data/mvy_cuda_12.bin\";\n\n    size_t A_size = M * K;\n    size_t v_size = K;\n    size_t y_size = M;\n\n    float *h_A = new float[A_size];\n    float *h_v = new float[v_size];\n    float *h_y = new float[y_size];\n\n    read_binary(A_file, h_A, A_size);\n    read_binary(v_file, h_v, v_size);\n\n    float *d_A, *d_v, *d_y;\n    cudaMalloc(&d_A, A_size * sizeof(float));\n    cudaMalloc(&d_v, v_size * sizeof(float));\n    cudaMalloc(&d_y, y_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, A_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_v, h_v, v_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    matvec_kernel<<<blocks, threads_per_block>>>(d_A, d_v, d_y, M, K);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_y, d_y, y_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(y_out_file, h_y, y_size);\n\n    cudaFree(d_A);\n    cudaFree(d_v);\n    cudaFree(d_y);\n    delete[] h_A;\n    delete[] h_v;\n    delete[] h_y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nK = 4096\n\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(43)\n\nA = torch.randn(M, K, dtype=torch.float32)\nv = torch.randn(K, dtype=torch.float32)\ny = A @ v\n\nA.numpy().tofile(\"data/mvA_12.bin\")\nv.numpy().tofile(\"data/mvv_12.bin\")\ny.numpy().tofile(\"data/mvy_ref_12.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file(s): {output_file if not os.path.exists(output_file) else ''} {ref_file if not os.path.exists(ref_file) else ''}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        print(\"Shape mismatch:\", output.shape, reference.shape)\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**12 \n    K = 4096\n    total_size = M\n\n    out_file = \"data/mvy_cuda_12.bin\"  # CUDA result\n    ref_file = \"data/mvy_ref_12.bin\"  # Reference result from PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Matrix_Vector_Multiplication kernel on GPU using CUDA. The kernel must multiply a 4096x4096 matrix (mvA_12) with a 4096-element vector (mvv_12), both float32 tensors, to produce a 4096-element output vector (mvy_cuda_12) of float32 values. Each element of the output vector is computed as the dot product between the corresponding row of the matrix and the input vector. The kernel must handle all 4096 rows and avoid out-of-bound memory accesses.", "level2_prompt": "Perform matrix-vector multiplication where a 4096x4096 matrix is multiplied by a 4096-element vector to produce a 4096-element output vector. For each row index i, compute the sum of element-wise products between row i of the matrix and the vector.", "level3_prompt": "Compute the matrix-vector multiplication of a 4096x4096 matrix and a 4096-element vector."}
{"id": 347, "task_name": "Matrix_Vector_Multiplication", "task_description": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mvA_14", "dtype": "float32", "shape": "(16384, 4096)"}, {"name": "mvv_14", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "mvy_cuda_14", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 14)   // 2^14 = 1024 rows\n#define K 4096        // vector length\n#define TOLERANCE 1e-5f\n\n__global__ void matvec_kernel(const float* A, const float* v, float* y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < K; ++j) {\n            sum += A[row * Q + j] * v[j];\n        }\n        y[row] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    std::string A_file = \"data/mvA_14.bin\";\n    std::string v_file = \"data/mvv_14.bin\";\n    std::string y_out_file = \"data/mvy_cuda_14.bin\";\n\n    size_t A_size = M * K;\n    size_t v_size = K;\n    size_t y_size = M;\n\n    float *h_A = new float[A_size];\n    float *h_v = new float[v_size];\n    float *h_y = new float[y_size];\n\n    read_binary(A_file, h_A, A_size);\n    read_binary(v_file, h_v, v_size);\n\n    float *d_A, *d_v, *d_y;\n    cudaMalloc(&d_A, A_size * sizeof(float));\n    cudaMalloc(&d_v, v_size * sizeof(float));\n    cudaMalloc(&d_y, y_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, A_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_v, h_v, v_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    matvec_kernel<<<blocks, threads_per_block>>>(d_A, d_v, d_y, M, K);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_y, d_y, y_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(y_out_file, h_y, y_size);\n\n    cudaFree(d_A);\n    cudaFree(d_v);\n    cudaFree(d_y);\n    delete[] h_A;\n    delete[] h_v;\n    delete[] h_y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nK = 4096\n\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(43)\n\nA = torch.randn(M, K, dtype=torch.float32)\nv = torch.randn(K, dtype=torch.float32)\ny = A @ v\n\nA.numpy().tofile(\"data/mvA_14.bin\")\nv.numpy().tofile(\"data/mvv_14.bin\")\ny.numpy().tofile(\"data/mvy_ref_14.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file(s): {output_file if not os.path.exists(output_file) else ''} {ref_file if not os.path.exists(ref_file) else ''}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        print(\"Shape mismatch:\", output.shape, reference.shape)\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**14  \n    K = 4096\n    total_size = M\n\n    out_file = \"data/mvy_cuda_14.bin\"  # CUDA result\n    ref_file = \"data/mvy_ref_14.bin\"  # Reference result from PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for matrix-vector multiplication. The input matrix has dimensions 16384x4096 with float32 data type, and the input vector has length 4096 with float32 data type. The output should be a vector of length 16384 with float32 data type, where each element is the dot product of a corresponding row from the matrix and the input vector. The kernel must accurately compute results within a tolerance of 1e-3 compared to reference implementations.", "level2_prompt": "Perform matrix-vector multiplication where a matrix of size M=16384 rows by K=4096 columns is multiplied by a vector of length K=4096. The output is a vector of length M=16384, where each element y[i] is computed as the sum of products between row i of the matrix and the input vector elements.", "level3_prompt": "Compute matrix-vector multiplication for a 16384x4096 matrix and a 4096-length vector to produce a 16384-length output vector."}
{"id": 348, "task_name": "Matrix_Vector_Multiplication", "task_description": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mvA_16", "dtype": "float32", "shape": "(65536, 4096)"}, {"name": "mvv_16", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "mvy_cuda_16", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 16)   // 2^16\n#define K 4096        // vector length\n#define TOLERANCE 1e-5f\n\n__global__ void matvec_kernel(const float* A, const float* v, float* y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < K; ++j) {\n            sum += A[row * Q + j] * v[j];\n        }\n        y[row] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    std::string A_file = \"data/mvA_16.bin\";\n    std::string v_file = \"data/mvv_16.bin\";\n    std::string y_out_file = \"data/mvy_cuda_16.bin\";\n\n    size_t A_size = M * K;\n    size_t v_size = K;\n    size_t y_size = M;\n\n    float *h_A = new float[A_size];\n    float *h_v = new float[v_size];\n    float *h_y = new float[y_size];\n\n    read_binary(A_file, h_A, A_size);\n    read_binary(v_file, h_v, v_size);\n\n    float *d_A, *d_v, *d_y;\n    cudaMalloc(&d_A, A_size * sizeof(float));\n    cudaMalloc(&d_v, v_size * sizeof(float));\n    cudaMalloc(&d_y, y_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, A_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_v, h_v, v_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    matvec_kernel<<<blocks, threads_per_block>>>(d_A, d_v, d_y, M, K);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_y, d_y, y_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(y_out_file, h_y, y_size);\n\n    cudaFree(d_A);\n    cudaFree(d_v);\n    cudaFree(d_y);\n    delete[] h_A;\n    delete[] h_v;\n    delete[] h_y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nK = 4096\n\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(43)\n\nA = torch.randn(M, K, dtype=torch.float32)\nv = torch.randn(K, dtype=torch.float32)\ny = A @ v\n\nA.numpy().tofile(\"data/mvA_16.bin\")\nv.numpy().tofile(\"data/mvv_16.bin\")\ny.numpy().tofile(\"data/mvy_ref_16.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file(s): {output_file if not os.path.exists(output_file) else ''} {ref_file if not os.path.exists(ref_file) else ''}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        print(\"Shape mismatch:\", output.shape, reference.shape)\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**16\n    K = 4096\n    total_size = M\n\n    out_file = \"data/mvy_cuda_16.bin\"  # CUDA result\n    ref_file = \"data/mvy_ref_16.bin\"  # Reference result from PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for matrix-vector multiplication. The input matrix 'mvA_16' has dimensions 65536x4096 and data type float32. The input vector 'mvv_16' has length 4096 and data type float32. The output vector 'mvy_cuda_16' must have length 65536 and data type float32. Each element of the output vector should be computed as the dot product of the corresponding row of the matrix with the input vector. The kernel must correctly handle the specified dimensions and ensure each output element corresponds to exactly one row of the input matrix.", "level2_prompt": "Perform matrix-vector multiplication where a matrix of size 65536x4096 is multiplied by a vector of length 4096 to produce an output vector of length 65536. For each output element at index i, compute the sum of products between elements of the i-th row of the matrix and the corresponding elements of the input vector.", "level3_prompt": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA."}
{"id": 349, "task_name": "Matrix_Vector_Multiplication", "task_description": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA.", "inputs": [{"name": "mvA_18", "dtype": "float32", "shape": "(262144, 4096)"}, {"name": "mvv_18", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "mvy_cuda_18", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define M (1 << 18)   // 2^18\n#define K 4096        // vector length\n#define TOLERANCE 1e-5f\n\n__global__ void matvec_kernel(const float* A, const float* v, float* y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < K; ++j) {\n            sum += A[row * Q + j] * v[j];\n        }\n        y[row] = sum;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    std::string A_file = \"data/mvA_18.bin\";\n    std::string v_file = \"data/mvv_18.bin\";\n    std::string y_out_file = \"data/mvy_cuda_18.bin\";\n\n    size_t A_size = M * K;\n    size_t v_size = K;\n    size_t y_size = M;\n\n    float *h_A = new float[A_size];\n    float *h_v = new float[v_size];\n    float *h_y = new float[y_size];\n\n    read_binary(A_file, h_A, A_size);\n    read_binary(v_file, h_v, v_size);\n\n    float *d_A, *d_v, *d_y;\n    cudaMalloc(&d_A, A_size * sizeof(float));\n    cudaMalloc(&d_v, v_size * sizeof(float));\n    cudaMalloc(&d_y, y_size * sizeof(float));\n\n    cudaMemcpy(d_A, h_A, A_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_v, h_v, v_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    matvec_kernel<<<blocks, threads_per_block>>>(d_A, d_v, d_y, M, K);\n    cudaDeviceSynchronize();\n\n    cudaMemcpy(h_y, d_y, y_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(y_out_file, h_y, y_size);\n\n    cudaFree(d_A);\n    cudaFree(d_v);\n    cudaFree(d_y);\n    delete[] h_A;\n    delete[] h_v;\n    delete[] h_y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nK = 4096\n\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(43)\n\nA = torch.randn(M, K, dtype=torch.float32)\nv = torch.randn(K, dtype=torch.float32)\ny = A @ v\n\nA.numpy().tofile(\"data/mvA_18.bin\")\nv.numpy().tofile(\"data/mvv_18.bin\")\ny.numpy().tofile(\"data/mvy_ref_18.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file(s): {output_file if not os.path.exists(output_file) else ''} {ref_file if not os.path.exists(ref_file) else ''}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        print(\"Shape mismatch:\", output.shape, reference.shape)\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**18\n    K = 4096\n    total_size = M\n\n    out_file = \"data/mvy_cuda_18.bin\"  # CUDA result\n    ref_file = \"data/mvy_ref_18.bin\"  # Reference result from PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Matrix_Vector_Multiplication task: Multiply a matrix by a vector to produce a vector. Input matrix A has shape (262144, 4096) and data type float32. Input vector v has shape (4096,) and data type float32. Output vector y must have shape (262144,) and data type float32. Each element y[i] is computed as the dot product of the i-th row of A with vector v. The kernel must handle matrices with 262144 rows and 4096 columns, where each output element depends solely on its corresponding row in A and the entire vector v.", "level2_prompt": "Matrix_Vector_Multiplication: For each row index i, compute the sum of element-wise products between row i of matrix A and vector v. The result for each row i forms element i of output vector y.", "level3_prompt": "Compute the Matrix_Vector_Multiplication kernel on GPU using CUDA."}
{"id": 350, "task_name": "Pairwise_Euclidean_Distance", "task_description": "Compute the Pairwise_Euclidean_Distance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define M (1 << 10) \n#define N 1024        // 1024 columns\n\n// CUDA kernel: compute row-wise L2 norm of (A - B)\n__global__ void rowwise_norm_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = A[row * Q + j] - B[row * Q + j];\n            sum += diff * diff;\n        }\n        Y[row] = sqrtf(sum);\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t sizeA = M * N;\n    size_t sizeB = M * N;\n    size_t sizeY = M;\n\n    // Host memory\n    float* h_A = new float[sizeA];\n    float* h_B = new float[sizeB];\n    float* h_Y = new float[sizeY];\n\n    // Load input data\n    read_binary(\"data/matA.bin\", h_A, sizeA);\n    read_binary(\"data/matB.bin\", h_B, sizeB);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, sizeA * sizeof(float));\n    cudaMalloc(&d_B, sizeB * sizeof(float));\n    cudaMalloc(&d_Y, sizeY * sizeof(float));\n\n    // Copy to device\n    cudaMemcpy(d_A, h_A, sizeA * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, sizeB * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Kernel launch\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    rowwise_norm_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy result back\n    cudaMemcpy(h_Y, d_Y, sizeY * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save output\n    write_binary(\"data/matC_cuda.bin\", h_Y, sizeY);\n\n    // Free memory\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nN = 1024\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Fixed random seed for reproducibility\ntorch.manual_seed(48)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\nY = torch.norm(A - B, dim=1)\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**10  # number of rows\n    total_size = M  # one norm value per row\n\n    out_file = \"data/matC_cuda.bin\"  # output from CUDA or C code\n    ref_file = \"data/matC_ref.bin\"  # reference generated by PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the pairwise Euclidean distance between corresponding rows of two matrices. The input matrices matA and matB are both float32 tensors with shape (1024, 1024). The output matC_cuda must be a float32 tensor of shape (1024,) where each element at index i represents the Euclidean distance between row i of matA and row i of matB. The computation must calculate the L2 norm for each row independently, summing squared differences element-wise and taking the square root.", "level2_prompt": "For each row index i, calculate the Euclidean distance between row i of matrix A and row i of matrix B. This involves computing the square root of the sum of squared differences between corresponding elements in the two rows.", "level3_prompt": "Compute the Pairwise Euclidean Distance between corresponding rows of two input matrices."}
{"id": 351, "task_name": "Pairwise_Euclidean_Distance", "task_description": "Compute the Pairwise_Euclidean_Distance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(4096, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define M (1 << 12) \n#define N 1024        // 1024 columns\n\n// CUDA kernel: compute row-wise L2 norm of (A - B)\n__global__ void rowwise_norm_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = A[row * Q + j] - B[row * Q + j];\n            sum += diff * diff;\n        }\n        Y[row] = sqrtf(sum);\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t sizeA = M * N;\n    size_t sizeB = M * N;\n    size_t sizeY = M;\n\n    // Host memory\n    float* h_A = new float[sizeA];\n    float* h_B = new float[sizeB];\n    float* h_Y = new float[sizeY];\n\n    // Load input data\n    read_binary(\"data/matA.bin\", h_A, sizeA);\n    read_binary(\"data/matB.bin\", h_B, sizeB);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, sizeA * sizeof(float));\n    cudaMalloc(&d_B, sizeB * sizeof(float));\n    cudaMalloc(&d_Y, sizeY * sizeof(float));\n\n    // Copy to device\n    cudaMemcpy(d_A, h_A, sizeA * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, sizeB * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Kernel launch\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    rowwise_norm_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy result back\n    cudaMemcpy(h_Y, d_Y, sizeY * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save output\n    write_binary(\"data/matC_cuda.bin\", h_Y, sizeY);\n\n    // Free memory\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nN = 1024\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Fixed random seed for reproducibility\ntorch.manual_seed(48)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\nY = torch.norm(A - B, dim=1)\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**12  # number of rows\n    total_size = M  # one norm value per row\n\n    out_file = \"data/matC_cuda.bin\"  # output from CUDA or C code\n    ref_file = \"data/matC_ref.bin\"  # reference generated by PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Pairwise_Euclidean_Distance' that computes the Euclidean distance between corresponding rows of two input matrices. The inputs are two float32 matrices (matA and matB) each with shape (4096, 1024). The output should be a float32 vector (matC_cuda) of length 4096, where each element represents the Euclidean distance between the corresponding rows of matA and matB. The kernel must process each row independently and compute the distance as the square root of the sum of squared element-wise differences between the two rows.", "level2_prompt": "Implement the 'Pairwise_Euclidean_Distance' kernel that calculates the Euclidean distance between corresponding rows of two matrices. For each row index i, compute the square root of the sum of squares of differences between elements in row i of matA and row i of matB.", "level3_prompt": "Compute the pairwise Euclidean distance between corresponding rows of two matrices."}
{"id": 352, "task_name": "Pairwise_Euclidean_Distance", "task_description": "Compute the Pairwise_Euclidean_Distance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(16384, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define M (1 << 14) \n#define N 1024        // 1024 columns\n\n// CUDA kernel: compute row-wise L2 norm of (A - B)\n__global__ void rowwise_norm_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < Q; ++j) {\n            float diff = A[row * N + j] - B[row * N + j];\n            sum += diff * diff;\n        }\n        Y[row] = sqrtf(sum);\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t sizeA = M * N;\n    size_t sizeB = M * N;\n    size_t sizeY = M;\n\n    // Host memory\n    float* h_A = new float[sizeA];\n    float* h_B = new float[sizeB];\n    float* h_Y = new float[sizeY];\n\n    // Load input data\n    read_binary(\"data/matA.bin\", h_A, sizeA);\n    read_binary(\"data/matB.bin\", h_B, sizeB);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, sizeA * sizeof(float));\n    cudaMalloc(&d_B, sizeB * sizeof(float));\n    cudaMalloc(&d_Y, sizeY * sizeof(float));\n\n    // Copy to device\n    cudaMemcpy(d_A, h_A, sizeA * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, sizeB * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Kernel launch\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    rowwise_norm_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy result back\n    cudaMemcpy(h_Y, d_Y, sizeY * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save output\n    write_binary(\"data/matC_cuda.bin\", h_Y, sizeY);\n\n    // Free memory\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nN = 1024\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Fixed random seed for reproducibility\ntorch.manual_seed(48)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\nY = torch.norm(A - B, dim=1)\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**14  # number of rows\n    total_size = M  # one norm value per row\n\n    out_file = \"data/matC_cuda.bin\"  # output from CUDA or C code\n    ref_file = \"data/matC_ref.bin\"  # reference generated by PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the pairwise Euclidean distance between corresponding rows of two matrices. The inputs are two matrices, matA and matB, each with 16384 rows and 1024 columns, of 32-bit floating point numbers. The output is a vector matC_cuda of length 16384, where each element is the Euclidean distance between the corresponding rows of matA and matB. The computation must be performed independently for each row and must handle the exact dimensions.", "level2_prompt": "For each row index i, compute the Euclidean distance between the i-th row of matA and the i-th row of matB. The Euclidean distance is the square root of the sum of the squares of the element-wise differences between the two rows.", "level3_prompt": "Compute the pairwise Euclidean distance between corresponding rows of two matrices."}
{"id": 353, "task_name": "Pairwise_Euclidean_Distance", "task_description": "Compute the Pairwise_Euclidean_Distance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(65536, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define M (1 << 16) \n#define N 1024        // 1024 columns\n\n// CUDA kernel: compute row-wise L2 norm of (A - B)\n__global__ void rowwise_norm_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < Q; ++j) {\n            float diff = A[row * N + j] - B[row * N + j];\n            sum += diff * diff;\n        }\n        Y[row] = sqrtf(sum);\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t sizeA = M * N;\n    size_t sizeB = M * N;\n    size_t sizeY = M;\n\n    // Host memory\n    float* h_A = new float[sizeA];\n    float* h_B = new float[sizeB];\n    float* h_Y = new float[sizeY];\n\n    // Load input data\n    read_binary(\"data/matA.bin\", h_A, sizeA);\n    read_binary(\"data/matB.bin\", h_B, sizeB);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, sizeA * sizeof(float));\n    cudaMalloc(&d_B, sizeB * sizeof(float));\n    cudaMalloc(&d_Y, sizeY * sizeof(float));\n\n    // Copy to device\n    cudaMemcpy(d_A, h_A, sizeA * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, sizeB * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Kernel launch\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    rowwise_norm_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy result back\n    cudaMemcpy(h_Y, d_Y, sizeY * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save output\n    write_binary(\"data/matC_cuda.bin\", h_Y, sizeY);\n\n    // Free memory\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nN = 1024\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Fixed random seed for reproducibility\ntorch.manual_seed(48)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\nY = torch.norm(A - B, dim=1)\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**16  # number of rows\n    total_size = M  # one norm value per row\n\n    out_file = \"data/matC_cuda.bin\"  # output from CUDA or C code\n    ref_file = \"data/matC_ref.bin\"  # reference generated by PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Pairwise_Euclidean_Distance that computes the Euclidean distance between corresponding rows of two input matrices. Inputs are two 2D tensors: matA and matB, each with shape (65536, 1024) and float32 data type. For each row index i, compute the Euclidean distance between matA[i] and matB[i], defined as the square root of the sum of squared differences for all elements in that row. The output is a 1D tensor named matC_cuda with shape (65536,) and float32 data type, where each element at index i contains the Euclidean distance between row i of matA and row i of matB. The kernel must compute one distance per row independently.", "level2_prompt": "Compute pairwise Euclidean distances for corresponding rows in two matrices. Given matrices A and B with dimensions P × Q, produce a vector Y of length P where each element Y[i] is the Euclidean distance between row A[i] and row B[i], calculated as sqrt(Σ_{j=0}^{Q-1} (A[i][j] - B[i][j])²).", "level3_prompt": "Compute the Pairwise_Euclidean_Distance kernel on GPU using CUDA."}
{"id": 354, "task_name": "Pairwise_Euclidean_Distance", "task_description": "Compute the Pairwise_Euclidean_Distance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 1024)"}, {"name": "matB", "dtype": "float32", "shape": "(262144, 1024)"}], "outputs": [{"name": "matC_cuda", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define M (1 << 18) \n#define N 1024        // 1024 columns\n\n// CUDA kernel: compute row-wise L2 norm of (A - B)\n__global__ void rowwise_norm_kernel(const float* A, const float* B, float* Y, int P, int Q) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < P) {\n        float sum = 0.0f;\n        for (int j = 0; j < Q; ++j) {\n            float diff = A[row * N + j] - B[row * N + j];\n            sum += diff * diff;\n        }\n        Y[row] = sqrtf(sum);\n    }\n}\n\n// Utility: read binary file\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\n// Utility: write binary file\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t sizeA = M * N;\n    size_t sizeB = M * N;\n    size_t sizeY = M;\n\n    // Host memory\n    float* h_A = new float[sizeA];\n    float* h_B = new float[sizeB];\n    float* h_Y = new float[sizeY];\n\n    // Load input data\n    read_binary(\"data/matA.bin\", h_A, sizeA);\n    read_binary(\"data/matB.bin\", h_B, sizeB);\n\n    // Device memory\n    float *d_A, *d_B, *d_Y;\n    cudaMalloc(&d_A, sizeA * sizeof(float));\n    cudaMalloc(&d_B, sizeB * sizeof(float));\n    cudaMalloc(&d_Y, sizeY * sizeof(float));\n\n    // Copy to device\n    cudaMemcpy(d_A, h_A, sizeA * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_B, h_B, sizeB * sizeof(float), cudaMemcpyHostToDevice);\n\n    // Kernel launch\n    int threads_per_block = 256;\n    int blocks = (M + threads_per_block - 1) / threads_per_block;\n\n    rowwise_norm_kernel<<<blocks, threads_per_block>>>(d_A, d_B, d_Y, M, N);\n    cudaDeviceSynchronize();\n\n    // Copy result back\n    cudaMemcpy(h_Y, d_Y, sizeY * sizeof(float), cudaMemcpyDeviceToHost);\n\n    // Save output\n    write_binary(\"data/matC_cuda.bin\", h_Y, sizeY);\n\n    // Free memory\n    cudaFree(d_A);\n    cudaFree(d_B);\n    cudaFree(d_Y);\n    delete[] h_A;\n    delete[] h_B;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nN = 1024\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Fixed random seed for reproducibility\ntorch.manual_seed(48)\n\n# Generate random matrices\nA = torch.randn(M, N, dtype=torch.float32)\nB = torch.randn(M, N, dtype=torch.float32)\nY = torch.norm(A - B, dim=1)\n\nA.numpy().tofile(\"data/matA.bin\")\nB.numpy().tofile(\"data/matB.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    \"\"\"Read binary float32 file and return a NumPy array.\"\"\"\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    \"\"\"Compare two arrays element-wise within a tolerance.\"\"\"\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    \n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M = 2**18  # number of rows\n    total_size = M  # one norm value per row\n\n    out_file = \"data/matC_cuda.bin\"  # output from CUDA or C code\n    ref_file = \"data/matC_ref.bin\"  # reference generated by PyTorch\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Pairwise_Euclidean_Distance' that computes Euclidean distances between corresponding rows of two matrices. The input matrices matA and matB are both float32 tensors with shape (262144, 1024). The output matC_cuda must be a float32 tensor of shape (262144,) where each element represents the Euclidean distance between the corresponding rows of matA and matB. The kernel must compute the distance as the square root of the sum of squared differences between elements in the same column position for each row pair.", "level2_prompt": "Create a CUDA kernel called 'Pairwise_Euclidean_Distance' that calculates the Euclidean distance for each corresponding row pair between two matrices. For each row index i, compute the square root of the sum of squared differences between elements at position (i,j) in both matrices across all columns j.", "level3_prompt": "Compute pairwise Euclidean distances between corresponding rows of two matrices."}
{"id": 355, "task_name": "FIR_Filtering", "task_description": "Compute the FIR_Filtering kernel on GPU using CUDA.", "inputs": [{"name": "signal_input", "dtype": "float32", "shape": "(65536,)"}, {"name": "filter_coeffs", "dtype": "float32", "shape": "(64,)"}], "outputs": [{"name": "signal_output", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define SIGNAL_LENGTH (1 << 16)  // 65536\n#define FILTER_LENGTH 64\n\n__global__ void fir_filter_kernel(const float* signal, const float* coeffs, float* output, int N, int M) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    float acc = 0.0f;\n    for (int k = 0; k < M; ++k) {\n        int s_idx = idx - k;\n        if (s_idx >= 0) {\n            acc += coeffs[k] * signal[s_idx];\n        }\n    }\n    output[idx] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int N = SIGNAL_LENGTH;\n    const int M = FILTER_LENGTH;\n    size_t signal_size = N;\n    size_t coeff_size = M;\n\n    float* h_signal = new float[signal_size];\n    float* h_coeffs = new float[coeff_size];\n    float* h_output = new float[signal_size];\n\n    std::string signal_file = \"./data/signal_input.bin\";\n    std::string coeff_file = \"./data/filter_coeffs.bin\";\n    read_binary(signal_file, h_signal, signal_size);\n    read_binary(coeff_file, h_coeffs, coeff_size);\n\n    float *d_signal, *d_coeffs, *d_output;\n    cudaMalloc(&d_signal, signal_size * sizeof(float));\n    cudaMalloc(&d_coeffs, coeff_size * sizeof(float));\n    cudaMalloc(&d_output, signal_size * sizeof(float));\n\n    cudaMemcpy(d_signal, h_signal, signal_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_coeffs, h_coeffs, coeff_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    fir_filter_kernel<<<blocks, threads>>>(d_signal, d_coeffs, d_output, N, M);\n\n    cudaMemcpy(h_output, d_output, signal_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/signal_output.bin\";\n    write_binary(out_file, h_output, signal_size);\n\n    cudaFree(d_signal);\n    cudaFree(d_coeffs);\n    cudaFree(d_output);\n    delete[] h_signal;\n    delete[] h_coeffs;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1 << 16\nM = 64\nseed = 42\n\n# ----------------------------\n# 1) CPU: design FIR low-pass (firwin-like)\n# ----------------------------\ndef firwin_lowpass(M: int, cutoff: float, window: str = \"hamming\") -> np.ndarray:\n    \"\"\"\n    cutoff: normalized to Nyquist (same style as firwin), e.g. 0.1\n    M: number of taps\n    \"\"\"\n    n = np.arange(M, dtype=np.float64)\n    # center\n    alpha = (M - 1) / 2.0\n    m = n - alpha\n\n    # ideal low-pass impulse response with normalized cutoff (to Nyquist)\n    # firwin uses sinc(2*fc*(n-alpha)); here fc=cutoff/2 in cycles/sample (Nyquist=0.5)\n    fc = cutoff / 2.0\n    h = 2.0 * fc * np.sinc(2.0 * fc * m)\n\n    if window.lower() == \"hamming\":\n        w = np.hamming(M)\n    elif window.lower() == \"hann\":\n        w = np.hanning(M)\n    else:\n        raise ValueError(f\"unsupported window: {window}\")\n\n    h = h * w\n    # common firwin normalization: unity gain at DC\n    h = h / np.sum(h)\n    return h.astype(np.float32)\n\ncoeffs = firwin_lowpass(M, cutoff=0.1, window=\"hamming\")  # float32\n\n# ----------------------------\n# 2) GPU: random signal + FIR via conv1d\n# ----------------------------\ntorch.manual_seed(seed)\ndevice = \"cuda:0\"\n\nsignal = torch.randn(N, device=device, dtype=torch.float32)\n\n# conv1d is correlation by default, so flip kernel to match convolution\nkernel = torch.from_numpy(coeffs).to(device=device, dtype=torch.float32).flip(0).view(1, 1, M)\n\n# input shape: (batch=1, channels=1, length=N)\nx = signal.view(1, 1, N)\n\n# \"full\" convolution length = N + M - 1\n# do it by padding (M-1) on both sides -> output length N + M - 1\ny_full = torch.nn.functional.conv1d(x, kernel, padding=M - 1)\n\n# take first N samples like your original code\noutput = y_full[0, 0, :N].contiguous()\n\n# ----------------------------\n# 3) save to bin (float32)\n# ----------------------------\nsignal_cpu = signal.detach().cpu().numpy().astype(np.float32)\noutput_cpu = output.detach().cpu().numpy().astype(np.float32)\n\nsignal_cpu.tofile(\"data/signal_input.bin\")\ncoeffs.astype(np.float32).tofile(\"data/filter_coeffs.bin\")\noutput_cpu.tofile(\"data/signal_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    # print(f\"Max abs diff: {max_diff:.6f}\")\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 16\n    out_file = \"./data/signal_output.bin\"\n    ref_file = \"./data/signal_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for FIR filtering. The input consists of a signal tensor with 65536 float32 elements and a filter coefficients tensor with 64 float32 elements. The output is a filtered signal tensor with 65536 float32 elements. For each output index i, compute the sum of the product between the filter coefficients and the corresponding input signal values starting from index i down to max(0, i-63). Boundary conditions must be handled such that indices below 0 are not accessed.", "level2_prompt": "Perform finite impulse response (FIR) filtering. For each output element at index i, calculate the dot product of the filter coefficient array and the input signal segment from index i to max(0, i - (filter_length-1)). The output length matches the input signal length (65536).", "level3_prompt": "Compute the FIR_Filtering kernel on GPU using CUDA."}
{"id": 356, "task_name": "FIR_Filtering", "task_description": "Compute the FIR_Filtering kernel on GPU using CUDA.", "inputs": [{"name": "signal_input", "dtype": "float32", "shape": "(131072,)"}, {"name": "filter_coeffs", "dtype": "float32", "shape": "(64,)"}], "outputs": [{"name": "signal_output", "dtype": "float32", "shape": "(131072,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define SIGNAL_LENGTH (1 << 17)\n#define FILTER_LENGTH 64\n\n__global__ void fir_filter_kernel(const float* signal, const float* coeffs, float* output, int N, int M) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    float acc = 0.0f;\n    for (int k = 0; k < M; ++k) {\n        int s_idx = idx - k;\n        if (s_idx >= 0) {\n            acc += coeffs[k] * signal[s_idx];\n        }\n    }\n    output[idx] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int N = SIGNAL_LENGTH;\n    const int M = FILTER_LENGTH;\n    size_t signal_size = N;\n    size_t coeff_size = M;\n\n    float* h_signal = new float[signal_size];\n    float* h_coeffs = new float[coeff_size];\n    float* h_output = new float[signal_size];\n\n    std::string signal_file = \"./data/signal_input.bin\";\n    std::string coeff_file = \"./data/filter_coeffs.bin\";\n    read_binary(signal_file, h_signal, signal_size);\n    read_binary(coeff_file, h_coeffs, coeff_size);\n\n    float *d_signal, *d_coeffs, *d_output;\n    cudaMalloc(&d_signal, signal_size * sizeof(float));\n    cudaMalloc(&d_coeffs, coeff_size * sizeof(float));\n    cudaMalloc(&d_output, signal_size * sizeof(float));\n\n    cudaMemcpy(d_signal, h_signal, signal_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_coeffs, h_coeffs, coeff_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    fir_filter_kernel<<<blocks, threads>>>(d_signal, d_coeffs, d_output, N, M);\n\n    cudaMemcpy(h_output, d_output, signal_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/signal_output.bin\";\n    write_binary(out_file, h_output, signal_size);\n\n    cudaFree(d_signal);\n    cudaFree(d_coeffs);\n    cudaFree(d_output);\n    delete[] h_signal;\n    delete[] h_coeffs;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1 << 17\nM = 64\nseed = 42\n\n# ----------------------------\n# 1) CPU: design FIR low-pass (firwin-like)\n# ----------------------------\ndef firwin_lowpass(M: int, cutoff: float, window: str = \"hamming\") -> np.ndarray:\n    \"\"\"\n    cutoff: normalized to Nyquist (same style as firwin), e.g. 0.1\n    M: number of taps\n    \"\"\"\n    n = np.arange(M, dtype=np.float64)\n    # center\n    alpha = (M - 1) / 2.0\n    m = n - alpha\n\n    # ideal low-pass impulse response with normalized cutoff (to Nyquist)\n    # firwin uses sinc(2*fc*(n-alpha)); here fc=cutoff/2 in cycles/sample (Nyquist=0.5)\n    fc = cutoff / 2.0\n    h = 2.0 * fc * np.sinc(2.0 * fc * m)\n\n    if window.lower() == \"hamming\":\n        w = np.hamming(M)\n    elif window.lower() == \"hann\":\n        w = np.hanning(M)\n    else:\n        raise ValueError(f\"unsupported window: {window}\")\n\n    h = h * w\n    # common firwin normalization: unity gain at DC\n    h = h / np.sum(h)\n    return h.astype(np.float32)\n\ncoeffs = firwin_lowpass(M, cutoff=0.1, window=\"hamming\")  # float32\n\n# ----------------------------\n# 2) GPU: random signal + FIR via conv1d\n# ----------------------------\ntorch.manual_seed(seed)\ndevice = \"cuda\"\n\nsignal = torch.randn(N, device=device, dtype=torch.float32)\n\n# conv1d is correlation by default, so flip kernel to match convolution\nkernel = torch.from_numpy(coeffs).to(device=device, dtype=torch.float32).flip(0).view(1, 1, M)\n\n# input shape: (batch=1, channels=1, length=N)\nx = signal.view(1, 1, N)\n\n# \"full\" convolution length = N + M - 1\n# do it by padding (M-1) on both sides -> output length N + M - 1\ny_full = torch.nn.functional.conv1d(x, kernel, padding=M - 1)\n\n# take first N samples like your original code\noutput = y_full[0, 0, :N].contiguous()\n\n# ----------------------------\n# 3) save to bin (float32)\n# ----------------------------\nsignal_cpu = signal.detach().cpu().numpy().astype(np.float32)\noutput_cpu = output.detach().cpu().numpy().astype(np.float32)\n\nsignal_cpu.tofile(\"data/signal_input.bin\")\ncoeffs.astype(np.float32).tofile(\"data/filter_coeffs.bin\")\noutput_cpu.tofile(\"data/signal_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    # print(f\"Max abs diff: {max_diff:.6f}\")\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 17\n    out_file = \"./data/signal_output.bin\"\n    ref_file = \"./data/signal_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a Finite Impulse Response (FIR) filter kernel named FIR_Filtering. The kernel should process an input signal tensor of 131072 float32 values using filter coefficients of 64 float32 values. Each output element at position i must be computed as the weighted sum of the current and previous input elements using the filter coefficients, with the constraint that only valid indices (i-k ≥ 0) are considered. The output should be a tensor of 131072 float32 values.", "level2_prompt": "FIR_Filtering computes a convolution where each output element y[i] is the sum of filter coefficients multiplied by shifted input signal elements: y[i] = ∑(coeff[k] * x[i-k]) for k=0 to M-1, where i-k must be non-negative. Input is a 131072-element vector, filter is 64 coefficients, and output matches input length.", "level3_prompt": "Compute the FIR_Filtering kernel on GPU using CUDA."}
{"id": 357, "task_name": "FIR_Filtering", "task_description": "Compute the FIR_Filtering kernel on GPU using CUDA.", "inputs": [{"name": "signal_input", "dtype": "float32", "shape": "(262144,)"}, {"name": "filter_coeffs", "dtype": "float32", "shape": "(64,)"}], "outputs": [{"name": "signal_output", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define SIGNAL_LENGTH (1 << 18)\n#define FILTER_LENGTH 64\n\n__global__ void fir_filter_kernel(const float* signal, const float* coeffs, float* output, int N, int M) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    float acc = 0.0f;\n    for (int k = 0; k < M; ++k) {\n        int s_idx = idx - k;\n        if (s_idx >= 0) {\n            acc += coeffs[k] * signal[s_idx];\n        }\n    }\n    output[idx] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int N = SIGNAL_LENGTH;\n    const int M = FILTER_LENGTH;\n    size_t signal_size = N;\n    size_t coeff_size = M;\n\n    float* h_signal = new float[signal_size];\n    float* h_coeffs = new float[coeff_size];\n    float* h_output = new float[signal_size];\n\n    std::string signal_file = \"./data/signal_input.bin\";\n    std::string coeff_file = \"./data/filter_coeffs.bin\";\n    read_binary(signal_file, h_signal, signal_size);\n    read_binary(coeff_file, h_coeffs, coeff_size);\n\n    float *d_signal, *d_coeffs, *d_output;\n    cudaMalloc(&d_signal, signal_size * sizeof(float));\n    cudaMalloc(&d_coeffs, coeff_size * sizeof(float));\n    cudaMalloc(&d_output, signal_size * sizeof(float));\n\n    cudaMemcpy(d_signal, h_signal, signal_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_coeffs, h_coeffs, coeff_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    fir_filter_kernel<<<blocks, threads>>>(d_signal, d_coeffs, d_output, N, M);\n\n    cudaMemcpy(h_output, d_output, signal_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/signal_output.bin\";\n    write_binary(out_file, h_output, signal_size);\n\n    cudaFree(d_signal);\n    cudaFree(d_coeffs);\n    cudaFree(d_output);\n    delete[] h_signal;\n    delete[] h_coeffs;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1 << 18\nM = 64\nseed = 42\n\n# ----------------------------\n# 1) CPU: design FIR low-pass (firwin-like)\n# ----------------------------\ndef firwin_lowpass(M: int, cutoff: float, window: str = \"hamming\") -> np.ndarray:\n    \"\"\"\n    cutoff: normalized to Nyquist (same style as firwin), e.g. 0.1\n    M: number of taps\n    \"\"\"\n    n = np.arange(M, dtype=np.float64)\n    # center\n    alpha = (M - 1) / 2.0\n    m = n - alpha\n\n    # ideal low-pass impulse response with normalized cutoff (to Nyquist)\n    # firwin uses sinc(2*fc*(n-alpha)); here fc=cutoff/2 in cycles/sample (Nyquist=0.5)\n    fc = cutoff / 2.0\n    h = 2.0 * fc * np.sinc(2.0 * fc * m)\n\n    if window.lower() == \"hamming\":\n        w = np.hamming(M)\n    elif window.lower() == \"hann\":\n        w = np.hanning(M)\n    else:\n        raise ValueError(f\"unsupported window: {window}\")\n\n    h = h * w\n    # common firwin normalization: unity gain at DC\n    h = h / np.sum(h)\n    return h.astype(np.float32)\n\ncoeffs = firwin_lowpass(M, cutoff=0.1, window=\"hamming\")  # float32\n\n# ----------------------------\n# 2) GPU: random signal + FIR via conv1d\n# ----------------------------\ntorch.manual_seed(seed)\ndevice = \"cuda\"\n\nsignal = torch.randn(N, device=device, dtype=torch.float32)\n\n# conv1d is correlation by default, so flip kernel to match convolution\nkernel = torch.from_numpy(coeffs).to(device=device, dtype=torch.float32).flip(0).view(1, 1, M)\n\n# input shape: (batch=1, channels=1, length=N)\nx = signal.view(1, 1, N)\n\n# \"full\" convolution length = N + M - 1\n# do it by padding (M-1) on both sides -> output length N + M - 1\ny_full = torch.nn.functional.conv1d(x, kernel, padding=M - 1)\n\n# take first N samples like your original code\noutput = y_full[0, 0, :N].contiguous()\n\n# ----------------------------\n# 3) save to bin (float32)\n# ----------------------------\nsignal_cpu = signal.detach().cpu().numpy().astype(np.float32)\noutput_cpu = output.detach().cpu().numpy().astype(np.float32)\n\nsignal_cpu.tofile(\"data/signal_input.bin\")\ncoeffs.astype(np.float32).tofile(\"data/filter_coeffs.bin\")\noutput_cpu.tofile(\"data/signal_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    # print(f\"Max abs diff: {max_diff:.6f}\")\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 18\n    out_file = \"./data/signal_output.bin\"\n    ref_file = \"./data/signal_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for FIR_Filtering. The kernel applies a finite impulse response (FIR) filter to an input signal using given filter coefficients. The input signal is a 1D float32 tensor of size 262144, and filter coefficients are a 1D float32 tensor of size 64. The output should be a 1D float32 tensor of size 262144. For each output index i, compute the sum of filter_coeffs[k] multiplied by signal_input[i-k] for k ranging from 0 to 63, but only when i-k is non-negative (i.e., valid indices).", "level2_prompt": "FIR_Filtering involves computing a convolution-like operation where each output element at index i is the dot product of the filter coefficients and a segment of the input signal starting from index i backwards for up to 63 samples. Mathematically: output[i] = ∑_{k=0}^{63} (filter_coeffs[k] × signal_input[i-k]) for all i where i-k ≥ 0.", "level3_prompt": "Compute the FIR_Filtering kernel on GPU using CUDA."}
{"id": 358, "task_name": "FIR_Filtering", "task_description": "Compute the FIR_Filtering kernel on GPU using CUDA.", "inputs": [{"name": "signal_input", "dtype": "float32", "shape": "(524288,)"}, {"name": "filter_coeffs", "dtype": "float32", "shape": "(64,)"}], "outputs": [{"name": "signal_output", "dtype": "float32", "shape": "(524288,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define SIGNAL_LENGTH (1 << 19)\n#define FILTER_LENGTH 64\n\n__global__ void fir_filter_kernel(const float* signal, const float* coeffs, float* output, int N, int M) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    float acc = 0.0f;\n    for (int k = 0; k < M; ++k) {\n        int s_idx = idx - k;\n        if (s_idx >= 0) {\n            acc += coeffs[k] * signal[s_idx];\n        }\n    }\n    output[idx] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int N = SIGNAL_LENGTH;\n    const int M = FILTER_LENGTH;\n    size_t signal_size = N;\n    size_t coeff_size = M;\n\n    float* h_signal = new float[signal_size];\n    float* h_coeffs = new float[coeff_size];\n    float* h_output = new float[signal_size];\n\n    std::string signal_file = \"./data/signal_input.bin\";\n    std::string coeff_file = \"./data/filter_coeffs.bin\";\n    read_binary(signal_file, h_signal, signal_size);\n    read_binary(coeff_file, h_coeffs, coeff_size);\n\n    float *d_signal, *d_coeffs, *d_output;\n    cudaMalloc(&d_signal, signal_size * sizeof(float));\n    cudaMalloc(&d_coeffs, coeff_size * sizeof(float));\n    cudaMalloc(&d_output, signal_size * sizeof(float));\n\n    cudaMemcpy(d_signal, h_signal, signal_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_coeffs, h_coeffs, coeff_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    fir_filter_kernel<<<blocks, threads>>>(d_signal, d_coeffs, d_output, N, M);\n\n    cudaMemcpy(h_output, d_output, signal_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/signal_output.bin\";\n    write_binary(out_file, h_output, signal_size);\n\n    cudaFree(d_signal);\n    cudaFree(d_coeffs);\n    cudaFree(d_output);\n    delete[] h_signal;\n    delete[] h_coeffs;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1 << 19\nM = 64\nseed = 42\n\n# ----------------------------\n# 1) CPU: design FIR low-pass (firwin-like)\n# ----------------------------\ndef firwin_lowpass(M: int, cutoff: float, window: str = \"hamming\") -> np.ndarray:\n    \"\"\"\n    cutoff: normalized to Nyquist (same style as firwin), e.g. 0.1\n    M: number of taps\n    \"\"\"\n    n = np.arange(M, dtype=np.float64)\n    # center\n    alpha = (M - 1) / 2.0\n    m = n - alpha\n\n    # ideal low-pass impulse response with normalized cutoff (to Nyquist)\n    # firwin uses sinc(2*fc*(n-alpha)); here fc=cutoff/2 in cycles/sample (Nyquist=0.5)\n    fc = cutoff / 2.0\n    h = 2.0 * fc * np.sinc(2.0 * fc * m)\n\n    if window.lower() == \"hamming\":\n        w = np.hamming(M)\n    elif window.lower() == \"hann\":\n        w = np.hanning(M)\n    else:\n        raise ValueError(f\"unsupported window: {window}\")\n\n    h = h * w\n    # common firwin normalization: unity gain at DC\n    h = h / np.sum(h)\n    return h.astype(np.float32)\n\ncoeffs = firwin_lowpass(M, cutoff=0.1, window=\"hamming\")  # float32\n\n# ----------------------------\n# 2) GPU: random signal + FIR via conv1d\n# ----------------------------\ntorch.manual_seed(seed)\ndevice = \"cuda\"\n\nsignal = torch.randn(N, device=device, dtype=torch.float32)\n\n# conv1d is correlation by default, so flip kernel to match convolution\nkernel = torch.from_numpy(coeffs).to(device=device, dtype=torch.float32).flip(0).view(1, 1, M)\n\n# input shape: (batch=1, channels=1, length=N)\nx = signal.view(1, 1, N)\n\n# \"full\" convolution length = N + M - 1\n# do it by padding (M-1) on both sides -> output length N + M - 1\ny_full = torch.nn.functional.conv1d(x, kernel, padding=M - 1)\n\n# take first N samples like your original code\noutput = y_full[0, 0, :N].contiguous()\n\n# ----------------------------\n# 3) save to bin (float32)\n# ----------------------------\nsignal_cpu = signal.detach().cpu().numpy().astype(np.float32)\noutput_cpu = output.detach().cpu().numpy().astype(np.float32)\n\nsignal_cpu.tofile(\"data/signal_input.bin\")\ncoeffs.astype(np.float32).tofile(\"data/filter_coeffs.bin\")\noutput_cpu.tofile(\"data/signal_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    # print(f\"Max abs diff: {max_diff:.6f}\")\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 19\n    out_file = \"./data/signal_output.bin\"\n    ref_file = \"./data/signal_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: FIR_Filtering. Implement a Finite Impulse Response (FIR) filter on an input signal using given filter coefficients. The input signal is a 1D array of 524288 float32 values. The filter coefficients are a 1D array of 64 float32 values. The output is a 1D array of 524288 float32 values representing the filtered signal. For each output index i, compute the sum of products between filter coefficients and signal values from index i down to i-63, but only for valid indices (i.e., ignore negative indices). The kernel must handle boundary conditions where fewer than 64 coefficients are used for the initial output indices.", "level2_prompt": "Task: FIR_Filtering. For each output position i, compute the discrete convolution of the filter coefficients with the input signal centered at i. Specifically, output[i] = sum_{k=0}^{63} (filter_coeffs[k] * signal_input[i-k]), but only when i-k >= 0. For positions where i-k is negative, omit those terms from the sum.", "level3_prompt": "Compute the FIR_Filtering kernel on GPU using CUDA."}
{"id": 359, "task_name": "FIR_Filtering", "task_description": "Compute the FIR_Filtering kernel on GPU using CUDA.", "inputs": [{"name": "signal_input", "dtype": "float32", "shape": "(1048576,)"}, {"name": "filter_coeffs", "dtype": "float32", "shape": "(64,)"}], "outputs": [{"name": "signal_output", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define SIGNAL_LENGTH (1 << 20)\n#define FILTER_LENGTH 64\n\n__global__ void fir_filter_kernel(const float* signal, const float* coeffs, float* output, int N, int M) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= N) return;\n\n    float acc = 0.0f;\n    for (int k = 0; k < M; ++k) {\n        int s_idx = idx - k;\n        if (s_idx >= 0) {\n            acc += coeffs[k] * signal[s_idx];\n        }\n    }\n    output[idx] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int N = SIGNAL_LENGTH;\n    const int M = FILTER_LENGTH;\n    size_t signal_size = N;\n    size_t coeff_size = M;\n\n    float* h_signal = new float[signal_size];\n    float* h_coeffs = new float[coeff_size];\n    float* h_output = new float[signal_size];\n\n    std::string signal_file = \"./data/signal_input.bin\";\n    std::string coeff_file = \"./data/filter_coeffs.bin\";\n    read_binary(signal_file, h_signal, signal_size);\n    read_binary(coeff_file, h_coeffs, coeff_size);\n\n    float *d_signal, *d_coeffs, *d_output;\n    cudaMalloc(&d_signal, signal_size * sizeof(float));\n    cudaMalloc(&d_coeffs, coeff_size * sizeof(float));\n    cudaMalloc(&d_output, signal_size * sizeof(float));\n\n    cudaMemcpy(d_signal, h_signal, signal_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_coeffs, h_coeffs, coeff_size * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    fir_filter_kernel<<<blocks, threads>>>(d_signal, d_coeffs, d_output, N, M);\n\n    cudaMemcpy(h_output, d_output, signal_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/signal_output.bin\";\n    write_binary(out_file, h_output, signal_size);\n\n    cudaFree(d_signal);\n    cudaFree(d_coeffs);\n    cudaFree(d_output);\n    delete[] h_signal;\n    delete[] h_coeffs;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1 << 20\nM = 64\nseed = 42\n\n# ----------------------------\n# 1) CPU: design FIR low-pass (firwin-like)\n# ----------------------------\ndef firwin_lowpass(M: int, cutoff: float, window: str = \"hamming\") -> np.ndarray:\n    \"\"\"\n    cutoff: normalized to Nyquist (same style as firwin), e.g. 0.1\n    M: number of taps\n    \"\"\"\n    n = np.arange(M, dtype=np.float64)\n    # center\n    alpha = (M - 1) / 2.0\n    m = n - alpha\n\n    # ideal low-pass impulse response with normalized cutoff (to Nyquist)\n    # firwin uses sinc(2*fc*(n-alpha)); here fc=cutoff/2 in cycles/sample (Nyquist=0.5)\n    fc = cutoff / 2.0\n    h = 2.0 * fc * np.sinc(2.0 * fc * m)\n\n    if window.lower() == \"hamming\":\n        w = np.hamming(M)\n    elif window.lower() == \"hann\":\n        w = np.hanning(M)\n    else:\n        raise ValueError(f\"unsupported window: {window}\")\n\n    h = h * w\n    # common firwin normalization: unity gain at DC\n    h = h / np.sum(h)\n    return h.astype(np.float32)\n\ncoeffs = firwin_lowpass(M, cutoff=0.1, window=\"hamming\")  # float32\n\n# ----------------------------\n# 2) GPU: random signal + FIR via conv1d\n# ----------------------------\ntorch.manual_seed(seed)\ndevice = \"cuda\"\n\nsignal = torch.randn(N, device=device, dtype=torch.float32)\n\n# conv1d is correlation by default, so flip kernel to match convolution\nkernel = torch.from_numpy(coeffs).to(device=device, dtype=torch.float32).flip(0).view(1, 1, M)\n\n# input shape: (batch=1, channels=1, length=N)\nx = signal.view(1, 1, N)\n\n# \"full\" convolution length = N + M - 1\n# do it by padding (M-1) on both sides -> output length N + M - 1\ny_full = torch.nn.functional.conv1d(x, kernel, padding=M - 1)\n\n# take first N samples like your original code\noutput = y_full[0, 0, :N].contiguous()\n\n# ----------------------------\n# 3) save to bin (float32)\n# ----------------------------\nsignal_cpu = signal.detach().cpu().numpy().astype(np.float32)\noutput_cpu = output.detach().cpu().numpy().astype(np.float32)\n\nsignal_cpu.tofile(\"data/signal_input.bin\")\ncoeffs.astype(np.float32).tofile(\"data/filter_coeffs.bin\")\noutput_cpu.tofile(\"data/signal_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    # print(f\"Max abs diff: {max_diff:.6f}\")\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 20\n    out_file = \"./data/signal_output.bin\"\n    ref_file = \"./data/signal_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "FIR_Filtering task: Implement a finite impulse response (FIR) filter kernel. The kernel should compute each output element as the weighted sum of the current and previous input samples using filter coefficients. Inputs are a 1D signal tensor with 1048576 float32 elements and a filter coefficient tensor with 64 float32 elements. Output is a 1D tensor with 1048576 float32 elements. For each output index i, compute the sum of filter_coeffs[j] * signal_input[i-j] for j from 0 to min(i,63), ensuring boundary handling when i < 63.", "level2_prompt": "FIR_Filtering task: For each output index i from 0 to 1048575, compute the dot product between the filter coefficients vector and the input signal segment spanning from index i (inclusive) backwards to max(0, i-63). The output element at position i is the sum of filter_coeffs[j] multiplied by signal_input[i-j] for all j where i-j >= 0.", "level3_prompt": "Compute the FIR_Filtering kernel on GPU using CUDA."}
{"id": 360, "task_name": "Rowwise_Maximum", "task_description": "Compute the Rowwise_Maximum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 10)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_max_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float max_val = -1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val > max_val) max_val = val;\n        }\n        Y[row] = max_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_max_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(47)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.max(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**10, 2048\n    total_size = M  # one max per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Rowwise_Maximum. Given a 2D input matrix 'matA' of shape (1024, 2048) with float32 elements, compute the maximum value for each row. The output 'matC_out' must be a vector of shape (1024,) with float32 elements, where each element represents the maximum value of the corresponding row in the input matrix. The kernel must process each row independently and handle the fixed dimensions correctly.", "level2_prompt": "Task: Rowwise_Maximum. For each row in the input matrix, identify the maximum value among all elements in that row and output it as a single value in the result vector.", "level3_prompt": "Compute the Rowwise_Maximum kernel on GPU using CUDA."}
{"id": 361, "task_name": "Rowwise_Maximum", "task_description": "Compute the Rowwise_Maximum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 12)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_max_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float max_val = -1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val > max_val) max_val = val;\n        }\n        Y[row] = max_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_max_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(47)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.max(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        print(f\"Shape mismatch: {output.shape} vs {reference.shape}\")\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**12, 2048\n    total_size = M  # one max per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Rowwise_Maximum. Compute the maximum value for each row in a 2D input matrix. The input is a float32 tensor of shape (4096, 2048). The output should be a float32 vector of length 4096, where each element represents the maximum value in the corresponding row of the input matrix. The kernel must process each row independently and handle all elements within a row to determine the maximum value.", "level2_prompt": "Task: Rowwise_Maximum. Given a 2D matrix with dimensions M×N, compute an output vector of length M where each element is the maximum value found in the corresponding row of the input matrix.", "level3_prompt": "Compute the Rowwise_Maximum kernel on GPU using CUDA."}
{"id": 362, "task_name": "Rowwise_Maximum", "task_description": "Compute the Rowwise_Maximum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 14)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_max_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float max_val = -1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val > max_val) max_val = val;\n        }\n        Y[row] = max_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_max_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(47)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.max(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**14, 2048\n    total_size = M  # one max per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the maximum value for each row in a 2D matrix. The input matrix 'matA' has dimensions 16384 rows by 2048 columns and is of type float32. The output 'matC_out' is a vector of 16384 float32 values, each being the maximum of the corresponding row. The kernel must process each row independently and the results must be accurate within a tolerance of 1e-5.", "level2_prompt": "For a given 2D matrix, compute the maximum value in each row, resulting in a vector of row maxima.", "level3_prompt": "Compute the maximum value of each row in a matrix."}
{"id": 363, "task_name": "Rowwise_Maximum", "task_description": "Compute the Rowwise_Maximum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 16)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_max_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float max_val = -1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val > max_val) max_val = val;\n        }\n        Y[row] = max_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_max_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(47)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.max(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**16, 2048\n    total_size = M  # one max per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Rowwise_Maximum that computes the maximum value for each row in a 2D input matrix. The input matrix 'matA' has dimensions 65536 rows by 2048 columns with float32 data type. The output 'matC_out' must be a 1D tensor of 65536 float32 elements, where each element represents the maximum value of its corresponding input row. Each row must be processed independently, and the kernel should handle the full matrix dimensions.", "level2_prompt": "Compute the Rowwise_Maximum kernel by finding the maximum value in each row of a 65536×2048 float32 matrix. For every row index i from 0 to 65535, iterate through all 2048 elements in that row, identify the maximum value, and store it in position i of the output vector.", "level3_prompt": "Compute the rowwise maximum of a matrix on GPU using CUDA."}
{"id": 364, "task_name": "Rowwise_Maximum", "task_description": "Compute the Rowwise_Maximum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 18)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_max_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float max_val = -1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val > max_val) max_val = val;\n        }\n        Y[row] = max_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_max_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(47)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.max(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**18, 2048\n    total_size = M  # one max per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Rowwise_Maximum CUDA kernel. The kernel should compute the maximum value in each row of a 2D input tensor named 'matA' with dimensions 262144 rows by 2048 columns, where all elements are 32-bit floating-point numbers. The output should be a 1D tensor named 'matC_out' with 262144 elements, containing the maximum value of each corresponding row. The kernel must process each row independently and ensure numerical accuracy within acceptable tolerance.", "level2_prompt": "Compute the maximum value per row for a matrix. Given a matrix with 262144 rows and 2048 columns, calculate the largest value in each individual row. The result should be a vector containing 262144 elements, where each element represents the maximum value of its corresponding row.", "level3_prompt": "Compute the Rowwise_Maximum kernel on GPU using CUDA."}
{"id": 365, "task_name": "Rowwise_Minimum", "task_description": "Compute the Rowwise_Minimum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 10)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_min_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float min_val = 1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val < min_val) min_val = val;\n        }\n        Y[row] = min_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_min_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(48)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.min(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**10, 2048\n    total_size = M  # one min per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Rowwise_Minimum. Given a 2D input tensor 'matA' of shape (1024, 2048) with float32 data type, compute the minimum value for each row. The output should be a 1D tensor 'matC_out' of shape (1024,) with float32 data type, where each element represents the minimum value of the corresponding row in the input. The kernel must process each row independently and handle the fixed dimensions (1024 rows and 2048 columns).", "level2_prompt": "Task: Rowwise_Minimum. For each row in the input matrix, find the minimum value among all elements in that row.", "level3_prompt": "Compute the Rowwise_Minimum kernel on GPU using CUDA."}
{"id": 366, "task_name": "Rowwise_Minimum", "task_description": "Compute the Rowwise_Minimum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 12)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_min_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float min_val = 1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val < min_val) min_val = val;\n        }\n        Y[row] = min_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_min_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(48)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.min(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**12, 2048\n    total_size = M  # one min per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Rowwise_Minimum that computes the minimum value for each row of a 2D input tensor. The input tensor matA has dimensions 4096 rows by 2048 columns with float32 data type. The output tensor matC_out must be a 1D vector of 4096 float32 elements, where each element corresponds to the minimum value in the respective row of matA. The kernel must handle exactly 4096 rows and 2048 columns, and preserve numerical precision within a tolerance of 1e-5.", "level2_prompt": "For each row in a 4096×2048 matrix, find the minimum value among all elements in that row and store it in a corresponding output vector position. The output should be a 4096-element vector where each element represents the row-wise minimum.", "level3_prompt": "Compute the Rowwise_Minimum kernel on GPU using CUDA."}
{"id": 367, "task_name": "Rowwise_Minimum", "task_description": "Compute the Rowwise_Minimum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 14)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_min_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float min_val = 1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val < min_val) min_val = val;\n        }\n        Y[row] = min_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_min_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(48)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.min(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**14, 2048\n    total_size = M  # one min per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Rowwise_Minimum that computes the minimum value for each row in a 2D input matrix. The input tensor 'matA' is a float32 matrix with dimensions 16384 rows by 2048 columns. The output tensor 'matC_out' must be a float32 vector with 16384 elements, where each element represents the minimum value of the corresponding row in the input matrix. The kernel must process each row independently and correctly handle all values within the matrix dimensions.", "level2_prompt": "Create a Rowwise_Minimum operation where for each row index i (0 ≤ i < 16384), the kernel finds the minimum value among all 2048 elements in that row. The result for row i is stored at position i in the output vector.", "level3_prompt": "Compute the minimum value of each row in a matrix."}
{"id": 368, "task_name": "Rowwise_Minimum", "task_description": "Compute the Rowwise_Minimum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 16)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_min_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float min_val = 1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val < min_val) min_val = val;\n        }\n        Y[row] = min_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_min_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(48)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.min(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**16, 2048\n    total_size = M  # one min per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Compute the row-wise minimum of a 2D matrix. The input is a tensor named 'matA' with 65536 rows and 2048 columns of type float32. The output is a tensor named 'matC_out' with 65536 elements of type float32, where each element is the minimum value of the corresponding row in the input matrix. The kernel must process each row independently to find the minimum value in that row.", "level2_prompt": "For each row in the input matrix, find the minimum value among all the elements in that row and store that minimum value in the corresponding position of the output vector.", "level3_prompt": "Compute the Rowwise_Minimum kernel on GPU using CUDA."}
{"id": 369, "task_name": "Rowwise_Minimum", "task_description": "Compute the Rowwise_Minimum kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 18)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_min_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float min_val = 1e30f;\n        for (int j = 0; j < N; ++j) {\n            float val = X[row * N + j];\n            if (val < min_val) min_val = val;\n        }\n        Y[row] = min_val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_min_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(48)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY, _ = X.min(dim=1)\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**18, 2048\n    total_size = M  # one min per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Rowwise_Minimum. Compute the minimum value for each row of a matrix. The input is a tensor named 'matA' with shape (262144, 2048) and data type float32. The output is a tensor named 'matC_out' with shape (262144,) and data type float32. Each element of the output must be the minimum value of the corresponding row in the input matrix. The computation for each row is independent.", "level2_prompt": "Task: Rowwise_Minimum. For each row in the input matrix, find the minimum value among the elements in that row and output that value in the corresponding position of the result vector.", "level3_prompt": "Compute the rowwise minimum of a matrix."}
{"id": 370, "task_name": "Rowwise_Variance", "task_description": "Compute the Rowwise_Variance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(1024, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 10)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_var_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float mean = 0.0f;\n        for (int j = 0; j < N; ++j)\n            mean += X[row * N + j];\n        mean /= N;\n\n        float var = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = X[row * N + j] - mean;\n            var += diff * diff;\n        }\n        Y[row] = var / N;  // unbiased=False\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_var_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**10\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(46)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY = X.var(dim=1, unbiased=False)  # row-wise variance\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**10, 2048\n    total_size = M  # one variance per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named Rowwise_Variance that computes the variance for each row of a 1024×2048 input matrix of 32-bit floats. The output should be a vector of 1024 elements where each element represents the population variance (unbiased=False) of its corresponding row. The kernel must correctly calculate the mean for each row first, then compute the average squared deviation from that mean.", "level2_prompt": "Create a Rowwise_Variance computation where for each row of the input matrix, you first compute the arithmetic mean of all elements in that row. Then, for each element in the row, calculate its deviation from the mean, square this deviation, and accumulate these squared values. Finally, divide the accumulated squared deviations by the number of elements in the row to produce the variance.", "level3_prompt": "Compute the row-wise variance of a matrix."}
{"id": 371, "task_name": "Rowwise_Variance", "task_description": "Compute the Rowwise_Variance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(4096, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 12)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_var_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float mean = 0.0f;\n        for (int j = 0; j < N; ++j)\n            mean += X[row * N + j];\n        mean /= N;\n\n        float var = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = X[row * N + j] - mean;\n            var += diff * diff;\n        }\n        Y[row] = var / N;  // unbiased=False\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_var_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**12\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(46)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY = X.var(dim=1, unbiased=False)  # row-wise variance\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**12, 2048\n    total_size = M  # one variance per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Rowwise_Variance CUDA kernel that computes the variance for each row of a 2D input matrix. The input is a float32 tensor named matA with shape (4096, 2048), representing a matrix of 4096 rows and 2048 columns. The output should be a float32 tensor named matC_out with shape (4096,), where each element corresponds to the variance of its respective row. The variance must be calculated using the biased estimator (dividing by N instead of N-1). Each row must be processed independently, and the kernel should respect the fixed input dimensions.", "level2_prompt": "Compute the variance for each row of a matrix. For every row, first calculate the mean of its elements. Then compute the average of squared differences between each element and this mean. The output is a vector containing one variance value per row.", "level3_prompt": "Compute the Rowwise_Variance kernel on GPU using CUDA."}
{"id": 372, "task_name": "Rowwise_Variance", "task_description": "Compute the Rowwise_Variance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(16384, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 14)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_var_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float mean = 0.0f;\n        for (int j = 0; j < N; ++j)\n            mean += X[row * N + j];\n        mean /= N;\n\n        float var = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = X[row * N + j] - mean;\n            var += diff * diff;\n        }\n        Y[row] = var / N;  // unbiased=False\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_var_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**14\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(46)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY = X.var(dim=1, unbiased=False)  # row-wise variance\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**14, 2048\n    total_size = M  # one variance per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel called Rowwise_Variance that computes the population variance for each row of a 2D input matrix. The input matrix 'matA' is a float32 tensor with dimensions (16384, 2048). The output 'matC_out' must be a float32 vector of length 16384, where each element represents the variance of the corresponding row. The variance calculation must first compute the mean of each row, then compute the average of squared differences from that mean, using the entire row length as the denominator (unbiased=False).", "level2_prompt": "Create a Rowwise_Variance kernel that calculates the population variance for each row in a matrix. For each row, compute the arithmetic mean of all elements. Then, for each element in the row, calculate the squared difference from the mean, sum these squared differences, and divide by the row length to obtain the variance.", "level3_prompt": "Compute the row-wise population variance of a matrix."}
{"id": 373, "task_name": "Rowwise_Variance", "task_description": "Compute the Rowwise_Variance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(65536, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 16)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_var_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float mean = 0.0f;\n        for (int j = 0; j < N; ++j)\n            mean += X[row * N + j];\n        mean /= N;\n\n        float var = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = X[row * N + j] - mean;\n            var += diff * diff;\n        }\n        Y[row] = var / N;  // unbiased=False\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_var_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**16\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(46)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY = X.var(dim=1, unbiased=False)  # row-wise variance\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**16, 2048\n    total_size = M  # one variance per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Rowwise_Variance' that computes the variance for each row in a 2D input tensor. The input tensor 'matA' has dimensions (65536, 2048) and contains float32 values. The output tensor 'matC_out' must be a 1D float32 tensor of size (65536,), where each element represents the variance of its corresponding row. The variance calculation must first compute the row mean, then sum the squared differences from this mean, and finally divide by the row length (2048) without bias correction.", "level2_prompt": "For the 'Rowwise_Variance' task, process a 65536×2048 float32 matrix to produce a 65536-element float32 vector. Each output element should be the variance of its corresponding input row, calculated as the average of squared differences from the row mean. Use the formula: variance = Σ((element - mean)²) / row_length.", "level3_prompt": "Compute the Rowwise_Variance kernel on GPU using CUDA."}
{"id": 374, "task_name": "Rowwise_Variance", "task_description": "Compute the Rowwise_Variance kernel on GPU using CUDA.", "inputs": [{"name": "matA", "dtype": "float32", "shape": "(262144, 2048)"}], "outputs": [{"name": "matC_out", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define M (1 << 18)\n#define N 2048\n#define TOLERANCE 1e-5f\n\n__global__ void rowwise_var_kernel(const float* X, float* Y) {\n    int row = blockIdx.x;\n    if (row < M) {\n        float mean = 0.0f;\n        for (int j = 0; j < N; ++j)\n            mean += X[row * N + j];\n        mean /= N;\n\n        float var = 0.0f;\n        for (int j = 0; j < N; ++j) {\n            float diff = X[row * N + j] - mean;\n            var += diff * diff;\n        }\n        Y[row] = var / N;  // unbiased=False\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t total_input = M * N;\n    size_t total_output = M;\n\n    float *h_X = new float[total_input];\n    float *h_Y = new float[total_output];\n\n    std::string input_file = \"./data/matA.bin\";\n    read_binary(input_file, h_X, total_input);\n\n    float *d_X, *d_Y;\n    cudaMalloc(&d_X, total_input * sizeof(float));\n    cudaMalloc(&d_Y, total_output * sizeof(float));\n    cudaMemcpy(d_X, h_X, total_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    rowwise_var_kernel<<<M, 1>>>(d_X, d_Y);\n    cudaMemcpy(h_Y, d_Y, total_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/matC_out.bin\";\n    write_binary(out_file, h_Y, total_output);\n\n    cudaFree(d_X);\n    cudaFree(d_Y);\n    delete[] h_X;\n    delete[] h_Y;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nM = 2**18\nN = 2048\nos.makedirs(\"data\", exist_ok=True)\n\ntorch.manual_seed(46)\n\nX = torch.randn(M, N, dtype=torch.float32)\nY = X.var(dim=1, unbiased=False)  # row-wise variance\n\nX.numpy().tofile(\"data/matA.bin\")\nY.numpy().tofile(\"data/matC_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    if not os.path.exists(filename):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n\n    if output.shape != reference.shape:\n        return False\n\n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n\n    if np.all(diff < tolerance):\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    M, N = 2**18, 2048\n    total_size = M  # one variance per row\n\n    out_file = \"data/matC_out.bin\"\n    ref_file = \"data/matC_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Rowwise_Variance' that computes the variance for each row of a 2D input matrix. The input is a float32 tensor with shape (262144, 2048). For each row, calculate the mean of its 2048 elements, then compute the average of squared differences from this mean (using biased variance calculation, i.e., dividing by N=2048). The output must be a float32 tensor with shape (262144,) containing one variance value per row. Ensure the kernel processes rows independently.", "level2_prompt": "Compute row-wise variance for a matrix. For each row, first calculate the mean of all elements in the row. Then compute the variance by averaging the squares of differences between each element and the row mean. The output should be a vector containing one variance value per row.", "level3_prompt": "Compute the Rowwise_Variance kernel on GPU using CUDA."}
{"id": 375, "task_name": "Color_Conversion", "task_description": "Compute the Color_Conversion kernel on GPU using CUDA.", "inputs": [{"name": "rgb_input", "dtype": "float32", "shape": "(256, 256, 3)"}], "outputs": [{"name": "gray_output", "dtype": "float32", "shape": "(256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 256\n#define WIDTH 256\n#define CHANNELS 3  // RGB channels\n\n__global__ void rgb_to_gray_kernel(const float* rgb, float* gray, int height, int width) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (h < height && w < width) {\n        int idx = (h * width + w) * CHANNELS;\n        float r = rgb[idx + 0];\n        float g = rgb[idx + 1];\n        float b = rgb[idx + 2];\n        // Standard luminance formula\n        gray[h * width + w] = 0.299f * r + 0.587f * g + 0.114f * b;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n\n    size_t size_rgb = H * W * C;\n    size_t size_gray = H * W;\n\n    float* h_rgb = new float[size_rgb];\n    float* h_gray = new float[size_gray];\n\n    std::string input_file = \"./data/rgb_input.bin\";\n    read_binary(input_file, h_rgb, size_rgb);\n\n    float *d_rgb, *d_gray;\n    cudaMalloc(&d_rgb, size_rgb * sizeof(float));\n    cudaMalloc(&d_gray, size_gray * sizeof(float));\n\n    cudaMemcpy(d_rgb, h_rgb, size_rgb * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    rgb_to_gray_kernel<<<grid, block>>>(d_rgb, d_gray, H, W);\n\n    cudaMemcpy(h_gray, d_gray, size_gray * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/gray_output.bin\";\n    write_binary(out_file, h_gray, size_gray);\n\n    cudaFree(d_rgb);\n    cudaFree(d_gray);\n    delete[] h_rgb;\n    delete[] h_gray;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 256, 256, 3\nseed = 42\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random RGB image tensor (H, W, C)\nimg_rgb = torch.rand(H, W, C, dtype=torch.float32)\n\n# Convert to grayscale using standard luminance formula\nr, g, b = img_rgb[..., 0], img_rgb[..., 1], img_rgb[..., 2]\nimg_gray = 0.299 * r + 0.587 * g + 0.114 * b\n\n# Save binary files\nimg_rgb.numpy().astype(\"float32\").tofile(\"data/rgb_input.bin\")\nimg_gray.numpy().astype(\"float32\").tofile(\"data/gray_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 256, 256, 3\n    size_gray = H * W\n\n    out_file = \"./data/gray_output.bin\"\n    ref_file = \"./data/gray_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_gray):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Color_Conversion task: Convert an RGB image to grayscale using the standard luminance formula. Input is a 256x256x3 float32 tensor representing RGB values. Output must be a 256x256 float32 tensor containing grayscale values. The conversion must use fixed weights: 0.299 for red, 0.587 for green, and 0.114 for blue. Each output pixel must be computed independently from its corresponding RGB input pixel.", "level2_prompt": "Color_Conversion task: For each pixel in a 256x256 RGB image, compute its grayscale value as a weighted sum of its red, green, and blue channels using weights 0.299, 0.587, and 0.114 respectively. Input has shape (256,256,3), output has shape (256,256).", "level3_prompt": "Compute the Color_Conversion kernel to convert RGB image to grayscale."}
{"id": 376, "task_name": "Color_Conversion", "task_description": "Compute the Color_Conversion kernel on GPU using CUDA.", "inputs": [{"name": "rgb_input", "dtype": "float32", "shape": "(512, 512, 3)"}], "outputs": [{"name": "gray_output", "dtype": "float32", "shape": "(262144,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 512\n#define WIDTH 512\n#define CHANNELS 3  // RGB channels\n\n__global__ void rgb_to_gray_kernel(const float* rgb, float* gray, int height, int width) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (h < height && w < width) {\n        int idx = (h * width + w) * CHANNELS;\n        float r = rgb[idx + 0];\n        float g = rgb[idx + 1];\n        float b = rgb[idx + 2];\n        // Standard luminance formula\n        gray[h * width + w] = 0.299f * r + 0.587f * g + 0.114f * b;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n\n    size_t size_rgb = H * W * C;\n    size_t size_gray = H * W;\n\n    float* h_rgb = new float[size_rgb];\n    float* h_gray = new float[size_gray];\n\n    std::string input_file = \"./data/rgb_input.bin\";\n    read_binary(input_file, h_rgb, size_rgb);\n\n    float *d_rgb, *d_gray;\n    cudaMalloc(&d_rgb, size_rgb * sizeof(float));\n    cudaMalloc(&d_gray, size_gray * sizeof(float));\n\n    cudaMemcpy(d_rgb, h_rgb, size_rgb * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    rgb_to_gray_kernel<<<grid, block>>>(d_rgb, d_gray, H, W);\n\n    cudaMemcpy(h_gray, d_gray, size_gray * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/gray_output.bin\";\n    write_binary(out_file, h_gray, size_gray);\n\n    cudaFree(d_rgb);\n    cudaFree(d_gray);\n    delete[] h_rgb;\n    delete[] h_gray;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 512, 512, 3\nseed = 42\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random RGB image tensor (H, W, C)\nimg_rgb = torch.rand(H, W, C, dtype=torch.float32)\n\n# Convert to grayscale using standard luminance formula\nr, g, b = img_rgb[..., 0], img_rgb[..., 1], img_rgb[..., 2]\nimg_gray = 0.299 * r + 0.587 * g + 0.114 * b\n\n# Save binary files\nimg_rgb.numpy().astype(\"float32\").tofile(\"data/rgb_input.bin\")\nimg_gray.numpy().astype(\"float32\").tofile(\"data/gray_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 512, 512, 3\n    size_gray = H * W\n\n    out_file = \"./data/gray_output.bin\"\n    ref_file = \"./data/gray_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_gray):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Color_Conversion. Convert an RGB image to a grayscale image. The input is a 3D tensor of shape (512, 512, 3) and data type float32, representing an RGB image. The output is a 1D tensor of shape (262144,) and data type float32, which is the flattened grayscale image. The conversion must use the standard luminance formula: 0.299 * red + 0.587 * green + 0.114 * blue for each pixel. Each output pixel is computed independently from the corresponding input pixel.", "level2_prompt": "Task: Color_Conversion. For each pixel in the input RGB image, compute a grayscale value by the weighted sum: 0.299 * red + 0.587 * green + 0.114 * blue. The output is a single-channel image with the same height and width as the input.", "level3_prompt": "Convert RGB image to grayscale."}
{"id": 377, "task_name": "Color_Conversion", "task_description": "Compute the Color_Conversion kernel on GPU using CUDA.", "inputs": [{"name": "rgb_input", "dtype": "float32", "shape": "(1024, 1024, 3)"}], "outputs": [{"name": "gray_output", "dtype": "float32", "shape": "(1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 1024\n#define WIDTH 1024\n#define CHANNELS 3  // RGB channels\n\n__global__ void rgb_to_gray_kernel(const float* rgb, float* gray, int height, int width) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (h < height && w < width) {\n        int idx = (h * width + w) * CHANNELS;\n        float r = rgb[idx + 0];\n        float g = rgb[idx + 1];\n        float b = rgb[idx + 2];\n        // Standard luminance formula\n        gray[h * width + w] = 0.299f * r + 0.587f * g + 0.114f * b;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n\n    size_t size_rgb = H * W * C;\n    size_t size_gray = H * W;\n\n    float* h_rgb = new float[size_rgb];\n    float* h_gray = new float[size_gray];\n\n    std::string input_file = \"./data/rgb_input.bin\";\n    read_binary(input_file, h_rgb, size_rgb);\n\n    float *d_rgb, *d_gray;\n    cudaMalloc(&d_rgb, size_rgb * sizeof(float));\n    cudaMalloc(&d_gray, size_gray * sizeof(float));\n\n    cudaMemcpy(d_rgb, h_rgb, size_rgb * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    rgb_to_gray_kernel<<<grid, block>>>(d_rgb, d_gray, H, W);\n\n    cudaMemcpy(h_gray, d_gray, size_gray * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/gray_output.bin\";\n    write_binary(out_file, h_gray, size_gray);\n\n    cudaFree(d_rgb);\n    cudaFree(d_gray);\n    delete[] h_rgb;\n    delete[] h_gray;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 1024, 1024, 3\nseed = 42\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random RGB image tensor (H, W, C)\nimg_rgb = torch.rand(H, W, C, dtype=torch.float32)\n\n# Convert to grayscale using standard luminance formula\nr, g, b = img_rgb[..., 0], img_rgb[..., 1], img_rgb[..., 2]\nimg_gray = 0.299 * r + 0.587 * g + 0.114 * b\n\n# Save binary files\nimg_rgb.numpy().astype(\"float32\").tofile(\"data/rgb_input.bin\")\nimg_gray.numpy().astype(\"float32\").tofile(\"data/gray_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 1024, 1024, 3\n    size_gray = H * W\n\n    out_file = \"./data/gray_output.bin\"\n    ref_file = \"./data/gray_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_gray):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Color_Conversion. Convert an input RGB image to a grayscale image. The input is a 3D tensor of shape (1024, 1024, 3) with float32 values representing red, green, and blue channels. The output is a 2D tensor of shape (1024, 1024) with float32 values. Each output pixel must be computed using the formula: grayscale = 0.299 * red + 0.587 * green + 0.114 * blue. The kernel must process each pixel independently.", "level2_prompt": "Task: Color_Conversion. For each pixel in a 1024x1024 RGB image, compute a single grayscale value by applying the luminance formula: weighted sum of red (0.299), green (0.587), and blue (0.114) channels.", "level3_prompt": "Compute the Color_Conversion kernel on GPU using CUDA."}
{"id": 378, "task_name": "Color_Conversion", "task_description": "Compute the Color_Conversion kernel on GPU using CUDA.", "inputs": [{"name": "rgb_input", "dtype": "float32", "shape": "(2048, 2048, 3)"}], "outputs": [{"name": "gray_output", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 2048\n#define WIDTH 2048\n#define CHANNELS 3  // RGB channels\n\n__global__ void rgb_to_gray_kernel(const float* rgb, float* gray, int height, int width) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (h < height && w < width) {\n        int idx = (h * width + w) * CHANNELS;\n        float r = rgb[idx + 0];\n        float g = rgb[idx + 1];\n        float b = rgb[idx + 2];\n        // Standard luminance formula\n        gray[h * width + w] = 0.299f * r + 0.587f * g + 0.114f * b;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n\n    size_t size_rgb = H * W * C;\n    size_t size_gray = H * W;\n\n    float* h_rgb = new float[size_rgb];\n    float* h_gray = new float[size_gray];\n\n    std::string input_file = \"./data/rgb_input.bin\";\n    read_binary(input_file, h_rgb, size_rgb);\n\n    float *d_rgb, *d_gray;\n    cudaMalloc(&d_rgb, size_rgb * sizeof(float));\n    cudaMalloc(&d_gray, size_gray * sizeof(float));\n\n    cudaMemcpy(d_rgb, h_rgb, size_rgb * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    rgb_to_gray_kernel<<<grid, block>>>(d_rgb, d_gray, H, W);\n\n    cudaMemcpy(h_gray, d_gray, size_gray * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/gray_output.bin\";\n    write_binary(out_file, h_gray, size_gray);\n\n    cudaFree(d_rgb);\n    cudaFree(d_gray);\n    delete[] h_rgb;\n    delete[] h_gray;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 2048, 2048, 3\nseed = 42\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random RGB image tensor (H, W, C)\nimg_rgb = torch.rand(H, W, C, dtype=torch.float32)\n\n# Convert to grayscale using standard luminance formula\nr, g, b = img_rgb[..., 0], img_rgb[..., 1], img_rgb[..., 2]\nimg_gray = 0.299 * r + 0.587 * g + 0.114 * b\n\n# Save binary files\nimg_rgb.numpy().astype(\"float32\").tofile(\"data/rgb_input.bin\")\nimg_gray.numpy().astype(\"float32\").tofile(\"data/gray_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 2048, 2048, 3\n    size_gray = H * W\n\n    out_file = \"./data/gray_output.bin\"\n    ref_file = \"./data/gray_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_gray):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Color_Conversion. Convert an RGB image to grayscale using a specific luminance formula. The input is a 2048x2048 image with 3 color channels (red, green, blue) as float32 values. The output should be a single-channel 2048x2048 grayscale image flattened into a 4194304-element float32 tensor. The conversion must use the weights: red channel multiplied by 0.299, green by 0.587, and blue by 0.114. Ensure the kernel handles all pixels within the image boundaries.", "level2_prompt": "Task: Color_Conversion. For each pixel in a 2048x2048 RGB image, compute a grayscale value using the formula: 0.299 × red + 0.587 × green + 0.114 × blue. The output should be a single-value per pixel in a flattened 2048x2048 output tensor.", "level3_prompt": "Convert an RGB image to grayscale."}
{"id": 379, "task_name": "Color_Conversion", "task_description": "Compute the Color_Conversion kernel on GPU using CUDA.", "inputs": [{"name": "rgb_input", "dtype": "float32", "shape": "(4096, 4096, 3)"}], "outputs": [{"name": "gray_output", "dtype": "float32", "shape": "(4096, 4096)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 4096\n#define WIDTH 4096\n#define CHANNELS 3  // RGB channels\n\n__global__ void rgb_to_gray_kernel(const float* rgb, float* gray, int height, int width) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (h < height && w < width) {\n        int idx = (h * width + w) * CHANNELS;\n        float r = rgb[idx + 0];\n        float g = rgb[idx + 1];\n        float b = rgb[idx + 2];\n        // Standard luminance formula\n        gray[h * width + w] = 0.299f * r + 0.587f * g + 0.114f * b;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n\n    size_t size_rgb = H * W * C;\n    size_t size_gray = H * W;\n\n    float* h_rgb = new float[size_rgb];\n    float* h_gray = new float[size_gray];\n\n    std::string input_file = \"./data/rgb_input.bin\";\n    read_binary(input_file, h_rgb, size_rgb);\n\n    float *d_rgb, *d_gray;\n    cudaMalloc(&d_rgb, size_rgb * sizeof(float));\n    cudaMalloc(&d_gray, size_gray * sizeof(float));\n\n    cudaMemcpy(d_rgb, h_rgb, size_rgb * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    rgb_to_gray_kernel<<<grid, block>>>(d_rgb, d_gray, H, W);\n\n    cudaMemcpy(h_gray, d_gray, size_gray * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/gray_output.bin\";\n    write_binary(out_file, h_gray, size_gray);\n\n    cudaFree(d_rgb);\n    cudaFree(d_gray);\n    delete[] h_rgb;\n    delete[] h_gray;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 4096, 4096, 3\nseed = 42\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random RGB image tensor (H, W, C)\nimg_rgb = torch.rand(H, W, C, dtype=torch.float32)\n\n# Convert to grayscale using standard luminance formula\nr, g, b = img_rgb[..., 0], img_rgb[..., 1], img_rgb[..., 2]\nimg_gray = 0.299 * r + 0.587 * g + 0.114 * b\n\n# Save binary files\nimg_rgb.numpy().astype(\"float32\").tofile(\"data/rgb_input.bin\")\nimg_gray.numpy().astype(\"float32\").tofile(\"data/gray_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 4096, 4096, 3\n    size_gray = H * W\n\n    out_file = \"./data/gray_output.bin\"\n    ref_file = \"./data/gray_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size_gray):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Color_Conversion. Convert an RGB image to grayscale using a standard luminance formula. The input is a 3D tensor of shape (4096, 4096, 3) with float32 values representing the RGB channels. The output must be a 2D tensor of shape (4096, 4096) with float32 values representing the grayscale result. The conversion must use fixed weights: red channel multiplied by 0.299, green by 0.587, and blue by 0.114.", "level2_prompt": "Task: Color_Conversion. For each pixel in the input image, compute a single grayscale value by taking the weighted sum of its red, green, and blue components using the coefficients 0.299, 0.587, and 0.114 respectively.", "level3_prompt": "Convert RGB image to grayscale using standard luminance weights."}
{"id": 380, "task_name": "Mean_Square_Error", "task_description": "Compute the Mean_Square_Error kernel on GPU using CUDA.", "inputs": [{"name": "mse_preds", "dtype": "float32", "shape": "(1024,)"}, {"name": "mse_targets", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "mse_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n__global__ void mseKernel(const float* predictions, const float* targets, size_t numElements, float* sum) {\n    size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < numElements) {\n        float diff = predictions[idx] - targets[idx];\n        float sq_diff = diff * diff;\n        atomicAdd(sum, sq_diff);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t N = 1 << 10;\n    size_t input_size = N * sizeof(float);\n\n    std::string pred_file = \"data/mse_preds.bin\";\n    std::string target_file = \"data/mse_targets.bin\";\n\n    float* h_preds = (float*)malloc(input_size);\n    float* h_targets = (float*)malloc(input_size);\n\n    read_binary(pred_file, h_preds, N);\n    read_binary(target_file, h_targets, N);\n\n    float *d_preds, *d_targets, *d_sum;\n    cudaMalloc(&d_preds, input_size);\n    cudaMalloc(&d_targets, input_size);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_preds, h_preds, input_size, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_targets, h_targets, input_size, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    mseKernel<<<blocks, threads>>>(d_preds, d_targets, N, d_sum);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n    float mse = h_sum / N;\n\n    // 写结果\n    write_binary(\"data/mse_out.bin\", &mse, 1);\n\n    cudaFree(d_preds);\n    cudaFree(d_targets);\n    cudaFree(d_sum);\n    free(h_preds);\n    free(h_targets);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nN = 1 << 10\nnp.random.seed(49)\n\npreds = (np.random.randn(N) * 10).astype(np.float32)\ntargets = (np.random.randn(N) * 10).astype(np.float32)\nmse = np.mean((preds - targets) ** 2).astype(np.float32)\n\nos.makedirs(\"data\", exist_ok=True)\npreds.tofile(\"data/mse_preds.bin\")\ntargets.tofile(\"data/mse_targets.bin\")\nnp.array([mse], dtype=np.float32).tofile(\"data/mse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_scalar(output_file, ref_file, tol=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, 1)[0]\n    ref = read_binary(ref_file, 1)[0]\n    return abs(out - ref) < tol\n\nif __name__ == \"__main__\":\n    out_file = \"data/mse_out.bin\"\n    ref_file = \"data/mse_ref.bin\"\n\n    if compare_scalar(out_file, ref_file):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Mean_Square_Error. Compute the mean squared error between two input vectors. The inputs are two vectors, each with 1024 elements of type float32, representing predictions and targets. The output is a single scalar of type float32, which is the average of the squared differences between corresponding elements. The vectors must be of the same length, and the computation must sum all squared differences before dividing by the number of elements.", "level2_prompt": "Task: Mean_Square_Error. The algorithm involves calculating the mean squared error as the sum of the squared differences between each pair of corresponding elements in the predictions and targets vectors, divided by the total number of elements (1024).", "level3_prompt": "Compute the mean squared error."}
{"id": 381, "task_name": "Mean_Square_Error", "task_description": "Compute the Mean_Square_Error kernel on GPU using CUDA.", "inputs": [{"name": "mse_preds", "dtype": "float32", "shape": "(4096,)"}, {"name": "mse_targets", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "mse_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n__global__ void mseKernel(const float* predictions, const float* targets, size_t numElements, float* sum) {\n    size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < numElements) {\n        float diff = predictions[idx] - targets[idx];\n        float sq_diff = diff * diff;\n        atomicAdd(sum, sq_diff);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t N = 1 << 12;\n    size_t input_size = N * sizeof(float);\n\n    std::string pred_file = \"data/mse_preds.bin\";\n    std::string target_file = \"data/mse_targets.bin\";\n\n    float* h_preds = (float*)malloc(input_size);\n    float* h_targets = (float*)malloc(input_size);\n\n    read_binary(pred_file, h_preds, N);\n    read_binary(target_file, h_targets, N);\n\n    float *d_preds, *d_targets, *d_sum;\n    cudaMalloc(&d_preds, input_size);\n    cudaMalloc(&d_targets, input_size);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_preds, h_preds, input_size, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_targets, h_targets, input_size, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    mseKernel<<<blocks, threads>>>(d_preds, d_targets, N, d_sum);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n    float mse = h_sum / N;\n\n    // 写结果\n    write_binary(\"data/mse_out.bin\", &mse, 1);\n\n    cudaFree(d_preds);\n    cudaFree(d_targets);\n    cudaFree(d_sum);\n    free(h_preds);\n    free(h_targets);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nN = 1 << 12\nnp.random.seed(49)\n\npreds = (np.random.randn(N) * 10).astype(np.float32)\ntargets = (np.random.randn(N) * 10).astype(np.float32)\nmse = np.mean((preds - targets) ** 2).astype(np.float32)\n\nos.makedirs(\"data\", exist_ok=True)\npreds.tofile(\"data/mse_preds.bin\")\ntargets.tofile(\"data/mse_targets.bin\")\nnp.array([mse], dtype=np.float32).tofile(\"data/mse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_scalar(output_file, ref_file, tol=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, 1)[0]\n    ref = read_binary(ref_file, 1)[0]\n    return abs(out - ref) < tol\n\nif __name__ == \"__main__\":\n    out_file = \"data/mse_out.bin\"\n    ref_file = \"data/mse_ref.bin\"\n\n    if compare_scalar(out_file, ref_file):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Mean_Square_Error. Compute the mean squared error between two input vectors. Inputs are two float32 vectors of shape (4096,): predictions and targets. Output is a single float32 scalar representing the average of squared element-wise differences. The kernel must calculate the sum of squared differences across all elements and divide by the total number of elements (4096).", "level2_prompt": "Task: Mean_Square_Error. Compute the average of squared differences between corresponding elements in two input vectors. For each element position, calculate the difference between prediction and target, square it, accumulate these values, and divide the total sum by the vector length.", "level3_prompt": "Compute the Mean_Square_Error kernel on GPU using CUDA."}
{"id": 382, "task_name": "Mean_Square_Error", "task_description": "Compute the Mean_Square_Error kernel on GPU using CUDA.", "inputs": [{"name": "mse_preds", "dtype": "float32", "shape": "(16384,)"}, {"name": "mse_targets", "dtype": "float32", "shape": "(16384,)"}], "outputs": [{"name": "mse_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n__global__ void mseKernel(const float* predictions, const float* targets, size_t numElements, float* sum) {\n    size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < numElements) {\n        float diff = predictions[idx] - targets[idx];\n        float sq_diff = diff * diff;\n        atomicAdd(sum, sq_diff);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t N = 1 << 14;\n    size_t input_size = N * sizeof(float);\n\n    std::string pred_file = \"data/mse_preds.bin\";\n    std::string target_file = \"data/mse_targets.bin\";\n\n    float* h_preds = (float*)malloc(input_size);\n    float* h_targets = (float*)malloc(input_size);\n\n    read_binary(pred_file, h_preds, N);\n    read_binary(target_file, h_targets, N);\n\n    float *d_preds, *d_targets, *d_sum;\n    cudaMalloc(&d_preds, input_size);\n    cudaMalloc(&d_targets, input_size);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_preds, h_preds, input_size, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_targets, h_targets, input_size, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    mseKernel<<<blocks, threads>>>(d_preds, d_targets, N, d_sum);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n    float mse = h_sum / N;\n\n    // 写结果\n    write_binary(\"data/mse_out.bin\", &mse, 1);\n\n    cudaFree(d_preds);\n    cudaFree(d_targets);\n    cudaFree(d_sum);\n    free(h_preds);\n    free(h_targets);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nN = 1 << 14\nnp.random.seed(49)\n\npreds = (np.random.randn(N) * 10).astype(np.float32)\ntargets = (np.random.randn(N) * 10).astype(np.float32)\nmse = np.mean((preds - targets) ** 2).astype(np.float32)\n\nos.makedirs(\"data\", exist_ok=True)\npreds.tofile(\"data/mse_preds.bin\")\ntargets.tofile(\"data/mse_targets.bin\")\nnp.array([mse], dtype=np.float32).tofile(\"data/mse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_scalar(output_file, ref_file, tol=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, 1)[0]\n    ref = read_binary(ref_file, 1)[0]\n    return abs(out - ref) < tol\n\nif __name__ == \"__main__\":\n    out_file = \"data/mse_out.bin\"\n    ref_file = \"data/mse_ref.bin\"\n\n    if compare_scalar(out_file, ref_file):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Mean_Square_Error. Compute the mean square error between two input vectors of 16384 float32 elements. The inputs are two vectors: mse_preds and mse_targets, both of shape (16384,) and dtype float32. The output is a scalar tensor of shape (1,) and dtype float32, which is the mean of the squared differences between corresponding elements in the input vectors. The kernel must handle vectors of exactly 16384 elements and compute the mean correctly by dividing the total sum of squared differences by 16384.", "level2_prompt": "Mean_Square_Error: For two vectors of length 16384, compute the mean of the squared element-wise differences. The mean square error is calculated by summing the squares of the differences between each pair of corresponding elements in the two vectors and then dividing the total by the number of elements (16384).", "level3_prompt": "Compute the Mean_Square_Error kernel on GPU using CUDA."}
{"id": 383, "task_name": "Mean_Square_Error", "task_description": "Compute the Mean_Square_Error kernel on GPU using CUDA.", "inputs": [{"name": "mse_preds", "dtype": "float32", "shape": "(65536,)"}, {"name": "mse_targets", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "mse_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n__global__ void mseKernel(const float* predictions, const float* targets, size_t numElements, float* sum) {\n    size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < numElements) {\n        float diff = predictions[idx] - targets[idx];\n        float sq_diff = diff * diff;\n        atomicAdd(sum, sq_diff);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t N = 1 << 16;\n    size_t input_size = N * sizeof(float);\n\n    std::string pred_file = \"data/mse_preds.bin\";\n    std::string target_file = \"data/mse_targets.bin\";\n\n    float* h_preds = (float*)malloc(input_size);\n    float* h_targets = (float*)malloc(input_size);\n\n    read_binary(pred_file, h_preds, N);\n    read_binary(target_file, h_targets, N);\n\n    float *d_preds, *d_targets, *d_sum;\n    cudaMalloc(&d_preds, input_size);\n    cudaMalloc(&d_targets, input_size);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_preds, h_preds, input_size, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_targets, h_targets, input_size, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    mseKernel<<<blocks, threads>>>(d_preds, d_targets, N, d_sum);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n    float mse = h_sum / N;\n\n    // 写结果\n    write_binary(\"data/mse_out.bin\", &mse, 1);\n\n    cudaFree(d_preds);\n    cudaFree(d_targets);\n    cudaFree(d_sum);\n    free(h_preds);\n    free(h_targets);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nN = 1 << 16\nnp.random.seed(49)\n\npreds = (np.random.randn(N) * 10).astype(np.float32)\ntargets = (np.random.randn(N) * 10).astype(np.float32)\nmse = np.mean((preds - targets) ** 2).astype(np.float32)\n\nos.makedirs(\"data\", exist_ok=True)\npreds.tofile(\"data/mse_preds.bin\")\ntargets.tofile(\"data/mse_targets.bin\")\nnp.array([mse], dtype=np.float32).tofile(\"data/mse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_scalar(output_file, ref_file, tol=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, 1)[0]\n    ref = read_binary(ref_file, 1)[0]\n    return abs(out - ref) < tol\n\nif __name__ == \"__main__\":\n    out_file = \"data/mse_out.bin\"\n    ref_file = \"data/mse_ref.bin\"\n\n    if compare_scalar(out_file, ref_file):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for Mean Square Error calculation. The kernel should compute the mean of the squared differences between two input vectors. The inputs are two float32 tensors named 'mse_preds' and 'mse_targets', each with shape (65536,). The output is a single float32 scalar in a tensor named 'mse_out' with shape (1,). The kernel must calculate the squared difference for each element pair, accumulate these squared differences using atomic addition for thread safety, and finally compute the mean by dividing the total sum by the number of elements (65536).", "level2_prompt": "Compute the mean squared error between two vectors. Given two input vectors of equal length, calculate the squared difference for each corresponding element pair. Sum all squared differences and divide by the total number of elements to produce a scalar output representing the average squared error.", "level3_prompt": "Compute the Mean_Square_Error kernel on GPU using CUDA."}
{"id": 384, "task_name": "Mean_Square_Error", "task_description": "Compute the Mean_Square_Error kernel on GPU using CUDA.", "inputs": [{"name": "mse_preds", "dtype": "float32", "shape": "(262144,)"}, {"name": "mse_targets", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "mse_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n__global__ void mseKernel(const float* predictions, const float* targets, size_t numElements, float* sum) {\n    size_t idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx < numElements) {\n        float diff = predictions[idx] - targets[idx];\n        float sq_diff = diff * diff;\n        atomicAdd(sum, sq_diff);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t N = 1 << 18;\n    size_t input_size = N * sizeof(float);\n\n    std::string pred_file = \"data/mse_preds.bin\";\n    std::string target_file = \"data/mse_targets.bin\";\n\n    float* h_preds = (float*)malloc(input_size);\n    float* h_targets = (float*)malloc(input_size);\n\n    read_binary(pred_file, h_preds, N);\n    read_binary(target_file, h_targets, N);\n\n    float *d_preds, *d_targets, *d_sum;\n    cudaMalloc(&d_preds, input_size);\n    cudaMalloc(&d_targets, input_size);\n    cudaMalloc(&d_sum, sizeof(float));\n    cudaMemcpy(d_preds, h_preds, input_size, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_targets, h_targets, input_size, cudaMemcpyHostToDevice);\n    cudaMemset(d_sum, 0, sizeof(float));\n\n    int threads = 256;\n    int blocks = (N + threads - 1) / threads;\n    mseKernel<<<blocks, threads>>>(d_preds, d_targets, N, d_sum);\n\n    float h_sum = 0.0f;\n    cudaMemcpy(&h_sum, d_sum, sizeof(float), cudaMemcpyDeviceToHost);\n    float mse = h_sum / N;\n\n    // 写结果\n    write_binary(\"data/mse_out.bin\", &mse, 1);\n\n    cudaFree(d_preds);\n    cudaFree(d_targets);\n    cudaFree(d_sum);\n    free(h_preds);\n    free(h_targets);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nN = 1 << 18\nnp.random.seed(49)\n\npreds = (np.random.randn(N) * 10).astype(np.float32)\ntargets = (np.random.randn(N) * 10).astype(np.float32)\nmse = np.mean((preds - targets) ** 2).astype(np.float32)\n\nos.makedirs(\"data\", exist_ok=True)\npreds.tofile(\"data/mse_preds.bin\")\ntargets.tofile(\"data/mse_targets.bin\")\nnp.array([mse], dtype=np.float32).tofile(\"data/mse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_scalar(output_file, ref_file, tol=1e-1):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, 1)[0]\n    ref = read_binary(ref_file, 1)[0]\n    return abs(out - ref) < tol\n\nif __name__ == \"__main__\":\n    out_file = \"data/mse_out.bin\"\n    ref_file = \"data/mse_ref.bin\"\n\n    if compare_scalar(out_file, ref_file):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Mean_Square_Error. Compute the mean squared error between two input vectors. The inputs are two float32 tensors, each of shape (262144,). The output is a single float32 scalar (shape (1,)) representing the mean of the squared differences between corresponding elements in the two vectors. The kernel must compute the squared difference for each element, sum these squared differences, and then divide the total sum by the number of elements to obtain the mean.", "level2_prompt": "Task: Mean_Square_Error. For two input vectors of the same length, calculate the average of the squared differences between each pair of corresponding elements.", "level3_prompt": "Compute the Mean_Square_Error kernel on GPU using CUDA."}
{"id": 385, "task_name": "Ball_Query", "task_description": "Compute the Ball_Query kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 4096, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 64, 3)"}], "outputs": [{"name": "output_ball_query_idx", "dtype": "int32", "shape": "(16, 64, 16)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define MIN_RADIUS 1.0f\n#define MAX_RADIUS 10.0f\n#define NUM_POINTS 4096\n#define NUM_CENTERS 64\n#define NUM_SAMPLES 16\n\n\n__global__ void ball_query_kernel(const float* xyz, const float* center_xyz, int* ball_query_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_center_xyz = center_xyz + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    int* this_ball_query_idx = ball_query_idx + bs_idx * NUM_CENTERS * NUM_SAMPLES + pt_idx * NUM_SAMPLES;\n\n    float min_radius2 = MIN_RADIUS * MIN_RADIUS;\n    float max_radius2 = MAX_RADIUS * MAX_RADIUS;\n\n    float center_x = this_center_xyz[0];\n    float center_y = this_center_xyz[1];\n    float center_z = this_center_xyz[2];\n\n    int count = 0;\n    for (int n = 0; n < NUM_POINTS; ++n) {\n        float xyz_x = this_xyz[n * 3 + 0];\n        float xyz_y = this_xyz[n * 3 + 1];\n        float xyz_z = this_xyz[n * 3 + 2];\n        float dist2 = (center_x - xyz_x) * (center_x - xyz_x) +\n                      (center_y - xyz_y) * (center_y - xyz_y) +\n                      (center_z - xyz_z) * (center_z - xyz_z);\n        if (dist2 == 0 || (dist2 >= min_radius2 && dist2 <= max_radius2)) {\n            if (count == 0) {\n                for (int k = 0; k < NUM_SAMPLES; ++k) {\n                    this_ball_query_idx[k] = n;\n                }\n            }\n            this_ball_query_idx[count] = n;\n            count++;\n            if (count >= NUM_SAMPLES) {\n                break;\n            }\n        }\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t output_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center_xyz = new float[center_size];\n    int* h_ball_query_idx = new int[output_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center_xyz, center_size);\n\n    float *d_xyz, *d_center_xyz;\n    int* d_ball_query_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center_xyz, center_size * sizeof(float));\n    cudaMalloc(&d_ball_query_idx, output_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center_xyz, h_center_xyz, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_ball_query_idx, 0, output_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    ball_query_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center_xyz, d_ball_query_idx);\n    cudaMemcpy(h_ball_query_idx, d_ball_query_idx, output_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_ball_query_idx.bin\";\n    write_binary(output_file, h_ball_query_idx, output_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center_xyz);\n    cudaFree(d_ball_query_idx);\n    delete[] h_xyz;\n    delete[] h_center_xyz;\n    delete[] h_ball_query_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nMIN_RADIUS = 1.0\nMAX_RADIUS = 10.0\nNUM_POINTS = 4096\nNUM_CENTERS = 64\nNUM_SAMPLES = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12 / 2.0\n\ndef ball_query_pytorch(xyz, center, min_radius, max_radius, num_samples):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros((B, M, num_samples), dtype=torch.int32)\n\n    min_radius2 = min_radius * min_radius\n    max_radius2 = max_radius * max_radius\n\n    for b in range(B):\n        for m in range(M):\n            center_point = center[b, m]\n            count = 0\n            for n in range(N):\n                xyz_point = xyz[b, n]\n                dist2 = torch.sum((center_point - xyz_point) ** 2)\n                if dist2 == 0 or (dist2 >= min_radius2 and dist2 <= max_radius2):\n                    if count == 0:\n                        idx[b, m, :] = n\n                    idx[b, m, count] = n\n                    count += 1\n                    if count >= num_samples:\n                        break\n    return idx\n\nball_query_idx = ball_query_pytorch(xyz, center, MIN_RADIUS, MAX_RADIUS, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nball_query_idx.numpy().tofile(\"./data/expected_ball_query_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 64\n    NUM_SAMPLES = 16\n    total_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES\n\n    output_file = \"./data/output_ball_query_idx.bin\"\n    ref_file = \"./data/expected_ball_query_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Ball_Query. The kernel should compute indices of points within a spherical shell around center points. For each center in a batch, find up to 16 points from the input point cloud where the squared Euclidean distance to the center is between 1.0 and 100.0 (inclusive), or exactly zero. Inputs: 'input_xyz' (float32, shape [16, 4096, 3]) and 'input_center' (float32, shape [16, 64, 3]). Output: 'output_ball_query_idx' (int32, shape [16, 64, 16]) storing point indices. If no points meet criteria, output indices default to zero. Each center must be processed independently.", "level2_prompt": "Ball_Query: For each of 16 batches and 64 centers per batch, collect indices of up to 16 points from 4096 points where squared distance to the center satisfies (distance² = 0) OR (1.0 ≤ distance² ≤ 100.0). If fewer than 16 points are found, remaining indices default to the first found point's index or zero.", "level3_prompt": "Compute the Ball_Query kernel on GPU using CUDA."}
{"id": 386, "task_name": "Ball_Query", "task_description": "Compute the Ball_Query kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 4096, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_ball_query_idx", "dtype": "int32", "shape": "(16, 128, 16)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define MIN_RADIUS 1.0f\n#define MAX_RADIUS 10.0f\n#define NUM_POINTS 4096\n#define NUM_CENTERS 128\n#define NUM_SAMPLES 16\n\n\n__global__ void ball_query_kernel(const float* xyz, const float* center_xyz, int* ball_query_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_center_xyz = center_xyz + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    int* this_ball_query_idx = ball_query_idx + bs_idx * NUM_CENTERS * NUM_SAMPLES + pt_idx * NUM_SAMPLES;\n\n    float min_radius2 = MIN_RADIUS * MIN_RADIUS;\n    float max_radius2 = MAX_RADIUS * MAX_RADIUS;\n\n    float center_x = this_center_xyz[0];\n    float center_y = this_center_xyz[1];\n    float center_z = this_center_xyz[2];\n\n    int count = 0;\n    for (int n = 0; n < NUM_POINTS; ++n) {\n        float xyz_x = this_xyz[n * 3 + 0];\n        float xyz_y = this_xyz[n * 3 + 1];\n        float xyz_z = this_xyz[n * 3 + 2];\n        float dist2 = (center_x - xyz_x) * (center_x - xyz_x) +\n                      (center_y - xyz_y) * (center_y - xyz_y) +\n                      (center_z - xyz_z) * (center_z - xyz_z);\n        if (dist2 == 0 || (dist2 >= min_radius2 && dist2 <= max_radius2)) {\n            if (count == 0) {\n                for (int k = 0; k < NUM_SAMPLES; ++k) {\n                    this_ball_query_idx[k] = n;\n                }\n            }\n            this_ball_query_idx[count] = n;\n            count++;\n            if (count >= NUM_SAMPLES) {\n                break;\n            }\n        }\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t output_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center_xyz = new float[center_size];\n    int* h_ball_query_idx = new int[output_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center_xyz, center_size);\n\n    float *d_xyz, *d_center_xyz;\n    int* d_ball_query_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center_xyz, center_size * sizeof(float));\n    cudaMalloc(&d_ball_query_idx, output_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center_xyz, h_center_xyz, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_ball_query_idx, 0, output_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    ball_query_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center_xyz, d_ball_query_idx);\n    cudaMemcpy(h_ball_query_idx, d_ball_query_idx, output_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_ball_query_idx.bin\";\n    write_binary(output_file, h_ball_query_idx, output_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center_xyz);\n    cudaFree(d_ball_query_idx);\n    delete[] h_xyz;\n    delete[] h_center_xyz;\n    delete[] h_ball_query_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nMIN_RADIUS = 1.0\nMAX_RADIUS = 10.0\nNUM_POINTS = 4096\nNUM_CENTERS = 128\nNUM_SAMPLES = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12 / 2.0\n\ndef ball_query_pytorch(xyz, center, min_radius, max_radius, num_samples):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros((B, M, num_samples), dtype=torch.int32)\n\n    min_radius2 = min_radius * min_radius\n    max_radius2 = max_radius * max_radius\n\n    for b in range(B):\n        for m in range(M):\n            center_point = center[b, m]\n            count = 0\n            for n in range(N):\n                xyz_point = xyz[b, n]\n                dist2 = torch.sum((center_point - xyz_point) ** 2)\n                if dist2 == 0 or (dist2 >= min_radius2 and dist2 <= max_radius2):\n                    if count == 0:\n                        idx[b, m, :] = n\n                    idx[b, m, count] = n\n                    count += 1\n                    if count >= num_samples:\n                        break\n    return idx\n\nball_query_idx = ball_query_pytorch(xyz, center, MIN_RADIUS, MAX_RADIUS, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nball_query_idx.numpy().tofile(\"./data/expected_ball_query_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 128\n    NUM_SAMPLES = 16\n    total_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES\n\n    output_file = \"./data/output_ball_query_idx.bin\"\n    ref_file = \"./data/expected_ball_query_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Ball_Query: Implement a CUDA kernel that processes batches of 3D points to find neighboring points within a spherical shell around center points. For each of 16 batches, the input includes 4096 points (float32, shape [16,4096,3]) and 128 center points (float32, shape [16,128,3]). The kernel must output a tensor (int32, shape [16,128,16]) containing indices of up to 16 neighboring points per center that satisfy two conditions: either exactly coinciding with the center or having Euclidean distance squared between 1.0 and 100.0. When points are found, initialize all output indices for that center with the first valid point's index, then overwrite sequentially with subsequent valid indices until 16 are collected. Maintain zeros for centers with no valid points.", "level2_prompt": "Ball_Query: For each center point across batches, compute squared Euclidean distances to all input points. Identify points where distance² is either zero or lies in [1.0, 100.0]. Output up to 16 indices per center: initialize all indices with the first valid point's index if any exist, then sequentially replace indices with subsequent valid points until reaching 16 or exhausting points. Return zeros for centers with no valid points.", "level3_prompt": "Compute the Ball_Query kernel on GPU using CUDA."}
{"id": 387, "task_name": "Ball_Query", "task_description": "Compute the Ball_Query kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 4096, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 256, 3)"}], "outputs": [{"name": "output_ball_query_idx", "dtype": "int32", "shape": "(16, 256, 16)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define MIN_RADIUS 1.0f\n#define MAX_RADIUS 10.0f\n#define NUM_POINTS 4096\n#define NUM_CENTERS 256\n#define NUM_SAMPLES 16\n\n\n__global__ void ball_query_kernel(const float* xyz, const float* center_xyz, int* ball_query_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_center_xyz = center_xyz + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    int* this_ball_query_idx = ball_query_idx + bs_idx * NUM_CENTERS * NUM_SAMPLES + pt_idx * NUM_SAMPLES;\n\n    float min_radius2 = MIN_RADIUS * MIN_RADIUS;\n    float max_radius2 = MAX_RADIUS * MAX_RADIUS;\n\n    float center_x = this_center_xyz[0];\n    float center_y = this_center_xyz[1];\n    float center_z = this_center_xyz[2];\n\n    int count = 0;\n    for (int n = 0; n < NUM_POINTS; ++n) {\n        float xyz_x = this_xyz[n * 3 + 0];\n        float xyz_y = this_xyz[n * 3 + 1];\n        float xyz_z = this_xyz[n * 3 + 2];\n        float dist2 = (center_x - xyz_x) * (center_x - xyz_x) +\n                      (center_y - xyz_y) * (center_y - xyz_y) +\n                      (center_z - xyz_z) * (center_z - xyz_z);\n        if (dist2 == 0 || (dist2 >= min_radius2 && dist2 <= max_radius2)) {\n            if (count == 0) {\n                for (int k = 0; k < NUM_SAMPLES; ++k) {\n                    this_ball_query_idx[k] = n;\n                }\n            }\n            this_ball_query_idx[count] = n;\n            count++;\n            if (count >= NUM_SAMPLES) {\n                break;\n            }\n        }\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t output_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center_xyz = new float[center_size];\n    int* h_ball_query_idx = new int[output_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center_xyz, center_size);\n\n    float *d_xyz, *d_center_xyz;\n    int* d_ball_query_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center_xyz, center_size * sizeof(float));\n    cudaMalloc(&d_ball_query_idx, output_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center_xyz, h_center_xyz, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_ball_query_idx, 0, output_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    ball_query_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center_xyz, d_ball_query_idx);\n    cudaMemcpy(h_ball_query_idx, d_ball_query_idx, output_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_ball_query_idx.bin\";\n    write_binary(output_file, h_ball_query_idx, output_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center_xyz);\n    cudaFree(d_ball_query_idx);\n    delete[] h_xyz;\n    delete[] h_center_xyz;\n    delete[] h_ball_query_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nMIN_RADIUS = 1.0\nMAX_RADIUS = 10.0\nNUM_POINTS = 4096\nNUM_CENTERS = 256\nNUM_SAMPLES = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12 / 2.0\n\ndef ball_query_pytorch(xyz, center, min_radius, max_radius, num_samples):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros((B, M, num_samples), dtype=torch.int32)\n\n    min_radius2 = min_radius * min_radius\n    max_radius2 = max_radius * max_radius\n\n    for b in range(B):\n        for m in range(M):\n            center_point = center[b, m]\n            count = 0\n            for n in range(N):\n                xyz_point = xyz[b, n]\n                dist2 = torch.sum((center_point - xyz_point) ** 2)\n                if dist2 == 0 or (dist2 >= min_radius2 and dist2 <= max_radius2):\n                    if count == 0:\n                        idx[b, m, :] = n\n                    idx[b, m, count] = n\n                    count += 1\n                    if count >= num_samples:\n                        break\n    return idx\n\nball_query_idx = ball_query_pytorch(xyz, center, MIN_RADIUS, MAX_RADIUS, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nball_query_idx.numpy().tofile(\"./data/expected_ball_query_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 256\n    NUM_SAMPLES = 16\n    total_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES\n\n    output_file = \"./data/output_ball_query_idx.bin\"\n    ref_file = \"./data/expected_ball_query_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Ball_Query. Compute the indices of up to 16 neighboring points within a spherical shell around each center point. Inputs include a 3D point cloud tensor of shape (16, 4096, 3) and center points tensor of shape (16, 256, 3), both float32. Output is an int32 tensor of shape (16, 256, 16) storing indices of qualifying points. Constraints: Points must lie within the same batch; neighbors must satisfy distance squared between 1 and 100 units from the center (inclusive); exactly matching centers (distance 0) are included; outputs are initialized to zero; if any point is found, all output indices for that center start with the first found point and subsequent positions are filled with additional points in traversal order.", "level2_prompt": "Ball_Query: For each center point in a batch, identify up to 16 neighboring points from the same batch where the squared Euclidean distance to the center is either zero or falls within [1, 100]. The output records the indices of qualifying points in traversal order, with the entire output array initialized to the first found point if any exist.", "level3_prompt": "Perform ball query to find neighboring points within radial bounds for each center."}
{"id": 388, "task_name": "Ball_Query", "task_description": "Compute the Ball_Query kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 4096, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 512, 3)"}], "outputs": [{"name": "output_ball_query_idx", "dtype": "int32", "shape": "(16, 512, 16)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define MIN_RADIUS 1.0f\n#define MAX_RADIUS 10.0f\n#define NUM_POINTS 4096\n#define NUM_CENTERS 512\n#define NUM_SAMPLES 16\n\n\n__global__ void ball_query_kernel(const float* xyz, const float* center_xyz, int* ball_query_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_center_xyz = center_xyz + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    int* this_ball_query_idx = ball_query_idx + bs_idx * NUM_CENTERS * NUM_SAMPLES + pt_idx * NUM_SAMPLES;\n\n    float min_radius2 = MIN_RADIUS * MIN_RADIUS;\n    float max_radius2 = MAX_RADIUS * MAX_RADIUS;\n\n    float center_x = this_center_xyz[0];\n    float center_y = this_center_xyz[1];\n    float center_z = this_center_xyz[2];\n\n    int count = 0;\n    for (int n = 0; n < NUM_POINTS; ++n) {\n        float xyz_x = this_xyz[n * 3 + 0];\n        float xyz_y = this_xyz[n * 3 + 1];\n        float xyz_z = this_xyz[n * 3 + 2];\n        float dist2 = (center_x - xyz_x) * (center_x - xyz_x) +\n                      (center_y - xyz_y) * (center_y - xyz_y) +\n                      (center_z - xyz_z) * (center_z - xyz_z);\n        if (dist2 == 0 || (dist2 >= min_radius2 && dist2 <= max_radius2)) {\n            if (count == 0) {\n                for (int k = 0; k < NUM_SAMPLES; ++k) {\n                    this_ball_query_idx[k] = n;\n                }\n            }\n            this_ball_query_idx[count] = n;\n            count++;\n            if (count >= NUM_SAMPLES) {\n                break;\n            }\n        }\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t output_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center_xyz = new float[center_size];\n    int* h_ball_query_idx = new int[output_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center_xyz, center_size);\n\n    float *d_xyz, *d_center_xyz;\n    int* d_ball_query_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center_xyz, center_size * sizeof(float));\n    cudaMalloc(&d_ball_query_idx, output_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center_xyz, h_center_xyz, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_ball_query_idx, 0, output_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    ball_query_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center_xyz, d_ball_query_idx);\n    cudaMemcpy(h_ball_query_idx, d_ball_query_idx, output_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_ball_query_idx.bin\";\n    write_binary(output_file, h_ball_query_idx, output_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center_xyz);\n    cudaFree(d_ball_query_idx);\n    delete[] h_xyz;\n    delete[] h_center_xyz;\n    delete[] h_ball_query_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nMIN_RADIUS = 1.0\nMAX_RADIUS = 10.0\nNUM_POINTS = 4096\nNUM_CENTERS = 512\nNUM_SAMPLES = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12 / 2.0\n\ndef ball_query_pytorch(xyz, center, min_radius, max_radius, num_samples):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros((B, M, num_samples), dtype=torch.int32)\n\n    min_radius2 = min_radius * min_radius\n    max_radius2 = max_radius * max_radius\n\n    for b in range(B):\n        for m in range(M):\n            center_point = center[b, m]\n            count = 0\n            for n in range(N):\n                xyz_point = xyz[b, n]\n                dist2 = torch.sum((center_point - xyz_point) ** 2)\n                if dist2 == 0 or (dist2 >= min_radius2 and dist2 <= max_radius2):\n                    if count == 0:\n                        idx[b, m, :] = n\n                    idx[b, m, count] = n\n                    count += 1\n                    if count >= num_samples:\n                        break\n    return idx\n\nball_query_idx = ball_query_pytorch(xyz, center, MIN_RADIUS, MAX_RADIUS, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nball_query_idx.numpy().tofile(\"./data/expected_ball_query_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 512\n    NUM_SAMPLES = 16\n    total_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES\n\n    output_file = \"./data/output_ball_query_idx.bin\"\n    ref_file = \"./data/expected_ball_query_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Ball_Query. For each center point in a batch, find indices of up to 16 points that lie either exactly at the center (distance squared equals zero) or within a spherical shell defined by minimum radius 1.0 and maximum radius 10.0. Inputs include: input_xyz (float32, shape [16, 4096, 3]) representing point clouds, and input_center (float32, shape [16, 512, 3]) representing center points. Output is output_ball_query_idx (int32, shape [16, 512, 16]). Constraints: Each center point must independently search all 4096 points in its batch; output indices are initialized to zero and overwritten when points are found; if no points satisfy the condition, indices remain zero.", "level2_prompt": "Ball_Query: For each center point, compute squared Euclidean distances to all points in the same batch. Collect indices of up to 16 points where distance squared is either zero or falls between 1.0 and 100.0. Output stores these indices per center, with the entire row set to the first found point's index initially.", "level3_prompt": "Compute the Ball_Query kernel."}
{"id": 389, "task_name": "Ball_Query", "task_description": "Compute the Ball_Query kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 4096, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 1024, 3)"}], "outputs": [{"name": "output_ball_query_idx", "dtype": "int32", "shape": "(16, 1024, 16)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define MIN_RADIUS 1.0f\n#define MAX_RADIUS 10.0f\n#define NUM_POINTS 4096\n#define NUM_CENTERS 1024\n#define NUM_SAMPLES 16\n\n\n__global__ void ball_query_kernel(const float* xyz, const float* center_xyz, int* ball_query_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_center_xyz = center_xyz + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    int* this_ball_query_idx = ball_query_idx + bs_idx * NUM_CENTERS * NUM_SAMPLES + pt_idx * NUM_SAMPLES;\n\n    float min_radius2 = MIN_RADIUS * MIN_RADIUS;\n    float max_radius2 = MAX_RADIUS * MAX_RADIUS;\n\n    float center_x = this_center_xyz[0];\n    float center_y = this_center_xyz[1];\n    float center_z = this_center_xyz[2];\n\n    int count = 0;\n    for (int n = 0; n < NUM_POINTS; ++n) {\n        float xyz_x = this_xyz[n * 3 + 0];\n        float xyz_y = this_xyz[n * 3 + 1];\n        float xyz_z = this_xyz[n * 3 + 2];\n        float dist2 = (center_x - xyz_x) * (center_x - xyz_x) +\n                      (center_y - xyz_y) * (center_y - xyz_y) +\n                      (center_z - xyz_z) * (center_z - xyz_z);\n        if (dist2 == 0 || (dist2 >= min_radius2 && dist2 <= max_radius2)) {\n            if (count == 0) {\n                for (int k = 0; k < NUM_SAMPLES; ++k) {\n                    this_ball_query_idx[k] = n;\n                }\n            }\n            this_ball_query_idx[count] = n;\n            count++;\n            if (count >= NUM_SAMPLES) {\n                break;\n            }\n        }\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t output_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center_xyz = new float[center_size];\n    int* h_ball_query_idx = new int[output_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center_xyz, center_size);\n\n    float *d_xyz, *d_center_xyz;\n    int* d_ball_query_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center_xyz, center_size * sizeof(float));\n    cudaMalloc(&d_ball_query_idx, output_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center_xyz, h_center_xyz, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_ball_query_idx, 0, output_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    ball_query_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center_xyz, d_ball_query_idx);\n    cudaMemcpy(h_ball_query_idx, d_ball_query_idx, output_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_ball_query_idx.bin\";\n    write_binary(output_file, h_ball_query_idx, output_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center_xyz);\n    cudaFree(d_ball_query_idx);\n    delete[] h_xyz;\n    delete[] h_center_xyz;\n    delete[] h_ball_query_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nMIN_RADIUS = 1.0\nMAX_RADIUS = 10.0\nNUM_POINTS = 4096\nNUM_CENTERS = 1024\nNUM_SAMPLES = 16\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12 / 2.0\n\ndef ball_query_pytorch(xyz, center, min_radius, max_radius, num_samples):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros((B, M, num_samples), dtype=torch.int32)\n\n    min_radius2 = min_radius * min_radius\n    max_radius2 = max_radius * max_radius\n\n    for b in range(B):\n        for m in range(M):\n            center_point = center[b, m]\n            count = 0\n            for n in range(N):\n                xyz_point = xyz[b, n]\n                dist2 = torch.sum((center_point - xyz_point) ** 2)\n                if dist2 == 0 or (dist2 >= min_radius2 and dist2 <= max_radius2):\n                    if count == 0:\n                        idx[b, m, :] = n\n                    idx[b, m, count] = n\n                    count += 1\n                    if count >= num_samples:\n                        break\n    return idx\n\nball_query_idx = ball_query_pytorch(xyz, center, MIN_RADIUS, MAX_RADIUS, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nball_query_idx.numpy().tofile(\"./data/expected_ball_query_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 1024\n    NUM_SAMPLES = 16\n    total_size = BATCH_SIZE * NUM_CENTERS * NUM_SAMPLES\n\n    output_file = \"./data/output_ball_query_idx.bin\"\n    ref_file = \"./data/expected_ball_query_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Ball_Query: Implement a CUDA kernel that, for each center point in a batch, finds up to 16 neighboring points within a spherical shell defined by inner radius 1.0 and outer radius 10.0. The input consists of two float32 tensors: input_xyz with shape (16, 4096, 3) representing point coordinates, and input_center with shape (16, 1024, 3) representing center points. The output is an int32 tensor with shape (16, 1024, 16) storing indices of qualifying points. For each center, if no points are found, output indices remain zero; if points are found, initialize all 16 indices to the first qualifying point and sequentially overwrite indices with subsequent points until 16 are recorded.", "level2_prompt": "Ball_Query: For each center point in a batch, iterate through all points to identify those whose squared Euclidean distance to the center is either zero or falls between 1.0 and 100.0. Record indices of up to 16 qualifying points per center. Initialize all output indices to the first qualifying point found, then sequentially replace indices with new points until 16 are recorded.", "level3_prompt": "Ball Query: Find indices of points within a spherical shell (radii 1.0-10.0) for each center point."}
{"id": 390, "task_name": "Chamfer_Distance", "task_description": "Compute the Chamfer_Distance kernel on GPU using CUDA.", "inputs": [{"name": "input_points_a", "dtype": "float32", "shape": "(512, 128, 2)"}, {"name": "input_points_b", "dtype": "float32", "shape": "(512, 256, 2)"}], "outputs": [{"name": "output_chamfer_distance", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 512\n#define NUM_POINTS_A 128\n#define NUM_POINTS_B 256\n\n\n__global__ void chamfer_distance_kernel(const float* points_a, const float* points_b, float* chamfer_distance) {\n    int batch_idx = blockIdx.x;\n    if (batch_idx >= BATCH_SIZE) return;\n\n    const float* a = points_a + batch_idx * NUM_POINTS_A * 2;\n    const float* b = points_b + batch_idx * NUM_POINTS_B * 2;\n    float dist_a_to_b = 0.0f;\n    float dist_b_to_a = 0.0f;\n\n    for (int i = 0; i < NUM_POINTS_A; ++i) {\n        float min_dist = 1e10f;\n        for (int j = 0; j < NUM_POINTS_B; ++j) {\n            float dx = a[i * 2] - b[j * 2];\n            float dy = a[i * 2 + 1] - b[j * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_a_to_b += min_dist;\n    }\n\n    for (int j = 0; j < NUM_POINTS_B; ++j) {\n        float min_dist = 1e10f;\n        for (int i = 0; i < NUM_POINTS_A; ++i) {\n            float dx = b[j * 2] - a[i * 2];\n            float dy = b[j * 2 + 1] - a[i * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_b_to_a += min_dist;\n    }\n    float loss = (dist_a_to_b / NUM_POINTS_A) + (dist_b_to_a / NUM_POINTS_B);\n    atomicAdd(chamfer_distance, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_a_size = BATCH_SIZE * NUM_POINTS_A * 2;\n    size_t points_b_size = BATCH_SIZE * NUM_POINTS_B * 2;\n    size_t chamfer_distance_size = 1;\n\n    float* h_points_a = new float[points_a_size];\n    float* h_points_b = new float[points_b_size];\n    float* h_chamfer_distance = new float[chamfer_distance_size];\n\n    read_binary(\"./data/input_points_a.bin\", h_points_a, points_a_size);\n    read_binary(\"./data/input_points_b.bin\", h_points_b, points_b_size);\n\n    float *d_points_a, *d_points_b, *d_chamfer_distance;\n    cudaMalloc(&d_points_a, points_a_size * sizeof(float));\n    cudaMalloc(&d_points_b, points_b_size * sizeof(float));\n    cudaMalloc(&d_chamfer_distance, chamfer_distance_size * sizeof(float));\n\n    cudaMemcpy(d_points_a, h_points_a, points_a_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_points_b, h_points_b, points_b_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_chamfer_distance, 0, chamfer_distance_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (BATCH_SIZE + threads_per_block - 1) / threads_per_block;\n    chamfer_distance_kernel<<<blocks, threads_per_block>>>(d_points_a, d_points_b, d_chamfer_distance);\n\n    cudaMemcpy(h_chamfer_distance, d_chamfer_distance, chamfer_distance_size * sizeof(float), cudaMemcpyDeviceToHost);\n    // mean\n    *h_chamfer_distance /= BATCH_SIZE;\n\n    std::string output_file = \"./data/output_chamfer_distance.bin\";\n    write_binary(output_file, h_chamfer_distance, chamfer_distance_size);\n\n    cudaFree(d_points_a);\n    cudaFree(d_points_b);\n    cudaFree(d_chamfer_distance);\n    delete[] h_points_a;\n    delete[] h_points_b;\n    delete[] h_chamfer_distance;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 512\nNUM_POINTS_A = 128\nNUM_POINTS_B = 256\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints_a = torch.rand(BATCH_SIZE, NUM_POINTS_A, 2) * 7.12\npoints_b = torch.rand(BATCH_SIZE, NUM_POINTS_B, 2) * 7.12\n\ndef chamfer_distance_pytorch(points_a, points_b):\n    diff = points_a.unsqueeze(2) - points_b.unsqueeze(1)\n    dist = torch.sum(diff ** 2, dim=-1)\n    dist_a_to_b, _ = torch.min(dist, dim=2)\n    dist_b_to_a, _ = torch.min(dist, dim=1)\n    cd = torch.mean(dist_a_to_b) + torch.mean(dist_b_to_a)\n    return cd\n\nchamfer_distance = chamfer_distance_pytorch(points_a, points_b)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints_a.numpy().tofile(\"./data/input_points_a.bin\")\npoints_b.numpy().tofile(\"./data/input_points_b.bin\")\nchamfer_distance.numpy().tofile(\"./data/expected_chamfer_distance.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    output_file = \"./data/output_chamfer_distance.bin\"\n    ref_file = \"./data/expected_chamfer_distance.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Chamfer_Distance. Compute the Chamfer distance between two sets of points for 512 batches. Each batch has two sets: set A with 128 points and set B with 256 points, each point having two coordinates (x, y). The kernel must compute, for each batch, two sums: (1) for each point in A, the minimum squared Euclidean distance to any point in B, summed and then divided by the number of points in A; (2) similarly for each point in B to A. The Chamfer distance for the batch is the sum of these two averages. The kernel accumulates the Chamfer distance for all batches and then divides the total by the batch size (512) to get the average Chamfer distance, which is output as a single scalar.", "level2_prompt": "Compute the Chamfer distance for multiple batches of point set pairs. For each batch, given two point sets A (128 points) and B (256 points), each point in 2D, the Chamfer distance is: (1/128) * sum_{i=0}^{127} [ min_{j} ( (A_i,x - B_j,x)^2 + (A_i,y - B_j,y)^2 ) ] + (1/256) * sum_{j=0}^{255} [ min_{i} ( (B_j,x - A_i,x)^2 + (B_j,y - A_i,y)^2 ) ]. The kernel then averages this distance over all 512 batches to produce a single output value.", "level3_prompt": "Compute the Chamfer distance between two sets of points for multiple batches."}
{"id": 391, "task_name": "Chamfer_Distance", "task_description": "Compute the Chamfer_Distance kernel on GPU using CUDA.", "inputs": [{"name": "input_points_a", "dtype": "float32", "shape": "(1024, 128, 2)"}, {"name": "input_points_b", "dtype": "float32", "shape": "(1024, 256, 2)"}], "outputs": [{"name": "output_chamfer_distance", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 1024\n#define NUM_POINTS_A 128\n#define NUM_POINTS_B 256\n\n\n__global__ void chamfer_distance_kernel(const float* points_a, const float* points_b, float* chamfer_distance) {\n    int batch_idx = blockIdx.x;\n    if (batch_idx >= BATCH_SIZE) return;\n\n    const float* a = points_a + batch_idx * NUM_POINTS_A * 2;\n    const float* b = points_b + batch_idx * NUM_POINTS_B * 2;\n    float dist_a_to_b = 0.0f;\n    float dist_b_to_a = 0.0f;\n\n    for (int i = 0; i < NUM_POINTS_A; ++i) {\n        float min_dist = 1e10f;\n        for (int j = 0; j < NUM_POINTS_B; ++j) {\n            float dx = a[i * 2] - b[j * 2];\n            float dy = a[i * 2 + 1] - b[j * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_a_to_b += min_dist;\n    }\n\n    for (int j = 0; j < NUM_POINTS_B; ++j) {\n        float min_dist = 1e10f;\n        for (int i = 0; i < NUM_POINTS_A; ++i) {\n            float dx = b[j * 2] - a[i * 2];\n            float dy = b[j * 2 + 1] - a[i * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_b_to_a += min_dist;\n    }\n    float loss = (dist_a_to_b / NUM_POINTS_A) + (dist_b_to_a / NUM_POINTS_B);\n    atomicAdd(chamfer_distance, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_a_size = BATCH_SIZE * NUM_POINTS_A * 2;\n    size_t points_b_size = BATCH_SIZE * NUM_POINTS_B * 2;\n    size_t chamfer_distance_size = 1;\n\n    float* h_points_a = new float[points_a_size];\n    float* h_points_b = new float[points_b_size];\n    float* h_chamfer_distance = new float[chamfer_distance_size];\n\n    read_binary(\"./data/input_points_a.bin\", h_points_a, points_a_size);\n    read_binary(\"./data/input_points_b.bin\", h_points_b, points_b_size);\n\n    float *d_points_a, *d_points_b, *d_chamfer_distance;\n    cudaMalloc(&d_points_a, points_a_size * sizeof(float));\n    cudaMalloc(&d_points_b, points_b_size * sizeof(float));\n    cudaMalloc(&d_chamfer_distance, chamfer_distance_size * sizeof(float));\n\n    cudaMemcpy(d_points_a, h_points_a, points_a_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_points_b, h_points_b, points_b_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_chamfer_distance, 0, chamfer_distance_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (BATCH_SIZE + threads_per_block - 1) / threads_per_block;\n    chamfer_distance_kernel<<<blocks, threads_per_block>>>(d_points_a, d_points_b, d_chamfer_distance);\n\n    cudaMemcpy(h_chamfer_distance, d_chamfer_distance, chamfer_distance_size * sizeof(float), cudaMemcpyDeviceToHost);\n    // mean\n    *h_chamfer_distance /= BATCH_SIZE;\n\n    std::string output_file = \"./data/output_chamfer_distance.bin\";\n    write_binary(output_file, h_chamfer_distance, chamfer_distance_size);\n\n    cudaFree(d_points_a);\n    cudaFree(d_points_b);\n    cudaFree(d_chamfer_distance);\n    delete[] h_points_a;\n    delete[] h_points_b;\n    delete[] h_chamfer_distance;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 1024\nNUM_POINTS_A = 128\nNUM_POINTS_B = 256\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints_a = torch.rand(BATCH_SIZE, NUM_POINTS_A, 2) * 7.12\npoints_b = torch.rand(BATCH_SIZE, NUM_POINTS_B, 2) * 7.12\n\ndef chamfer_distance_pytorch(points_a, points_b):\n    diff = points_a.unsqueeze(2) - points_b.unsqueeze(1)\n    dist = torch.sum(diff ** 2, dim=-1)\n    dist_a_to_b, _ = torch.min(dist, dim=2)\n    dist_b_to_a, _ = torch.min(dist, dim=1)\n    cd = torch.mean(dist_a_to_b) + torch.mean(dist_b_to_a)\n    return cd\n\nchamfer_distance = chamfer_distance_pytorch(points_a, points_b)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints_a.numpy().tofile(\"./data/input_points_a.bin\")\npoints_b.numpy().tofile(\"./data/input_points_b.bin\")\nchamfer_distance.numpy().tofile(\"./data/expected_chamfer_distance.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    output_file = \"./data/output_chamfer_distance.bin\"\n    ref_file = \"./data/expected_chamfer_distance.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Chamfer_Distance kernel. The task involves computing the Chamfer distance between two sets of 2D points across multiple batches. Input A is a float32 tensor of shape (1024, 128, 2) representing 1024 batches with 128 points each. Input B is a float32 tensor of shape (1024, 256, 2) with 256 points per batch. For each batch, calculate two components: first, for every point in set A, find its nearest point in set B using squared Euclidean distance and sum these minima; second, repeat the process for every point in set B to find its nearest in set A. Average the first sum by the number of points in A and the second by points in B. Sum these averages to get the Chamfer distance per batch. Finally, compute the mean Chamfer distance across all batches and output it as a single float32 value in a tensor of shape (1,).", "level2_prompt": "Compute the Chamfer_Distance by processing 1024 batches of 2D points. For each batch, take set A (128 points) and set B (256 points). For every point in A, find the minimum squared Euclidean distance to any point in B and accumulate these minima. Similarly, for every point in B, find the minimum squared Euclidean distance to any point in A and accumulate. Divide the first accumulation by 128 and the second by 256. Sum these two results to get the batch's Chamfer distance. Finally, average the Chamfer distances of all batches to produce a single output value.", "level3_prompt": "Compute the Chamfer distance kernel for 1024 batches of 2D point sets, with 128 points in set A and 256 in set B per batch, outputting the average distance."}
{"id": 392, "task_name": "Chamfer_Distance", "task_description": "Compute the Chamfer_Distance kernel on GPU using CUDA.", "inputs": [{"name": "input_points_a", "dtype": "float32", "shape": "(2048, 128, 2)"}, {"name": "input_points_b", "dtype": "float32", "shape": "(2048, 256, 2)"}], "outputs": [{"name": "output_chamfer_distance", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 2048\n#define NUM_POINTS_A 128\n#define NUM_POINTS_B 256\n\n\n__global__ void chamfer_distance_kernel(const float* points_a, const float* points_b, float* chamfer_distance) {\n    int batch_idx = blockIdx.x;\n    if (batch_idx >= BATCH_SIZE) return;\n\n    const float* a = points_a + batch_idx * NUM_POINTS_A * 2;\n    const float* b = points_b + batch_idx * NUM_POINTS_B * 2;\n    float dist_a_to_b = 0.0f;\n    float dist_b_to_a = 0.0f;\n\n    for (int i = 0; i < NUM_POINTS_A; ++i) {\n        float min_dist = 1e10f;\n        for (int j = 0; j < NUM_POINTS_B; ++j) {\n            float dx = a[i * 2] - b[j * 2];\n            float dy = a[i * 2 + 1] - b[j * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_a_to_b += min_dist;\n    }\n\n    for (int j = 0; j < NUM_POINTS_B; ++j) {\n        float min_dist = 1e10f;\n        for (int i = 0; i < NUM_POINTS_A; ++i) {\n            float dx = b[j * 2] - a[i * 2];\n            float dy = b[j * 2 + 1] - a[i * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_b_to_a += min_dist;\n    }\n    float loss = (dist_a_to_b / NUM_POINTS_A) + (dist_b_to_a / NUM_POINTS_B);\n    atomicAdd(chamfer_distance, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_a_size = BATCH_SIZE * NUM_POINTS_A * 2;\n    size_t points_b_size = BATCH_SIZE * NUM_POINTS_B * 2;\n    size_t chamfer_distance_size = 1;\n\n    float* h_points_a = new float[points_a_size];\n    float* h_points_b = new float[points_b_size];\n    float* h_chamfer_distance = new float[chamfer_distance_size];\n\n    read_binary(\"./data/input_points_a.bin\", h_points_a, points_a_size);\n    read_binary(\"./data/input_points_b.bin\", h_points_b, points_b_size);\n\n    float *d_points_a, *d_points_b, *d_chamfer_distance;\n    cudaMalloc(&d_points_a, points_a_size * sizeof(float));\n    cudaMalloc(&d_points_b, points_b_size * sizeof(float));\n    cudaMalloc(&d_chamfer_distance, chamfer_distance_size * sizeof(float));\n\n    cudaMemcpy(d_points_a, h_points_a, points_a_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_points_b, h_points_b, points_b_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_chamfer_distance, 0, chamfer_distance_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (BATCH_SIZE + threads_per_block - 1) / threads_per_block;\n    chamfer_distance_kernel<<<blocks, threads_per_block>>>(d_points_a, d_points_b, d_chamfer_distance);\n\n    cudaMemcpy(h_chamfer_distance, d_chamfer_distance, chamfer_distance_size * sizeof(float), cudaMemcpyDeviceToHost);\n    // mean\n    *h_chamfer_distance /= BATCH_SIZE;\n\n    std::string output_file = \"./data/output_chamfer_distance.bin\";\n    write_binary(output_file, h_chamfer_distance, chamfer_distance_size);\n\n    cudaFree(d_points_a);\n    cudaFree(d_points_b);\n    cudaFree(d_chamfer_distance);\n    delete[] h_points_a;\n    delete[] h_points_b;\n    delete[] h_chamfer_distance;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 2048\nNUM_POINTS_A = 128\nNUM_POINTS_B = 256\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints_a = torch.rand(BATCH_SIZE, NUM_POINTS_A, 2) * 7.12\npoints_b = torch.rand(BATCH_SIZE, NUM_POINTS_B, 2) * 7.12\n\ndef chamfer_distance_pytorch(points_a, points_b):\n    diff = points_a.unsqueeze(2) - points_b.unsqueeze(1)\n    dist = torch.sum(diff ** 2, dim=-1)\n    dist_a_to_b, _ = torch.min(dist, dim=2)\n    dist_b_to_a, _ = torch.min(dist, dim=1)\n    cd = torch.mean(dist_a_to_b) + torch.mean(dist_b_to_a)\n    return cd\n\nchamfer_distance = chamfer_distance_pytorch(points_a, points_b)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints_a.numpy().tofile(\"./data/input_points_a.bin\")\npoints_b.numpy().tofile(\"./data/input_points_b.bin\")\nchamfer_distance.numpy().tofile(\"./data/expected_chamfer_distance.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    output_file = \"./data/output_chamfer_distance.bin\"\n    ref_file = \"./data/expected_chamfer_distance.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'Chamfer_Distance' that computes the Chamfer distance between two sets of points for a batch of 2048 samples. Each sample has two point sets: set A with 128 points and set B with 256 points, each point being 2D (x, y). The inputs are two tensors: 'input_points_a' of shape (2048, 128, 2) and 'input_points_b' of shape (2048, 256, 2), both with dtype float32. The output is a scalar tensor 'output_chamfer_distance' of shape (1,) and dtype float32. For each sample, the kernel must compute two sums: (1) the sum of the minimum squared Euclidean distances from each point in set A to any point in set B, and (2) the sum of the minimum squared Euclidean distances from each point in set B to any point in set A. The per-sample loss is then computed as (sum_A / 128) + (sum_B / 256). The kernel must use atomicAdd to accumulate this per-sample loss into the output scalar. Note: the kernel does not average over the batch; the host will divide the accumulated output by 2048 to get the mean.", "level2_prompt": "Compute the Chamfer distance for a batch of samples. For each sample, given two point sets A (128 points) and B (256 points) in 2D, calculate the per-sample loss as ( (sum of min squared distances from each point in A to B) / 128 ) + ( (sum of min squared distances from each point in B to A) / 256 ). The kernel should accumulate the per-sample loss over all 2048 samples into a single scalar using atomic addition.", "level3_prompt": "Compute the Chamfer_Distance kernel on GPU using CUDA."}
{"id": 393, "task_name": "Chamfer_Distance", "task_description": "Compute the Chamfer_Distance kernel on GPU using CUDA.", "inputs": [{"name": "input_points_a", "dtype": "float32", "shape": "(4096, 128, 2)"}, {"name": "input_points_b", "dtype": "float32", "shape": "(4096, 256, 2)"}], "outputs": [{"name": "output_chamfer_distance", "dtype": "float32", "shape": "()"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 4096\n#define NUM_POINTS_A 128\n#define NUM_POINTS_B 256\n\n\n__global__ void chamfer_distance_kernel(const float* points_a, const float* points_b, float* chamfer_distance) {\n    int batch_idx = blockIdx.x;\n    if (batch_idx >= BATCH_SIZE) return;\n\n    const float* a = points_a + batch_idx * NUM_POINTS_A * 2;\n    const float* b = points_b + batch_idx * NUM_POINTS_B * 2;\n    float dist_a_to_b = 0.0f;\n    float dist_b_to_a = 0.0f;\n\n    for (int i = 0; i < NUM_POINTS_A; ++i) {\n        float min_dist = 1e10f;\n        for (int j = 0; j < NUM_POINTS_B; ++j) {\n            float dx = a[i * 2] - b[j * 2];\n            float dy = a[i * 2 + 1] - b[j * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_a_to_b += min_dist;\n    }\n\n    for (int j = 0; j < NUM_POINTS_B; ++j) {\n        float min_dist = 1e10f;\n        for (int i = 0; i < NUM_POINTS_A; ++i) {\n            float dx = b[j * 2] - a[i * 2];\n            float dy = b[j * 2 + 1] - a[i * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_b_to_a += min_dist;\n    }\n    float loss = (dist_a_to_b / NUM_POINTS_A) + (dist_b_to_a / NUM_POINTS_B);\n    atomicAdd(chamfer_distance, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_a_size = BATCH_SIZE * NUM_POINTS_A * 2;\n    size_t points_b_size = BATCH_SIZE * NUM_POINTS_B * 2;\n    size_t chamfer_distance_size = 1;\n\n    float* h_points_a = new float[points_a_size];\n    float* h_points_b = new float[points_b_size];\n    float* h_chamfer_distance = new float[chamfer_distance_size];\n\n    read_binary(\"./data/input_points_a.bin\", h_points_a, points_a_size);\n    read_binary(\"./data/input_points_b.bin\", h_points_b, points_b_size);\n\n    float *d_points_a, *d_points_b, *d_chamfer_distance;\n    cudaMalloc(&d_points_a, points_a_size * sizeof(float));\n    cudaMalloc(&d_points_b, points_b_size * sizeof(float));\n    cudaMalloc(&d_chamfer_distance, chamfer_distance_size * sizeof(float));\n\n    cudaMemcpy(d_points_a, h_points_a, points_a_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_points_b, h_points_b, points_b_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_chamfer_distance, 0, chamfer_distance_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (BATCH_SIZE + threads_per_block - 1) / threads_per_block;\n    chamfer_distance_kernel<<<blocks, threads_per_block>>>(d_points_a, d_points_b, d_chamfer_distance);\n\n    cudaMemcpy(h_chamfer_distance, d_chamfer_distance, chamfer_distance_size * sizeof(float), cudaMemcpyDeviceToHost);\n    // mean\n    *h_chamfer_distance /= BATCH_SIZE;\n\n    std::string output_file = \"./data/output_chamfer_distance.bin\";\n    write_binary(output_file, h_chamfer_distance, chamfer_distance_size);\n\n    cudaFree(d_points_a);\n    cudaFree(d_points_b);\n    cudaFree(d_chamfer_distance);\n    delete[] h_points_a;\n    delete[] h_points_b;\n    delete[] h_chamfer_distance;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 4096\nNUM_POINTS_A = 128\nNUM_POINTS_B = 256\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints_a = torch.rand(BATCH_SIZE, NUM_POINTS_A, 2) * 7.12\npoints_b = torch.rand(BATCH_SIZE, NUM_POINTS_B, 2) * 7.12\n\ndef chamfer_distance_pytorch(points_a, points_b):\n    diff = points_a.unsqueeze(2) - points_b.unsqueeze(1)\n    dist = torch.sum(diff ** 2, dim=-1)\n    dist_a_to_b, _ = torch.min(dist, dim=2)\n    dist_b_to_a, _ = torch.min(dist, dim=1)\n    cd = torch.mean(dist_a_to_b) + torch.mean(dist_b_to_a)\n    return cd\n\nchamfer_distance = chamfer_distance_pytorch(points_a, points_b)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints_a.numpy().tofile(\"./data/input_points_a.bin\")\npoints_b.numpy().tofile(\"./data/input_points_b.bin\")\nchamfer_distance.numpy().tofile(\"./data/expected_chamfer_distance.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    output_file = \"./data/output_chamfer_distance.bin\"\n    ref_file = \"./data/expected_chamfer_distance.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Compute the Chamfer distance for a batch of point set pairs. The input consists of two tensors: input_points_a of shape (4096, 128, 2) and input_points_b of shape (4096, 256, 2), both of dtype float32. For each batch element, compute the Chamfer distance as the sum of two terms: the average of the minimum squared Euclidean distances from each point in set A to any point in set B, and the average of the minimum squared Euclidean distances from each point in set B to any point in set A. The kernel must accumulate the Chamfer distance for each batch element and output a single scalar that is the sum of these per-batch distances. The host will then average this sum by the batch size (4096). The output tensor output_chamfer_distance is a scalar of dtype float32.", "level2_prompt": "The Chamfer_Distance task computes the sum of per-batch-element Chamfer distances. For each of the 4096 batches, given a set A of 128 points and a set B of 256 points (each point in 2D), the Chamfer distance for the batch element is: (1/128 * sum_{p in A} min_{q in B} ||p-q||^2) + (1/256 * sum_{q in B} min_{p in A} ||q-p||^2). The kernel sums this value over all batches.", "level3_prompt": "Compute the Chamfer_Distance kernel on GPU using CUDA."}
{"id": 394, "task_name": "Chamfer_Distance", "task_description": "Compute the Chamfer_Distance kernel on GPU using CUDA.", "inputs": [{"name": "input_points_a", "dtype": "float32", "shape": "(8192, 128, 2)"}, {"name": "input_points_b", "dtype": "float32", "shape": "(8192, 256, 2)"}], "outputs": [{"name": "output_chamfer_distance", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8192\n#define NUM_POINTS_A 128\n#define NUM_POINTS_B 256\n\n\n__global__ void chamfer_distance_kernel(const float* points_a, const float* points_b, float* chamfer_distance) {\n    int batch_idx = blockIdx.x;\n    if (batch_idx >= BATCH_SIZE) return;\n\n    const float* a = points_a + batch_idx * NUM_POINTS_A * 2;\n    const float* b = points_b + batch_idx * NUM_POINTS_B * 2;\n    float dist_a_to_b = 0.0f;\n    float dist_b_to_a = 0.0f;\n\n    for (int i = 0; i < NUM_POINTS_A; ++i) {\n        float min_dist = 1e10f;\n        for (int j = 0; j < NUM_POINTS_B; ++j) {\n            float dx = a[i * 2] - b[j * 2];\n            float dy = a[i * 2 + 1] - b[j * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_a_to_b += min_dist;\n    }\n\n    for (int j = 0; j < NUM_POINTS_B; ++j) {\n        float min_dist = 1e10f;\n        for (int i = 0; i < NUM_POINTS_A; ++i) {\n            float dx = b[j * 2] - a[i * 2];\n            float dy = b[j * 2 + 1] - a[i * 2 + 1];\n            float dist = dx * dx + dy * dy;\n            if (dist < min_dist) {\n                min_dist = dist;\n            }\n        }\n        dist_b_to_a += min_dist;\n    }\n    float loss = (dist_a_to_b / NUM_POINTS_A) + (dist_b_to_a / NUM_POINTS_B);\n    atomicAdd(chamfer_distance, loss);\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_a_size = BATCH_SIZE * NUM_POINTS_A * 2;\n    size_t points_b_size = BATCH_SIZE * NUM_POINTS_B * 2;\n    size_t chamfer_distance_size = 1;\n\n    float* h_points_a = new float[points_a_size];\n    float* h_points_b = new float[points_b_size];\n    float* h_chamfer_distance = new float[chamfer_distance_size];\n\n    read_binary(\"./data/input_points_a.bin\", h_points_a, points_a_size);\n    read_binary(\"./data/input_points_b.bin\", h_points_b, points_b_size);\n\n    float *d_points_a, *d_points_b, *d_chamfer_distance;\n    cudaMalloc(&d_points_a, points_a_size * sizeof(float));\n    cudaMalloc(&d_points_b, points_b_size * sizeof(float));\n    cudaMalloc(&d_chamfer_distance, chamfer_distance_size * sizeof(float));\n\n    cudaMemcpy(d_points_a, h_points_a, points_a_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_points_b, h_points_b, points_b_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_chamfer_distance, 0, chamfer_distance_size * sizeof(float));\n\n    int threads_per_block = 256;\n    int blocks = (BATCH_SIZE + threads_per_block - 1) / threads_per_block;\n    chamfer_distance_kernel<<<blocks, threads_per_block>>>(d_points_a, d_points_b, d_chamfer_distance);\n\n    cudaMemcpy(h_chamfer_distance, d_chamfer_distance, chamfer_distance_size * sizeof(float), cudaMemcpyDeviceToHost);\n    // mean\n    *h_chamfer_distance /= BATCH_SIZE;\n\n    std::string output_file = \"./data/output_chamfer_distance.bin\";\n    write_binary(output_file, h_chamfer_distance, chamfer_distance_size);\n\n    cudaFree(d_points_a);\n    cudaFree(d_points_b);\n    cudaFree(d_chamfer_distance);\n    delete[] h_points_a;\n    delete[] h_points_b;\n    delete[] h_chamfer_distance;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8192\nNUM_POINTS_A = 128\nNUM_POINTS_B = 256\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints_a = torch.rand(BATCH_SIZE, NUM_POINTS_A, 2) * 7.12\npoints_b = torch.rand(BATCH_SIZE, NUM_POINTS_B, 2) * 7.12\n\ndef chamfer_distance_pytorch(points_a, points_b):\n    diff = points_a.unsqueeze(2) - points_b.unsqueeze(1)\n    dist = torch.sum(diff ** 2, dim=-1)\n    dist_a_to_b, _ = torch.min(dist, dim=2)\n    dist_b_to_a, _ = torch.min(dist, dim=1)\n    cd = torch.mean(dist_a_to_b) + torch.mean(dist_b_to_a)\n    return cd\n\nchamfer_distance = chamfer_distance_pytorch(points_a, points_b)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints_a.numpy().tofile(\"./data/input_points_a.bin\")\npoints_b.numpy().tofile(\"./data/input_points_b.bin\")\nchamfer_distance.numpy().tofile(\"./data/expected_chamfer_distance.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    output_file = \"./data/output_chamfer_distance.bin\"\n    ref_file = \"./data/expected_chamfer_distance.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-1):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Chamfer_Distance kernel to compute the average Chamfer distance between two sets of 2D points across multiple batches. The inputs are two float32 tensors: input_points_a with shape (8192, 128, 2) and input_points_b with shape (8192, 256, 2). The output is a single float32 value representing the average Chamfer distance across all batches. For each batch, compute two sums: (1) the minimum squared Euclidean distance from each point in set A to any point in set B, averaged over set A points; (2) the minimum squared Euclidean distance from each point in set B to any point in set A, averaged over set B points. The Chamfer distance per batch is the sum of these two averages. Accumulate this value across all batches and divide by the batch count to produce the final output.", "level2_prompt": "Compute the Chamfer distance between two point sets. For each batch, find the minimum squared Euclidean distance from every point in set A to any point in set B, sum these minima, and divide by the count of set A points. Repeat the process for set B points relative to set A. The batch's Chamfer distance is the sum of these two normalized sums. Average this distance across all batches to produce a single scalar output.", "level3_prompt": "Compute the Chamfer_Distance kernel on GPU for batch-processed 2D point sets."}
{"id": 395, "task_name": "Dynamic_Voxelize", "task_description": "Compute the Dynamic_Voxelize kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(1024, 5)"}], "outputs": [{"name": "output_dynamic_voxelize_coordinates", "dtype": "int32", "shape": "(1024, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define NUM_POINTS 1024\n#define NUM_FEATURES 5\n#define VOXEL_SIZE_X 1.0f\n#define VOXEL_SIZE_Y 1.0f\n#define VOXEL_SIZE_Z 1.0f\n#define COORDINATES_MIN_X 0.0f\n#define COORDINATES_MIN_Y 0.0f\n#define COORDINATES_MIN_Z 0.0f\n#define COORDINATES_MAX_X 5.0f\n#define COORDINATES_MAX_Y 5.0f\n#define COORDINATES_MAX_Z 5.0f\n#define GRID_SIZE_X (round((COORDINATES_MAX_X - COORDINATES_MIN_X) / VOXEL_SIZE_X))\n#define GRID_SIZE_Y (round((COORDINATES_MAX_Y - COORDINATES_MIN_Y) / VOXEL_SIZE_Y))\n#define GRID_SIZE_Z (round((COORDINATES_MAX_Z - COORDINATES_MIN_Z) / VOXEL_SIZE_Z))\n\n\n__global__ void dynamic_voxelize_kernel(const float* points, int* coordinates) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= NUM_POINTS) return;\n\n    const float* this_point = points + idx * NUM_FEATURES;\n    int* this_coordinate = coordinates + idx * 3;\n\n    int coordinate_x = floorf((this_point[0] - COORDINATES_MIN_X) / VOXEL_SIZE_X);\n    if (coordinate_x < 0 || coordinate_x >= GRID_SIZE_X) {\n        this_coordinate[0] = -1;\n        return;\n    }\n    int coordinate_y = floorf((this_point[1] - COORDINATES_MIN_Y) / VOXEL_SIZE_Y);\n    if (coordinate_y < 0 || coordinate_y >= GRID_SIZE_Y) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        return;\n    }\n    int coordinate_z = floorf((this_point[2] - COORDINATES_MIN_Z) / VOXEL_SIZE_Z);\n    if (coordinate_z < 0 || coordinate_z >= GRID_SIZE_Z) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        this_coordinate[2] = -1;\n        return;\n    } else {\n        this_coordinate[0] = coordinate_z;\n        this_coordinate[1] = coordinate_y;\n        this_coordinate[2] = coordinate_x;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = NUM_POINTS * NUM_FEATURES;\n    size_t coordinates_size = NUM_POINTS * 3;\n\n    float* h_points = new float[points_size];\n    int* h_coordinates = new int[coordinates_size];\n\n    std::string points_file = \"./data/input_points.bin\";\n    read_binary(points_file, h_points, points_size);\n\n    float* d_points;\n    int* d_coordinates;\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_coordinates, coordinates_size * sizeof(int));\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_coordinates, 0, coordinates_size * sizeof(int));\n\n    int threads_per_block = 256;\n    int num_blocks = (NUM_POINTS + threads_per_block - 1) / threads_per_block;\n    dynamic_voxelize_kernel<<<num_blocks, threads_per_block>>>(d_points, d_coordinates);\n    cudaMemcpy(h_coordinates, d_coordinates, coordinates_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_dynamic_voxelize_coordinates.bin\";\n    write_binary(output_file, h_coordinates, coordinates_size);\n\n    cudaFree(d_points);\n    cudaFree(d_coordinates);\n    delete[] h_points;\n    delete[] h_coordinates;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport math\n\nNUM_POINTS = 1024\nNUM_FEATURES = 5\nVOXEL_SIZE = [1.0, 1.0, 1.0]\nCOORDINATES_MIN = [0.0, 0.0, 0.0]\nCOORDINATES_MAX = [5.0, 5.0, 5.0]\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(NUM_POINTS, NUM_FEATURES) * 7.12\n\ndef dynamic_voxelize_pytorch(points, voxel_size, coordinates_min, coordinates_max):\n    num_points, num_features = points.shape\n    voxel_x, voxel_y, voxel_z = voxel_size\n    x_min, y_min, z_min = coordinates_min\n    x_max, y_max, z_max = coordinates_max\n    grid_size_x = int((x_max - x_min) / voxel_x)\n    grid_size_y = int((y_max - y_min) / voxel_y)\n    grid_size_z = int((z_max - z_min) / voxel_z)\n\n    coordinates = torch.zeros((num_points, 3), dtype=torch.int)\n    for i in range(num_points):\n        this_point = points[i]\n        coordinate_x = math.floor((this_point[0] - x_min) / voxel_x)\n        if coordinate_x < 0 or coordinate_x >= grid_size_x:\n            coordinates[i][0] = -1\n            continue\n        coordinate_y = math.floor((this_point[1] - y_min) / voxel_y)\n        if coordinate_y < 0 or coordinate_y >= grid_size_y:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            continue\n        coordinate_z = math.floor((this_point[2] - z_min) / voxel_z)\n        if coordinate_z < 0 or coordinate_z >= grid_size_z:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            coordinates[i][2] = -1\n            continue\n        else:\n            coordinates[i][0] = coordinate_z\n            coordinates[i][1] = coordinate_y\n            coordinates[i][2] = coordinate_x\n    return coordinates\n\ncoordinates = dynamic_voxelize_pytorch(points, VOXEL_SIZE, COORDINATES_MIN, COORDINATES_MAX)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\ncoordinates.numpy().tofile(\"./data/expected_dynamic_voxelize_coordinates.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    NUM_POINTS = 1024\n    total_size = NUM_POINTS * 3\n\n    output_file = \"./data/output_dynamic_voxelize_coordinates.bin\"\n    ref_file = \"./data/expected_dynamic_voxelize_coordinates.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Dynamic_Voxelize. Given an input tensor of 1024 points with 5 features each (dtype float32), where the first three features represent 3D coordinates (x, y, z), compute voxel indices for each point in a fixed grid. The grid has boundaries [0.0, 5.0] in all dimensions and a voxel size of 1.0 in each axis. For each point, calculate integer voxel coordinates (z, y, x) by normalizing and discretizing its 3D position. If a point's x-coordinate falls outside the grid, output (-1, 0, 0); if y is outside, output (-1, -1, 0); if z is outside, output (-1, -1, -1). The output must be a tensor of shape (1024, 3) with dtype int32.", "level2_prompt": "For each of the 1024 input points, extract its (x, y, z) coordinates. Compute voxel indices by applying floor division: voxel_x = floor((x - 0.0) / 1.0), similarly for y and z. If voxel_x is outside [0, 5), output (-1, 0, 0). Else, if voxel_y is outside [0, 5), output (-1, -1, 0). Else, if voxel_z is outside [0, 5), output (-1, -1, -1). Else, output (voxel_z, voxel_y, voxel_x).", "level3_prompt": "Compute the Dynamic_Voxelize kernel on GPU using CUDA."}
{"id": 396, "task_name": "Dynamic_Voxelize", "task_description": "Compute the Dynamic_Voxelize kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(2048, 5)"}], "outputs": [{"name": "output_dynamic_voxelize_coordinates", "dtype": "int32", "shape": "(6144,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define NUM_POINTS 2048\n#define NUM_FEATURES 5\n#define VOXEL_SIZE_X 1.0f\n#define VOXEL_SIZE_Y 1.0f\n#define VOXEL_SIZE_Z 1.0f\n#define COORDINATES_MIN_X 0.0f\n#define COORDINATES_MIN_Y 0.0f\n#define COORDINATES_MIN_Z 0.0f\n#define COORDINATES_MAX_X 5.0f\n#define COORDINATES_MAX_Y 5.0f\n#define COORDINATES_MAX_Z 5.0f\n#define GRID_SIZE_X (round((COORDINATES_MAX_X - COORDINATES_MIN_X) / VOXEL_SIZE_X))\n#define GRID_SIZE_Y (round((COORDINATES_MAX_Y - COORDINATES_MIN_Y) / VOXEL_SIZE_Y))\n#define GRID_SIZE_Z (round((COORDINATES_MAX_Z - COORDINATES_MIN_Z) / VOXEL_SIZE_Z))\n\n\n__global__ void dynamic_voxelize_kernel(const float* points, int* coordinates) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= NUM_POINTS) return;\n\n    const float* this_point = points + idx * NUM_FEATURES;\n    int* this_coordinate = coordinates + idx * 3;\n\n    int coordinate_x = floorf((this_point[0] - COORDINATES_MIN_X) / VOXEL_SIZE_X);\n    if (coordinate_x < 0 || coordinate_x >= GRID_SIZE_X) {\n        this_coordinate[0] = -1;\n        return;\n    }\n    int coordinate_y = floorf((this_point[1] - COORDINATES_MIN_Y) / VOXEL_SIZE_Y);\n    if (coordinate_y < 0 || coordinate_y >= GRID_SIZE_Y) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        return;\n    }\n    int coordinate_z = floorf((this_point[2] - COORDINATES_MIN_Z) / VOXEL_SIZE_Z);\n    if (coordinate_z < 0 || coordinate_z >= GRID_SIZE_Z) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        this_coordinate[2] = -1;\n        return;\n    } else {\n        this_coordinate[0] = coordinate_z;\n        this_coordinate[1] = coordinate_y;\n        this_coordinate[2] = coordinate_x;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = NUM_POINTS * NUM_FEATURES;\n    size_t coordinates_size = NUM_POINTS * 3;\n\n    float* h_points = new float[points_size];\n    int* h_coordinates = new int[coordinates_size];\n\n    std::string points_file = \"./data/input_points.bin\";\n    read_binary(points_file, h_points, points_size);\n\n    float* d_points;\n    int* d_coordinates;\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_coordinates, coordinates_size * sizeof(int));\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_coordinates, 0, coordinates_size * sizeof(int));\n\n    int threads_per_block = 256;\n    int num_blocks = (NUM_POINTS + threads_per_block - 1) / threads_per_block;\n    dynamic_voxelize_kernel<<<num_blocks, threads_per_block>>>(d_points, d_coordinates);\n    cudaMemcpy(h_coordinates, d_coordinates, coordinates_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_dynamic_voxelize_coordinates.bin\";\n    write_binary(output_file, h_coordinates, coordinates_size);\n\n    cudaFree(d_points);\n    cudaFree(d_coordinates);\n    delete[] h_points;\n    delete[] h_coordinates;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport math\n\nNUM_POINTS = 2048\nNUM_FEATURES = 5\nVOXEL_SIZE = [1.0, 1.0, 1.0]\nCOORDINATES_MIN = [0.0, 0.0, 0.0]\nCOORDINATES_MAX = [5.0, 5.0, 5.0]\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(NUM_POINTS, NUM_FEATURES) * 7.12\n\ndef dynamic_voxelize_pytorch(points, voxel_size, coordinates_min, coordinates_max):\n    num_points, num_features = points.shape\n    voxel_x, voxel_y, voxel_z = voxel_size\n    x_min, y_min, z_min = coordinates_min\n    x_max, y_max, z_max = coordinates_max\n    grid_size_x = int((x_max - x_min) / voxel_x)\n    grid_size_y = int((y_max - y_min) / voxel_y)\n    grid_size_z = int((z_max - z_min) / voxel_z)\n\n    coordinates = torch.zeros((num_points, 3), dtype=torch.int)\n    for i in range(num_points):\n        this_point = points[i]\n        coordinate_x = math.floor((this_point[0] - x_min) / voxel_x)\n        if coordinate_x < 0 or coordinate_x >= grid_size_x:\n            coordinates[i][0] = -1\n            continue\n        coordinate_y = math.floor((this_point[1] - y_min) / voxel_y)\n        if coordinate_y < 0 or coordinate_y >= grid_size_y:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            continue\n        coordinate_z = math.floor((this_point[2] - z_min) / voxel_z)\n        if coordinate_z < 0 or coordinate_z >= grid_size_z:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            coordinates[i][2] = -1\n            continue\n        else:\n            coordinates[i][0] = coordinate_z\n            coordinates[i][1] = coordinate_y\n            coordinates[i][2] = coordinate_x\n    return coordinates\n\ncoordinates = dynamic_voxelize_pytorch(points, VOXEL_SIZE, COORDINATES_MIN, COORDINATES_MAX)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\ncoordinates.numpy().tofile(\"./data/expected_dynamic_voxelize_coordinates.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    NUM_POINTS = 2048\n    total_size = NUM_POINTS * 3\n\n    output_file = \"./data/output_dynamic_voxelize_coordinates.bin\"\n    ref_file = \"./data/expected_dynamic_voxelize_coordinates.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Dynamic_Voxelize. Compute the voxel coordinates for each point in a 3D grid. The input is a tensor of shape (2048, 5) with dtype float32, representing points with 5 features. The output is a tensor of shape (6144,) with dtype int32, storing 3 integers per point for the voxel coordinates. Use fixed voxel sizes of 1.0 in each dimension and coordinate ranges from min [0.0, 0.0, 0.0] to max [5.0, 5.0, 5.0], resulting in a grid size of 5 in each dimension. For each point, if the computed x-coordinate is out of bounds (less than 0 or >=5), set all three output coordinates to -1. If y is out of bounds after a valid x, set to -1. Similarly for z. If all coordinates are valid, store them as (z, y, x) for the point. Ensure the output matches the shape and data type.", "level2_prompt": "Task name: Dynamic_Voxelize. For each input point with coordinates (x, y, z), compute the voxel indices: idx_x = floor((x - 0) / 1.0), idx_y = floor((y - 0) / 1.0), idx_z = floor((z - 0) / 1.0). If idx_x < 0 or idx_x >= 5, set the output for that point to (-1, -1, -1). Otherwise, if idx_y < 0 or idx_y >= 5, set to (-1, -1, -1). Otherwise, if idx_z < 0 or idx_z >= 5, set to (-1, -1, -1). Else, store (idx_z, idx_y, idx_x) for the point. The output is a flattened array of these triples.", "level3_prompt": "Compute voxel coordinates for points in a 3D grid."}
{"id": 397, "task_name": "Dynamic_Voxelize", "task_description": "Compute the Dynamic_Voxelize kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(4096, 5)"}], "outputs": [{"name": "output_dynamic_voxelize_coordinates", "dtype": "int32", "shape": "(4096, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define NUM_POINTS 4096\n#define NUM_FEATURES 5\n#define VOXEL_SIZE_X 1.0f\n#define VOXEL_SIZE_Y 1.0f\n#define VOXEL_SIZE_Z 1.0f\n#define COORDINATES_MIN_X 0.0f\n#define COORDINATES_MIN_Y 0.0f\n#define COORDINATES_MIN_Z 0.0f\n#define COORDINATES_MAX_X 5.0f\n#define COORDINATES_MAX_Y 5.0f\n#define COORDINATES_MAX_Z 5.0f\n#define GRID_SIZE_X (round((COORDINATES_MAX_X - COORDINATES_MIN_X) / VOXEL_SIZE_X))\n#define GRID_SIZE_Y (round((COORDINATES_MAX_Y - COORDINATES_MIN_Y) / VOXEL_SIZE_Y))\n#define GRID_SIZE_Z (round((COORDINATES_MAX_Z - COORDINATES_MIN_Z) / VOXEL_SIZE_Z))\n\n\n__global__ void dynamic_voxelize_kernel(const float* points, int* coordinates) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= NUM_POINTS) return;\n\n    const float* this_point = points + idx * NUM_FEATURES;\n    int* this_coordinate = coordinates + idx * 3;\n\n    int coordinate_x = floorf((this_point[0] - COORDINATES_MIN_X) / VOXEL_SIZE_X);\n    if (coordinate_x < 0 || coordinate_x >= GRID_SIZE_X) {\n        this_coordinate[0] = -1;\n        return;\n    }\n    int coordinate_y = floorf((this_point[1] - COORDINATES_MIN_Y) / VOXEL_SIZE_Y);\n    if (coordinate_y < 0 || coordinate_y >= GRID_SIZE_Y) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        return;\n    }\n    int coordinate_z = floorf((this_point[2] - COORDINATES_MIN_Z) / VOXEL_SIZE_Z);\n    if (coordinate_z < 0 || coordinate_z >= GRID_SIZE_Z) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        this_coordinate[2] = -1;\n        return;\n    } else {\n        this_coordinate[0] = coordinate_z;\n        this_coordinate[1] = coordinate_y;\n        this_coordinate[2] = coordinate_x;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = NUM_POINTS * NUM_FEATURES;\n    size_t coordinates_size = NUM_POINTS * 3;\n\n    float* h_points = new float[points_size];\n    int* h_coordinates = new int[coordinates_size];\n\n    std::string points_file = \"./data/input_points.bin\";\n    read_binary(points_file, h_points, points_size);\n\n    float* d_points;\n    int* d_coordinates;\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_coordinates, coordinates_size * sizeof(int));\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_coordinates, 0, coordinates_size * sizeof(int));\n\n    int threads_per_block = 256;\n    int num_blocks = (NUM_POINTS + threads_per_block - 1) / threads_per_block;\n    dynamic_voxelize_kernel<<<num_blocks, threads_per_block>>>(d_points, d_coordinates);\n    cudaMemcpy(h_coordinates, d_coordinates, coordinates_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_dynamic_voxelize_coordinates.bin\";\n    write_binary(output_file, h_coordinates, coordinates_size);\n\n    cudaFree(d_points);\n    cudaFree(d_coordinates);\n    delete[] h_points;\n    delete[] h_coordinates;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport math\n\nNUM_POINTS = 4096\nNUM_FEATURES = 5\nVOXEL_SIZE = [1.0, 1.0, 1.0]\nCOORDINATES_MIN = [0.0, 0.0, 0.0]\nCOORDINATES_MAX = [5.0, 5.0, 5.0]\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(NUM_POINTS, NUM_FEATURES) * 7.12\n\ndef dynamic_voxelize_pytorch(points, voxel_size, coordinates_min, coordinates_max):\n    num_points, num_features = points.shape\n    voxel_x, voxel_y, voxel_z = voxel_size\n    x_min, y_min, z_min = coordinates_min\n    x_max, y_max, z_max = coordinates_max\n    grid_size_x = int((x_max - x_min) / voxel_x)\n    grid_size_y = int((y_max - y_min) / voxel_y)\n    grid_size_z = int((z_max - z_min) / voxel_z)\n\n    coordinates = torch.zeros((num_points, 3), dtype=torch.int)\n    for i in range(num_points):\n        this_point = points[i]\n        coordinate_x = math.floor((this_point[0] - x_min) / voxel_x)\n        if coordinate_x < 0 or coordinate_x >= grid_size_x:\n            coordinates[i][0] = -1\n            continue\n        coordinate_y = math.floor((this_point[1] - y_min) / voxel_y)\n        if coordinate_y < 0 or coordinate_y >= grid_size_y:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            continue\n        coordinate_z = math.floor((this_point[2] - z_min) / voxel_z)\n        if coordinate_z < 0 or coordinate_z >= grid_size_z:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            coordinates[i][2] = -1\n            continue\n        else:\n            coordinates[i][0] = coordinate_z\n            coordinates[i][1] = coordinate_y\n            coordinates[i][2] = coordinate_x\n    return coordinates\n\ncoordinates = dynamic_voxelize_pytorch(points, VOXEL_SIZE, COORDINATES_MIN, COORDINATES_MAX)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\ncoordinates.numpy().tofile(\"./data/expected_dynamic_voxelize_coordinates.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    NUM_POINTS = 4096\n    total_size = NUM_POINTS * 3\n\n    output_file = \"./data/output_dynamic_voxelize_coordinates.bin\"\n    ref_file = \"./data/expected_dynamic_voxelize_coordinates.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Dynamic_Voxelize. Given 4096 points with 5 features each (float32), compute voxel coordinates for each point in a fixed 3D grid. The grid spans from (0.0, 0.0, 0.0) to (5.0, 5.0, 5.0) with voxel size 1.0 in each dimension. For each point, use the first three features (x,y,z) to compute voxel indices by subtracting the minimum coordinate and dividing by voxel size, then taking the floor. If x is outside [0,5), set the first output coordinate to -1. If x is valid but y is outside [0,5), set the first two output coordinates to -1. If both x and y are valid but z is outside [0,5), set all three output coordinates to -1. For valid points, output voxel indices in (z,y,x) order. Output must be a 4096x3 int32 tensor.", "level2_prompt": "Task: Dynamic_Voxelize. For each point, map its (x,y,z) coordinates to voxel indices using: index = floor((coordinate - min_coordinate) / voxel_size). Check indices sequentially: if x is invalid, output (-1,0,0); if x valid but y invalid, output (-1,-1,0); if x and y valid but z invalid, output (-1,-1,-1); else output (z_index,y_index,x_index). Grid bounds are [0,5) in all dimensions.", "level3_prompt": "Compute voxel coordinates for 3D points in a fixed grid, marking invalid points."}
{"id": 398, "task_name": "Dynamic_Voxelize", "task_description": "Compute the Dynamic_Voxelize kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(8192, 5)"}], "outputs": [{"name": "output_dynamic_voxelize_coordinates", "dtype": "int32", "shape": "(8192, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define NUM_POINTS 8192\n#define NUM_FEATURES 5\n#define VOXEL_SIZE_X 1.0f\n#define VOXEL_SIZE_Y 1.0f\n#define VOXEL_SIZE_Z 1.0f\n#define COORDINATES_MIN_X 0.0f\n#define COORDINATES_MIN_Y 0.0f\n#define COORDINATES_MIN_Z 0.0f\n#define COORDINATES_MAX_X 5.0f\n#define COORDINATES_MAX_Y 5.0f\n#define COORDINATES_MAX_Z 5.0f\n#define GRID_SIZE_X (round((COORDINATES_MAX_X - COORDINATES_MIN_X) / VOXEL_SIZE_X))\n#define GRID_SIZE_Y (round((COORDINATES_MAX_Y - COORDINATES_MIN_Y) / VOXEL_SIZE_Y))\n#define GRID_SIZE_Z (round((COORDINATES_MAX_Z - COORDINATES_MIN_Z) / VOXEL_SIZE_Z))\n\n\n__global__ void dynamic_voxelize_kernel(const float* points, int* coordinates) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= NUM_POINTS) return;\n\n    const float* this_point = points + idx * NUM_FEATURES;\n    int* this_coordinate = coordinates + idx * 3;\n\n    int coordinate_x = floorf((this_point[0] - COORDINATES_MIN_X) / VOXEL_SIZE_X);\n    if (coordinate_x < 0 || coordinate_x >= GRID_SIZE_X) {\n        this_coordinate[0] = -1;\n        return;\n    }\n    int coordinate_y = floorf((this_point[1] - COORDINATES_MIN_Y) / VOXEL_SIZE_Y);\n    if (coordinate_y < 0 || coordinate_y >= GRID_SIZE_Y) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        return;\n    }\n    int coordinate_z = floorf((this_point[2] - COORDINATES_MIN_Z) / VOXEL_SIZE_Z);\n    if (coordinate_z < 0 || coordinate_z >= GRID_SIZE_Z) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        this_coordinate[2] = -1;\n        return;\n    } else {\n        this_coordinate[0] = coordinate_z;\n        this_coordinate[1] = coordinate_y;\n        this_coordinate[2] = coordinate_x;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = NUM_POINTS * NUM_FEATURES;\n    size_t coordinates_size = NUM_POINTS * 3;\n\n    float* h_points = new float[points_size];\n    int* h_coordinates = new int[coordinates_size];\n\n    std::string points_file = \"./data/input_points.bin\";\n    read_binary(points_file, h_points, points_size);\n\n    float* d_points;\n    int* d_coordinates;\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_coordinates, coordinates_size * sizeof(int));\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_coordinates, 0, coordinates_size * sizeof(int));\n\n    int threads_per_block = 256;\n    int num_blocks = (NUM_POINTS + threads_per_block - 1) / threads_per_block;\n    dynamic_voxelize_kernel<<<num_blocks, threads_per_block>>>(d_points, d_coordinates);\n    cudaMemcpy(h_coordinates, d_coordinates, coordinates_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_dynamic_voxelize_coordinates.bin\";\n    write_binary(output_file, h_coordinates, coordinates_size);\n\n    cudaFree(d_points);\n    cudaFree(d_coordinates);\n    delete[] h_points;\n    delete[] h_coordinates;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport math\n\nNUM_POINTS = 8192\nNUM_FEATURES = 5\nVOXEL_SIZE = [1.0, 1.0, 1.0]\nCOORDINATES_MIN = [0.0, 0.0, 0.0]\nCOORDINATES_MAX = [5.0, 5.0, 5.0]\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(NUM_POINTS, NUM_FEATURES) * 7.12\n\ndef dynamic_voxelize_pytorch(points, voxel_size, coordinates_min, coordinates_max):\n    num_points, num_features = points.shape\n    voxel_x, voxel_y, voxel_z = voxel_size\n    x_min, y_min, z_min = coordinates_min\n    x_max, y_max, z_max = coordinates_max\n    grid_size_x = int((x_max - x_min) / voxel_x)\n    grid_size_y = int((y_max - y_min) / voxel_y)\n    grid_size_z = int((z_max - z_min) / voxel_z)\n\n    coordinates = torch.zeros((num_points, 3), dtype=torch.int)\n    for i in range(num_points):\n        this_point = points[i]\n        coordinate_x = math.floor((this_point[0] - x_min) / voxel_x)\n        if coordinate_x < 0 or coordinate_x >= grid_size_x:\n            coordinates[i][0] = -1\n            continue\n        coordinate_y = math.floor((this_point[1] - y_min) / voxel_y)\n        if coordinate_y < 0 or coordinate_y >= grid_size_y:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            continue\n        coordinate_z = math.floor((this_point[2] - z_min) / voxel_z)\n        if coordinate_z < 0 or coordinate_z >= grid_size_z:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            coordinates[i][2] = -1\n            continue\n        else:\n            coordinates[i][0] = coordinate_z\n            coordinates[i][1] = coordinate_y\n            coordinates[i][2] = coordinate_x\n    return coordinates\n\ncoordinates = dynamic_voxelize_pytorch(points, VOXEL_SIZE, COORDINATES_MIN, COORDINATES_MAX)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\ncoordinates.numpy().tofile(\"./data/expected_dynamic_voxelize_coordinates.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    NUM_POINTS = 8192\n    total_size = NUM_POINTS * 3\n\n    output_file = \"./data/output_dynamic_voxelize_coordinates.bin\"\n    ref_file = \"./data/expected_dynamic_voxelize_coordinates.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named Dynamic_Voxelize that assigns each input point to a voxel in a predefined 3D grid. The input is a tensor with shape (8192, 5) of float32 values, where only the first three elements (x, y, z) are used. The grid spans from (0.0, 0.0, 0.0) to (5.0, 5.0, 5.0) with voxel size 1.0 in all dimensions. For each point, compute integer voxel coordinates by subtracting the grid minimum and dividing by the voxel size. If the point lies outside the grid boundaries in any dimension, output (-1, -1, -1). Otherwise, output the voxel coordinates as (z, y, x). The output tensor must be of shape (8192, 3) with int32 data type.", "level2_prompt": "The Dynamic_Voxelize kernel processes 8192 points to determine their voxel coordinates in a 5x5x5 grid starting at (0,0,0). For each point: subtract the grid's minimum coordinate from x, y, z; divide each result by the voxel size (1.0); take the floor to get integer indices. If any index is negative or exceeds the grid size (5), set all output coordinates to -1. Otherwise, assign the output as (z_index, y_index, x_index).", "level3_prompt": "Compute voxel coordinates for input points in a fixed 3D grid, marking out-of-bound points with -1."}
{"id": 399, "task_name": "Dynamic_Voxelize", "task_description": "Compute the Dynamic_Voxelize kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(16384, 5)"}], "outputs": [{"name": "output_dynamic_voxelize_coordinates", "dtype": "int32", "shape": "(16384, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define NUM_POINTS 16384\n#define NUM_FEATURES 5\n#define VOXEL_SIZE_X 1.0f\n#define VOXEL_SIZE_Y 1.0f\n#define VOXEL_SIZE_Z 1.0f\n#define COORDINATES_MIN_X 0.0f\n#define COORDINATES_MIN_Y 0.0f\n#define COORDINATES_MIN_Z 0.0f\n#define COORDINATES_MAX_X 5.0f\n#define COORDINATES_MAX_Y 5.0f\n#define COORDINATES_MAX_Z 5.0f\n#define GRID_SIZE_X (round((COORDINATES_MAX_X - COORDINATES_MIN_X) / VOXEL_SIZE_X))\n#define GRID_SIZE_Y (round((COORDINATES_MAX_Y - COORDINATES_MIN_Y) / VOXEL_SIZE_Y))\n#define GRID_SIZE_Z (round((COORDINATES_MAX_Z - COORDINATES_MIN_Z) / VOXEL_SIZE_Z))\n\n\n__global__ void dynamic_voxelize_kernel(const float* points, int* coordinates) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx >= NUM_POINTS) return;\n\n    const float* this_point = points + idx * NUM_FEATURES;\n    int* this_coordinate = coordinates + idx * 3;\n\n    int coordinate_x = floorf((this_point[0] - COORDINATES_MIN_X) / VOXEL_SIZE_X);\n    if (coordinate_x < 0 || coordinate_x >= GRID_SIZE_X) {\n        this_coordinate[0] = -1;\n        return;\n    }\n    int coordinate_y = floorf((this_point[1] - COORDINATES_MIN_Y) / VOXEL_SIZE_Y);\n    if (coordinate_y < 0 || coordinate_y >= GRID_SIZE_Y) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        return;\n    }\n    int coordinate_z = floorf((this_point[2] - COORDINATES_MIN_Z) / VOXEL_SIZE_Z);\n    if (coordinate_z < 0 || coordinate_z >= GRID_SIZE_Z) {\n        this_coordinate[0] = -1;\n        this_coordinate[1] = -1;\n        this_coordinate[2] = -1;\n        return;\n    } else {\n        this_coordinate[0] = coordinate_z;\n        this_coordinate[1] = coordinate_y;\n        this_coordinate[2] = coordinate_x;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = NUM_POINTS * NUM_FEATURES;\n    size_t coordinates_size = NUM_POINTS * 3;\n\n    float* h_points = new float[points_size];\n    int* h_coordinates = new int[coordinates_size];\n\n    std::string points_file = \"./data/input_points.bin\";\n    read_binary(points_file, h_points, points_size);\n\n    float* d_points;\n    int* d_coordinates;\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_coordinates, coordinates_size * sizeof(int));\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_coordinates, 0, coordinates_size * sizeof(int));\n\n    int threads_per_block = 256;\n    int num_blocks = (NUM_POINTS + threads_per_block - 1) / threads_per_block;\n    dynamic_voxelize_kernel<<<num_blocks, threads_per_block>>>(d_points, d_coordinates);\n    cudaMemcpy(h_coordinates, d_coordinates, coordinates_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_dynamic_voxelize_coordinates.bin\";\n    write_binary(output_file, h_coordinates, coordinates_size);\n\n    cudaFree(d_points);\n    cudaFree(d_coordinates);\n    delete[] h_points;\n    delete[] h_coordinates;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport math\n\nNUM_POINTS = 16384\nNUM_FEATURES = 5\nVOXEL_SIZE = [1.0, 1.0, 1.0]\nCOORDINATES_MIN = [0.0, 0.0, 0.0]\nCOORDINATES_MAX = [5.0, 5.0, 5.0]\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(NUM_POINTS, NUM_FEATURES) * 7.12\n\ndef dynamic_voxelize_pytorch(points, voxel_size, coordinates_min, coordinates_max):\n    num_points, num_features = points.shape\n    voxel_x, voxel_y, voxel_z = voxel_size\n    x_min, y_min, z_min = coordinates_min\n    x_max, y_max, z_max = coordinates_max\n    grid_size_x = int((x_max - x_min) / voxel_x)\n    grid_size_y = int((y_max - y_min) / voxel_y)\n    grid_size_z = int((z_max - z_min) / voxel_z)\n\n    coordinates = torch.zeros((num_points, 3), dtype=torch.int)\n    for i in range(num_points):\n        this_point = points[i]\n        coordinate_x = math.floor((this_point[0] - x_min) / voxel_x)\n        if coordinate_x < 0 or coordinate_x >= grid_size_x:\n            coordinates[i][0] = -1\n            continue\n        coordinate_y = math.floor((this_point[1] - y_min) / voxel_y)\n        if coordinate_y < 0 or coordinate_y >= grid_size_y:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            continue\n        coordinate_z = math.floor((this_point[2] - z_min) / voxel_z)\n        if coordinate_z < 0 or coordinate_z >= grid_size_z:\n            coordinates[i][0] = -1\n            coordinates[i][1] = -1\n            coordinates[i][2] = -1\n            continue\n        else:\n            coordinates[i][0] = coordinate_z\n            coordinates[i][1] = coordinate_y\n            coordinates[i][2] = coordinate_x\n    return coordinates\n\ncoordinates = dynamic_voxelize_pytorch(points, VOXEL_SIZE, COORDINATES_MIN, COORDINATES_MAX)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\ncoordinates.numpy().tofile(\"./data/expected_dynamic_voxelize_coordinates.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    NUM_POINTS = 16384\n    total_size = NUM_POINTS * 3\n\n    output_file = \"./data/output_dynamic_voxelize_coordinates.bin\"\n    ref_file = \"./data/expected_dynamic_voxelize_coordinates.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Dynamic_Voxelize. Description: Assign each 3D point to a voxel in a fixed grid. The grid spans coordinates (0.0, 0.0, 0.0) to (5.0, 5.0, 5.0) with 1.0-unit voxel sizes. Input is a float32 tensor of shape (16384, 5), where only the first three features (x, y, z) are used. For each point, compute voxel indices by subtracting min coordinates and dividing by voxel size. If x-coordinate is out-of-bounds, output (-1, 0, 0); if y is out-of-bounds, output (-1, -1, 0); if z is out-of-bounds, output (-1, -1, -1); otherwise output (z_index, y_index, x_index). Output must be an int32 tensor of shape (16384, 3).", "level2_prompt": "Task: Dynamic_Voxelize. For each input point (16384 points with 5 float32 features), compute voxel coordinates in a 5x5x5 grid spanning [0,5] in each dimension. Using the first three features (x,y,z), calculate indices via: index = floor((coordinate - min) / voxel_size). Handle boundaries: invalid x yields (-1,0,0); valid x but invalid y yields (-1,-1,0); valid x,y but invalid z yields (-1,-1,-1); valid coordinates yield (z,y,x) indices.", "level3_prompt": "Voxelize 3D points into a fixed grid with boundary checks."}
{"id": 400, "task_name": "Furthest_Point_Sample", "task_description": "Compute the Furthest_Point_Sample kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(8, 128, 3)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 128\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_kernel(const float* points, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_points = points + bs_idx * NUM_POINTS * 3;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        float x1 = this_points[old_best_idx * 3 + 0];\n        float y1 = this_points[old_best_idx * 3 + 1];\n        float z1 = this_points[old_best_idx * 3 + 2];\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float x2 = this_points[n * 3 + 0];\n            float y2 = this_points[n * 3 + 1];\n            float z2 = this_points[n * 3 + 2];\n            float dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_points = new float[points_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_points.bin\", h_points, points_size);\n\n    float* d_points;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7f, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_kernel<<<BATCH_SIZE, 512>>>(d_points, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_points);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_points;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 128\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\n\ndef furthest_point_sample_pytorch(points, num_samples):\n    B, N, _ = points.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dist = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for j in range(1, num_samples):\n            x1, y1, z1 = points[b, old_best_idx]\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                x2, y2, z2 = points[b, n]\n                dist = (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2\n                dist = min(dist, temp_dist[b, n])\n                temp_dist[b, n] = dist\n                if dist > best_dist:\n                    best_idx = n\n                    best_dist = dist\n            sampled[b, j] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_pytorch(points, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Furthest_Point_Sample. The kernel should perform furthest point sampling on a batch of 8 point clouds, each containing 128 points in 3D space. The input is a float32 tensor of shape (8, 128, 3). The algorithm must start by selecting index 0 as the first sample for each cloud. For each subsequent sample (31 more per cloud), it should compute the squared Euclidean distance from every point to the last selected sample, update the minimum distance to any selected sample, and select the point with the maximum updated distance. The output is a float32 tensor of shape (1,).", "level2_prompt": "Furthest_Point_Sample: For each of 8 point clouds (128 points each), initialize with sample index 0. For 31 additional samples per cloud, update each point's minimum squared Euclidean distance to existing samples and select the point with maximum distance. Output a tensor of shape (1,).", "level3_prompt": "Compute the Furthest_Point_Sample kernel on GPU using CUDA."}
{"id": 401, "task_name": "Furthest_Point_Sample", "task_description": "Compute the Furthest_Point_Sample kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(8, 256, 3)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "int32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 256\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_kernel(const float* points, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_points = points + bs_idx * NUM_POINTS * 3;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        float x1 = this_points[old_best_idx * 3 + 0];\n        float y1 = this_points[old_best_idx * 3 + 1];\n        float z1 = this_points[old_best_idx * 3 + 2];\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float x2 = this_points[n * 3 + 0];\n            float y2 = this_points[n * 3 + 1];\n            float z2 = this_points[n * 3 + 2];\n            float dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_points = new float[points_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_points.bin\", h_points, points_size);\n\n    float* d_points;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7f, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_kernel<<<BATCH_SIZE, 512>>>(d_points, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_points);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_points;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 256\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\n\ndef furthest_point_sample_pytorch(points, num_samples):\n    B, N, _ = points.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dist = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for j in range(1, num_samples):\n            x1, y1, z1 = points[b, old_best_idx]\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                x2, y2, z2 = points[b, n]\n                dist = (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2\n                dist = min(dist, temp_dist[b, n])\n                temp_dist[b, n] = dist\n                if dist > best_dist:\n                    best_idx = n\n                    best_dist = dist\n            sampled[b, j] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_pytorch(points, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Furthest_Point_Sample. Perform furthest point sampling on batches of 3D points to select a subset of points maximally distant from each other. The input is a float32 tensor of shape (8, 256, 3), representing 8 batches of 256 points with 3D coordinates. The output is an int32 tensor of shape (8, 32) containing indices of the selected points in each batch. Constraints: Each batch must be processed independently, starting with index 0 as the first sample. For each subsequent sample, update the minimum distance of all points to the current sample set and select the point with the maximum updated distance. Exactly 32 points must be sampled per batch.", "level2_prompt": "Task name: Furthest_Point_Sample. For each batch, initialize by selecting index 0. Iteratively select 31 additional points: for each candidate point, compute the squared Euclidean distance to the last selected point, update its minimum distance to any selected point, and choose the point with the largest updated distance as the next sample.", "level3_prompt": "Compute the Furthest_Point_Sample kernel on GPU using CUDA."}
{"id": 402, "task_name": "Furthest_Point_Sample", "task_description": "Compute the Furthest_Point_Sample kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(8, 512, 3)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "int32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 512\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_kernel(const float* points, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_points = points + bs_idx * NUM_POINTS * 3;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        float x1 = this_points[old_best_idx * 3 + 0];\n        float y1 = this_points[old_best_idx * 3 + 1];\n        float z1 = this_points[old_best_idx * 3 + 2];\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float x2 = this_points[n * 3 + 0];\n            float y2 = this_points[n * 3 + 1];\n            float z2 = this_points[n * 3 + 2];\n            float dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_points = new float[points_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_points.bin\", h_points, points_size);\n\n    float* d_points;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7f, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_kernel<<<BATCH_SIZE, 512>>>(d_points, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_points);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_points;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 512\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\n\ndef furthest_point_sample_pytorch(points, num_samples):\n    B, N, _ = points.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dist = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for j in range(1, num_samples):\n            x1, y1, z1 = points[b, old_best_idx]\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                x2, y2, z2 = points[b, n]\n                dist = (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2\n                dist = min(dist, temp_dist[b, n])\n                temp_dist[b, n] = dist\n                if dist > best_dist:\n                    best_idx = n\n                    best_dist = dist\n            sampled[b, j] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_pytorch(points, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Furthest_Point_Sample kernel. The kernel processes a batch of 8 point clouds, each containing 512 points in 3D space (x, y, z). For each point cloud, the kernel should select 32 points that are maximally distant from each other. The algorithm starts by selecting the first point (index 0) and then iteratively selects the point with the maximum minimum distance to the already selected set. The input is a float32 tensor of shape (8, 512, 3). The output is an int32 tensor of shape (8, 32) containing the indices of the selected points for each batch. The kernel must use a temporary distance array per batch, initialized to a large value, and update it at each step by taking the minimum between the current distance and the distance to the last selected point. The next selected point is the one with the maximum value in this temporary array.", "level2_prompt": "The task is Furthest_Point_Sample. For each batch of 512 3D points, initialize a distance array to a large value. Start by selecting the first point (index 0). Then, for each of the remaining 31 samples: compute the squared Euclidean distance from every point to the last selected point; for each point, update its distance to the minimum of its current distance and this new distance; then select the point with the maximum updated distance. Record the index of each selected point. The output is a list of 32 indices per batch.", "level3_prompt": "Compute the Furthest_Point_Sample kernel on GPU using CUDA."}
{"id": 403, "task_name": "Furthest_Point_Sample", "task_description": "Compute the Furthest_Point_Sample kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(8, 1024, 3)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 1024\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_kernel(const float* points, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_points = points + bs_idx * NUM_POINTS * 3;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        float x1 = this_points[old_best_idx * 3 + 0];\n        float y1 = this_points[old_best_idx * 3 + 1];\n        float z1 = this_points[old_best_idx * 3 + 2];\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float x2 = this_points[n * 3 + 0];\n            float y2 = this_points[n * 3 + 1];\n            float z2 = this_points[n * 3 + 2];\n            float dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_points = new float[points_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_points.bin\", h_points, points_size);\n\n    float* d_points;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7f, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_kernel<<<BATCH_SIZE, 512>>>(d_points, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_points);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_points;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 1024\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\n\ndef furthest_point_sample_pytorch(points, num_samples):\n    B, N, _ = points.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dist = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for j in range(1, num_samples):\n            x1, y1, z1 = points[b, old_best_idx]\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                x2, y2, z2 = points[b, n]\n                dist = (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2\n                dist = min(dist, temp_dist[b, n])\n                temp_dist[b, n] = dist\n                if dist > best_dist:\n                    best_idx = n\n                    best_dist = dist\n            sampled[b, j] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_pytorch(points, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Furthest_Point_Sample kernel. The input is a float32 tensor named 'input_points' with shape (8, 1024, 3), representing 8 batches of 1024 points in 3D space. The output is a float32 tensor named 'output_sampled_indices' with shape (1,). The kernel must perform furthest point sampling to select 32 points per batch. The algorithm starts by selecting the point at index 0 in each batch. Then, for each subsequent sample, it selects the point that has the maximum minimum distance to the set of already selected points. The kernel must maintain a temporary distance array for each point to track the minimum distance to the selected set. The output is a single float32 value, which is the result of the sampling process.", "level2_prompt": "Implement the Furthest_Point_Sample algorithm for 3D point clouds. Given a batch of 8 point clouds, each containing 1024 points, sample 32 points per batch by iteratively selecting the point that is furthest from the current set of selected points. The output is a single float32 value.", "level3_prompt": "Compute the Furthest_Point_Sample kernel on GPU using CUDA."}
{"id": 404, "task_name": "Furthest_Point_Sample", "task_description": "Compute the Furthest_Point_Sample kernel on GPU using CUDA.", "inputs": [{"name": "input_points", "dtype": "float32", "shape": "(8, 2048, 3)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 2048\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_kernel(const float* points, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_points = points + bs_idx * NUM_POINTS * 3;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        float x1 = this_points[old_best_idx * 3 + 0];\n        float y1 = this_points[old_best_idx * 3 + 1];\n        float z1 = this_points[old_best_idx * 3 + 2];\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float x2 = this_points[n * 3 + 0];\n            float y2 = this_points[n * 3 + 1];\n            float z2 = this_points[n * 3 + 2];\n            float dist = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1);\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t points_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_points = new float[points_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_points.bin\", h_points, points_size);\n\n    float* d_points;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_points, points_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_points, h_points, points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7f, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_kernel<<<BATCH_SIZE, 512>>>(d_points, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_points);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_points;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 2048\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoints = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\n\ndef furthest_point_sample_pytorch(points, num_samples):\n    B, N, _ = points.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dist = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for j in range(1, num_samples):\n            x1, y1, z1 = points[b, old_best_idx]\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                x2, y2, z2 = points[b, n]\n                dist = (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2\n                dist = min(dist, temp_dist[b, n])\n                temp_dist[b, n] = dist\n                if dist > best_dist:\n                    best_idx = n\n                    best_dist = dist\n            sampled[b, j] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_pytorch(points, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoints.numpy().tofile(\"./data/input_points.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Furthest_Point_Sample. Implement a CUDA kernel for furthest point sampling. The input is a tensor 'input_points' of shape (8, 2048, 3) and dtype float32, containing 8 batches of 2048 points in 3D space. The kernel must select 32 points per batch by iteratively choosing the point with the maximum minimum distance to the current set of selected points, starting with index 0 for each batch. The output is a tensor 'output_sampled_indices' of shape (1,) and dtype float32. The kernel must run on the GPU and process batches independently.", "level2_prompt": "Perform iterative furthest point sampling on 8 batches of 2048 points in 3D space. For each batch, initialize by selecting index 0. Then, for each subsequent sample, compute the minimum Euclidean distance from every point to the selected set and choose the point with the maximum such distance. Output a single float32 value.", "level3_prompt": "Compute the Furthest_Point_Sample kernel on GPU using CUDA."}
{"id": 405, "task_name": "Furthest_Point_Sample_with_Dist", "task_description": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA.", "inputs": [{"name": "input_point_dists", "dtype": "float32", "shape": "(8, 128, 128)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "float32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 128\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_with_dist_kernel(const float* point_dists, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_point_dists = point_dists + bs_idx * NUM_POINTS * NUM_POINTS;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float dist = this_point_dists[old_best_idx * NUM_POINTS + n];\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t point_dists_size = BATCH_SIZE * NUM_POINTS * NUM_POINTS;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_point_dists = new float[point_dists_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_point_dists.bin\", h_point_dists, point_dists_size);\n\n    float* d_point_dists;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_point_dists, point_dists_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_point_dists, h_point_dists, point_dists_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7F, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_with_dist_kernel<<<BATCH_SIZE, 512>>>(d_point_dists, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_point_dists);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_point_dists;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 128\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoint_dists = torch.rand(BATCH_SIZE, NUM_POINTS, NUM_POINTS) * 7.12\n\ndef furthest_point_sample_with_dist_pytorch(point_dists, num_samples):\n    B, N, _ = point_dists.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dists = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for i in range(1, num_samples):\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                dist = point_dists[b, old_best_idx, n]\n                dist = min(dist, temp_dists[b, n])\n                temp_dists[b, n] = dist\n                if dist > best_dist:\n                    best_dist = dist\n                    best_idx = n\n            sampled[b, i] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_with_dist_pytorch(point_dists, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoint_dists.numpy().tofile(\"./data/input_point_dists.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Furthest_Point_Sample_with_Dist. Given an input tensor of shape (8, 128, 128) with dtype float32 representing pairwise distances between points across 8 batches (each with 128 points), output a tensor of shape (8, 32) with dtype float32 containing the indices of 32 sampled points per batch. The kernel must implement iterative furthest point sampling: start with point index 0, then repeatedly select the point with the maximum minimum distance to the already-sampled set. For each new selection, update minimum distances by comparing existing values against distances from the latest sampled point. Batches must be processed independently.", "level2_prompt": "Task: Furthest_Point_Sample_with_Dist. For each of 8 batches, initialize a distance array for 128 points with large values. Start by sampling index 0. For subsequent 31 samples: update each point's minimum distance to the sampled set by taking the smaller value between its current distance and the distance from the latest sampled point. Then select the point with the largest updated distance as the next sample. Output the 32 sampled indices per batch.", "level3_prompt": "Compute furthest point sampling with distance matrices for 8 batches of 128 points, outputting 32 sampled indices per batch."}
{"id": 406, "task_name": "Furthest_Point_Sample_with_Dist", "task_description": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA.", "inputs": [{"name": "input_point_dists", "dtype": "float32", "shape": "(8, 256, 256)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "int32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 256\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_with_dist_kernel(const float* point_dists, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_point_dists = point_dists + bs_idx * NUM_POINTS * NUM_POINTS;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float dist = this_point_dists[old_best_idx * NUM_POINTS + n];\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t point_dists_size = BATCH_SIZE * NUM_POINTS * NUM_POINTS;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_point_dists = new float[point_dists_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_point_dists.bin\", h_point_dists, point_dists_size);\n\n    float* d_point_dists;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_point_dists, point_dists_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_point_dists, h_point_dists, point_dists_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7F, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_with_dist_kernel<<<BATCH_SIZE, 512>>>(d_point_dists, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_point_dists);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_point_dists;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 256\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoint_dists = torch.rand(BATCH_SIZE, NUM_POINTS, NUM_POINTS) * 7.12\n\ndef furthest_point_sample_with_dist_pytorch(point_dists, num_samples):\n    B, N, _ = point_dists.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dists = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for i in range(1, num_samples):\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                dist = point_dists[b, old_best_idx, n]\n                dist = min(dist, temp_dists[b, n])\n                temp_dists[b, n] = dist\n                if dist > best_dist:\n                    best_dist = dist\n                    best_idx = n\n            sampled[b, i] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_with_dist_pytorch(point_dists, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoint_dists.numpy().tofile(\"./data/input_point_dists.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Furthest Point Sample with Dist: Implement a kernel that performs iterative furthest point sampling based on pairwise distances. The input is a 3D tensor of float32 values with shape (8, 256, 256), representing 8 batches where each batch contains a 256x256 matrix of distances between every point pair. The output should be a 2D tensor of int32 values with shape (8, 32), containing indices of 32 sampled points per batch. The kernel must start by selecting point 0 as the first sample in each batch. For subsequent samples, it must update a temporary distance array to track the minimum distance from each point to the current selected set and select the point with the maximum such distance. The kernel must handle batches independently and maintain the invariant that each new sample maximizes the minimum distance to existing samples.", "level2_prompt": "Furthest Point Sample with Dist: For each batch, initialize by selecting point index 0. Iteratively select 31 additional points where each new point is chosen as the one with the maximum minimum distance to all previously selected points. Maintain and update a distance array per point that tracks the smallest distance to any selected point. At each iteration, compare candidate distances against this array and select the point with the largest updated distance.", "level3_prompt": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA."}
{"id": 407, "task_name": "Furthest_Point_Sample_with_Dist", "task_description": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA.", "inputs": [{"name": "input_point_dists", "dtype": "float32", "shape": "(8, 512, 512)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "int32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 512\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_with_dist_kernel(const float* point_dists, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_point_dists = point_dists + bs_idx * NUM_POINTS * NUM_POINTS;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float dist = this_point_dists[old_best_idx * NUM_POINTS + n];\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t point_dists_size = BATCH_SIZE * NUM_POINTS * NUM_POINTS;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_point_dists = new float[point_dists_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_point_dists.bin\", h_point_dists, point_dists_size);\n\n    float* d_point_dists;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_point_dists, point_dists_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_point_dists, h_point_dists, point_dists_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7F, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_with_dist_kernel<<<BATCH_SIZE, 512>>>(d_point_dists, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_point_dists);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_point_dists;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 512\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoint_dists = torch.rand(BATCH_SIZE, NUM_POINTS, NUM_POINTS) * 7.12\n\ndef furthest_point_sample_with_dist_pytorch(point_dists, num_samples):\n    B, N, _ = point_dists.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dists = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for i in range(1, num_samples):\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                dist = point_dists[b, old_best_idx, n]\n                dist = min(dist, temp_dists[b, n])\n                temp_dists[b, n] = dist\n                if dist > best_dist:\n                    best_dist = dist\n                    best_idx = n\n            sampled[b, i] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_with_dist_pytorch(point_dists, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoint_dists.numpy().tofile(\"./data/input_point_dists.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Furthest_Point_Sample_with_Dist kernel. Given a 3D float32 tensor of shape (8, 512, 512) representing distance matrices between points for 8 batches, sample 32 points per batch where each new point is the furthest from all previously selected points. The output should be an int32 tensor of shape (8, 32) containing the indices of sampled points. The algorithm must start with index 0 as the first sample and iteratively select points that maximize the minimum distance to existing samples.", "level2_prompt": "Perform iterative furthest point sampling using distance matrices. For each of 8 batches containing 512 points, initialize with point index 0. For each subsequent sample, compute minimum distances from all points to selected points, then select the point with maximum minimum distance. Repeat until 32 points are sampled per batch.", "level3_prompt": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA."}
{"id": 408, "task_name": "Furthest_Point_Sample_with_Dist", "task_description": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA.", "inputs": [{"name": "input_point_dists", "dtype": "float32", "shape": "(8, 1024, 1024)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "int32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 1024\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_with_dist_kernel(const float* point_dists, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_point_dists = point_dists + bs_idx * NUM_POINTS * NUM_POINTS;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float dist = this_point_dists[old_best_idx * NUM_POINTS + n];\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t point_dists_size = BATCH_SIZE * NUM_POINTS * NUM_POINTS;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_point_dists = new float[point_dists_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_point_dists.bin\", h_point_dists, point_dists_size);\n\n    float* d_point_dists;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_point_dists, point_dists_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_point_dists, h_point_dists, point_dists_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7F, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_with_dist_kernel<<<BATCH_SIZE, 512>>>(d_point_dists, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_point_dists);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_point_dists;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 1024\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoint_dists = torch.rand(BATCH_SIZE, NUM_POINTS, NUM_POINTS) * 7.12\n\ndef furthest_point_sample_with_dist_pytorch(point_dists, num_samples):\n    B, N, _ = point_dists.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dists = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for i in range(1, num_samples):\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                dist = point_dists[b, old_best_idx, n]\n                dist = min(dist, temp_dists[b, n])\n                temp_dists[b, n] = dist\n                if dist > best_dist:\n                    best_dist = dist\n                    best_idx = n\n            sampled[b, i] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_with_dist_pytorch(point_dists, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoint_dists.numpy().tofile(\"./data/input_point_dists.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task Name: Furthest_Point_Sample_with_Dist. For each of 8 batches, given a 1024x1024 matrix of pairwise distances between points (float32), select 32 points such that each new point maximizes the minimum distance to already selected points. Start with point index 0. Output the indices (int32) of selected points for each batch in a (8, 32) tensor. Maintain and update a distance array tracking each point's minimum distance to the current selection set.", "level2_prompt": "Task Name: Furthest_Point_Sample_with_Dist. For each batch: initialize a distance array with large values. Start by selecting index 0. For each subsequent sample: update distances by taking the minimum between existing distances and distances from the last selected point. Then select the point with maximum updated distance. Repeat until 32 points are selected.", "level3_prompt": "Perform furthest point sampling with distance matrices to select 32 points from 1024 points for each of 8 batches."}
{"id": 409, "task_name": "Furthest_Point_Sample_with_Dist", "task_description": "Compute the Furthest_Point_Sample_with_Dist kernel on GPU using CUDA.", "inputs": [{"name": "input_point_dists", "dtype": "float32", "shape": "(8, 2048, 2048)"}], "outputs": [{"name": "output_sampled_indices", "dtype": "int32", "shape": "(8, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 8\n#define NUM_POINTS 2048\n#define NUM_SAMPLES 32\n\n\ninline __device__ void __update_max(float* dists, int* dists_idx, int idx1, int idx2) {\n    const float d1 = dists[idx1], d2 = dists[idx2];\n    const int i1 = dists_idx[idx1], i2 = dists_idx[idx2];\n    dists[idx1] = fmaxf(d1, d2);\n    dists_idx[idx1] = d2 > d1 ? i2 : i1;\n}\n\n\n__global__ void furthest_point_sample_with_dist_kernel(const float* point_dists, float* temp_dists, int* sampled_indices) {\n    int bs_idx = blockIdx.x;\n    if (bs_idx >= BATCH_SIZE) return;\n    const int block_size = 512;\n\n    __shared__ float dists[block_size];\n    __shared__ int dists_idx[block_size];\n\n    const float* this_point_dists = point_dists + bs_idx * NUM_POINTS * NUM_POINTS;\n    float* this_temp_dists = temp_dists + bs_idx * NUM_POINTS;\n    int* this_sampled_indices = sampled_indices + bs_idx * NUM_SAMPLES;\n\n    int t_idx = threadIdx.x;\n    int old_best_idx = 0;\n    if (t_idx == 0) this_sampled_indices[0] = old_best_idx;\n    __syncthreads();\n\n    for (int j = 1; j < NUM_SAMPLES; ++j) {\n        int best_idx = 0;\n        float best_dist = -1.0f;\n        for (int n = t_idx; n < NUM_POINTS; n+= block_size) {\n            float dist = this_point_dists[old_best_idx * NUM_POINTS + n];\n            dist = fminf(dist, this_temp_dists[n]);\n            this_temp_dists[n] = dist;\n            if (dist > best_dist) {\n                best_dist = dist;\n                best_idx = n;\n            }\n        }\n        dists[t_idx] = best_dist;\n        dists_idx[t_idx] = best_idx;\n        __syncthreads();\n\n        #pragma unroll\n        for (int block_size_threshold = 512; block_size_threshold >= 2; block_size_threshold >>= 1) {\n            const int t_idx_threshold = block_size_threshold >> 1;\n            if (block_size >= block_size_threshold && t_idx < t_idx_threshold) {\n                __update_max(dists, dists_idx, t_idx, t_idx + t_idx_threshold);\n            }\n            __syncthreads();\n        }\n\n        old_best_idx = dists_idx[0];\n        if (t_idx == 0) this_sampled_indices[j] = old_best_idx;\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t point_dists_size = BATCH_SIZE * NUM_POINTS * NUM_POINTS;\n    size_t temp_dists_size = BATCH_SIZE * NUM_POINTS;\n    size_t sampled_indices_size = BATCH_SIZE * NUM_SAMPLES;\n\n    float* h_point_dists = new float[point_dists_size];\n    float* h_temp_dists = new float[temp_dists_size];\n    int* h_sampled_indices = new int[sampled_indices_size];\n\n    read_binary(\"./data/input_point_dists.bin\", h_point_dists, point_dists_size);\n\n    float* d_point_dists;\n    float* d_temp_dists;\n    int* d_sampled_indices;\n\n    cudaMalloc(&d_point_dists, point_dists_size * sizeof(float));\n    cudaMalloc(&d_temp_dists, temp_dists_size * sizeof(float));\n    cudaMalloc(&d_sampled_indices, sampled_indices_size * sizeof(int));\n\n    cudaMemcpy(d_point_dists, h_point_dists, point_dists_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_temp_dists, 0x7F, temp_dists_size * sizeof(float));\n    cudaMemset(d_sampled_indices, 0, sampled_indices_size * sizeof(int));\n\n    furthest_point_sample_with_dist_kernel<<<BATCH_SIZE, 512>>>(d_point_dists, d_temp_dists, d_sampled_indices);\n\n    cudaMemcpy(h_sampled_indices, d_sampled_indices, sampled_indices_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_sampled_indices.bin\", h_sampled_indices, sampled_indices_size);\n\n    cudaFree(d_point_dists);\n    cudaFree(d_temp_dists);\n    cudaFree(d_sampled_indices);\n    delete[] h_point_dists;\n    delete[] h_temp_dists;\n    delete[] h_sampled_indices;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 8\nNUM_POINTS = 2048\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\npoint_dists = torch.rand(BATCH_SIZE, NUM_POINTS, NUM_POINTS) * 7.12\n\ndef furthest_point_sample_with_dist_pytorch(point_dists, num_samples):\n    B, N, _ = point_dists.shape\n    sampled = torch.zeros(B, num_samples, dtype=torch.int32)\n    temp_dists = torch.zeros(B, N) + 1e10\n\n    for b in range(B):\n        old_best_idx = 0\n        sampled[b, 0] = old_best_idx\n        for i in range(1, num_samples):\n            best_idx, best_dist = 0, -1.0\n            for n in range(N):\n                dist = point_dists[b, old_best_idx, n]\n                dist = min(dist, temp_dists[b, n])\n                temp_dists[b, n] = dist\n                if dist > best_dist:\n                    best_dist = dist\n                    best_idx = n\n            sampled[b, i] = best_idx\n            old_best_idx = best_idx\n    return sampled\n\nsampled_indices = furthest_point_sample_with_dist_pytorch(point_dists, NUM_SAMPLES)\n\nos.makedirs(\"./data\", exist_ok=True)\npoint_dists.numpy().tofile(\"./data/input_point_dists.bin\")\nsampled_indices.numpy().tofile(\"./data/expected_sampled_indices.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 8\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * NUM_SAMPLES\n\n    output_file = \"./data/output_sampled_indices.bin\"\n    ref_file = \"./data/expected_sampled_indices.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Furthest_Point_Sample_with_Dist: Implement a kernel that performs furthest point sampling using distance matrices. The input is a 3D tensor of shape (8, 2048, 2048) containing float32 values representing pairwise distances between points in each batch. The output should be a 2D tensor of shape (8, 32) containing int32 indices of sampled points. For each batch independently, initialize the first sampled point as index 0. For each subsequent sample, update minimum distances between all points and the current sampled set by comparing existing distances with distances from the latest sampled point. Select the point with the maximum updated distance as the next sample. The kernel must process batches in parallel and maintain intermediate distance arrays.", "level2_prompt": "Furthest_Point_Sample_with_Dist: For each of 8 batches, sample 32 points from 2048 points using a greedy algorithm. Start with point 0. For each subsequent sample: 1) Update per-point minimum distances to selected points by taking the minimum between existing distances and distances from the last selected point. 2) Select the point with the maximum updated distance. Repeat until 32 samples are selected per batch.", "level3_prompt": "Compute furthest point sampling with distances for batch processing."}
{"id": 410, "task_name": "Group_Points", "task_description": "Compute the Group_Points kernel on GPU using CUDA.", "inputs": [{"name": "input_features", "dtype": "float32", "shape": "(16, 4, 1024)"}, {"name": "input_indices", "dtype": "int32", "shape": "(16, 32, 32)"}], "outputs": [{"name": "output_grouped_features", "dtype": "float32", "shape": "(16, 4, 32, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define C 4\n#define N 1024\n#define NUM_POINTS 32\n#define NUM_SAMPLES 32\n\n\n__global__ void group_points_kernel(const float* features, const int* indices, float* grouped_features) {\n    int n_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int c_idx = blockIdx.y;\n    int b_idx = blockIdx.z;\n    if (n_idx >= NUM_POINTS * NUM_SAMPLES || c_idx >= C || b_idx >= BATCH_SIZE) return;\n\n    int point_idx = n_idx / NUM_SAMPLES;\n    int sample_idx = n_idx % NUM_SAMPLES;\n\n    const int* idx = indices + b_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n    int in_idx = b_idx * C * N + c_idx * N + idx[0];\n    int out_idx = b_idx * C * NUM_POINTS * NUM_SAMPLES + c_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n\n    grouped_features[out_idx] = features[in_idx];\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t features_size = BATCH_SIZE * C * N;\n    size_t indices_size = BATCH_SIZE * NUM_POINTS * NUM_SAMPLES;\n    size_t output_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES;\n\n    float* h_features = new float[features_size];\n    int* h_indices = new int[indices_size];\n    float* h_output = new float[output_size];\n\n    read_binary(\"./data/input_features.bin\", h_features, features_size);\n    read_binary(\"./data/input_indices.bin\", h_indices, indices_size);\n\n    float *d_features, *d_output;\n    int* d_indices;\n    cudaMalloc(&d_features, features_size * sizeof(float));\n    cudaMalloc(&d_indices, indices_size * sizeof(int));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n\n    cudaMemcpy(d_features, h_features, features_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_indices, h_indices, indices_size * sizeof(int), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_POINTS * NUM_SAMPLES + threads_per_block - 1) / threads_per_block, C, BATCH_SIZE);\n    group_points_kernel<<<blocks, threads_per_block>>>(d_features, d_indices, d_output);\n\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_grouped_features.bin\", h_output, output_size);\n\n    delete[] h_features;\n    delete[] h_indices;\n    delete[] h_output;\n    cudaFree(d_features);\n    cudaFree(d_indices);\n    cudaFree(d_output);\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nC = 4\nN = 1024\nNUM_POINTS = 32\nNUM_SAMPLES = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nfeatures = torch.randn(BATCH_SIZE, C, N) * 7.12\nindices = torch.randint(0, N, (BATCH_SIZE, NUM_POINTS, NUM_SAMPLES), dtype=torch.int32)\n\ndef group_points_pytorch(features, indices):\n    B, C, N = features.shape\n    _, num_points, num_samples = indices.shape\n    grouped_features = torch.zeros(B, C, num_points, num_samples)\n\n    for b in range(B):\n        for c in range(C):\n            for p in range(num_points):\n                for s in range(num_samples):\n                    idx = indices[b, p, s]\n                    grouped_features[b, c, p, s] = features[b, c, idx]\n    return grouped_features\n\ngrouped_features = group_points_pytorch(features, indices)\n\nos.makedirs(\"./data\", exist_ok=True)\nfeatures.numpy().tofile(\"./data/input_features.bin\")\nindices.numpy().tofile(\"./data/input_indices.bin\")\ngrouped_features.numpy().tofile(\"./data/expected_grouped_features.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    C = 4\n    N = 1024\n    NUM_POINTS = 32\n    NUM_SAMPLES = 32\n    total_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES\n\n    output_file = \"./data/output_grouped_features.bin\"\n    ref_file = \"./data/expected_grouped_features.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Group_Points kernel. Given an input_features tensor of shape (16, 4, 1024) containing float32 values and an input_indices tensor of shape (16, 32, 32) containing int32 indices, produce an output_grouped_features tensor of shape (16, 4, 32, 32) with float32 values. For each batch (16), channel (4), point (32), and sample (32), select the feature value from input_features using the index specified in input_indices. The indices must be within valid range [0, 1023] for the last dimension of input_features.", "level2_prompt": "Group_Points operation: For each batch b, channel c, point p, and sample s, set output[b, c, p, s] = input_features[b, c, idx], where idx = input_indices[b, p, s]. The operation maps indices from a (16,32,32) tensor to gather values from a (16,4,1024) tensor, resulting in a (16,4,32,32) output.", "level3_prompt": "Group points based on indices to form grouped features."}
{"id": 411, "task_name": "Group_Points", "task_description": "Compute the Group_Points kernel on GPU using CUDA.", "inputs": [{"name": "input_features", "dtype": "float32", "shape": "(16, 4, 1024)"}, {"name": "input_indices", "dtype": "int32", "shape": "(16, 32, 64)"}], "outputs": [{"name": "output_grouped_features", "dtype": "float32", "shape": "(16, 4, 32, 64)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define C 4\n#define N 1024\n#define NUM_POINTS 32\n#define NUM_SAMPLES 64\n\n\n__global__ void group_points_kernel(const float* features, const int* indices, float* grouped_features) {\n    int n_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int c_idx = blockIdx.y;\n    int b_idx = blockIdx.z;\n    if (n_idx >= NUM_POINTS * NUM_SAMPLES || c_idx >= C || b_idx >= BATCH_SIZE) return;\n\n    int point_idx = n_idx / NUM_SAMPLES;\n    int sample_idx = n_idx % NUM_SAMPLES;\n\n    const int* idx = indices + b_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n    int in_idx = b_idx * C * N + c_idx * N + idx[0];\n    int out_idx = b_idx * C * NUM_POINTS * NUM_SAMPLES + c_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n\n    grouped_features[out_idx] = features[in_idx];\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t features_size = BATCH_SIZE * C * N;\n    size_t indices_size = BATCH_SIZE * NUM_POINTS * NUM_SAMPLES;\n    size_t output_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES;\n\n    float* h_features = new float[features_size];\n    int* h_indices = new int[indices_size];\n    float* h_output = new float[output_size];\n\n    read_binary(\"./data/input_features.bin\", h_features, features_size);\n    read_binary(\"./data/input_indices.bin\", h_indices, indices_size);\n\n    float *d_features, *d_output;\n    int* d_indices;\n    cudaMalloc(&d_features, features_size * sizeof(float));\n    cudaMalloc(&d_indices, indices_size * sizeof(int));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n\n    cudaMemcpy(d_features, h_features, features_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_indices, h_indices, indices_size * sizeof(int), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_POINTS * NUM_SAMPLES + threads_per_block - 1) / threads_per_block, C, BATCH_SIZE);\n    group_points_kernel<<<blocks, threads_per_block>>>(d_features, d_indices, d_output);\n\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_grouped_features.bin\", h_output, output_size);\n\n    delete[] h_features;\n    delete[] h_indices;\n    delete[] h_output;\n    cudaFree(d_features);\n    cudaFree(d_indices);\n    cudaFree(d_output);\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nC = 4\nN = 1024\nNUM_POINTS = 32\nNUM_SAMPLES = 64\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nfeatures = torch.randn(BATCH_SIZE, C, N) * 7.12\nindices = torch.randint(0, N, (BATCH_SIZE, NUM_POINTS, NUM_SAMPLES), dtype=torch.int32)\n\ndef group_points_pytorch(features, indices):\n    B, C, N = features.shape\n    _, num_points, num_samples = indices.shape\n    grouped_features = torch.zeros(B, C, num_points, num_samples)\n\n    for b in range(B):\n        for c in range(C):\n            for p in range(num_points):\n                for s in range(num_samples):\n                    idx = indices[b, p, s]\n                    grouped_features[b, c, p, s] = features[b, c, idx]\n    return grouped_features\n\ngrouped_features = group_points_pytorch(features, indices)\n\nos.makedirs(\"./data\", exist_ok=True)\nfeatures.numpy().tofile(\"./data/input_features.bin\")\nindices.numpy().tofile(\"./data/input_indices.bin\")\ngrouped_features.numpy().tofile(\"./data/expected_grouped_features.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    C = 4\n    N = 1024\n    NUM_POINTS = 32\n    NUM_SAMPLES = 64\n    total_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES\n\n    output_file = \"./data/output_grouped_features.bin\"\n    ref_file = \"./data/expected_grouped_features.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Group_Points. Given an input feature tensor of shape (16, 4, 1024) and an input indices tensor of shape (16, 32, 64), both batched over 16 examples, produce an output tensor of shape (16, 4, 32, 64). For each batch, channel, point, and sample, select the feature value from the input feature tensor at the index specified in the input indices tensor. The indices are guaranteed to be in the range [0, 1023], and the kernel must respect tensor bounds without memory access violations.", "level2_prompt": "Task: Group_Points. For each batch b, channel c, point p, and sample s, retrieve the index i from the input indices tensor at (b, p, s). Copy the feature value from the input feature tensor at (b, c, i) to the output tensor at position (b, c, p, s).", "level3_prompt": "Compute the Group_Points kernel on GPU using CUDA."}
{"id": 412, "task_name": "Group_Points", "task_description": "Compute the Group_Points kernel on GPU using CUDA.", "inputs": [{"name": "input_features", "dtype": "float32", "shape": "(16, 4, 1024)"}, {"name": "input_indices", "dtype": "int32", "shape": "(16, 32, 128)"}], "outputs": [{"name": "output_grouped_features", "dtype": "float32", "shape": "(16, 4, 32, 128)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define C 4\n#define N 1024\n#define NUM_POINTS 32\n#define NUM_SAMPLES 128\n\n\n__global__ void group_points_kernel(const float* features, const int* indices, float* grouped_features) {\n    int n_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int c_idx = blockIdx.y;\n    int b_idx = blockIdx.z;\n    if (n_idx >= NUM_POINTS * NUM_SAMPLES || c_idx >= C || b_idx >= BATCH_SIZE) return;\n\n    int point_idx = n_idx / NUM_SAMPLES;\n    int sample_idx = n_idx % NUM_SAMPLES;\n\n    const int* idx = indices + b_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n    int in_idx = b_idx * C * N + c_idx * N + idx[0];\n    int out_idx = b_idx * C * NUM_POINTS * NUM_SAMPLES + c_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n\n    grouped_features[out_idx] = features[in_idx];\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t features_size = BATCH_SIZE * C * N;\n    size_t indices_size = BATCH_SIZE * NUM_POINTS * NUM_SAMPLES;\n    size_t output_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES;\n\n    float* h_features = new float[features_size];\n    int* h_indices = new int[indices_size];\n    float* h_output = new float[output_size];\n\n    read_binary(\"./data/input_features.bin\", h_features, features_size);\n    read_binary(\"./data/input_indices.bin\", h_indices, indices_size);\n\n    float *d_features, *d_output;\n    int* d_indices;\n    cudaMalloc(&d_features, features_size * sizeof(float));\n    cudaMalloc(&d_indices, indices_size * sizeof(int));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n\n    cudaMemcpy(d_features, h_features, features_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_indices, h_indices, indices_size * sizeof(int), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_POINTS * NUM_SAMPLES + threads_per_block - 1) / threads_per_block, C, BATCH_SIZE);\n    group_points_kernel<<<blocks, threads_per_block>>>(d_features, d_indices, d_output);\n\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_grouped_features.bin\", h_output, output_size);\n\n    delete[] h_features;\n    delete[] h_indices;\n    delete[] h_output;\n    cudaFree(d_features);\n    cudaFree(d_indices);\n    cudaFree(d_output);\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nC = 4\nN = 1024\nNUM_POINTS = 32\nNUM_SAMPLES = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nfeatures = torch.randn(BATCH_SIZE, C, N) * 7.12\nindices = torch.randint(0, N, (BATCH_SIZE, NUM_POINTS, NUM_SAMPLES), dtype=torch.int32)\n\ndef group_points_pytorch(features, indices):\n    B, C, N = features.shape\n    _, num_points, num_samples = indices.shape\n    grouped_features = torch.zeros(B, C, num_points, num_samples)\n\n    for b in range(B):\n        for c in range(C):\n            for p in range(num_points):\n                for s in range(num_samples):\n                    idx = indices[b, p, s]\n                    grouped_features[b, c, p, s] = features[b, c, idx]\n    return grouped_features\n\ngrouped_features = group_points_pytorch(features, indices)\n\nos.makedirs(\"./data\", exist_ok=True)\nfeatures.numpy().tofile(\"./data/input_features.bin\")\nindices.numpy().tofile(\"./data/input_indices.bin\")\ngrouped_features.numpy().tofile(\"./data/expected_grouped_features.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    C = 4\n    N = 1024\n    NUM_POINTS = 32\n    NUM_SAMPLES = 128\n    total_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES\n\n    output_file = \"./data/output_grouped_features.bin\"\n    ref_file = \"./data/expected_grouped_features.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Group_Points. The kernel should group feature points using indices. Inputs include a feature tensor of shape (16, 4, 1024) with float32 data type and an indices tensor of shape (16, 32, 128) with int32 data type. The output is a grouped feature tensor of shape (16, 4, 32, 128) with float32 data type. For each batch, channel, point, and sample, the kernel must use the index value from the input indices tensor to select the corresponding feature value from the input feature tensor and place it in the output tensor. Indices must be within the valid range [0, 1023].", "level2_prompt": "Task name: Group_Points. For each batch index b, channel index c, point index p, and sample index s, retrieve the index value idx from the input indices tensor at position (b, p, s). Then, assign the value from the input feature tensor at position (b, c, idx) to the output tensor at position (b, c, p, s).", "level3_prompt": "Compute the Group_Points kernel on GPU using CUDA."}
{"id": 413, "task_name": "Group_Points", "task_description": "Compute the Group_Points kernel on GPU using CUDA.", "inputs": [{"name": "input_features", "dtype": "float32", "shape": "(16, 4, 1024)"}, {"name": "input_indices", "dtype": "int32", "shape": "(16, 32, 256)"}], "outputs": [{"name": "output_grouped_features", "dtype": "float32", "shape": "(16, 4, 32, 256)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define C 4\n#define N 1024\n#define NUM_POINTS 32\n#define NUM_SAMPLES 256\n\n\n__global__ void group_points_kernel(const float* features, const int* indices, float* grouped_features) {\n    int n_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int c_idx = blockIdx.y;\n    int b_idx = blockIdx.z;\n    if (n_idx >= NUM_POINTS * NUM_SAMPLES || c_idx >= C || b_idx >= BATCH_SIZE) return;\n\n    int point_idx = n_idx / NUM_SAMPLES;\n    int sample_idx = n_idx % NUM_SAMPLES;\n\n    const int* idx = indices + b_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n    int in_idx = b_idx * C * N + c_idx * N + idx[0];\n    int out_idx = b_idx * C * NUM_POINTS * NUM_SAMPLES + c_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n\n    grouped_features[out_idx] = features[in_idx];\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t features_size = BATCH_SIZE * C * N;\n    size_t indices_size = BATCH_SIZE * NUM_POINTS * NUM_SAMPLES;\n    size_t output_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES;\n\n    float* h_features = new float[features_size];\n    int* h_indices = new int[indices_size];\n    float* h_output = new float[output_size];\n\n    read_binary(\"./data/input_features.bin\", h_features, features_size);\n    read_binary(\"./data/input_indices.bin\", h_indices, indices_size);\n\n    float *d_features, *d_output;\n    int* d_indices;\n    cudaMalloc(&d_features, features_size * sizeof(float));\n    cudaMalloc(&d_indices, indices_size * sizeof(int));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n\n    cudaMemcpy(d_features, h_features, features_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_indices, h_indices, indices_size * sizeof(int), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_POINTS * NUM_SAMPLES + threads_per_block - 1) / threads_per_block, C, BATCH_SIZE);\n    group_points_kernel<<<blocks, threads_per_block>>>(d_features, d_indices, d_output);\n\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_grouped_features.bin\", h_output, output_size);\n\n    delete[] h_features;\n    delete[] h_indices;\n    delete[] h_output;\n    cudaFree(d_features);\n    cudaFree(d_indices);\n    cudaFree(d_output);\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nC = 4\nN = 1024\nNUM_POINTS = 32\nNUM_SAMPLES = 256\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nfeatures = torch.randn(BATCH_SIZE, C, N) * 7.12\nindices = torch.randint(0, N, (BATCH_SIZE, NUM_POINTS, NUM_SAMPLES), dtype=torch.int32)\n\ndef group_points_pytorch(features, indices):\n    B, C, N = features.shape\n    _, num_points, num_samples = indices.shape\n    grouped_features = torch.zeros(B, C, num_points, num_samples)\n\n    for b in range(B):\n        for c in range(C):\n            for p in range(num_points):\n                for s in range(num_samples):\n                    idx = indices[b, p, s]\n                    grouped_features[b, c, p, s] = features[b, c, idx]\n    return grouped_features\n\ngrouped_features = group_points_pytorch(features, indices)\n\nos.makedirs(\"./data\", exist_ok=True)\nfeatures.numpy().tofile(\"./data/input_features.bin\")\nindices.numpy().tofile(\"./data/input_indices.bin\")\ngrouped_features.numpy().tofile(\"./data/expected_grouped_features.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    C = 4\n    N = 1024\n    NUM_POINTS = 32\n    NUM_SAMPLES = 256\n    total_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES\n\n    output_file = \"./data/output_grouped_features.bin\"\n    ref_file = \"./data/expected_grouped_features.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'Group_Points'. The kernel should group point features based on provided indices. Input includes 'input_features' tensor of shape (16, 4, 1024) with float32 values and 'input_indices' tensor of shape (16, 32, 256) with int32 values. Output must be 'output_grouped_features' tensor of shape (16, 4, 32, 256) with float32 values. The kernel must gather features such that for each batch, channel, point, and sample, the feature value at the index specified by 'input_indices' is taken from 'input_features' and placed in the corresponding position in the output. Indices must be in the range [0, 1023] to be valid.", "level2_prompt": "Implement the 'Group_Points' kernel. For each batch, each channel, each of 32 points, and each of 256 samples, use the integer index from input_indices to fetch the corresponding feature value from input_features and assign it to the output tensor at the current batch, channel, point, and sample position.", "level3_prompt": "Compute the Group_Points kernel on GPU using CUDA."}
{"id": 414, "task_name": "Group_Points", "task_description": "Compute the Group_Points kernel on GPU using CUDA.", "inputs": [{"name": "input_features", "dtype": "float32", "shape": "(16, 4, 1024)"}, {"name": "input_indices", "dtype": "int32", "shape": "(16, 32, 512)"}], "outputs": [{"name": "output_grouped_features", "dtype": "float32", "shape": "(16, 4, 32, 512)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define C 4\n#define N 1024\n#define NUM_POINTS 32\n#define NUM_SAMPLES 512\n\n\n__global__ void group_points_kernel(const float* features, const int* indices, float* grouped_features) {\n    int n_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int c_idx = blockIdx.y;\n    int b_idx = blockIdx.z;\n    if (n_idx >= NUM_POINTS * NUM_SAMPLES || c_idx >= C || b_idx >= BATCH_SIZE) return;\n\n    int point_idx = n_idx / NUM_SAMPLES;\n    int sample_idx = n_idx % NUM_SAMPLES;\n\n    const int* idx = indices + b_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n    int in_idx = b_idx * C * N + c_idx * N + idx[0];\n    int out_idx = b_idx * C * NUM_POINTS * NUM_SAMPLES + c_idx * NUM_POINTS * NUM_SAMPLES + point_idx * NUM_SAMPLES + sample_idx;\n\n    grouped_features[out_idx] = features[in_idx];\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t features_size = BATCH_SIZE * C * N;\n    size_t indices_size = BATCH_SIZE * NUM_POINTS * NUM_SAMPLES;\n    size_t output_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES;\n\n    float* h_features = new float[features_size];\n    int* h_indices = new int[indices_size];\n    float* h_output = new float[output_size];\n\n    read_binary(\"./data/input_features.bin\", h_features, features_size);\n    read_binary(\"./data/input_indices.bin\", h_indices, indices_size);\n\n    float *d_features, *d_output;\n    int* d_indices;\n    cudaMalloc(&d_features, features_size * sizeof(float));\n    cudaMalloc(&d_indices, indices_size * sizeof(int));\n    cudaMalloc(&d_output, output_size * sizeof(float));\n\n    cudaMemcpy(d_features, h_features, features_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_indices, h_indices, indices_size * sizeof(int), cudaMemcpyHostToDevice);\n    cudaMemset(d_output, 0, output_size * sizeof(float));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_POINTS * NUM_SAMPLES + threads_per_block - 1) / threads_per_block, C, BATCH_SIZE);\n    group_points_kernel<<<blocks, threads_per_block>>>(d_features, d_indices, d_output);\n\n    cudaMemcpy(h_output, d_output, output_size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/output_grouped_features.bin\", h_output, output_size);\n\n    delete[] h_features;\n    delete[] h_indices;\n    delete[] h_output;\n    cudaFree(d_features);\n    cudaFree(d_indices);\n    cudaFree(d_output);\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nC = 4\nN = 1024\nNUM_POINTS = 32\nNUM_SAMPLES = 512\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nfeatures = torch.randn(BATCH_SIZE, C, N) * 7.12\nindices = torch.randint(0, N, (BATCH_SIZE, NUM_POINTS, NUM_SAMPLES), dtype=torch.int32)\n\ndef group_points_pytorch(features, indices):\n    B, C, N = features.shape\n    _, num_points, num_samples = indices.shape\n    grouped_features = torch.zeros(B, C, num_points, num_samples)\n\n    for b in range(B):\n        for c in range(C):\n            for p in range(num_points):\n                for s in range(num_samples):\n                    idx = indices[b, p, s]\n                    grouped_features[b, c, p, s] = features[b, c, idx]\n    return grouped_features\n\ngrouped_features = group_points_pytorch(features, indices)\n\nos.makedirs(\"./data\", exist_ok=True)\nfeatures.numpy().tofile(\"./data/input_features.bin\")\nindices.numpy().tofile(\"./data/input_indices.bin\")\ngrouped_features.numpy().tofile(\"./data/expected_grouped_features.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    C = 4\n    N = 1024\n    NUM_POINTS = 32\n    NUM_SAMPLES = 512\n    total_size = BATCH_SIZE * C * NUM_POINTS * NUM_SAMPLES\n\n    output_file = \"./data/output_grouped_features.bin\"\n    ref_file = \"./data/expected_grouped_features.bin\"\n\n    if compare_results(output_file, ref_file, np.float32, 1, 1e-5):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Group_Points. Given an input features tensor of shape (16, 4, 1024) with float32 data type and an input indices tensor of shape (16, 32, 512) with int32 data type, produce an output tensor of shape (16, 4, 32, 512) with float32 data type. The kernel must gather features from the input features tensor using the indices. For each batch, channel, point (from 32 points), and sample (from 512 samples), the kernel uses the index from the input indices tensor to select a feature from the input features tensor (from the 1024 points). The indices must be in the range [0, 1023].", "level2_prompt": "Task: Group_Points. For a batch size of 16, 4 channels, and 1024 input points, and given 32 points each with 512 samples, the output tensor is constructed such that each element in the output at (b, c, p, s) is the feature value from the input features tensor at (b, c, index) where index is taken from the input indices tensor at (b, p, s).", "level3_prompt": "Group point features using indices."}
{"id": 415, "task_name": "KNN", "task_description": "Compute the KNN kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 2048, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 64, 3)"}], "outputs": [{"name": "output_knn_idx", "dtype": "int32", "shape": "(16, 64, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n\n#define BATCH_SIZE 16\n#define NUM_POINTS 2048\n#define NUM_CENTERS 64\n#define K 32\n\n// Modified from\n// https://github.com/CVMI-Lab/PAConv/tree/main/scene_seg/lib/pointops/src/knnquery_heap\n\n\ntemplate<typename T>\ninline __device__ void swap(T* x, T* y) {\n    T temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n\n__device__ void reheap(float* dist, int* idx, int k) {\n    int root = 0;\n    int child = root * 2 + 1;\n    while (child < k) {\n        if (child + 1 < k && dist[child + 1] > dist[child]) {\n            child ++;\n        }\n        if (dist[root] > dist[child]) {\n            return;\n        }\n        swap(&dist[root], &dist[child]);\n        swap(&idx[root], &idx[child]);\n        root = child;\n        child = root * 2 + 1;\n    }\n}\n\n\n__device__ void heap_sort(float* dist, int* idx, int k) {\n    for (int i = k - 1; i > 0; --i) {\n        swap(&dist[0], &dist[i]);\n        swap(&idx[0], &idx[i]);\n        reheap(dist, idx, i);\n    }\n}\n\n\n// output: knn_idx [BATCH_SIZE, NUM_CENTERS, K]\n__global__ void knn_kernel(const float* xyz, const float* center, int* knn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    const float* this_center = center + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    int* this_knn_idx = knn_idx + bs_idx * NUM_CENTERS * K + pt_idx * K;\n\n    float best_dist[K];\n    int best_idx[K];\n\n    #pragma unroll\n    for (int i = 0; i < K; ++i) {\n        best_dist[i] = 1e10;\n        best_idx[i] = 0;\n    }\n\n    float center_x = this_center[0];\n    float center_y = this_center[1];\n    float center_z = this_center[2];\n\n    for (int i = 0; i < NUM_POINTS; ++i) {\n        float diff_x = this_xyz[i * 3 + 0] - center_x;\n        float diff_y = this_xyz[i * 3 + 1] - center_y;\n        float diff_z = this_xyz[i * 3 + 2] - center_z;\n        float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;\n\n        if (dist < best_dist[0]) {\n            best_dist[0] = dist;\n            best_idx[0] = i;\n            reheap(best_dist, best_idx, K);\n        }\n    }\n    heap_sort(best_dist, best_idx, K);\n    for (int i = 0; i < K; ++i) {\n        this_knn_idx[i] = best_idx[i];\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t knn_idx_size = BATCH_SIZE * K * NUM_CENTERS;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center = new float[center_size];\n    int* h_knn_idx = new int[knn_idx_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center, center_size);\n\n    float *d_xyz, *d_center;\n    int* d_knn_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center, center_size * sizeof(float));\n    cudaMalloc(&d_knn_idx, knn_idx_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center, h_center, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_knn_idx, 0, knn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    knn_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center, d_knn_idx);\n    cudaMemcpy(h_knn_idx, d_knn_idx, knn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_knn_idx.bin\";\n    write_binary(output_file, h_knn_idx, knn_idx_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center);\n    cudaFree(d_knn_idx);\n    delete[] h_xyz;\n    delete[] h_center;\n    delete[] h_knn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_POINTS = 2048\nNUM_CENTERS = 64\nK = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12\n\ndef knn_pytorch(xyz, center, k):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros(B, M, k, dtype=torch.int32)\n\n    for b in range(B):\n        for m in range(M):\n            dists = torch.sum((xyz[b] - center[b, m].unsqueeze(0)) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, k, largest=False)\n            idx[b, m, :] = knn_idx\n    return idx\n\nknn_idx = knn_pytorch(xyz, center, K)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nknn_idx.numpy().tofile(\"./data/expected_knn_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 64\n    K = 32\n    total_size = BATCH_SIZE * K * NUM_CENTERS\n\n    output_file = \"./data/output_knn_idx.bin\"\n    ref_file = \"./data/expected_knn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the KNN kernel to find the K nearest neighbors for each center point in a batch of point clouds. The input includes two tensors: 'input_xyz' (float32, shape [16, 2048, 3]) representing batch point coordinates, and 'input_center' (float32, shape [16, 64, 3]) representing center point coordinates. The output tensor 'output_knn_idx' (int32, shape [16, 64, 32]) must store indices of the 32 nearest points from 'input_xyz' for each center point. Use squared Euclidean distance as the metric, maintain a max-heap for efficient neighbor tracking, and ensure sorted results from closest to farthest.", "level2_prompt": "For each batch and center point, compute squared Euclidean distances to all points in the same batch. Track the K smallest distances using a max-heap, updating it when closer points are found. After processing all points, sort the heap to order neighbors by ascending distance and output their indices.", "level3_prompt": "Compute the KNN kernel on GPU using CUDA."}
{"id": 416, "task_name": "KNN", "task_description": "Compute the KNN kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 2048, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_knn_idx", "dtype": "int32", "shape": "(16, 128, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n\n#define BATCH_SIZE 16\n#define NUM_POINTS 2048\n#define NUM_CENTERS 128\n#define K 32\n\n// Modified from\n// https://github.com/CVMI-Lab/PAConv/tree/main/scene_seg/lib/pointops/src/knnquery_heap\n\n\ntemplate<typename T>\ninline __device__ void swap(T* x, T* y) {\n    T temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n\n__device__ void reheap(float* dist, int* idx, int k) {\n    int root = 0;\n    int child = root * 2 + 1;\n    while (child < k) {\n        if (child + 1 < k && dist[child + 1] > dist[child]) {\n            child ++;\n        }\n        if (dist[root] > dist[child]) {\n            return;\n        }\n        swap(&dist[root], &dist[child]);\n        swap(&idx[root], &idx[child]);\n        root = child;\n        child = root * 2 + 1;\n    }\n}\n\n\n__device__ void heap_sort(float* dist, int* idx, int k) {\n    for (int i = k - 1; i > 0; --i) {\n        swap(&dist[0], &dist[i]);\n        swap(&idx[0], &idx[i]);\n        reheap(dist, idx, i);\n    }\n}\n\n\n// output: knn_idx [BATCH_SIZE, NUM_CENTERS, K]\n__global__ void knn_kernel(const float* xyz, const float* center, int* knn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    const float* this_center = center + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    int* this_knn_idx = knn_idx + bs_idx * NUM_CENTERS * K + pt_idx * K;\n\n    float best_dist[K];\n    int best_idx[K];\n\n    #pragma unroll\n    for (int i = 0; i < K; ++i) {\n        best_dist[i] = 1e10;\n        best_idx[i] = 0;\n    }\n\n    float center_x = this_center[0];\n    float center_y = this_center[1];\n    float center_z = this_center[2];\n\n    for (int i = 0; i < NUM_POINTS; ++i) {\n        float diff_x = this_xyz[i * 3 + 0] - center_x;\n        float diff_y = this_xyz[i * 3 + 1] - center_y;\n        float diff_z = this_xyz[i * 3 + 2] - center_z;\n        float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;\n\n        if (dist < best_dist[0]) {\n            best_dist[0] = dist;\n            best_idx[0] = i;\n            reheap(best_dist, best_idx, K);\n        }\n    }\n    heap_sort(best_dist, best_idx, K);\n    for (int i = 0; i < K; ++i) {\n        this_knn_idx[i] = best_idx[i];\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t knn_idx_size = BATCH_SIZE * K * NUM_CENTERS;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center = new float[center_size];\n    int* h_knn_idx = new int[knn_idx_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center, center_size);\n\n    float *d_xyz, *d_center;\n    int* d_knn_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center, center_size * sizeof(float));\n    cudaMalloc(&d_knn_idx, knn_idx_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center, h_center, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_knn_idx, 0, knn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    knn_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center, d_knn_idx);\n    cudaMemcpy(h_knn_idx, d_knn_idx, knn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_knn_idx.bin\";\n    write_binary(output_file, h_knn_idx, knn_idx_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center);\n    cudaFree(d_knn_idx);\n    delete[] h_xyz;\n    delete[] h_center;\n    delete[] h_knn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_POINTS = 2048\nNUM_CENTERS = 128\nK = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12\n\ndef knn_pytorch(xyz, center, k):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros(B, M, k, dtype=torch.int32)\n\n    for b in range(B):\n        for m in range(M):\n            dists = torch.sum((xyz[b] - center[b, m].unsqueeze(0)) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, k, largest=False)\n            idx[b, m, :] = knn_idx\n    return idx\n\nknn_idx = knn_pytorch(xyz, center, K)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nknn_idx.numpy().tofile(\"./data/expected_knn_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 128\n    K = 32\n    total_size = BATCH_SIZE * K * NUM_CENTERS\n\n    output_file = \"./data/output_knn_idx.bin\"\n    ref_file = \"./data/expected_knn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for K-Nearest Neighbors (KNN). Given a batch of point clouds and center points, compute the indices of the K nearest points for each center. Inputs include a float32 tensor 'input_xyz' with shape (16, 2048, 3) representing point coordinates and a float32 tensor 'input_center' with shape (16, 128, 3) representing center coordinates. Output must be an int32 tensor 'output_knn_idx' with shape (16, 128, 32) containing indices of the 32 nearest neighbors for each center. The kernel must compute squared Euclidean distances, maintain a min-heap of the K smallest distances, sort the results by distance, and output sorted indices.", "level2_prompt": "Implement K-Nearest Neighbors computation. For each batch and center point, calculate squared Euclidean distances to all points in the same batch. Find and sort the indices of the K points with smallest distances. The kernel should process centers in parallel using batch and center indices.", "level3_prompt": "Compute the KNN kernel on GPU using CUDA."}
{"id": 417, "task_name": "KNN", "task_description": "Compute the KNN kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 2048, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 256, 3)"}], "outputs": [{"name": "output_knn_idx", "dtype": "int32", "shape": "(16, 256, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n\n#define BATCH_SIZE 16\n#define NUM_POINTS 2048\n#define NUM_CENTERS 256\n#define K 32\n\n// Modified from\n// https://github.com/CVMI-Lab/PAConv/tree/main/scene_seg/lib/pointops/src/knnquery_heap\n\n\ntemplate<typename T>\ninline __device__ void swap(T* x, T* y) {\n    T temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n\n__device__ void reheap(float* dist, int* idx, int k) {\n    int root = 0;\n    int child = root * 2 + 1;\n    while (child < k) {\n        if (child + 1 < k && dist[child + 1] > dist[child]) {\n            child ++;\n        }\n        if (dist[root] > dist[child]) {\n            return;\n        }\n        swap(&dist[root], &dist[child]);\n        swap(&idx[root], &idx[child]);\n        root = child;\n        child = root * 2 + 1;\n    }\n}\n\n\n__device__ void heap_sort(float* dist, int* idx, int k) {\n    for (int i = k - 1; i > 0; --i) {\n        swap(&dist[0], &dist[i]);\n        swap(&idx[0], &idx[i]);\n        reheap(dist, idx, i);\n    }\n}\n\n\n// output: knn_idx [BATCH_SIZE, NUM_CENTERS, K]\n__global__ void knn_kernel(const float* xyz, const float* center, int* knn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    const float* this_center = center + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    int* this_knn_idx = knn_idx + bs_idx * NUM_CENTERS * K + pt_idx * K;\n\n    float best_dist[K];\n    int best_idx[K];\n\n    #pragma unroll\n    for (int i = 0; i < K; ++i) {\n        best_dist[i] = 1e10;\n        best_idx[i] = 0;\n    }\n\n    float center_x = this_center[0];\n    float center_y = this_center[1];\n    float center_z = this_center[2];\n\n    for (int i = 0; i < NUM_POINTS; ++i) {\n        float diff_x = this_xyz[i * 3 + 0] - center_x;\n        float diff_y = this_xyz[i * 3 + 1] - center_y;\n        float diff_z = this_xyz[i * 3 + 2] - center_z;\n        float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;\n\n        if (dist < best_dist[0]) {\n            best_dist[0] = dist;\n            best_idx[0] = i;\n            reheap(best_dist, best_idx, K);\n        }\n    }\n    heap_sort(best_dist, best_idx, K);\n    for (int i = 0; i < K; ++i) {\n        this_knn_idx[i] = best_idx[i];\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t knn_idx_size = BATCH_SIZE * K * NUM_CENTERS;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center = new float[center_size];\n    int* h_knn_idx = new int[knn_idx_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center, center_size);\n\n    float *d_xyz, *d_center;\n    int* d_knn_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center, center_size * sizeof(float));\n    cudaMalloc(&d_knn_idx, knn_idx_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center, h_center, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_knn_idx, 0, knn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    knn_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center, d_knn_idx);\n    cudaMemcpy(h_knn_idx, d_knn_idx, knn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_knn_idx.bin\";\n    write_binary(output_file, h_knn_idx, knn_idx_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center);\n    cudaFree(d_knn_idx);\n    delete[] h_xyz;\n    delete[] h_center;\n    delete[] h_knn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_POINTS = 2048\nNUM_CENTERS = 256\nK = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12\n\ndef knn_pytorch(xyz, center, k):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros(B, M, k, dtype=torch.int32)\n\n    for b in range(B):\n        for m in range(M):\n            dists = torch.sum((xyz[b] - center[b, m].unsqueeze(0)) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, k, largest=False)\n            idx[b, m, :] = knn_idx\n    return idx\n\nknn_idx = knn_pytorch(xyz, center, K)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nknn_idx.numpy().tofile(\"./data/expected_knn_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 256\n    K = 32\n    total_size = BATCH_SIZE * K * NUM_CENTERS\n\n    output_file = \"./data/output_knn_idx.bin\"\n    ref_file = \"./data/expected_knn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: KNN. Given a batch of 16 sets of points (each set has 2048 points in 3D space) and a batch of 16 sets of center points (each set has 256 points in 3D space), compute for each center point the indices of the 32 nearest points from the corresponding set of points. The distance metric is squared Euclidean distance. The output must be a tensor of shape (16, 256, 32) of type int32, where for each center point, the 32 indices are ordered from the closest point (smallest distance) to the 32nd closest. The kernel must use a max-heap to efficiently track the nearest neighbors during the iteration and then sort the heap to produce the indices in ascending order of distance.", "level2_prompt": "Task name: KNN. For each center point in each batch, iterate over all points in the same batch and compute the squared Euclidean distance. Maintain a max-heap of the 32 smallest distances and their indices. When a new distance is smaller than the largest distance in the heap, replace the largest and adjust the heap. After processing all points, sort the heap to produce the indices in ascending order of distance (closest first).", "level3_prompt": "Compute the KNN kernel on GPU using CUDA."}
{"id": 418, "task_name": "KNN", "task_description": "Compute the KNN kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 2048, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 512, 3)"}], "outputs": [{"name": "output_knn_idx", "dtype": "int32", "shape": "(16, 512, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n\n#define BATCH_SIZE 16\n#define NUM_POINTS 2048\n#define NUM_CENTERS 512\n#define K 32\n\n// Modified from\n// https://github.com/CVMI-Lab/PAConv/tree/main/scene_seg/lib/pointops/src/knnquery_heap\n\n\ntemplate<typename T>\ninline __device__ void swap(T* x, T* y) {\n    T temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n\n__device__ void reheap(float* dist, int* idx, int k) {\n    int root = 0;\n    int child = root * 2 + 1;\n    while (child < k) {\n        if (child + 1 < k && dist[child + 1] > dist[child]) {\n            child ++;\n        }\n        if (dist[root] > dist[child]) {\n            return;\n        }\n        swap(&dist[root], &dist[child]);\n        swap(&idx[root], &idx[child]);\n        root = child;\n        child = root * 2 + 1;\n    }\n}\n\n\n__device__ void heap_sort(float* dist, int* idx, int k) {\n    for (int i = k - 1; i > 0; --i) {\n        swap(&dist[0], &dist[i]);\n        swap(&idx[0], &idx[i]);\n        reheap(dist, idx, i);\n    }\n}\n\n\n// output: knn_idx [BATCH_SIZE, NUM_CENTERS, K]\n__global__ void knn_kernel(const float* xyz, const float* center, int* knn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    const float* this_center = center + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    int* this_knn_idx = knn_idx + bs_idx * NUM_CENTERS * K + pt_idx * K;\n\n    float best_dist[K];\n    int best_idx[K];\n\n    #pragma unroll\n    for (int i = 0; i < K; ++i) {\n        best_dist[i] = 1e10;\n        best_idx[i] = 0;\n    }\n\n    float center_x = this_center[0];\n    float center_y = this_center[1];\n    float center_z = this_center[2];\n\n    for (int i = 0; i < NUM_POINTS; ++i) {\n        float diff_x = this_xyz[i * 3 + 0] - center_x;\n        float diff_y = this_xyz[i * 3 + 1] - center_y;\n        float diff_z = this_xyz[i * 3 + 2] - center_z;\n        float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;\n\n        if (dist < best_dist[0]) {\n            best_dist[0] = dist;\n            best_idx[0] = i;\n            reheap(best_dist, best_idx, K);\n        }\n    }\n    heap_sort(best_dist, best_idx, K);\n    for (int i = 0; i < K; ++i) {\n        this_knn_idx[i] = best_idx[i];\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t knn_idx_size = BATCH_SIZE * K * NUM_CENTERS;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center = new float[center_size];\n    int* h_knn_idx = new int[knn_idx_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center, center_size);\n\n    float *d_xyz, *d_center;\n    int* d_knn_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center, center_size * sizeof(float));\n    cudaMalloc(&d_knn_idx, knn_idx_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center, h_center, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_knn_idx, 0, knn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    knn_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center, d_knn_idx);\n    cudaMemcpy(h_knn_idx, d_knn_idx, knn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_knn_idx.bin\";\n    write_binary(output_file, h_knn_idx, knn_idx_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center);\n    cudaFree(d_knn_idx);\n    delete[] h_xyz;\n    delete[] h_center;\n    delete[] h_knn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_POINTS = 2048\nNUM_CENTERS = 512\nK = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12\n\ndef knn_pytorch(xyz, center, k):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros(B, M, k, dtype=torch.int32)\n\n    for b in range(B):\n        for m in range(M):\n            dists = torch.sum((xyz[b] - center[b, m].unsqueeze(0)) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, k, largest=False)\n            idx[b, m, :] = knn_idx\n    return idx\n\nknn_idx = knn_pytorch(xyz, center, K)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nknn_idx.numpy().tofile(\"./data/expected_knn_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 512\n    K = 32\n    total_size = BATCH_SIZE * K * NUM_CENTERS\n\n    output_file = \"./data/output_knn_idx.bin\"\n    ref_file = \"./data/expected_knn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for K-Nearest Neighbors (KNN) computation. The kernel should process batches of 3D point clouds to find the 32 nearest neighbors for each center point. Inputs include a float32 tensor of shape (16, 2048, 3) representing 16 batches of 2048 points each with XYZ coordinates, and a float32 tensor of shape (16, 512, 3) representing center points. The output should be an int32 tensor of shape (16, 512, 32) storing indices of nearest neighbors in the input point cloud for each center. For each center point, compute squared Euclidean distances to all input points, maintain a max-heap of the 32 smallest distances, and output indices sorted by ascending distance.", "level2_prompt": "Implement K-Nearest Neighbors computation. For each batch, each center point finds its K=32 nearest neighbors from the input points using squared Euclidean distance. Maintain a max-heap to track smallest distances during computation, then sort neighbors by distance before outputting their indices.", "level3_prompt": "Compute the KNN kernel on GPU using CUDA."}
{"id": 419, "task_name": "KNN", "task_description": "Compute the KNN kernel on GPU using CUDA.", "inputs": [{"name": "input_xyz", "dtype": "float32", "shape": "(16, 2048, 3)"}, {"name": "input_center", "dtype": "float32", "shape": "(16, 1024, 3)"}], "outputs": [{"name": "output_knn_idx", "dtype": "int32", "shape": "(16, 1024, 32)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n\n#define BATCH_SIZE 16\n#define NUM_POINTS 2048\n#define NUM_CENTERS 1024\n#define K 32\n\n// Modified from\n// https://github.com/CVMI-Lab/PAConv/tree/main/scene_seg/lib/pointops/src/knnquery_heap\n\n\ntemplate<typename T>\ninline __device__ void swap(T* x, T* y) {\n    T temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n\n__device__ void reheap(float* dist, int* idx, int k) {\n    int root = 0;\n    int child = root * 2 + 1;\n    while (child < k) {\n        if (child + 1 < k && dist[child + 1] > dist[child]) {\n            child ++;\n        }\n        if (dist[root] > dist[child]) {\n            return;\n        }\n        swap(&dist[root], &dist[child]);\n        swap(&idx[root], &idx[child]);\n        root = child;\n        child = root * 2 + 1;\n    }\n}\n\n\n__device__ void heap_sort(float* dist, int* idx, int k) {\n    for (int i = k - 1; i > 0; --i) {\n        swap(&dist[0], &dist[i]);\n        swap(&idx[0], &idx[i]);\n        reheap(dist, idx, i);\n    }\n}\n\n\n// output: knn_idx [BATCH_SIZE, NUM_CENTERS, K]\n__global__ void knn_kernel(const float* xyz, const float* center, int* knn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_CENTERS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_xyz = xyz + bs_idx * NUM_POINTS * 3;\n    const float* this_center = center + bs_idx * NUM_CENTERS * 3 + pt_idx * 3;\n    int* this_knn_idx = knn_idx + bs_idx * NUM_CENTERS * K + pt_idx * K;\n\n    float best_dist[K];\n    int best_idx[K];\n\n    #pragma unroll\n    for (int i = 0; i < K; ++i) {\n        best_dist[i] = 1e10;\n        best_idx[i] = 0;\n    }\n\n    float center_x = this_center[0];\n    float center_y = this_center[1];\n    float center_z = this_center[2];\n\n    for (int i = 0; i < NUM_POINTS; ++i) {\n        float diff_x = this_xyz[i * 3 + 0] - center_x;\n        float diff_y = this_xyz[i * 3 + 1] - center_y;\n        float diff_z = this_xyz[i * 3 + 2] - center_z;\n        float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;\n\n        if (dist < best_dist[0]) {\n            best_dist[0] = dist;\n            best_idx[0] = i;\n            reheap(best_dist, best_idx, K);\n        }\n    }\n    heap_sort(best_dist, best_idx, K);\n    for (int i = 0; i < K; ++i) {\n        this_knn_idx[i] = best_idx[i];\n    }\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t xyz_size = BATCH_SIZE * NUM_POINTS * 3;\n    size_t center_size = BATCH_SIZE * NUM_CENTERS * 3;\n    size_t knn_idx_size = BATCH_SIZE * K * NUM_CENTERS;\n\n    float* h_xyz = new float[xyz_size];\n    float* h_center = new float[center_size];\n    int* h_knn_idx = new int[knn_idx_size];\n\n    std::string xyz_file = \"./data/input_xyz.bin\";\n    std::string center_file = \"./data/input_center.bin\";\n    read_binary(xyz_file, h_xyz, xyz_size);\n    read_binary(center_file, h_center, center_size);\n\n    float *d_xyz, *d_center;\n    int* d_knn_idx;\n    cudaMalloc(&d_xyz, xyz_size * sizeof(float));\n    cudaMalloc(&d_center, center_size * sizeof(float));\n    cudaMalloc(&d_knn_idx, knn_idx_size * sizeof(int));\n    cudaMemcpy(d_xyz, h_xyz, xyz_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_center, h_center, center_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_knn_idx, 0, knn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_CENTERS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    knn_kernel<<<blocks, threads_per_block>>>(d_xyz, d_center, d_knn_idx);\n    cudaMemcpy(h_knn_idx, d_knn_idx, knn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_knn_idx.bin\";\n    write_binary(output_file, h_knn_idx, knn_idx_size);\n\n    cudaFree(d_xyz);\n    cudaFree(d_center);\n    cudaFree(d_knn_idx);\n    delete[] h_xyz;\n    delete[] h_center;\n    delete[] h_knn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_POINTS = 2048\nNUM_CENTERS = 1024\nK = 32\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nxyz = torch.randn(BATCH_SIZE, NUM_POINTS, 3) * 7.12\ncenter = torch.randn(BATCH_SIZE, NUM_CENTERS, 3) * 7.12\n\ndef knn_pytorch(xyz, center, k):\n    B, N, _ = xyz.shape\n    _, M, _ = center.shape\n    idx = torch.zeros(B, M, k, dtype=torch.int32)\n\n    for b in range(B):\n        for m in range(M):\n            dists = torch.sum((xyz[b] - center[b, m].unsqueeze(0)) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, k, largest=False)\n            idx[b, m, :] = knn_idx\n    return idx\n\nknn_idx = knn_pytorch(xyz, center, K)\n\nos.makedirs(\"./data\", exist_ok=True)\nxyz.numpy().tofile(\"./data/input_xyz.bin\")\ncenter.numpy().tofile(\"./data/input_center.bin\")\nknn_idx.numpy().tofile(\"./data/expected_knn_idx.bin\")", "compare.py": "import numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_CENTERS = 1024\n    K = 32\n    total_size = BATCH_SIZE * K * NUM_CENTERS\n\n    output_file = \"./data/output_knn_idx.bin\"\n    ref_file = \"./data/expected_knn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the KNN task. For each center point in 3D space, find the indices of the K nearest points from a separate set of points. The input consists of two tensors: 'input_xyz' with float32 values of shape (16, 2048, 3) representing 16 batches of 2048 points each, and 'input_center' with float32 values of shape (16, 1024, 3) representing center points. The output tensor 'output_knn_idx' must be int32 with shape (16, 1024, 32) storing the indices of the 32 nearest points for each center. The kernel must compute Euclidean distances and maintain a min-heap to track nearest neighbors.", "level2_prompt": "KNN task: For each batch and center point, compute squared Euclidean distances to all points. Maintain a min-heap to track the K smallest distances. After processing all points, sort the heap to get indices of nearest neighbors in ascending distance order.", "level3_prompt": "Compute K-nearest neighbors for center points using Euclidean distance."}
{"id": 420, "task_name": "Three_NN", "task_description": "Compute the Three_NN kernel on GPU using CUDA.", "inputs": [{"name": "input_unknown_points", "dtype": "float32", "shape": "(16, 256, 3)"}, {"name": "input_known_points", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_three_nn_idx", "dtype": "int32", "shape": "(16, 256, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define NUM_UNKNOWN_POINTS 256\n#define NUM_KNOWN_POINTS 128\n\n__global__ void three_nn_kernel(const float* unknown_points, const float* known_points, int* three_nn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_UNKNOWN_POINTS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_unknow_point = unknown_points + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n    const float* this_known_point = known_points + bs_idx * NUM_KNOWN_POINTS * 3;\n    int* this_three_nn_idx = three_nn_idx + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n\n    float unknown_point_x = this_unknow_point[0];\n    float unknown_point_y = this_unknow_point[1];\n    float unknown_point_z = this_unknow_point[2];\n\n    float min_dist1 = 1e10, min_dist2 = 1e10, min_dist3 = 1e10;\n    int idx1 = -1, idx2 = -1, idx3 = -1;\n\n    for (int k = 0; k < NUM_KNOWN_POINTS; ++k) {\n        float known_point_x = this_known_point[k * 3 + 0];\n        float known_point_y = this_known_point[k * 3 + 1];\n        float known_point_z = this_known_point[k * 3 + 2];\n\n        float dist = (unknown_point_x - known_point_x) * (unknown_point_x - known_point_x) +\n                     (unknown_point_y - known_point_y) * (unknown_point_y - known_point_y) +\n                     (unknown_point_z - known_point_z) * (unknown_point_z - known_point_z);\n        // Update the three nearest neighbors\n        if (dist < min_dist1) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = min_dist1;\n            idx2 = idx1;\n            min_dist1 = dist;\n            idx1 = k;\n        } else if (dist < min_dist2) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = dist;\n            idx2 = k;\n        } else if (dist < min_dist3) {\n            min_dist3 = dist;\n            idx3 = k;\n        }\n    }\n    this_three_nn_idx[0] = idx1;\n    this_three_nn_idx[1] = idx2;\n    this_three_nn_idx[2] = idx3;\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t unknown_points_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n    size_t known_points_size = BATCH_SIZE * NUM_KNOWN_POINTS * 3;\n    size_t three_nn_idx_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n\n    float* h_unknown_points = new float[unknown_points_size];\n    float* h_known_points = new float[known_points_size];\n    int* h_three_nn_idx = new int[three_nn_idx_size];\n\n    std::string unknown_points_file = \"./data/input_unknown_points.bin\";\n    std::string known_points_file = \"./data/input_known_points.bin\";\n    read_binary(unknown_points_file, h_unknown_points, unknown_points_size);\n    read_binary(known_points_file, h_known_points, known_points_size);\n\n    float *d_unknown_points, *d_known_points;\n    int* d_three_nn_idx;\n    cudaMalloc(&d_unknown_points, unknown_points_size * sizeof(float));\n    cudaMalloc(&d_known_points, known_points_size * sizeof(float));\n    cudaMalloc(&d_three_nn_idx, three_nn_idx_size * sizeof(int));\n    cudaMemcpy(d_unknown_points, h_unknown_points, unknown_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_known_points, h_known_points, known_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_three_nn_idx, 0, three_nn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_UNKNOWN_POINTS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    three_nn_kernel<<<blocks, threads_per_block>>>(d_unknown_points, d_known_points, d_three_nn_idx);\n    cudaMemcpy(h_three_nn_idx, d_three_nn_idx, three_nn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_three_nn_idx.bin\";\n    write_binary(output_file, h_three_nn_idx, three_nn_idx_size);\n\n    cudaFree(d_unknown_points);\n    cudaFree(d_known_points);\n    cudaFree(d_three_nn_idx);\n    delete[] h_unknown_points;\n    delete[] h_known_points;\n    delete[] h_three_nn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_UNKNOWN_POINTS = 256\nNUM_KNOWN_POINTS = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nunknown_points = torch.rand(BATCH_SIZE, NUM_UNKNOWN_POINTS, 3) * 71.2\nknown_points = torch.rand(BATCH_SIZE, NUM_KNOWN_POINTS, 3) * 71.2\n\n\ndef three_nn_pytorch(unknow_points, known_points):\n    B, N, _ = unknown_points.shape\n    _, M, _ = known_points.shape\n    idx = torch.zeros(B, N, 3, dtype=torch.int32)\n\n    for b in range(B):\n        for n in range(N):\n            dists = torch.sum((known_points[b] - unknown_points[b, n]) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, 3, largest=False)\n            idx[b, n] = knn_idx\n    return idx\n\n\nthree_nn_idx = three_nn_pytorch(unknown_points, known_points)\n\nos.makedirs(\"data\", exist_ok=True)\nunknown_points.numpy().tofile(\"data/input_unknown_points.bin\")\nknown_points.numpy().tofile(\"data/input_known_points.bin\")\nthree_nn_idx.numpy().tofile(\"data/expected_three_nn_idx.bin\")", "compare.py": "\nimport numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_UNKNOWN_POINTS = 256\n    total_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3  # 3 nearest neighbors\n\n    output_file = \"./data/output_three_nn_idx.bin\"\n    ref_file = \"./data/expected_three_nn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n\n", "level1_prompt": "Task: Three_NN. For each of 16 batches, for each of 256 unknown points (each with 3D coordinates), find the indices of the three nearest points from a set of 128 known points in the same batch. The distance is computed as squared Euclidean distance. The output must be a tensor of shape (16, 256, 3) with int32 indices, where each index corresponds to a point in the known set (ranging from 0 to 127) and is ordered by ascending distance (closest first).", "level2_prompt": "Three_NN: For each batch, each unknown point, and each known point in the same batch, compute the squared Euclidean distance. For each unknown point, identify the three known points with the smallest distances and output their indices in ascending order of distance.", "level3_prompt": "Find the indices of the three nearest neighbors for each unknown point from a set of known points."}
{"id": 421, "task_name": "Three_NN", "task_description": "Compute the Three_NN kernel on GPU using CUDA.", "inputs": [{"name": "input_unknown_points", "dtype": "float32", "shape": "(16, 512, 3)"}, {"name": "input_known_points", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_three_nn_idx", "dtype": "int32", "shape": "(16, 512, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define NUM_UNKNOWN_POINTS 512\n#define NUM_KNOWN_POINTS 128\n\n__global__ void three_nn_kernel(const float* unknown_points, const float* known_points, int* three_nn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_UNKNOWN_POINTS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_unknow_point = unknown_points + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n    const float* this_known_point = known_points + bs_idx * NUM_KNOWN_POINTS * 3;\n    int* this_three_nn_idx = three_nn_idx + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n\n    float unknown_point_x = this_unknow_point[0];\n    float unknown_point_y = this_unknow_point[1];\n    float unknown_point_z = this_unknow_point[2];\n\n    float min_dist1 = 1e10, min_dist2 = 1e10, min_dist3 = 1e10;\n    int idx1 = -1, idx2 = -1, idx3 = -1;\n\n    for (int k = 0; k < NUM_KNOWN_POINTS; ++k) {\n        float known_point_x = this_known_point[k * 3 + 0];\n        float known_point_y = this_known_point[k * 3 + 1];\n        float known_point_z = this_known_point[k * 3 + 2];\n\n        float dist = (unknown_point_x - known_point_x) * (unknown_point_x - known_point_x) +\n                     (unknown_point_y - known_point_y) * (unknown_point_y - known_point_y) +\n                     (unknown_point_z - known_point_z) * (unknown_point_z - known_point_z);\n        // Update the three nearest neighbors\n        if (dist < min_dist1) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = min_dist1;\n            idx2 = idx1;\n            min_dist1 = dist;\n            idx1 = k;\n        } else if (dist < min_dist2) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = dist;\n            idx2 = k;\n        } else if (dist < min_dist3) {\n            min_dist3 = dist;\n            idx3 = k;\n        }\n    }\n    this_three_nn_idx[0] = idx1;\n    this_three_nn_idx[1] = idx2;\n    this_three_nn_idx[2] = idx3;\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t unknown_points_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n    size_t known_points_size = BATCH_SIZE * NUM_KNOWN_POINTS * 3;\n    size_t three_nn_idx_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n\n    float* h_unknown_points = new float[unknown_points_size];\n    float* h_known_points = new float[known_points_size];\n    int* h_three_nn_idx = new int[three_nn_idx_size];\n\n    std::string unknown_points_file = \"./data/input_unknown_points.bin\";\n    std::string known_points_file = \"./data/input_known_points.bin\";\n    read_binary(unknown_points_file, h_unknown_points, unknown_points_size);\n    read_binary(known_points_file, h_known_points, known_points_size);\n\n    float *d_unknown_points, *d_known_points;\n    int* d_three_nn_idx;\n    cudaMalloc(&d_unknown_points, unknown_points_size * sizeof(float));\n    cudaMalloc(&d_known_points, known_points_size * sizeof(float));\n    cudaMalloc(&d_three_nn_idx, three_nn_idx_size * sizeof(int));\n    cudaMemcpy(d_unknown_points, h_unknown_points, unknown_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_known_points, h_known_points, known_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_three_nn_idx, 0, three_nn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_UNKNOWN_POINTS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    three_nn_kernel<<<blocks, threads_per_block>>>(d_unknown_points, d_known_points, d_three_nn_idx);\n    cudaMemcpy(h_three_nn_idx, d_three_nn_idx, three_nn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_three_nn_idx.bin\";\n    write_binary(output_file, h_three_nn_idx, three_nn_idx_size);\n\n    cudaFree(d_unknown_points);\n    cudaFree(d_known_points);\n    cudaFree(d_three_nn_idx);\n    delete[] h_unknown_points;\n    delete[] h_known_points;\n    delete[] h_three_nn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_UNKNOWN_POINTS = 512\nNUM_KNOWN_POINTS = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nunknown_points = torch.rand(BATCH_SIZE, NUM_UNKNOWN_POINTS, 3) * 71.2\nknown_points = torch.rand(BATCH_SIZE, NUM_KNOWN_POINTS, 3) * 71.2\n\n\ndef three_nn_pytorch(unknow_points, known_points):\n    B, N, _ = unknown_points.shape\n    _, M, _ = known_points.shape\n    idx = torch.zeros(B, N, 3, dtype=torch.int32)\n\n    for b in range(B):\n        for n in range(N):\n            dists = torch.sum((known_points[b] - unknown_points[b, n]) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, 3, largest=False)\n            idx[b, n] = knn_idx\n    return idx\n\n\nthree_nn_idx = three_nn_pytorch(unknown_points, known_points)\n\nos.makedirs(\"data\", exist_ok=True)\nunknown_points.numpy().tofile(\"data/input_unknown_points.bin\")\nknown_points.numpy().tofile(\"data/input_known_points.bin\")\nthree_nn_idx.numpy().tofile(\"data/expected_three_nn_idx.bin\")", "compare.py": "\nimport numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_UNKNOWN_POINTS = 512\n    total_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3  # 3 nearest neighbors\n\n    output_file = \"./data/output_three_nn_idx.bin\"\n    ref_file = \"./data/expected_three_nn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n\n", "level1_prompt": "Implement the Three_NN kernel to compute the three nearest neighbors for each point in a set of unknown points from a set of known points. The input includes two 3D point clouds: 'input_unknown_points' of shape (16, 512, 3) and 'input_known_points' of shape (16, 128, 3), both with float32 data type. The output 'output_three_nn_idx' must be an int32 tensor of shape (16, 512, 3) storing the indices of the three closest known points for each unknown point. For each batch and unknown point, calculate squared Euclidean distances to all known points, maintain the three smallest distances, and track their indices. The kernel must process batches independently.", "level2_prompt": "For each unknown point in a batch, find the indices of its three nearest neighbors among the known points using squared Euclidean distance. The computation involves iterating through known points, updating the three smallest distances and their corresponding indices for every unknown point.", "level3_prompt": "Compute the Three_NN kernel on GPU using CUDA."}
{"id": 422, "task_name": "Three_NN", "task_description": "Compute the Three_NN kernel on GPU using CUDA.", "inputs": [{"name": "input_unknown_points", "dtype": "float32", "shape": "(16, 1024, 3)"}, {"name": "input_known_points", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_three_nn_idx", "dtype": "int32", "shape": "(16, 1024, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define NUM_UNKNOWN_POINTS 1024\n#define NUM_KNOWN_POINTS 128\n\n__global__ void three_nn_kernel(const float* unknown_points, const float* known_points, int* three_nn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_UNKNOWN_POINTS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_unknow_point = unknown_points + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n    const float* this_known_point = known_points + bs_idx * NUM_KNOWN_POINTS * 3;\n    int* this_three_nn_idx = three_nn_idx + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n\n    float unknown_point_x = this_unknow_point[0];\n    float unknown_point_y = this_unknow_point[1];\n    float unknown_point_z = this_unknow_point[2];\n\n    float min_dist1 = 1e10, min_dist2 = 1e10, min_dist3 = 1e10;\n    int idx1 = -1, idx2 = -1, idx3 = -1;\n\n    for (int k = 0; k < NUM_KNOWN_POINTS; ++k) {\n        float known_point_x = this_known_point[k * 3 + 0];\n        float known_point_y = this_known_point[k * 3 + 1];\n        float known_point_z = this_known_point[k * 3 + 2];\n\n        float dist = (unknown_point_x - known_point_x) * (unknown_point_x - known_point_x) +\n                     (unknown_point_y - known_point_y) * (unknown_point_y - known_point_y) +\n                     (unknown_point_z - known_point_z) * (unknown_point_z - known_point_z);\n        // Update the three nearest neighbors\n        if (dist < min_dist1) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = min_dist1;\n            idx2 = idx1;\n            min_dist1 = dist;\n            idx1 = k;\n        } else if (dist < min_dist2) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = dist;\n            idx2 = k;\n        } else if (dist < min_dist3) {\n            min_dist3 = dist;\n            idx3 = k;\n        }\n    }\n    this_three_nn_idx[0] = idx1;\n    this_three_nn_idx[1] = idx2;\n    this_three_nn_idx[2] = idx3;\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t unknown_points_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n    size_t known_points_size = BATCH_SIZE * NUM_KNOWN_POINTS * 3;\n    size_t three_nn_idx_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n\n    float* h_unknown_points = new float[unknown_points_size];\n    float* h_known_points = new float[known_points_size];\n    int* h_three_nn_idx = new int[three_nn_idx_size];\n\n    std::string unknown_points_file = \"./data/input_unknown_points.bin\";\n    std::string known_points_file = \"./data/input_known_points.bin\";\n    read_binary(unknown_points_file, h_unknown_points, unknown_points_size);\n    read_binary(known_points_file, h_known_points, known_points_size);\n\n    float *d_unknown_points, *d_known_points;\n    int* d_three_nn_idx;\n    cudaMalloc(&d_unknown_points, unknown_points_size * sizeof(float));\n    cudaMalloc(&d_known_points, known_points_size * sizeof(float));\n    cudaMalloc(&d_three_nn_idx, three_nn_idx_size * sizeof(int));\n    cudaMemcpy(d_unknown_points, h_unknown_points, unknown_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_known_points, h_known_points, known_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_three_nn_idx, 0, three_nn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_UNKNOWN_POINTS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    three_nn_kernel<<<blocks, threads_per_block>>>(d_unknown_points, d_known_points, d_three_nn_idx);\n    cudaMemcpy(h_three_nn_idx, d_three_nn_idx, three_nn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_three_nn_idx.bin\";\n    write_binary(output_file, h_three_nn_idx, three_nn_idx_size);\n\n    cudaFree(d_unknown_points);\n    cudaFree(d_known_points);\n    cudaFree(d_three_nn_idx);\n    delete[] h_unknown_points;\n    delete[] h_known_points;\n    delete[] h_three_nn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_UNKNOWN_POINTS = 1024\nNUM_KNOWN_POINTS = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nunknown_points = torch.rand(BATCH_SIZE, NUM_UNKNOWN_POINTS, 3) * 71.2\nknown_points = torch.rand(BATCH_SIZE, NUM_KNOWN_POINTS, 3) * 71.2\n\n\ndef three_nn_pytorch(unknow_points, known_points):\n    B, N, _ = unknown_points.shape\n    _, M, _ = known_points.shape\n    idx = torch.zeros(B, N, 3, dtype=torch.int32)\n\n    for b in range(B):\n        for n in range(N):\n            dists = torch.sum((known_points[b] - unknown_points[b, n]) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, 3, largest=False)\n            idx[b, n] = knn_idx\n    return idx\n\n\nthree_nn_idx = three_nn_pytorch(unknown_points, known_points)\n\nos.makedirs(\"data\", exist_ok=True)\nunknown_points.numpy().tofile(\"data/input_unknown_points.bin\")\nknown_points.numpy().tofile(\"data/input_known_points.bin\")\nthree_nn_idx.numpy().tofile(\"data/expected_three_nn_idx.bin\")", "compare.py": "\nimport numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_UNKNOWN_POINTS = 1024\n    total_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3  # 3 nearest neighbors\n\n    output_file = \"./data/output_three_nn_idx.bin\"\n    ref_file = \"./data/expected_three_nn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n\n", "level1_prompt": "Three_NN task: Implement a CUDA kernel that computes the indices of the three nearest neighbors for each unknown point within a batch. The input consists of two float32 tensors: 'input_unknown_points' with shape (16, 1024, 3) representing 16 batches of 1024 unknown 3D points, and 'input_known_points' with shape (16, 128, 3) representing 16 batches of 128 known 3D points. The output must be an int32 tensor 'output_three_nn_idx' with shape (16, 1024, 3) storing the indices (0-127) of the three closest known points for each unknown point. The kernel must compute squared Euclidean distances and maintain batch independence.", "level2_prompt": "Three_NN task: For each batch, compute the three nearest known points for every unknown point. For each unknown point, calculate squared Euclidean distances to all known points in the same batch. Track the three smallest distances and record the corresponding indices of the known points. The indices must be stored for each unknown point.", "level3_prompt": "Compute the Three_NN kernel: Find indices of the three closest known points for each unknown point in a batch."}
{"id": 423, "task_name": "Three_NN", "task_description": "Compute the Three_NN kernel on GPU using CUDA.", "inputs": [{"name": "input_unknown_points", "dtype": "float32", "shape": "(16, 2048, 3)"}, {"name": "input_known_points", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_three_nn_idx", "dtype": "int32", "shape": "(16, 2048, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define NUM_UNKNOWN_POINTS 2048\n#define NUM_KNOWN_POINTS 128\n\n__global__ void three_nn_kernel(const float* unknown_points, const float* known_points, int* three_nn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_UNKNOWN_POINTS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_unknow_point = unknown_points + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n    const float* this_known_point = known_points + bs_idx * NUM_KNOWN_POINTS * 3;\n    int* this_three_nn_idx = three_nn_idx + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n\n    float unknown_point_x = this_unknow_point[0];\n    float unknown_point_y = this_unknow_point[1];\n    float unknown_point_z = this_unknow_point[2];\n\n    float min_dist1 = 1e10, min_dist2 = 1e10, min_dist3 = 1e10;\n    int idx1 = -1, idx2 = -1, idx3 = -1;\n\n    for (int k = 0; k < NUM_KNOWN_POINTS; ++k) {\n        float known_point_x = this_known_point[k * 3 + 0];\n        float known_point_y = this_known_point[k * 3 + 1];\n        float known_point_z = this_known_point[k * 3 + 2];\n\n        float dist = (unknown_point_x - known_point_x) * (unknown_point_x - known_point_x) +\n                     (unknown_point_y - known_point_y) * (unknown_point_y - known_point_y) +\n                     (unknown_point_z - known_point_z) * (unknown_point_z - known_point_z);\n        // Update the three nearest neighbors\n        if (dist < min_dist1) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = min_dist1;\n            idx2 = idx1;\n            min_dist1 = dist;\n            idx1 = k;\n        } else if (dist < min_dist2) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = dist;\n            idx2 = k;\n        } else if (dist < min_dist3) {\n            min_dist3 = dist;\n            idx3 = k;\n        }\n    }\n    this_three_nn_idx[0] = idx1;\n    this_three_nn_idx[1] = idx2;\n    this_three_nn_idx[2] = idx3;\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t unknown_points_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n    size_t known_points_size = BATCH_SIZE * NUM_KNOWN_POINTS * 3;\n    size_t three_nn_idx_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n\n    float* h_unknown_points = new float[unknown_points_size];\n    float* h_known_points = new float[known_points_size];\n    int* h_three_nn_idx = new int[three_nn_idx_size];\n\n    std::string unknown_points_file = \"./data/input_unknown_points.bin\";\n    std::string known_points_file = \"./data/input_known_points.bin\";\n    read_binary(unknown_points_file, h_unknown_points, unknown_points_size);\n    read_binary(known_points_file, h_known_points, known_points_size);\n\n    float *d_unknown_points, *d_known_points;\n    int* d_three_nn_idx;\n    cudaMalloc(&d_unknown_points, unknown_points_size * sizeof(float));\n    cudaMalloc(&d_known_points, known_points_size * sizeof(float));\n    cudaMalloc(&d_three_nn_idx, three_nn_idx_size * sizeof(int));\n    cudaMemcpy(d_unknown_points, h_unknown_points, unknown_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_known_points, h_known_points, known_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_three_nn_idx, 0, three_nn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_UNKNOWN_POINTS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    three_nn_kernel<<<blocks, threads_per_block>>>(d_unknown_points, d_known_points, d_three_nn_idx);\n    cudaMemcpy(h_three_nn_idx, d_three_nn_idx, three_nn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_three_nn_idx.bin\";\n    write_binary(output_file, h_three_nn_idx, three_nn_idx_size);\n\n    cudaFree(d_unknown_points);\n    cudaFree(d_known_points);\n    cudaFree(d_three_nn_idx);\n    delete[] h_unknown_points;\n    delete[] h_known_points;\n    delete[] h_three_nn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_UNKNOWN_POINTS = 2048\nNUM_KNOWN_POINTS = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nunknown_points = torch.rand(BATCH_SIZE, NUM_UNKNOWN_POINTS, 3) * 71.2\nknown_points = torch.rand(BATCH_SIZE, NUM_KNOWN_POINTS, 3) * 71.2\n\n\ndef three_nn_pytorch(unknow_points, known_points):\n    B, N, _ = unknown_points.shape\n    _, M, _ = known_points.shape\n    idx = torch.zeros(B, N, 3, dtype=torch.int32)\n\n    for b in range(B):\n        for n in range(N):\n            dists = torch.sum((known_points[b] - unknown_points[b, n]) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, 3, largest=False)\n            idx[b, n] = knn_idx\n    return idx\n\n\nthree_nn_idx = three_nn_pytorch(unknown_points, known_points)\n\nos.makedirs(\"data\", exist_ok=True)\nunknown_points.numpy().tofile(\"data/input_unknown_points.bin\")\nknown_points.numpy().tofile(\"data/input_known_points.bin\")\nthree_nn_idx.numpy().tofile(\"data/expected_three_nn_idx.bin\")", "compare.py": "\nimport numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_UNKNOWN_POINTS = 2048\n    total_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3  # 3 nearest neighbors\n\n    output_file = \"./data/output_three_nn_idx.bin\"\n    ref_file = \"./data/expected_three_nn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n\n", "level1_prompt": "Task: Three_NN. For each batch of 16 sets containing 2048 unknown 3D points, find the indices of the three nearest neighbors from a corresponding set of 128 known 3D points per batch. Inputs include float32 tensors for unknown points (16x2048x3) and known points (16x128x3). Output must be an int32 tensor (16x2048x3) storing indices of the three closest known points for each unknown point, ordered by ascending distance. Kernel must compute squared Euclidean distances and maintain per-batch isolation.", "level2_prompt": "Task: Three_NN. For every unknown 3D point across all batches, compute squared Euclidean distances to all known points in its batch. Identify and record indices of the three closest known points per unknown point, sorted by proximity. Batch processing must remain independent.", "level3_prompt": "Compute the Three_NN kernel on GPU using CUDA."}
{"id": 424, "task_name": "Three_NN", "task_description": "Compute the Three_NN kernel on GPU using CUDA.", "inputs": [{"name": "input_unknown_points", "dtype": "float32", "shape": "(16, 4096, 3)"}, {"name": "input_known_points", "dtype": "float32", "shape": "(16, 128, 3)"}], "outputs": [{"name": "output_three_nn_idx", "dtype": "int32", "shape": "(16, 4096, 3)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <fstream>\n#include <cmath>\n\n#include <cuda_runtime.h>\n\n#define BATCH_SIZE 16\n#define NUM_UNKNOWN_POINTS 4096\n#define NUM_KNOWN_POINTS 128\n\n__global__ void three_nn_kernel(const float* unknown_points, const float* known_points, int* three_nn_idx) {\n    int pt_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int bs_idx = blockIdx.y;\n    if (pt_idx >= NUM_UNKNOWN_POINTS || bs_idx >= BATCH_SIZE) return;\n\n    const float* this_unknow_point = unknown_points + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n    const float* this_known_point = known_points + bs_idx * NUM_KNOWN_POINTS * 3;\n    int* this_three_nn_idx = three_nn_idx + bs_idx * NUM_UNKNOWN_POINTS * 3 + pt_idx * 3;\n\n    float unknown_point_x = this_unknow_point[0];\n    float unknown_point_y = this_unknow_point[1];\n    float unknown_point_z = this_unknow_point[2];\n\n    float min_dist1 = 1e10, min_dist2 = 1e10, min_dist3 = 1e10;\n    int idx1 = -1, idx2 = -1, idx3 = -1;\n\n    for (int k = 0; k < NUM_KNOWN_POINTS; ++k) {\n        float known_point_x = this_known_point[k * 3 + 0];\n        float known_point_y = this_known_point[k * 3 + 1];\n        float known_point_z = this_known_point[k * 3 + 2];\n\n        float dist = (unknown_point_x - known_point_x) * (unknown_point_x - known_point_x) +\n                     (unknown_point_y - known_point_y) * (unknown_point_y - known_point_y) +\n                     (unknown_point_z - known_point_z) * (unknown_point_z - known_point_z);\n        // Update the three nearest neighbors\n        if (dist < min_dist1) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = min_dist1;\n            idx2 = idx1;\n            min_dist1 = dist;\n            idx1 = k;\n        } else if (dist < min_dist2) {\n            min_dist3 = min_dist2;\n            idx3 = idx2;\n            min_dist2 = dist;\n            idx2 = k;\n        } else if (dist < min_dist3) {\n            min_dist3 = dist;\n            idx3 = k;\n        }\n    }\n    this_three_nn_idx[0] = idx1;\n    this_three_nn_idx[1] = idx2;\n    this_three_nn_idx[2] = idx3;\n}\n\n\ntemplate<typename T>\nvoid read_binary(const std::string& filename, T* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(T));\n    in.close();\n}\n\n\ntemplate<typename T>\nvoid write_binary(const std::string& filename, const T* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(T));\n    out.close();\n}\n\n\nint main() {\n    size_t unknown_points_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n    size_t known_points_size = BATCH_SIZE * NUM_KNOWN_POINTS * 3;\n    size_t three_nn_idx_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3;\n\n    float* h_unknown_points = new float[unknown_points_size];\n    float* h_known_points = new float[known_points_size];\n    int* h_three_nn_idx = new int[three_nn_idx_size];\n\n    std::string unknown_points_file = \"./data/input_unknown_points.bin\";\n    std::string known_points_file = \"./data/input_known_points.bin\";\n    read_binary(unknown_points_file, h_unknown_points, unknown_points_size);\n    read_binary(known_points_file, h_known_points, known_points_size);\n\n    float *d_unknown_points, *d_known_points;\n    int* d_three_nn_idx;\n    cudaMalloc(&d_unknown_points, unknown_points_size * sizeof(float));\n    cudaMalloc(&d_known_points, known_points_size * sizeof(float));\n    cudaMalloc(&d_three_nn_idx, three_nn_idx_size * sizeof(int));\n    cudaMemcpy(d_unknown_points, h_unknown_points, unknown_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_known_points, h_known_points, known_points_size * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemset(d_three_nn_idx, 0, three_nn_idx_size * sizeof(int));\n\n    int threads_per_block = 256;\n    dim3 blocks((NUM_UNKNOWN_POINTS + threads_per_block - 1) / threads_per_block, BATCH_SIZE);\n    three_nn_kernel<<<blocks, threads_per_block>>>(d_unknown_points, d_known_points, d_three_nn_idx);\n    cudaMemcpy(h_three_nn_idx, d_three_nn_idx, three_nn_idx_size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    std::string output_file = \"./data/output_three_nn_idx.bin\";\n    write_binary(output_file, h_three_nn_idx, three_nn_idx_size);\n\n    cudaFree(d_unknown_points);\n    cudaFree(d_known_points);\n    cudaFree(d_three_nn_idx);\n    delete[] h_unknown_points;\n    delete[] h_known_points;\n    delete[] h_three_nn_idx;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\n\nBATCH_SIZE = 16\nNUM_UNKNOWN_POINTS = 4096\nNUM_KNOWN_POINTS = 128\nseed = 0x66ccff\n\ntorch.manual_seed(seed)\n\nunknown_points = torch.rand(BATCH_SIZE, NUM_UNKNOWN_POINTS, 3) * 71.2\nknown_points = torch.rand(BATCH_SIZE, NUM_KNOWN_POINTS, 3) * 71.2\n\n\ndef three_nn_pytorch(unknow_points, known_points):\n    B, N, _ = unknown_points.shape\n    _, M, _ = known_points.shape\n    idx = torch.zeros(B, N, 3, dtype=torch.int32)\n\n    for b in range(B):\n        for n in range(N):\n            dists = torch.sum((known_points[b] - unknown_points[b, n]) ** 2, dim=1)\n            knn_dists, knn_idx = torch.topk(dists, 3, largest=False)\n            idx[b, n] = knn_idx\n    return idx\n\n\nthree_nn_idx = three_nn_pytorch(unknown_points, known_points)\n\nos.makedirs(\"data\", exist_ok=True)\nunknown_points.numpy().tofile(\"data/input_unknown_points.bin\")\nknown_points.numpy().tofile(\"data/input_known_points.bin\")\nthree_nn_idx.numpy().tofile(\"data/expected_three_nn_idx.bin\")", "compare.py": "\nimport numpy as np\nimport os\n\n\ndef read_binary(filename, dtype, size):\n    return np.fromfile(filename, dtype=dtype, count=size)\n\n\ndef compare_results(output_file, ref_file, dtype, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, dtype, size)\n    reference = read_binary(ref_file, dtype, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\n\nif __name__ == \"__main__\":\n    BATCH_SIZE = 16\n    NUM_UNKNOWN_POINTS = 4096\n    total_size = BATCH_SIZE * NUM_UNKNOWN_POINTS * 3  # 3 nearest neighbors\n\n    output_file = \"./data/output_three_nn_idx.bin\"\n    ref_file = \"./data/expected_three_nn_idx.bin\"\n\n    if compare_results(output_file, ref_file, np.int32, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n\n", "level1_prompt": "Task: Three_NN. Compute the indices of the three nearest neighbors for each unknown point from a set of known points. The input includes two tensors: input_unknown_points of shape (16, 4096, 3) and input_known_points of shape (16, 128, 3), both with float32 data type representing 3D coordinates. The output is a tensor named output_three_nn_idx of shape (16, 4096, 3) with int32 data type, storing the indices of the three closest known points for each unknown point. Constraints: Each batch is processed independently, and the kernel must compute Euclidean distances to find the nearest neighbors without modifying input data.", "level2_prompt": "Task: Three_NN. For each batch and each unknown point, calculate the Euclidean distance to all known points in the same batch. Identify the three closest known points and record their indices. The output must store these indices for every unknown point across all batches.", "level3_prompt": "Compute the Three_NN kernel on GPU using CUDA."}
{"id": 425, "task_name": "Edge_Detection", "task_description": "Compute the Edge_Detection kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(256, 256)"}], "outputs": [{"name": "img_edges", "dtype": "float32", "shape": "(256, 256)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define HEIGHT 256\n#define WIDTH 256\n#define TILE_WIDTH 16\n\n__global__ void edge_detection_kernel(const float* input, float* output, int H, int W) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    // Sobel operators\n    const float Gx[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    const float Gy[3][3] = {\n        { 1,  2,  1},\n        { 0,  0,  0},\n        {-1, -2, -1}\n    };\n\n    float grad_x = 0.0f, grad_y = 0.0f;\n\n    // Apply Sobel filter (zero-padded)\n    for (int ky = -1; ky <= 1; ++ky) {\n        for (int kx = -1; kx <= 1; ++kx) {\n            int ny = y + ky;\n            int nx = x + kx;\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n                float val = input[ny * W + nx];\n                grad_x += val * Gx[ky + 1][kx + 1];\n                grad_y += val * Gy[ky + 1][kx + 1];\n            }\n        }\n    }\n\n    float magnitude = sqrtf(grad_x * grad_x + grad_y * grad_y);\n    if (magnitude > 255.0f) magnitude = 255.0f; // clamp\n    output[y * W + x] = magnitude;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n\n    size_t size_input = H * W;\n    size_t size_output = H * W;\n\n    float* h_input = new float[size_input];\n    float* h_output = new float[size_output];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size_input);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, size_input * sizeof(float));\n    cudaMalloc(&d_output, size_output * sizeof(float));\n    cudaMemcpy(d_input, h_input, size_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE_WIDTH, TILE_WIDTH);\n    dim3 grid((W + TILE_WIDTH - 1) / TILE_WIDTH, (H + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    edge_detection_kernel<<<grid, block>>>(d_input, d_output, H, W);\n    cudaMemcpy(h_output, d_output, size_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_edges.bin\";\n    write_binary(out_file, h_output, size_output);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nfrom scipy.signal import convolve2d\n\nH, W = 256, 256\nseed = 42\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random grayscale input\nimg = (torch.rand(H, W, dtype=torch.float32) * 255.0).numpy().astype(np.float32)\nimg.tofile(\"data/img_input.bin\")\n\n# Sobel filters (identical to CUDA kernel)\nGx = np.array([[-1, 0, 1],\n               [-2, 0, 2],\n               [-1, 0, 1]], dtype=np.float32)\nGy = np.array([[ 1,  2,  1],\n               [ 0,  0,  0],\n               [-1, -2, -1]], dtype=np.float32)\n\n# Zero-padded convolution (same as CUDA)\ngrad_x = convolve2d(img, Gx, mode='same', boundary='fill', fillvalue=0)\ngrad_y = convolve2d(img, Gy, mode='same', boundary='fill', fillvalue=0)\n\nedges = np.sqrt(grad_x ** 2 + grad_y ** 2)\nedges = np.clip(edges, 0, 255).astype(np.float32)\n\nedges.tofile(\"data/img_edges_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W = 256, 256\n    size = H * W\n    out_file = \"./data/img_edges.bin\"\n    ref_file = \"./data/img_edges_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Edge_Detection: Implement a kernel that detects edges in an input image using the Sobel operator. The input is a 256x256 float32 tensor representing the image. The output is a 256x256 float32 tensor containing the edge map. Compute horizontal and vertical gradients by applying 3x3 Sobel kernels with zero-padding for boundary pixels, then calculate the gradient magnitude as the Euclidean norm of the gradients and clamp it to the range [0, 255].", "level2_prompt": "Edge_Detection: For each pixel in the image, convolve with horizontal and vertical Sobel filters to obtain gradient components, compute the magnitude as the square root of the sum of their squares, and clamp the result to [0, 255]. Boundary handling ensures only valid neighboring pixels are considered.", "level3_prompt": "Compute edge detection for an input image."}
{"id": 426, "task_name": "Edge_Detection", "task_description": "Compute the Edge_Detection kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(512, 512)"}], "outputs": [{"name": "img_edges", "dtype": "float32", "shape": "(512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define HEIGHT 512\n#define WIDTH 512\n#define TILE_WIDTH 16\n\n__global__ void edge_detection_kernel(const float* input, float* output, int H, int W) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    // Sobel operators\n    const float Gx[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    const float Gy[3][3] = {\n        { 1,  2,  1},\n        { 0,  0,  0},\n        {-1, -2, -1}\n    };\n\n    float grad_x = 0.0f, grad_y = 0.0f;\n\n    // Apply Sobel filter (zero-padded)\n    for (int ky = -1; ky <= 1; ++ky) {\n        for (int kx = -1; kx <= 1; ++kx) {\n            int ny = y + ky;\n            int nx = x + kx;\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n                float val = input[ny * W + nx];\n                grad_x += val * Gx[ky + 1][kx + 1];\n                grad_y += val * Gy[ky + 1][kx + 1];\n            }\n        }\n    }\n\n    float magnitude = sqrtf(grad_x * grad_x + grad_y * grad_y);\n    if (magnitude > 255.0f) magnitude = 255.0f; // clamp\n    output[y * W + x] = magnitude;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n\n    size_t size_input = H * W;\n    size_t size_output = H * W;\n\n    float* h_input = new float[size_input];\n    float* h_output = new float[size_output];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size_input);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, size_input * sizeof(float));\n    cudaMalloc(&d_output, size_output * sizeof(float));\n    cudaMemcpy(d_input, h_input, size_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE_WIDTH, TILE_WIDTH);\n    dim3 grid((W + TILE_WIDTH - 1) / TILE_WIDTH, (H + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    edge_detection_kernel<<<grid, block>>>(d_input, d_output, H, W);\n    cudaMemcpy(h_output, d_output, size_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_edges.bin\";\n    write_binary(out_file, h_output, size_output);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nfrom scipy.signal import convolve2d\n\nH, W = 512, 512\nseed = 42\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random grayscale input\nimg = (torch.rand(H, W, dtype=torch.float32) * 255.0).numpy().astype(np.float32)\nimg.tofile(\"data/img_input.bin\")\n\n# Sobel filters (identical to CUDA kernel)\nGx = np.array([[-1, 0, 1],\n               [-2, 0, 2],\n               [-1, 0, 1]], dtype=np.float32)\nGy = np.array([[ 1,  2,  1],\n               [ 0,  0,  0],\n               [-1, -2, -1]], dtype=np.float32)\n\n# Zero-padded convolution (same as CUDA)\ngrad_x = convolve2d(img, Gx, mode='same', boundary='fill', fillvalue=0)\ngrad_y = convolve2d(img, Gy, mode='same', boundary='fill', fillvalue=0)\n\nedges = np.sqrt(grad_x ** 2 + grad_y ** 2)\nedges = np.clip(edges, 0, 255).astype(np.float32)\n\nedges.tofile(\"data/img_edges_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W = 512, 512\n    size = H * W\n    out_file = \"./data/img_edges.bin\"\n    ref_file = \"./data/img_edges_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Edge_Detection. Compute edge detection on a 512x512 grayscale input image using the Sobel operator. The Sobel operator involves applying two 3x3 filters: one for horizontal gradients (Gx) and one for vertical gradients (Gy). For each pixel, compute the gradient magnitudes by convolving the surrounding 3x3 pixel neighborhood with these filters. Boundary pixels should be handled via zero-padding. The output magnitude is the Euclidean norm of the horizontal and vertical gradients, clamped to a maximum value of 255. The input is a float32 tensor of shape (512, 512), and the output is a float32 tensor of the same shape.", "level2_prompt": "Edge_Detection: For each pixel in a 512x512 image, calculate horizontal and vertical gradients using 3x3 Sobel kernels. The horizontal kernel is [[-1,0,1], [-2,0,2], [-1,0,1]], and the vertical kernel is [[1,2,1], [0,0,0], [-1,-2,-1]]. The edge magnitude is the square root of the sum of squares of these gradients, clamped to 255.", "level3_prompt": "Edge detection on a 512x512 image."}
{"id": 427, "task_name": "Edge_Detection", "task_description": "Compute the Edge_Detection kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "img_edges", "dtype": "float32", "shape": "(1024, 1024)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define HEIGHT 1024\n#define WIDTH 1024\n#define TILE_WIDTH 16\n\n__global__ void edge_detection_kernel(const float* input, float* output, int H, int W) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    // Sobel operators\n    const float Gx[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    const float Gy[3][3] = {\n        { 1,  2,  1},\n        { 0,  0,  0},\n        {-1, -2, -1}\n    };\n\n    float grad_x = 0.0f, grad_y = 0.0f;\n\n    // Apply Sobel filter (zero-padded)\n    for (int ky = -1; ky <= 1; ++ky) {\n        for (int kx = -1; kx <= 1; ++kx) {\n            int ny = y + ky;\n            int nx = x + kx;\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n                float val = input[ny * W + nx];\n                grad_x += val * Gx[ky + 1][kx + 1];\n                grad_y += val * Gy[ky + 1][kx + 1];\n            }\n        }\n    }\n\n    float magnitude = sqrtf(grad_x * grad_x + grad_y * grad_y);\n    if (magnitude > 255.0f) magnitude = 255.0f; // clamp\n    output[y * W + x] = magnitude;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n\n    size_t size_input = H * W;\n    size_t size_output = H * W;\n\n    float* h_input = new float[size_input];\n    float* h_output = new float[size_output];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size_input);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, size_input * sizeof(float));\n    cudaMalloc(&d_output, size_output * sizeof(float));\n    cudaMemcpy(d_input, h_input, size_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE_WIDTH, TILE_WIDTH);\n    dim3 grid((W + TILE_WIDTH - 1) / TILE_WIDTH, (H + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    edge_detection_kernel<<<grid, block>>>(d_input, d_output, H, W);\n    cudaMemcpy(h_output, d_output, size_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_edges.bin\";\n    write_binary(out_file, h_output, size_output);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nfrom scipy.signal import convolve2d\n\nH, W = 1024, 1024\nseed = 42\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random grayscale input\nimg = (torch.rand(H, W, dtype=torch.float32) * 255.0).numpy().astype(np.float32)\nimg.tofile(\"data/img_input.bin\")\n\n# Sobel filters (identical to CUDA kernel)\nGx = np.array([[-1, 0, 1],\n               [-2, 0, 2],\n               [-1, 0, 1]], dtype=np.float32)\nGy = np.array([[ 1,  2,  1],\n               [ 0,  0,  0],\n               [-1, -2, -1]], dtype=np.float32)\n\n# Zero-padded convolution (same as CUDA)\ngrad_x = convolve2d(img, Gx, mode='same', boundary='fill', fillvalue=0)\ngrad_y = convolve2d(img, Gy, mode='same', boundary='fill', fillvalue=0)\n\nedges = np.sqrt(grad_x ** 2 + grad_y ** 2)\nedges = np.clip(edges, 0, 255).astype(np.float32)\n\nedges.tofile(\"data/img_edges_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W = 1024, 1024\n    size = H * W\n    out_file = \"./data/img_edges.bin\"\n    ref_file = \"./data/img_edges_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Edge Detection. The kernel must compute edge detection on a 1024x1024 input image. The input tensor, named img_input, is a float32 array of shape (1024, 1024) representing a grayscale image. The output tensor, named img_edges, is a float32 array of the same shape (1024, 1024). The kernel must apply the Sobel operator to compute the gradient at each pixel. Specifically, for each pixel, compute the horizontal gradient (Gx) and vertical gradient (Gy) by convolving the 3x3 Sobel filters (Gx: [[-1,0,1],[-2,0,2],[-1,0,1]] and Gy: [[1,2,1],[0,0,0],[-1,-2,-1]]) with the 3x3 neighborhood of the pixel, using zero-padding for boundary pixels. The magnitude of the gradient is then calculated as the square root of (Gx^2 + Gy^2) and clamped to a maximum value of 255.0. The output for each pixel is this clamped magnitude.", "level2_prompt": "Task: Edge Detection. For each pixel in the input image, compute the edge magnitude using the Sobel operator. The Sobel operator uses two 3x3 filters: one for horizontal gradient and one for vertical gradient. The horizontal filter is [-1, 0, 1; -2, 0, 2; -1, 0, 1] and the vertical filter is [1, 2, 1; 0, 0, 0; -1, -2, -1]. The gradients are computed by taking the weighted sum of the 3x3 neighborhood of the pixel (with weights from the respective filter), and the magnitude is the Euclidean norm of the two gradients. The magnitude is then clamped to 255.0.", "level3_prompt": "Edge detection using the Sobel operator."}
{"id": 428, "task_name": "Edge_Detection", "task_description": "Compute the Edge_Detection kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "img_edges", "dtype": "float32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define HEIGHT 2048\n#define WIDTH 2048\n#define TILE_WIDTH 16\n\n__global__ void edge_detection_kernel(const float* input, float* output, int H, int W) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    // Sobel operators\n    const float Gx[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    const float Gy[3][3] = {\n        { 1,  2,  1},\n        { 0,  0,  0},\n        {-1, -2, -1}\n    };\n\n    float grad_x = 0.0f, grad_y = 0.0f;\n\n    // Apply Sobel filter (zero-padded)\n    for (int ky = -1; ky <= 1; ++ky) {\n        for (int kx = -1; kx <= 1; ++kx) {\n            int ny = y + ky;\n            int nx = x + kx;\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n                float val = input[ny * W + nx];\n                grad_x += val * Gx[ky + 1][kx + 1];\n                grad_y += val * Gy[ky + 1][kx + 1];\n            }\n        }\n    }\n\n    float magnitude = sqrtf(grad_x * grad_x + grad_y * grad_y);\n    if (magnitude > 255.0f) magnitude = 255.0f; // clamp\n    output[y * W + x] = magnitude;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n\n    size_t size_input = H * W;\n    size_t size_output = H * W;\n\n    float* h_input = new float[size_input];\n    float* h_output = new float[size_output];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size_input);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, size_input * sizeof(float));\n    cudaMalloc(&d_output, size_output * sizeof(float));\n    cudaMemcpy(d_input, h_input, size_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE_WIDTH, TILE_WIDTH);\n    dim3 grid((W + TILE_WIDTH - 1) / TILE_WIDTH, (H + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    edge_detection_kernel<<<grid, block>>>(d_input, d_output, H, W);\n    cudaMemcpy(h_output, d_output, size_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_edges.bin\";\n    write_binary(out_file, h_output, size_output);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nfrom scipy.signal import convolve2d\n\nH, W = 2048, 2048\nseed = 42\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random grayscale input\nimg = (torch.rand(H, W, dtype=torch.float32) * 255.0).numpy().astype(np.float32)\nimg.tofile(\"data/img_input.bin\")\n\n# Sobel filters (identical to CUDA kernel)\nGx = np.array([[-1, 0, 1],\n               [-2, 0, 2],\n               [-1, 0, 1]], dtype=np.float32)\nGy = np.array([[ 1,  2,  1],\n               [ 0,  0,  0],\n               [-1, -2, -1]], dtype=np.float32)\n\n# Zero-padded convolution (same as CUDA)\ngrad_x = convolve2d(img, Gx, mode='same', boundary='fill', fillvalue=0)\ngrad_y = convolve2d(img, Gy, mode='same', boundary='fill', fillvalue=0)\n\nedges = np.sqrt(grad_x ** 2 + grad_y ** 2)\nedges = np.clip(edges, 0, 255).astype(np.float32)\n\nedges.tofile(\"data/img_edges_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W = 2048, 2048\n    size = H * W\n    out_file = \"./data/img_edges.bin\"\n    ref_file = \"./data/img_edges_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Edge Detection: Implement a CUDA kernel that performs edge detection on a 2048x2048 grayscale image. The input is a float32 tensor representing pixel intensities. Apply the Sobel operator using 3x3 filters (Gx and Gy) with zero-padding at boundaries. For each pixel, compute horizontal and vertical gradients through weighted neighborhood sums, then calculate the Euclidean norm of these gradients. Clamp the resulting magnitude to 255.0 if it exceeds this value. Output a float32 tensor of identical dimensions to the input.", "level2_prompt": "Edge Detection: For each pixel in a 2048x2048 image, compute edge magnitude by convolving with horizontal and vertical Sobel kernels. The horizontal kernel weights are [-1,0,1], [-2,0,2], [-1,0,1], and the vertical kernel weights are [1,2,1], [0,0,0], [-1,-2,-1]. Handle boundaries via zero-padding. The edge strength is the Euclidean norm of the convolution results, clamped to 255.0 maximum.", "level3_prompt": "Compute the Edge_Detection kernel on GPU using CUDA for a 2048x2048 image."}
{"id": 429, "task_name": "Edge_Detection", "task_description": "Compute the Edge_Detection kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(4096, 4096)"}], "outputs": [{"name": "img_edges", "dtype": "float32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define HEIGHT 4096\n#define WIDTH 4096\n#define TILE_WIDTH 16\n\n__global__ void edge_detection_kernel(const float* input, float* output, int H, int W) {\n    int x = blockIdx.x * blockDim.x + threadIdx.x;\n    int y = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (x >= W || y >= H) return;\n\n    // Sobel operators\n    const float Gx[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    const float Gy[3][3] = {\n        { 1,  2,  1},\n        { 0,  0,  0},\n        {-1, -2, -1}\n    };\n\n    float grad_x = 0.0f, grad_y = 0.0f;\n\n    // Apply Sobel filter (zero-padded)\n    for (int ky = -1; ky <= 1; ++ky) {\n        for (int kx = -1; kx <= 1; ++kx) {\n            int ny = y + ky;\n            int nx = x + kx;\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W) {\n                float val = input[ny * W + nx];\n                grad_x += val * Gx[ky + 1][kx + 1];\n                grad_y += val * Gy[ky + 1][kx + 1];\n            }\n        }\n    }\n\n    float magnitude = sqrtf(grad_x * grad_x + grad_y * grad_y);\n    if (magnitude > 255.0f) magnitude = 255.0f; // clamp\n    output[y * W + x] = magnitude;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n\n    size_t size_input = H * W;\n    size_t size_output = H * W;\n\n    float* h_input = new float[size_input];\n    float* h_output = new float[size_output];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size_input);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, size_input * sizeof(float));\n    cudaMalloc(&d_output, size_output * sizeof(float));\n    cudaMemcpy(d_input, h_input, size_input * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(TILE_WIDTH, TILE_WIDTH);\n    dim3 grid((W + TILE_WIDTH - 1) / TILE_WIDTH, (H + TILE_WIDTH - 1) / TILE_WIDTH);\n\n    edge_detection_kernel<<<grid, block>>>(d_input, d_output, H, W);\n    cudaMemcpy(h_output, d_output, size_output * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_edges.bin\";\n    write_binary(out_file, h_output, size_output);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nfrom scipy.signal import convolve2d\n\nH, W = 4096, 4096\nseed = 42\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random grayscale input\nimg = (torch.rand(H, W, dtype=torch.float32) * 255.0).numpy().astype(np.float32)\nimg.tofile(\"data/img_input.bin\")\n\n# Sobel filters (identical to CUDA kernel)\nGx = np.array([[-1, 0, 1],\n               [-2, 0, 2],\n               [-1, 0, 1]], dtype=np.float32)\nGy = np.array([[ 1,  2,  1],\n               [ 0,  0,  0],\n               [-1, -2, -1]], dtype=np.float32)\n\n# Zero-padded convolution (same as CUDA)\ngrad_x = convolve2d(img, Gx, mode='same', boundary='fill', fillvalue=0)\ngrad_y = convolve2d(img, Gy, mode='same', boundary='fill', fillvalue=0)\n\nedges = np.sqrt(grad_x ** 2 + grad_y ** 2)\nedges = np.clip(edges, 0, 255).astype(np.float32)\n\nedges.tofile(\"data/img_edges_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W = 4096, 4096\n    size = H * W\n    out_file = \"./data/img_edges.bin\"\n    ref_file = \"./data/img_edges_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an edge detection kernel for a 4096x4096 grayscale image. The input is a 2D tensor of float32 values representing pixel intensities. Apply the Sobel operator using two predefined 3x3 filters: one for horizontal gradients (Gx: [[-1,0,1], [-2,0,2], [-1,0,1]]) and one for vertical gradients (Gy: [[1,2,1], [0,0,0], [-1,-2,-1]]). For each pixel, compute the convolution with both filters over its 3x3 neighborhood, using zero-padding for boundary pixels. Calculate the gradient magnitude as the square root of the sum of squares of the horizontal and vertical gradients. Clamp the output magnitude to 255 if it exceeds this value. The output is a 1D tensor of float32 values with length 16777216 (4096x4096 flattened).", "level2_prompt": "For each pixel in a 4096x4096 image, compute edge detection using the Sobel operator. Apply horizontal and vertical 3x3 filters to the pixel's neighborhood (with zero-padding at boundaries). The edge magnitude is the Euclidean norm of the two filter results, clamped to a maximum of 255. Output the results as a flattened tensor.", "level3_prompt": "Edge detection for a 4096x4096 image using the Sobel operator."}
{"id": 430, "task_name": "Image_Convolution", "task_description": "Compute the Image_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(256, 256, 3)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(3, 3)"}], "outputs": [{"name": "img_output", "dtype": "float32", "shape": "(256, 256, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 256\n#define WIDTH  256\n#define CHANNELS 3\n#define KERNEL_SIZE 3\n#define STRIDE 1\n#define PADDING 1\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n__global__ void conv2d_depthwise_hwc_kernel(const float* __restrict__ input,\n                                            const float* __restrict__ kernel,\n                                            float* __restrict__ output,\n                                            int H, int W, int C) {\n    // Each block.z handles one channel\n    int c = blockIdx.z;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (c >= C || h >= H || w >= W) return;\n\n    // Zero-padded, stride=1, dilation=1\n    float acc = 0.0f;\n\n    #pragma unroll\n    for (int kh = 0; kh < KERNEL_SIZE; ++kh) {\n        int ih = h + kh - PADDING;\n        if (ih < 0 || ih >= H) continue;\n\n        #pragma unroll\n        for (int kw = 0; kw < KERNEL_SIZE; ++kw) {\n            int iw = w + kw - PADDING;\n            if (iw < 0 || iw >= W) continue;\n\n            float x = input[idx_hwc(ih, iw, c, H, W, C)];\n            float k = kernel[kh * KERNEL_SIZE + kw]; // same kernel for all channels\n            acc += x * k;\n        }\n    }\n\n    output[idx_hwc(h, w, c, H, W, C)] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT, W = WIDTH, C = CHANNELS;\n\n    const size_t in_elems  = static_cast<size_t>(H) * W * C;               // HWC\n    const size_t ker_elems = static_cast<size_t>(KERNEL_SIZE) * KERNEL_SIZE; // 3x3\n    const size_t out_elems = in_elems;\n\n    float* h_input  = new float[in_elems];\n    float* h_kernel = new float[ker_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file  = \"./data/img_input.bin\";\n    std::string kernel_file = \"./data/conv_kernel.bin\";\n    read_binary(input_file,  h_input,  in_elems);\n    read_binary(kernel_file, h_kernel, ker_elems);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input,  in_elems  * sizeof(float));\n    cudaMalloc(&d_kernel, ker_elems * sizeof(float));\n    cudaMalloc(&d_output, out_elems * sizeof(float));\n\n    cudaMemcpy(d_input,  h_input,  in_elems  * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, ker_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16, 1);\n    dim3 grid( (W + block.x - 1) / block.x,\n               (H + block.y - 1) / block.y,\n               C );\n\n    conv2d_depthwise_hwc_kernel<<<grid, block>>>(d_input, d_kernel, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\n# Image and kernel configuration (must match CUDA)\nH, W, C = 256, 256, 3\nKH = KW = 3\nPADDING = 1  # zero pad\nSTRIDE = 1\n\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random image in HWC layout (float32)\n# Range chosen to be reasonable (e.g., -1..1); adjust as needed\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Create a single shared 3x3 kernel applied to each channel (depthwise)\n# Example: simple normalized blur kernel; replace with any values as needed\nkernel = torch.tensor([[1., 2., 1.],\n                       [2., 4., 2.],\n                       [1., 2., 1.]], dtype=torch.float32)\nkernel = kernel / kernel.sum()\n\n# --- Save inputs ---\nimg.numpy().tofile(\"data/img_input.bin\")\nkernel.numpy().tofile(\"data/conv_kernel.bin\")\n\n# --- Reference convolution using PyTorch ---\n# Convert to NCHW and build grouped weight so the same kernel is used per channel\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()   # [1, C, H, W]\n\n# Weight shape for depthwise: [out_channels=C, in_channels_per_group=1, KH, KW], groups=C\nw = kernel.view(1, 1, KH, KW).expand(C, 1, KH, KW).contiguous()\ny_nchw = F.conv2d(x_nchw, w, bias=None, stride=STRIDE, padding=PADDING, dilation=1, groups=C)\n\n# Back to HWC\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()    # [H, W, C]\n\n# --- Save reference output ---\ny_hwc.numpy().tofile(\"data/img_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 256, 256, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_output.bin\"\n    ref_file = \"./data/img_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Image_Convolution task. The kernel should perform a depthwise convolution on an input image tensor of shape (256, 256, 3) with data type float32, using a 3x3 convolution kernel of data type float32. The output tensor must have the same shape (256, 256, 3) and dtype float32. The convolution must be applied with a stride of 1 and padding of 1 (zero-padding), resulting in output dimensions matching the input. The same kernel is used for each channel independently, and the computation must respect the depthwise constraint where channels are processed separately without cross-channel interactions.", "level2_prompt": "The Image_Convolution task involves computing a convolution where for each output pixel position (h, w) and each channel c, the value is the sum of the products of the input values in a 3x3 neighborhood centered at (h, w) and the corresponding kernel weights. Zero-padding is applied at the boundaries to maintain the output dimensions, and the kernel is identical for all channels, ensuring no mixing between channels.", "level3_prompt": "Compute the image convolution using a depthwise approach with a 3x3 kernel."}
{"id": 431, "task_name": "Image_Convolution", "task_description": "Compute the Image_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(512, 512, 3)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(3, 3)"}], "outputs": [{"name": "img_output", "dtype": "float32", "shape": "(512, 512, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 512\n#define WIDTH  512\n#define CHANNELS 3\n#define KERNEL_SIZE 3\n#define STRIDE 1\n#define PADDING 1\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n__global__ void conv2d_depthwise_hwc_kernel(const float* __restrict__ input,\n                                            const float* __restrict__ kernel,\n                                            float* __restrict__ output,\n                                            int H, int W, int C) {\n    // Each block.z handles one channel\n    int c = blockIdx.z;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (c >= C || h >= H || w >= W) return;\n\n    // Zero-padded, stride=1, dilation=1\n    float acc = 0.0f;\n\n    #pragma unroll\n    for (int kh = 0; kh < KERNEL_SIZE; ++kh) {\n        int ih = h + kh - PADDING;\n        if (ih < 0 || ih >= H) continue;\n\n        #pragma unroll\n        for (int kw = 0; kw < KERNEL_SIZE; ++kw) {\n            int iw = w + kw - PADDING;\n            if (iw < 0 || iw >= W) continue;\n\n            float x = input[idx_hwc(ih, iw, c, H, W, C)];\n            float k = kernel[kh * KERNEL_SIZE + kw]; // same kernel for all channels\n            acc += x * k;\n        }\n    }\n\n    output[idx_hwc(h, w, c, H, W, C)] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT, W = WIDTH, C = CHANNELS;\n\n    const size_t in_elems  = static_cast<size_t>(H) * W * C;               // HWC\n    const size_t ker_elems = static_cast<size_t>(KERNEL_SIZE) * KERNEL_SIZE; // 3x3\n    const size_t out_elems = in_elems;\n\n    float* h_input  = new float[in_elems];\n    float* h_kernel = new float[ker_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file  = \"./data/img_input.bin\";\n    std::string kernel_file = \"./data/conv_kernel.bin\";\n    read_binary(input_file,  h_input,  in_elems);\n    read_binary(kernel_file, h_kernel, ker_elems);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input,  in_elems  * sizeof(float));\n    cudaMalloc(&d_kernel, ker_elems * sizeof(float));\n    cudaMalloc(&d_output, out_elems * sizeof(float));\n\n    cudaMemcpy(d_input,  h_input,  in_elems  * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, ker_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16, 1);\n    dim3 grid( (W + block.x - 1) / block.x,\n               (H + block.y - 1) / block.y,\n               C );\n\n    conv2d_depthwise_hwc_kernel<<<grid, block>>>(d_input, d_kernel, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\n# Image and kernel configuration (must match CUDA)\nH, W, C = 512, 512, 3\nKH = KW = 3\nPADDING = 1  # zero pad\nSTRIDE = 1\n\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random image in HWC layout (float32)\n# Range chosen to be reasonable (e.g., -1..1); adjust as needed\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Create a single shared 3x3 kernel applied to each channel (depthwise)\n# Example: simple normalized blur kernel; replace with any values as needed\nkernel = torch.tensor([[1., 2., 1.],\n                       [2., 4., 2.],\n                       [1., 2., 1.]], dtype=torch.float32)\nkernel = kernel / kernel.sum()\n\n# --- Save inputs ---\nimg.numpy().tofile(\"data/img_input.bin\")\nkernel.numpy().tofile(\"data/conv_kernel.bin\")\n\n# --- Reference convolution using PyTorch ---\n# Convert to NCHW and build grouped weight so the same kernel is used per channel\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()   # [1, C, H, W]\n\n# Weight shape for depthwise: [out_channels=C, in_channels_per_group=1, KH, KW], groups=C\nw = kernel.view(1, 1, KH, KW).expand(C, 1, KH, KW).contiguous()\ny_nchw = F.conv2d(x_nchw, w, bias=None, stride=STRIDE, padding=PADDING, dilation=1, groups=C)\n\n# Back to HWC\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()    # [H, W, C]\n\n# --- Save reference output ---\ny_hwc.numpy().tofile(\"data/img_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 512, 512, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_output.bin\"\n    ref_file = \"./data/img_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a depthwise convolution kernel for image processing. The input is a 512x512x3 tensor (height, width, channels) of float32 values representing an image. Apply a shared 3x3 convolution kernel (float32) independently to each channel. Use stride=1 and zero-padding=1 to maintain output dimensions. For each output pixel, compute the weighted sum of surrounding pixels from the same channel using the kernel weights, skipping out-of-bound pixels. Output must be a 512x512x3 float32 tensor matching input dimensions.", "level2_prompt": "Perform a depthwise convolution where a single 3x3 kernel is applied independently to each channel of a 512x512x3 input tensor. For each output position (h,w,c), compute the sum of kernel weights multiplied by input pixels from the same channel at positions offset by [-1,0,1] in height and width. Apply zero-padding: skip contributions from invalid positions outside the image boundaries.", "level3_prompt": "Compute the Image_Convolution kernel on GPU using CUDA."}
{"id": 432, "task_name": "Image_Convolution", "task_description": "Compute the Image_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(1024, 1024, 3)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(3, 3)"}], "outputs": [{"name": "img_output", "dtype": "float32", "shape": "(1024, 1024, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 1024\n#define WIDTH  1024\n#define CHANNELS 3\n#define KERNEL_SIZE 3\n#define STRIDE 1\n#define PADDING 1\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n__global__ void conv2d_depthwise_hwc_kernel(const float* __restrict__ input,\n                                            const float* __restrict__ kernel,\n                                            float* __restrict__ output,\n                                            int H, int W, int C) {\n    // Each block.z handles one channel\n    int c = blockIdx.z;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (c >= C || h >= H || w >= W) return;\n\n    // Zero-padded, stride=1, dilation=1\n    float acc = 0.0f;\n\n    #pragma unroll\n    for (int kh = 0; kh < KERNEL_SIZE; ++kh) {\n        int ih = h + kh - PADDING;\n        if (ih < 0 || ih >= H) continue;\n\n        #pragma unroll\n        for (int kw = 0; kw < KERNEL_SIZE; ++kw) {\n            int iw = w + kw - PADDING;\n            if (iw < 0 || iw >= W) continue;\n\n            float x = input[idx_hwc(ih, iw, c, H, W, C)];\n            float k = kernel[kh * KERNEL_SIZE + kw]; // same kernel for all channels\n            acc += x * k;\n        }\n    }\n\n    output[idx_hwc(h, w, c, H, W, C)] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT, W = WIDTH, C = CHANNELS;\n\n    const size_t in_elems  = static_cast<size_t>(H) * W * C;               // HWC\n    const size_t ker_elems = static_cast<size_t>(KERNEL_SIZE) * KERNEL_SIZE; // 3x3\n    const size_t out_elems = in_elems;\n\n    float* h_input  = new float[in_elems];\n    float* h_kernel = new float[ker_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file  = \"./data/img_input.bin\";\n    std::string kernel_file = \"./data/conv_kernel.bin\";\n    read_binary(input_file,  h_input,  in_elems);\n    read_binary(kernel_file, h_kernel, ker_elems);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input,  in_elems  * sizeof(float));\n    cudaMalloc(&d_kernel, ker_elems * sizeof(float));\n    cudaMalloc(&d_output, out_elems * sizeof(float));\n\n    cudaMemcpy(d_input,  h_input,  in_elems  * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, ker_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16, 1);\n    dim3 grid( (W + block.x - 1) / block.x,\n               (H + block.y - 1) / block.y,\n               C );\n\n    conv2d_depthwise_hwc_kernel<<<grid, block>>>(d_input, d_kernel, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\n# Image and kernel configuration (must match CUDA)\nH, W, C = 1024, 1024, 3\nKH = KW = 3\nPADDING = 1  # zero pad\nSTRIDE = 1\n\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random image in HWC layout (float32)\n# Range chosen to be reasonable (e.g., -1..1); adjust as needed\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Create a single shared 3x3 kernel applied to each channel (depthwise)\n# Example: simple normalized blur kernel; replace with any values as needed\nkernel = torch.tensor([[1., 2., 1.],\n                       [2., 4., 2.],\n                       [1., 2., 1.]], dtype=torch.float32)\nkernel = kernel / kernel.sum()\n\n# --- Save inputs ---\nimg.numpy().tofile(\"data/img_input.bin\")\nkernel.numpy().tofile(\"data/conv_kernel.bin\")\n\n# --- Reference convolution using PyTorch ---\n# Convert to NCHW and build grouped weight so the same kernel is used per channel\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()   # [1, C, H, W]\n\n# Weight shape for depthwise: [out_channels=C, in_channels_per_group=1, KH, KW], groups=C\nw = kernel.view(1, 1, KH, KW).expand(C, 1, KH, KW).contiguous()\ny_nchw = F.conv2d(x_nchw, w, bias=None, stride=STRIDE, padding=PADDING, dilation=1, groups=C)\n\n# Back to HWC\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()    # [H, W, C]\n\n# --- Save reference output ---\ny_hwc.numpy().tofile(\"data/img_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 1024, 1024, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_output.bin\"\n    ref_file = \"./data/img_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Image_Convolution. Perform a depthwise 2D convolution on a 1024x1024x3 image (HWC layout) using a 3x3 kernel. The input tensor 'img_input' is of shape (1024, 1024, 3) and type float32. The kernel tensor 'conv_kernel' is of shape (3, 3) and type float32. The output tensor 'img_output' must be of the same shape (1024, 1024, 3) and type float32. The convolution must use a stride of 1 and zero-padding of 1 pixel on all sides. Each channel of the image is convolved independently with the same kernel. For each output pixel, compute the sum of the element-wise products between the kernel and the corresponding input window, skipping out-of-bound input pixels (treated as zero).", "level2_prompt": "Task: Image_Convolution. For each channel and each output pixel at (h, w), compute the convolution by taking the 3x3 kernel and sliding it over the input image. The output value at (h, w) in channel c is the sum over kernel rows kh and columns kw of: kernel[kh, kw] multiplied by the input pixel at (h + kh - 1, w + kw - 1, c) if that pixel is within the image boundaries, otherwise zero.", "level3_prompt": "Compute the Image_Convolution kernel on GPU using CUDA."}
{"id": 433, "task_name": "Image_Convolution", "task_description": "Compute the Image_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(2048, 2048, 3)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(3, 3)"}], "outputs": [{"name": "img_output", "dtype": "float32", "shape": "(2048, 2048, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 2048\n#define WIDTH  2048\n#define CHANNELS 3\n#define KERNEL_SIZE 3\n#define STRIDE 1\n#define PADDING 1\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n__global__ void conv2d_depthwise_hwc_kernel(const float* __restrict__ input,\n                                            const float* __restrict__ kernel,\n                                            float* __restrict__ output,\n                                            int H, int W, int C) {\n    // Each block.z handles one channel\n    int c = blockIdx.z;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (c >= C || h >= H || w >= W) return;\n\n    // Zero-padded, stride=1, dilation=1\n    float acc = 0.0f;\n\n    #pragma unroll\n    for (int kh = 0; kh < KERNEL_SIZE; ++kh) {\n        int ih = h + kh - PADDING;\n        if (ih < 0 || ih >= H) continue;\n\n        #pragma unroll\n        for (int kw = 0; kw < KERNEL_SIZE; ++kw) {\n            int iw = w + kw - PADDING;\n            if (iw < 0 || iw >= W) continue;\n\n            float x = input[idx_hwc(ih, iw, c, H, W, C)];\n            float k = kernel[kh * KERNEL_SIZE + kw]; // same kernel for all channels\n            acc += x * k;\n        }\n    }\n\n    output[idx_hwc(h, w, c, H, W, C)] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT, W = WIDTH, C = CHANNELS;\n\n    const size_t in_elems  = static_cast<size_t>(H) * W * C;               // HWC\n    const size_t ker_elems = static_cast<size_t>(KERNEL_SIZE) * KERNEL_SIZE; // 3x3\n    const size_t out_elems = in_elems;\n\n    float* h_input  = new float[in_elems];\n    float* h_kernel = new float[ker_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file  = \"./data/img_input.bin\";\n    std::string kernel_file = \"./data/conv_kernel.bin\";\n    read_binary(input_file,  h_input,  in_elems);\n    read_binary(kernel_file, h_kernel, ker_elems);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input,  in_elems  * sizeof(float));\n    cudaMalloc(&d_kernel, ker_elems * sizeof(float));\n    cudaMalloc(&d_output, out_elems * sizeof(float));\n\n    cudaMemcpy(d_input,  h_input,  in_elems  * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, ker_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16, 1);\n    dim3 grid( (W + block.x - 1) / block.x,\n               (H + block.y - 1) / block.y,\n               C );\n\n    conv2d_depthwise_hwc_kernel<<<grid, block>>>(d_input, d_kernel, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\n# Image and kernel configuration (must match CUDA)\nH, W, C = 2048, 2048, 3\nKH = KW = 3\nPADDING = 1  # zero pad\nSTRIDE = 1\n\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random image in HWC layout (float32)\n# Range chosen to be reasonable (e.g., -1..1); adjust as needed\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Create a single shared 3x3 kernel applied to each channel (depthwise)\n# Example: simple normalized blur kernel; replace with any values as needed\nkernel = torch.tensor([[1., 2., 1.],\n                       [2., 4., 2.],\n                       [1., 2., 1.]], dtype=torch.float32)\nkernel = kernel / kernel.sum()\n\n# --- Save inputs ---\nimg.numpy().tofile(\"data/img_input.bin\")\nkernel.numpy().tofile(\"data/conv_kernel.bin\")\n\n# --- Reference convolution using PyTorch ---\n# Convert to NCHW and build grouped weight so the same kernel is used per channel\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()   # [1, C, H, W]\n\n# Weight shape for depthwise: [out_channels=C, in_channels_per_group=1, KH, KW], groups=C\nw = kernel.view(1, 1, KH, KW).expand(C, 1, KH, KW).contiguous()\ny_nchw = F.conv2d(x_nchw, w, bias=None, stride=STRIDE, padding=PADDING, dilation=1, groups=C)\n\n# Back to HWC\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()    # [H, W, C]\n\n# --- Save reference output ---\ny_hwc.numpy().tofile(\"data/img_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 2048, 2048, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_output.bin\"\n    ref_file = \"./data/img_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Image_Convolution kernel. Perform a depthwise convolution on a 3-channel input image using a 3x3 kernel. The input tensor is a 2048x2048x3 float32 array representing image data in height-width-channel layout. The kernel tensor is a 3x3 float32 array. Apply the same kernel to each channel independently with stride 1 and zero-padding of 1 pixel. The output must be a 2048x2048x3 float32 tensor with identical dimensions to the input. Each output pixel is computed by taking the weighted sum of its 3x3 neighborhood in the corresponding input channel, skipping out-of-bound pixels.", "level2_prompt": "Compute depthwise convolution for a 3-channel image. For each output pixel location (h,w) in each channel c, sum the products of input pixels (h+kh-1, w+kw-1, c) with kernel weights (kh, kw), skipping coordinates outside image boundaries.", "level3_prompt": "Compute the Image_Convolution kernel on GPU using CUDA."}
{"id": 434, "task_name": "Image_Convolution", "task_description": "Compute the Image_Convolution kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(4096, 4096, 3)"}, {"name": "conv_kernel", "dtype": "float32", "shape": "(3, 3)"}], "outputs": [{"name": "img_output", "dtype": "float32", "shape": "(4096, 4096, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 4096\n#define WIDTH  4096\n#define CHANNELS 3\n#define KERNEL_SIZE 3\n#define STRIDE 1\n#define PADDING 1\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n__global__ void conv2d_depthwise_hwc_kernel(const float* __restrict__ input,\n                                            const float* __restrict__ kernel,\n                                            float* __restrict__ output,\n                                            int H, int W, int C) {\n    // Each block.z handles one channel\n    int c = blockIdx.z;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n\n    if (c >= C || h >= H || w >= W) return;\n\n    // Zero-padded, stride=1, dilation=1\n    float acc = 0.0f;\n\n    #pragma unroll\n    for (int kh = 0; kh < KERNEL_SIZE; ++kh) {\n        int ih = h + kh - PADDING;\n        if (ih < 0 || ih >= H) continue;\n\n        #pragma unroll\n        for (int kw = 0; kw < KERNEL_SIZE; ++kw) {\n            int iw = w + kw - PADDING;\n            if (iw < 0 || iw >= W) continue;\n\n            float x = input[idx_hwc(ih, iw, c, H, W, C)];\n            float k = kernel[kh * KERNEL_SIZE + kw]; // same kernel for all channels\n            acc += x * k;\n        }\n    }\n\n    output[idx_hwc(h, w, c, H, W, C)] = acc;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT, W = WIDTH, C = CHANNELS;\n\n    const size_t in_elems  = static_cast<size_t>(H) * W * C;               // HWC\n    const size_t ker_elems = static_cast<size_t>(KERNEL_SIZE) * KERNEL_SIZE; // 3x3\n    const size_t out_elems = in_elems;\n\n    float* h_input  = new float[in_elems];\n    float* h_kernel = new float[ker_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file  = \"./data/img_input.bin\";\n    std::string kernel_file = \"./data/conv_kernel.bin\";\n    read_binary(input_file,  h_input,  in_elems);\n    read_binary(kernel_file, h_kernel, ker_elems);\n\n    float *d_input, *d_kernel, *d_output;\n    cudaMalloc(&d_input,  in_elems  * sizeof(float));\n    cudaMalloc(&d_kernel, ker_elems * sizeof(float));\n    cudaMalloc(&d_output, out_elems * sizeof(float));\n\n    cudaMemcpy(d_input,  h_input,  in_elems  * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_kernel, h_kernel, ker_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16, 1);\n    dim3 grid( (W + block.x - 1) / block.x,\n               (H + block.y - 1) / block.y,\n               C );\n\n    conv2d_depthwise_hwc_kernel<<<grid, block>>>(d_input, d_kernel, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_output.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_kernel);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_kernel;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\n# Image and kernel configuration (must match CUDA)\nH, W, C = 4096, 4096, 3\nKH = KW = 3\nPADDING = 1  # zero pad\nSTRIDE = 1\n\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Create random image in HWC layout (float32)\n# Range chosen to be reasonable (e.g., -1..1); adjust as needed\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Create a single shared 3x3 kernel applied to each channel (depthwise)\n# Example: simple normalized blur kernel; replace with any values as needed\nkernel = torch.tensor([[1., 2., 1.],\n                       [2., 4., 2.],\n                       [1., 2., 1.]], dtype=torch.float32)\nkernel = kernel / kernel.sum()\n\n# --- Save inputs ---\nimg.numpy().tofile(\"data/img_input.bin\")\nkernel.numpy().tofile(\"data/conv_kernel.bin\")\n\n# --- Reference convolution using PyTorch ---\n# Convert to NCHW and build grouped weight so the same kernel is used per channel\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()   # [1, C, H, W]\n\n# Weight shape for depthwise: [out_channels=C, in_channels_per_group=1, KH, KW], groups=C\nw = kernel.view(1, 1, KH, KW).expand(C, 1, KH, KW).contiguous()\ny_nchw = F.conv2d(x_nchw, w, bias=None, stride=STRIDE, padding=PADDING, dilation=1, groups=C)\n\n# Back to HWC\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()    # [H, W, C]\n\n# --- Save reference output ---\ny_hwc.numpy().tofile(\"data/img_output_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 4096, 4096, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_output.bin\"\n    ref_file = \"./data/img_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Image_Convolution kernel. Perform a depthwise convolution on a 3-channel input image with dimensions 4096x4096 using a 3x3 kernel. The input tensor 'img_input' is float32 with shape (4096, 4096, 3), and the kernel tensor 'conv_kernel' is float32 with shape (3, 3). Output tensor 'img_output' must match the input shape and dtype. Use stride=1, padding=1 (zero-padded), and apply the same kernel independently to each channel. Boundary pixels must be handled by skipping out-of-bounds kernel elements.", "level2_prompt": "Image_Convolution: For each channel independently, convolve a 4096x4096 image with a 3x3 kernel. Compute output pixels by sliding the kernel across the image with stride 1 and padding 1. Each output pixel is the sum of element-wise products between the kernel and corresponding input window, treating out-of-bound positions as zero.", "level3_prompt": "Compute the Image_Convolution kernel on GPU using CUDA."}
{"id": 435, "task_name": "Matrix_Transpose", "task_description": "Compute the Matrix_Transpose kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(1024, 1024)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define ROWS (1 << 10)  \n#define COLS (1 << 10)\n\n__global__ void matrix_transpose_kernel(const float* A, float* B, int rows, int cols) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < rows && col < cols) {\n        int idx_in = row * cols + col;\n        int idx_out = col * rows + row;\n        B[idx_out] = A[idx_in];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_elems = ROWS * COLS;\n    size_t output_elems = COLS * ROWS;\n    size_t input_bytes = input_elems * sizeof(float);\n    size_t output_bytes = output_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    std::string input_file = \"data/matrix_input.bin\";\n    read_binary(input_file, h_input, input_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((COLS + threads.x - 1) / threads.x,\n                (ROWS + threads.y - 1) / threads.y);\n\n    matrix_transpose_kernel<<<blocks, threads>>>(d_input, d_output, ROWS, COLS);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/matrix_out.bin\";\n    write_binary(out_file, h_output, output_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nROWS, COLS = 1 << 10, 1 << 10\n\nA = np.random.rand(ROWS, COLS).astype(np.float32)\nA_T = A.T\n\nA.tofile(\"data/matrix_input.bin\")\nA_T.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    ROWS, COLS = 1 << 10, 1 << 10\n    size = ROWS * COLS\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task name: Matrix_Transpose. The kernel should compute the transpose of a 1024x1024 matrix. The input tensor 'matrix_input' has shape (1024, 1024) and data type float32, representing the input matrix. The output tensor 'matrix_out' must be a flattened array of the transposed matrix, with shape (1048576,) and data type float32. The kernel must map each element at position (i, j) in the input matrix to position (j, i) in the transposed matrix, which is then flattened into a 1D array in row-major order.", "level2_prompt": "Task name: Matrix_Transpose. Given a matrix of size 1024 rows by 1024 columns, compute its transpose. The transpose operation swaps the rows and columns: the element at row i and column j in the input matrix becomes the element at row j and column i in the transposed matrix. The output is a 1D array containing the elements of the transposed matrix stored in row-major order.", "level3_prompt": "Compute the Matrix_Transpose kernel on GPU using CUDA."}
{"id": 436, "task_name": "Matrix_Transpose", "task_description": "Compute the Matrix_Transpose kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(2048, 2048)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(2048, 2048)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define ROWS (1 << 11)  \n#define COLS (1 << 11)\n\n__global__ void matrix_transpose_kernel(const float* A, float* B, int rows, int cols) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < rows && col < cols) {\n        int idx_in = row * cols + col;\n        int idx_out = col * rows + row;\n        B[idx_out] = A[idx_in];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_elems = ROWS * COLS;\n    size_t output_elems = COLS * ROWS;\n    size_t input_bytes = input_elems * sizeof(float);\n    size_t output_bytes = output_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    std::string input_file = \"data/matrix_input.bin\";\n    read_binary(input_file, h_input, input_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((COLS + threads.x - 1) / threads.x,\n                (ROWS + threads.y - 1) / threads.y);\n\n    matrix_transpose_kernel<<<blocks, threads>>>(d_input, d_output, ROWS, COLS);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/matrix_out.bin\";\n    write_binary(out_file, h_output, output_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nROWS, COLS = 1 << 11, 1 << 11\n\nA = np.random.rand(ROWS, COLS).astype(np.float32)\nA_T = A.T\n\nA.tofile(\"data/matrix_input.bin\")\nA_T.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    ROWS, COLS = 1 << 11, 1 << 11\n    size = ROWS * COLS\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Matrix_Transpose task requires implementing a CUDA kernel that transposes a 2048x2048 matrix of float32 values. The input tensor 'matrix_input' with shape (2048, 2048) must be transformed such that each element at position (i, j) in the input appears at position (j, i) in the output tensor 'matrix_out'. The kernel must preserve all values exactly during transposition without altering data types or values.", "level2_prompt": "Implement a matrix transpose operation for a 2048x2048 float32 matrix. The computation must map each element from input position (i, j) to output position (j, i). The output matrix dimensions must be swapped relative to the input.", "level3_prompt": "Compute the Matrix_Transpose kernel on GPU using CUDA."}
{"id": 437, "task_name": "Matrix_Transpose", "task_description": "Compute the Matrix_Transpose kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(4096, 4096)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define ROWS (1 << 12)  \n#define COLS (1 << 12)\n\n__global__ void matrix_transpose_kernel(const float* A, float* B, int rows, int cols) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < rows && col < cols) {\n        int idx_in = row * cols + col;\n        int idx_out = col * rows + row;\n        B[idx_out] = A[idx_in];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_elems = ROWS * COLS;\n    size_t output_elems = COLS * ROWS;\n    size_t input_bytes = input_elems * sizeof(float);\n    size_t output_bytes = output_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    std::string input_file = \"data/matrix_input.bin\";\n    read_binary(input_file, h_input, input_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((COLS + threads.x - 1) / threads.x,\n                (ROWS + threads.y - 1) / threads.y);\n\n    matrix_transpose_kernel<<<blocks, threads>>>(d_input, d_output, ROWS, COLS);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/matrix_out.bin\";\n    write_binary(out_file, h_output, output_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nROWS, COLS = 1 << 12, 1 << 12\n\nA = np.random.rand(ROWS, COLS).astype(np.float32)\nA_T = A.T\n\nA.tofile(\"data/matrix_input.bin\")\nA_T.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    ROWS, COLS = 1 << 12, 1 << 12\n    size = ROWS * COLS\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Matrix Transpose. Given an input matrix of 4096 rows and 4096 columns (each element is a 32-bit floating point number), compute its transpose. The input is provided as a 1D array of 16777216 elements in row-major order, meaning the element at row i and column j is at index i * 4096 + j. The output must be a 1D array of 16777216 elements representing the transposed matrix stored in row-major order, so that the element originally at (i, j) in the input is placed at (j, i) in the output matrix (which is stored at index j * 4096 + i). The kernel must only process indices within the valid range [0, 4095] for both row and column indices.", "level2_prompt": "Task: Matrix Transpose. For every element in the input matrix at position (i, j) (with 0 <= i < 4096 and 0 <= j < 4096), place it in the output matrix at position (j, i). The input is stored as a contiguous 1D array in row-major order (element (i,j) at index i * 4096 + j). The output must be stored as a contiguous 1D array in row-major order (element (j,i) at index j * 4096 + i).", "level3_prompt": "Matrix transpose."}
{"id": 438, "task_name": "Matrix_Transpose", "task_description": "Compute the Matrix_Transpose kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(8192, 8192)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(67108864,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define ROWS (1 << 13)  \n#define COLS (1 << 13)\n\n__global__ void matrix_transpose_kernel(const float* A, float* B, int rows, int cols) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < rows && col < cols) {\n        int idx_in = row * cols + col;\n        int idx_out = col * rows + row;\n        B[idx_out] = A[idx_in];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_elems = ROWS * COLS;\n    size_t output_elems = COLS * ROWS;\n    size_t input_bytes = input_elems * sizeof(float);\n    size_t output_bytes = output_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    std::string input_file = \"data/matrix_input.bin\";\n    read_binary(input_file, h_input, input_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((COLS + threads.x - 1) / threads.x,\n                (ROWS + threads.y - 1) / threads.y);\n\n    matrix_transpose_kernel<<<blocks, threads>>>(d_input, d_output, ROWS, COLS);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/matrix_out.bin\";\n    write_binary(out_file, h_output, output_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nROWS, COLS = 1 << 13, 1 << 13\n\nA = np.random.rand(ROWS, COLS).astype(np.float32)\nA_T = A.T\n\nA.tofile(\"data/matrix_input.bin\")\nA_T.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    ROWS, COLS = 1 << 13, 1 << 13\n    size = ROWS * COLS\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Matrix_Transpose. Perform a matrix transpose operation on an input matrix of size 8192 rows by 8192 columns, with data type float32. The input is provided as a two-dimensional tensor with shape (8192, 8192). The output should be a one-dimensional tensor with shape (67108864,) and dtype float32, representing the flattened transposed matrix where each element originally at row i and column j in the input is placed at the position corresponding to row j and column i in the logical transposed matrix. Ensure the kernel handles all elements within the matrix bounds and produces an output that matches the reference transpose exactly.", "level2_prompt": "Task: Matrix_Transpose. Mathematically, transpose the input matrix by swapping rows and columns. For an input matrix of dimensions 8192 by 8192, each element at position (i, j) should be mapped to position (j, i) in the output matrix, resulting in an output of dimensions 8192 by 8192.", "level3_prompt": "Transpose a matrix."}
{"id": 439, "task_name": "Matrix_Transpose", "task_description": "Compute the Matrix_Transpose kernel on GPU using CUDA.", "inputs": [{"name": "matrix_input", "dtype": "float32", "shape": "(16384, 16384)"}], "outputs": [{"name": "matrix_out", "dtype": "float32", "shape": "(16384, 16384)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <fstream>\n#include <cmath>\n#include <string>\n\n#define ROWS (1 << 14)  \n#define COLS (1 << 14)\n\n__global__ void matrix_transpose_kernel(const float* A, float* B, int rows, int cols) {\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if (row < rows && col < cols) {\n        int idx_in = row * cols + col;\n        int idx_out = col * rows + row;\n        B[idx_out] = A[idx_in];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open file: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write file: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t input_elems = ROWS * COLS;\n    size_t output_elems = COLS * ROWS;\n    size_t input_bytes = input_elems * sizeof(float);\n    size_t output_bytes = output_elems * sizeof(float);\n\n    float* h_input = (float*)malloc(input_bytes);\n    float* h_output = (float*)malloc(output_bytes);\n\n    std::string input_file = \"data/matrix_input.bin\";\n    read_binary(input_file, h_input, input_elems);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, input_bytes);\n    cudaMalloc(&d_output, output_bytes);\n    cudaMemcpy(d_input, h_input, input_bytes, cudaMemcpyHostToDevice);\n\n    dim3 threads(16, 16);\n    dim3 blocks((COLS + threads.x - 1) / threads.x,\n                (ROWS + threads.y - 1) / threads.y);\n\n    matrix_transpose_kernel<<<blocks, threads>>>(d_input, d_output, ROWS, COLS);\n    cudaMemcpy(h_output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/matrix_out.bin\";\n    write_binary(out_file, h_output, output_elems);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    free(h_input);\n    free(h_output);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(49)\n\nROWS, COLS = 1 << 14, 1 << 14\n\nA = np.random.rand(ROWS, COLS).astype(np.float32)\nA_T = A.T\n\nA.tofile(\"data/matrix_input.bin\")\nA_T.tofile(\"data/matrix_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    ROWS, COLS = 1 << 14, 1 << 14\n    size = ROWS * COLS\n    out_file = \"data/matrix_out.bin\"\n    ref_file = \"data/matrix_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for matrix transposition. The kernel should transpose a 16384x16384 input matrix of float32 values to an output matrix of the same shape and data type. For every element in the input matrix at position (i, j), it must appear at position (j, i) in the output matrix. Ensure all elements are correctly transposed without data loss or out-of-bound access.", "level2_prompt": "Perform matrix transposition on a square matrix of size 16384x16384. For each element at row i and column j in the input matrix, place it at row j and column i in the output matrix.", "level3_prompt": "Compute the Matrix_Transpose kernel on GPU using CUDA."}
{"id": 440, "task_name": "Image_Rotate", "task_description": "Compute the Image_Rotate kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(256, 256, 3)"}], "outputs": [{"name": "img_rotated", "dtype": "float32", "shape": "(256, 256, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 256\n#define WIDTH 256\n#define CHANNELS 3\n\n__global__ void image_rotate90_kernel(const float* input, float* output, int H, int W, int C) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    if (h >= H || w >= W) return;\n\n    for (int c = 0; c < C; ++c) {\n        // (h, w) in input → (w, H - 1 - h) in output\n        int in_idx  = (h * W + w) * C + c;\n        int out_idx = (w * H + (H - 1 - h)) * C + c;\n        output[out_idx] = input[in_idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n    size_t size = H * W * C;\n\n    float* h_input  = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input,  size * sizeof(float));\n    cudaMalloc(&d_output, size * sizeof(float));\n    cudaMemcpy(d_input, h_input, size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    image_rotate90_kernel<<<grid, block>>>(d_input, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_rotated.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 256, 256, 3\nseed = 123\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Input image in [H, W, C]\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Rotate 90 degrees clockwise (→ rotate once along last two dims)\nrotated = torch.rot90(img, k=-1, dims=(0, 1))  # k=-1 for clockwise 90°\n\n# Save binary files\nimg.numpy().tofile(\"data/img_input.bin\")\nrotated.numpy().tofile(\"data/img_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 256, 256, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_rotated.bin\"\n    ref_file = \"./data/img_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for the Image_Rotate task that rotates an input image 90 degrees clockwise. The input is a 256×256×3 float32 tensor representing an image with height 256, width 256, and 3 color channels. The output should be a 256×256×3 float32 tensor with the rotated image. Each input pixel at (h, w) must map to output position (w, 255-h) while preserving channel values. The kernel must handle boundary checks to avoid out-of-bounds memory access.", "level2_prompt": "Perform a 90-degree clockwise rotation on a 256×256×3 image. For each input pixel at position (h, w), move it to output position (w, H-1-h) where H is the height dimension. Channel values must remain unchanged during rotation.", "level3_prompt": "Rotate the input image by 90 degrees clockwise."}
{"id": 441, "task_name": "Image_Rotate", "task_description": "Compute the Image_Rotate kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(512, 512, 3)"}], "outputs": [{"name": "img_rotated", "dtype": "float32", "shape": "(512, 512, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 512\n#define WIDTH 512\n#define CHANNELS 3\n\n__global__ void image_rotate90_kernel(const float* input, float* output, int H, int W, int C) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    if (h >= H || w >= W) return;\n\n    for (int c = 0; c < C; ++c) {\n        // (h, w) in input → (w, H - 1 - h) in output\n        int in_idx  = (h * W + w) * C + c;\n        int out_idx = (w * H + (H - 1 - h)) * C + c;\n        output[out_idx] = input[in_idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n    size_t size = H * W * C;\n\n    float* h_input  = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input,  size * sizeof(float));\n    cudaMalloc(&d_output, size * sizeof(float));\n    cudaMemcpy(d_input, h_input, size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    image_rotate90_kernel<<<grid, block>>>(d_input, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_rotated.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 512, 512, 3\nseed = 123\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Input image in [H, W, C]\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Rotate 90 degrees clockwise (→ rotate once along last two dims)\nrotated = torch.rot90(img, k=-1, dims=(0, 1))  # k=-1 for clockwise 90°\n\n# Save binary files\nimg.numpy().tofile(\"data/img_input.bin\")\nrotated.numpy().tofile(\"data/img_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 512, 512, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_rotated.bin\"\n    ref_file = \"./data/img_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Image_Rotate. The kernel must rotate a 3-channel input image 90 degrees clockwise. The input is a float32 tensor of shape (512, 512, 3), representing an image with height 512, width 512, and 3 channels. The output is a float32 tensor of the same shape, containing the rotated image. Constraints: Each pixel from input position (h, w) must be mapped to output position (w, 511 - h), and the kernel must avoid out-of-bounds access by checking indices. Invariants: All pixel values must be copied exactly without modification, preserving the data.", "level2_prompt": "Task: Image_Rotate. The algorithm rotates an input image 90 degrees clockwise. For each pixel at height index h and width index w in the input, it is moved to width index w and height index 511 - h in the output, where height and width are both 512 dimensions, and this applies to all 3 channels.", "level3_prompt": "Rotate an input image 90 degrees clockwise."}
{"id": 442, "task_name": "Image_Rotate", "task_description": "Compute the Image_Rotate kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(1024, 1024, 3)"}], "outputs": [{"name": "img_rotated", "dtype": "float32", "shape": "(1024, 1024, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 1024\n#define WIDTH 1024\n#define CHANNELS 3\n\n__global__ void image_rotate90_kernel(const float* input, float* output, int H, int W, int C) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    if (h >= H || w >= W) return;\n\n    for (int c = 0; c < C; ++c) {\n        // (h, w) in input → (w, H - 1 - h) in output\n        int in_idx  = (h * W + w) * C + c;\n        int out_idx = (w * H + (H - 1 - h)) * C + c;\n        output[out_idx] = input[in_idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n    size_t size = H * W * C;\n\n    float* h_input  = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input,  size * sizeof(float));\n    cudaMalloc(&d_output, size * sizeof(float));\n    cudaMemcpy(d_input, h_input, size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    image_rotate90_kernel<<<grid, block>>>(d_input, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_rotated.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 1024, 1024, 3\nseed = 123\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Input image in [H, W, C]\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Rotate 90 degrees clockwise (→ rotate once along last two dims)\nrotated = torch.rot90(img, k=-1, dims=(0, 1))  # k=-1 for clockwise 90°\n\n# Save binary files\nimg.numpy().tofile(\"data/img_input.bin\")\nrotated.numpy().tofile(\"data/img_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 1024, 1024, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_rotated.bin\"\n    ref_file = \"./data/img_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Image_Rotate. Rotate a 1024x1024 RGB image (3 channels) by 90 degrees clockwise. Input tensor 'img_input' is a float32 array of shape (1024, 1024, 3). Output tensor 'img_rotated' must be a float32 array of the same shape. The kernel must map each input pixel at (h, w) to the output pixel at (w, 1023 - h) for each color channel, without exceeding the image boundaries.", "level2_prompt": "Task: Image_Rotate. Rotate a 2D image with dimensions 1024x1024 and 3 color channels by 90 degrees clockwise. Each input pixel (h, w) is mapped to (w, 1023 - h) in the output for every channel.", "level3_prompt": "Compute the Image_Rotate kernel on GPU using CUDA."}
{"id": 443, "task_name": "Image_Rotate", "task_description": "Compute the Image_Rotate kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(2048, 2048, 3)"}], "outputs": [{"name": "img_rotated", "dtype": "float32", "shape": "(2048, 2048, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 2048\n#define WIDTH 2048\n#define CHANNELS 3\n\n__global__ void image_rotate90_kernel(const float* input, float* output, int H, int W, int C) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    if (h >= H || w >= W) return;\n\n    for (int c = 0; c < C; ++c) {\n        // (h, w) in input → (w, H - 1 - h) in output\n        int in_idx  = (h * W + w) * C + c;\n        int out_idx = (w * H + (H - 1 - h)) * C + c;\n        output[out_idx] = input[in_idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n    size_t size = H * W * C;\n\n    float* h_input  = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input,  size * sizeof(float));\n    cudaMalloc(&d_output, size * sizeof(float));\n    cudaMemcpy(d_input, h_input, size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    image_rotate90_kernel<<<grid, block>>>(d_input, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_rotated.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 2048, 2048, 3\nseed = 123\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Input image in [H, W, C]\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Rotate 90 degrees clockwise (→ rotate once along last two dims)\nrotated = torch.rot90(img, k=-1, dims=(0, 1))  # k=-1 for clockwise 90°\n\n# Save binary files\nimg.numpy().tofile(\"data/img_input.bin\")\nrotated.numpy().tofile(\"data/img_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 2048, 2048, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_rotated.bin\"\n    ref_file = \"./data/img_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel that rotates an input image by 90 degrees clockwise. The input tensor 'img_input' has shape (2048, 2048, 3) and dtype float32, representing an image with height 2048, width 2048, and 3 color channels. The output tensor 'img_rotated' must have the same shape and dtype. Each pixel at position (h, w) in the input should be mapped to position (w, H-1-h) in the output, where H is the image height (2048). The kernel must preserve channel data and handle all pixels without altering the original data.", "level2_prompt": "Perform a 90-degree clockwise rotation on a 2048x2048 RGB image. For each input pixel at coordinate (h, w) in channel c, assign its value to output coordinate (w, 2047-h) in channel c. The transformation should be applied uniformly across all three color channels.", "level3_prompt": "Rotate the input image by 90 degrees clockwise."}
{"id": 444, "task_name": "Image_Rotate", "task_description": "Compute the Image_Rotate kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(4096, 4096, 3)"}], "outputs": [{"name": "img_rotated", "dtype": "float32", "shape": "(4096, 4096, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define HEIGHT 4096\n#define WIDTH 4096\n#define CHANNELS 3\n\n__global__ void image_rotate90_kernel(const float* input, float* output, int H, int W, int C) {\n    int h = blockIdx.y * blockDim.y + threadIdx.y;\n    int w = blockIdx.x * blockDim.x + threadIdx.x;\n    if (h >= H || w >= W) return;\n\n    for (int c = 0; c < C; ++c) {\n        // (h, w) in input → (w, H - 1 - h) in output\n        int in_idx  = (h * W + w) * C + c;\n        int out_idx = (w * H + (H - 1 - h)) * C + c;\n        output[out_idx] = input[in_idx];\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int H = HEIGHT;\n    const int W = WIDTH;\n    const int C = CHANNELS;\n    size_t size = H * W * C;\n\n    float* h_input  = new float[size];\n    float* h_output = new float[size];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, size);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input,  size * sizeof(float));\n    cudaMalloc(&d_output, size * sizeof(float));\n    cudaMemcpy(d_input, h_input, size * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((W + block.x - 1) / block.x, (H + block.y - 1) / block.y);\n\n    image_rotate90_kernel<<<grid, block>>>(d_input, d_output, H, W, C);\n    cudaMemcpy(h_output, d_output, size * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_rotated.bin\";\n    write_binary(out_file, h_output, size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import torch\nimport os\n\nH, W, C = 4096, 4096, 3\nseed = 123\ntorch.manual_seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Input image in [H, W, C]\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Rotate 90 degrees clockwise (→ rotate once along last two dims)\nrotated = torch.rot90(img, k=-1, dims=(0, 1))  # k=-1 for clockwise 90°\n\n# Save binary files\nimg.numpy().tofile(\"data/img_input.bin\")\nrotated.numpy().tofile(\"data/img_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 4096, 4096, 3\n    total_size = H * W * C\n\n    out_file = \"./data/img_rotated.bin\"\n    ref_file = \"./data/img_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_size):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Image_Rotate kernel to rotate an input image by 90 degrees clockwise. The input is a float32 tensor of shape (4096, 4096, 3) representing an RGB image. The output should be a float32 tensor of the same shape. Each input pixel at position (h, w) must map to output position (w, H-1-h) for all color channels, where H is the image height (4096). The kernel must preserve channel order and data type while handling all pixels.", "level2_prompt": "Perform a 90-degree clockwise rotation on a 4096x4096 RGB image with 3 color channels. For each input pixel coordinate (h, w), the corresponding output pixel should be placed at (w, H-1-h) while maintaining the same channel values. The transformation must cover all pixels and preserve data precision.", "level3_prompt": "Compute the Image_Rotate kernel on GPU using CUDA."}
{"id": 445, "task_name": "Image_Scaling", "task_description": "Compute the Image_Scaling kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(256, 256, 3)"}], "outputs": [{"name": "img_scaled", "dtype": "float32", "shape": "(384, 384, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define HEIGHT 256\n#define WIDTH  256\n#define CHANNELS 3\n\n// Target (scaled) size\n#define OUT_HEIGHT 384  // e.g., 256 * 1.5\n#define OUT_WIDTH  384\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n// Bilinear image scaling (HWC). Matches PyTorch align_corners=false mapping.\n__global__ void image_scale_bilinear_kernel(const float* __restrict__ in,\n                                            float* __restrict__ out,\n                                            int inH, int inW, int C,\n                                            int outH, int outW) {\n    int ow = blockIdx.x * blockDim.x + threadIdx.x;\n    int oh = blockIdx.y * blockDim.y + threadIdx.y;\n    if (ow >= outW || oh >= outH) return;\n\n    // align_corners = false mapping:\n    // in_x = (ow + 0.5) * (inW / outW) - 0.5\n    // in_y = (oh + 0.5) * (inH / outH) - 0.5\n    float scale_x = static_cast<float>(inW) / static_cast<float>(outW);\n    float scale_y = static_cast<float>(inH) / static_cast<float>(outH);\n    float in_x = (ow + 0.5f) * scale_x - 0.5f;\n    float in_y = (oh + 0.5f) * scale_y - 0.5f;\n\n    int x0 = static_cast<int>(floorf(in_x));\n    int y0 = static_cast<int>(floorf(in_y));\n    int x1 = x0 + 1;\n    int y1 = y0 + 1;\n\n    float dx = in_x - x0;\n    float dy = in_y - y0;\n\n    // Clamp sampling coords\n    x0 = max(0, min(x0, inW - 1));\n    x1 = max(0, min(x1, inW - 1));\n    y0 = max(0, min(y0, inH - 1));\n    y1 = max(0, min(y1, inH - 1));\n\n    float w00 = (1.f - dx) * (1.f - dy);\n    float w01 = (1.f - dx) * (      dy);\n    float w10 = (      dx) * (1.f - dy);\n    float w11 = (      dx) * (      dy);\n\n    // Loop channels (HWC)\n    for (int c = 0; c < C; ++c) {\n        float v00 = in[idx_hwc(y0, x0, c, inH, inW, C)];\n        float v01 = in[idx_hwc(y1, x0, c, inH, inW, C)];\n        float v10 = in[idx_hwc(y0, x1, c, inH, inW, C)];\n        float v11 = in[idx_hwc(y1, x1, c, inH, inW, C)];\n\n        float val = w00 * v00 + w01 * v01 + w10 * v10 + w11 * v11;\n        out[idx_hwc(oh, ow, c, outH, outW, C)] = val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int inH = HEIGHT, inW = WIDTH, C = CHANNELS;\n    const int outH = OUT_HEIGHT, outW = OUT_WIDTH;\n\n    size_t in_elems  = static_cast<size_t>(inH) * inW * C;\n    size_t out_elems = static_cast<size_t>(outH) * outW * C;\n\n    float* h_input  = new float[in_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_in, *d_out;\n    cudaMalloc(&d_in,  in_elems  * sizeof(float));\n    cudaMalloc(&d_out, out_elems * sizeof(float));\n    cudaMemcpy(d_in, h_input, in_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((outW + block.x - 1) / block.x,\n              (outH + block.y - 1) / block.y);\n\n    image_scale_bilinear_kernel<<<grid, block>>>(d_in, d_out, inH, inW, C, outH, outW);\n    cudaMemcpy(h_output, d_out, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_scaled.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\nH, W, C = 256, 256, 3\nOUT_H, OUT_W = 384, 384  # must match CUDA\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random input image (HWC, float32)\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Save input\nimg.numpy().tofile(\"data/img_input.bin\")\n\n# Reference bilinear scaling using PyTorch (align_corners=False)\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()  # [1, C, H, W]\ny_nchw = F.interpolate(x_nchw, size=(OUT_H, OUT_W), mode=\"bilinear\", align_corners=False)\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()  # [OUT_H, OUT_W, C]\n\n# Save reference\ny_hwc.numpy().tofile(\"data/img_scaled_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    OUT_H, OUT_W, C = 384, 384, 3\n    total = OUT_H * OUT_W * C\n    out_file = \"./data/img_scaled.bin\"\n    ref_file = \"./data/img_scaled_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an image scaling kernel named 'Image_Scaling'. The kernel should bilinearly interpolate an input image from 256x256 resolution to 384x384 resolution. Input is a 256x256x3 tensor of float32 values in HWC format (height, width, channels). Output must be a 384x384x3 float32 tensor in the same format. Use the coordinate mapping: input_x = (output_x + 0.5) * (input_width / output_width) - 0.5 and similarly for y. Clamp sampling coordinates to image boundaries and weight contributions from four nearest neighbors using fractional differences. Ensure identical results to PyTorch's bilinear interpolation with align_corners=False.", "level2_prompt": "Scale an image from 256x256 to 384x384 resolution using bilinear interpolation. For each output pixel coordinate (oh, ow), compute corresponding continuous coordinates (in_x, in_y) in the input space using fractional scaling. Determine the four nearest integer pixel neighbors, clamp them within input boundaries, calculate interpolation weights based on fractional distances, and compute weighted averages across all three color channels.", "level3_prompt": "Compute the Image_Scaling kernel on GPU using CUDA."}
{"id": 446, "task_name": "Image_Scaling", "task_description": "Compute the Image_Scaling kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(512, 512, 3)"}], "outputs": [{"name": "img_scaled", "dtype": "float32", "shape": "(768, 768, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define HEIGHT 512\n#define WIDTH  512\n#define CHANNELS 3\n\n// Target (scaled) size\n#define OUT_HEIGHT HEIGHT*1.5\n#define OUT_WIDTH  WIDTH*1.5\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n// Bilinear image scaling (HWC). Matches PyTorch align_corners=false mapping.\n__global__ void image_scale_bilinear_kernel(const float* __restrict__ in,\n                                            float* __restrict__ out,\n                                            int inH, int inW, int C,\n                                            int outH, int outW) {\n    int ow = blockIdx.x * blockDim.x + threadIdx.x;\n    int oh = blockIdx.y * blockDim.y + threadIdx.y;\n    if (ow >= outW || oh >= outH) return;\n\n    // align_corners = false mapping:\n    // in_x = (ow + 0.5) * (inW / outW) - 0.5\n    // in_y = (oh + 0.5) * (inH / outH) - 0.5\n    float scale_x = static_cast<float>(inW) / static_cast<float>(outW);\n    float scale_y = static_cast<float>(inH) / static_cast<float>(outH);\n    float in_x = (ow + 0.5f) * scale_x - 0.5f;\n    float in_y = (oh + 0.5f) * scale_y - 0.5f;\n\n    int x0 = static_cast<int>(floorf(in_x));\n    int y0 = static_cast<int>(floorf(in_y));\n    int x1 = x0 + 1;\n    int y1 = y0 + 1;\n\n    float dx = in_x - x0;\n    float dy = in_y - y0;\n\n    // Clamp sampling coords\n    x0 = max(0, min(x0, inW - 1));\n    x1 = max(0, min(x1, inW - 1));\n    y0 = max(0, min(y0, inH - 1));\n    y1 = max(0, min(y1, inH - 1));\n\n    float w00 = (1.f - dx) * (1.f - dy);\n    float w01 = (1.f - dx) * (      dy);\n    float w10 = (      dx) * (1.f - dy);\n    float w11 = (      dx) * (      dy);\n\n    // Loop channels (HWC)\n    for (int c = 0; c < C; ++c) {\n        float v00 = in[idx_hwc(y0, x0, c, inH, inW, C)];\n        float v01 = in[idx_hwc(y1, x0, c, inH, inW, C)];\n        float v10 = in[idx_hwc(y0, x1, c, inH, inW, C)];\n        float v11 = in[idx_hwc(y1, x1, c, inH, inW, C)];\n\n        float val = w00 * v00 + w01 * v01 + w10 * v10 + w11 * v11;\n        out[idx_hwc(oh, ow, c, outH, outW, C)] = val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int inH = HEIGHT, inW = WIDTH, C = CHANNELS;\n    const int outH = OUT_HEIGHT, outW = OUT_WIDTH;\n\n    size_t in_elems  = static_cast<size_t>(inH) * inW * C;\n    size_t out_elems = static_cast<size_t>(outH) * outW * C;\n\n    float* h_input  = new float[in_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_in, *d_out;\n    cudaMalloc(&d_in,  in_elems  * sizeof(float));\n    cudaMalloc(&d_out, out_elems * sizeof(float));\n    cudaMemcpy(d_in, h_input, in_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((outW + block.x - 1) / block.x,\n              (outH + block.y - 1) / block.y);\n\n    image_scale_bilinear_kernel<<<grid, block>>>(d_in, d_out, inH, inW, C, outH, outW);\n    cudaMemcpy(h_output, d_out, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_scaled.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\nH, W, C = 512, 512, 3\nOUT_H, OUT_W = int(H*1.5), int(W*1.5)  # must match CUDA\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random input image (HWC, float32)\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Save input\nimg.numpy().tofile(\"data/img_input.bin\")\n\n# Reference bilinear scaling using PyTorch (align_corners=False)\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()  # [1, C, H, W]\ny_nchw = F.interpolate(x_nchw, size=(OUT_H, OUT_W), mode=\"bilinear\", align_corners=False)\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()  # [OUT_H, OUT_W, C]\n\n# Save reference\ny_hwc.numpy().tofile(\"data/img_scaled_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 512, 512, 3\n    OUT_H, OUT_W = int(H*1.5), int(W*1.5)\n    total = OUT_H * OUT_W * C\n    out_file = \"./data/img_scaled.bin\"\n    ref_file = \"./data/img_scaled_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel for bilinear image scaling. The input is a 512x512 RGB image with 3 channels stored as float32 in HWC layout. The output is a scaled 768x768 RGB image with 3 channels in float32. The scaling must use bilinear interpolation with coordinate mapping that matches align_corners=false behavior. Coordinates must be clamped to image boundaries during sampling. The kernel should handle each output pixel independently.", "level2_prompt": "Scale a 512x512 image to 768x768 using bilinear interpolation. For each output pixel coordinate (oh, ow), compute corresponding input coordinates using: in_x = (ow + 0.5) * (512/768) - 0.5 and in_y = (oh + 0.5) * (512/768) - 0.5. Sample four nearest input pixels, clamp coordinates to image boundaries, compute weights based on fractional distances, and calculate weighted average for each color channel.", "level3_prompt": "Compute the Image_Scaling kernel on GPU using CUDA."}
{"id": 447, "task_name": "Image_Scaling", "task_description": "Compute the Image_Scaling kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(1024, 1024, 3)"}], "outputs": [{"name": "img_scaled", "dtype": "float32", "shape": "(1536, 1536, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define HEIGHT 1024\n#define WIDTH  1024\n#define CHANNELS 3\n\n// Target (scaled) size\n#define OUT_HEIGHT HEIGHT*1.5\n#define OUT_WIDTH  WIDTH*1.5\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n// Bilinear image scaling (HWC). Matches PyTorch align_corners=false mapping.\n__global__ void image_scale_bilinear_kernel(const float* __restrict__ in,\n                                            float* __restrict__ out,\n                                            int inH, int inW, int C,\n                                            int outH, int outW) {\n    int ow = blockIdx.x * blockDim.x + threadIdx.x;\n    int oh = blockIdx.y * blockDim.y + threadIdx.y;\n    if (ow >= outW || oh >= outH) return;\n\n    // align_corners = false mapping:\n    // in_x = (ow + 0.5) * (inW / outW) - 0.5\n    // in_y = (oh + 0.5) * (inH / outH) - 0.5\n    float scale_x = static_cast<float>(inW) / static_cast<float>(outW);\n    float scale_y = static_cast<float>(inH) / static_cast<float>(outH);\n    float in_x = (ow + 0.5f) * scale_x - 0.5f;\n    float in_y = (oh + 0.5f) * scale_y - 0.5f;\n\n    int x0 = static_cast<int>(floorf(in_x));\n    int y0 = static_cast<int>(floorf(in_y));\n    int x1 = x0 + 1;\n    int y1 = y0 + 1;\n\n    float dx = in_x - x0;\n    float dy = in_y - y0;\n\n    // Clamp sampling coords\n    x0 = max(0, min(x0, inW - 1));\n    x1 = max(0, min(x1, inW - 1));\n    y0 = max(0, min(y0, inH - 1));\n    y1 = max(0, min(y1, inH - 1));\n\n    float w00 = (1.f - dx) * (1.f - dy);\n    float w01 = (1.f - dx) * (      dy);\n    float w10 = (      dx) * (1.f - dy);\n    float w11 = (      dx) * (      dy);\n\n    // Loop channels (HWC)\n    for (int c = 0; c < C; ++c) {\n        float v00 = in[idx_hwc(y0, x0, c, inH, inW, C)];\n        float v01 = in[idx_hwc(y1, x0, c, inH, inW, C)];\n        float v10 = in[idx_hwc(y0, x1, c, inH, inW, C)];\n        float v11 = in[idx_hwc(y1, x1, c, inH, inW, C)];\n\n        float val = w00 * v00 + w01 * v01 + w10 * v10 + w11 * v11;\n        out[idx_hwc(oh, ow, c, outH, outW, C)] = val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int inH = HEIGHT, inW = WIDTH, C = CHANNELS;\n    const int outH = OUT_HEIGHT, outW = OUT_WIDTH;\n\n    size_t in_elems  = static_cast<size_t>(inH) * inW * C;\n    size_t out_elems = static_cast<size_t>(outH) * outW * C;\n\n    float* h_input  = new float[in_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_in, *d_out;\n    cudaMalloc(&d_in,  in_elems  * sizeof(float));\n    cudaMalloc(&d_out, out_elems * sizeof(float));\n    cudaMemcpy(d_in, h_input, in_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((outW + block.x - 1) / block.x,\n              (outH + block.y - 1) / block.y);\n\n    image_scale_bilinear_kernel<<<grid, block>>>(d_in, d_out, inH, inW, C, outH, outW);\n    cudaMemcpy(h_output, d_out, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_scaled.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\nH, W, C = 1024, 1024, 3\nOUT_H, OUT_W = int(H*1.5), int(W*1.5)  # must match CUDA\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random input image (HWC, float32)\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Save input\nimg.numpy().tofile(\"data/img_input.bin\")\n\n# Reference bilinear scaling using PyTorch (align_corners=False)\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()  # [1, C, H, W]\ny_nchw = F.interpolate(x_nchw, size=(OUT_H, OUT_W), mode=\"bilinear\", align_corners=False)\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()  # [OUT_H, OUT_W, C]\n\n# Save reference\ny_hwc.numpy().tofile(\"data/img_scaled_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    # print(diff)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 1024, 1024, 3\n    OUT_H, OUT_W = int(H*1.5), int(W*1.5)\n    total = OUT_H * OUT_W * C\n    out_file = \"./data/img_scaled.bin\"\n    ref_file = \"./data/img_scaled_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement an image scaling kernel named 'Image_Scaling'. The kernel should take an input tensor 'img_input' of shape (1024, 1024, 3) and data type float32, representing an image in HWC layout. It should produce an output tensor 'img_scaled' of shape (1536, 1536, 3) and data type float32. The kernel must use bilinear interpolation to scale the image from 1024x1024 to 1536x1536. The interpolation method must align with the 'align_corners=False' setting in PyTorch. For each output pixel and each channel, the kernel must compute the corresponding input coordinates, then take the four nearest input pixels (clamped to the image boundaries) and compute a weighted average based on the fractional distances to the neighboring pixels.", "level2_prompt": "The 'Image_Scaling' task requires bilinear image scaling. For each output pixel at (oh, ow) and each channel, map to input coordinates (in_x, in_y) using: in_x = (ow + 0.5) * (1024 / 1536) - 0.5 and in_y = (oh + 0.5) * (1024 / 1536) - 0.5. Then, take the four neighboring pixels (x0, y0), (x0, y1), (x1, y0), (x1, y1) where x0 = floor(in_x), y0 = floor(in_y), x1 = x0+1, y1 = y0+1. Clamp these coordinates to the input image boundaries. Compute weights w00 = (1-dx)*(1-dy), w01 = (1-dx)*dy, w10 = dx*(1-dy), w11 = dx*dy, where dx = in_x - x0, dy = in_y - y0. The output value is the weighted sum of the input values at these four positions for the current channel.", "level3_prompt": "Scale an image from 1024x1024 to 1536x1536 using bilinear interpolation."}
{"id": 448, "task_name": "Image_Scaling", "task_description": "Compute the Image_Scaling kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(2048, 2048, 3)"}], "outputs": [{"name": "img_scaled", "dtype": "float32", "shape": "(3072, 3072, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define HEIGHT 2048\n#define WIDTH  2048\n#define CHANNELS 3\n\n// Target (scaled) size\n#define OUT_HEIGHT HEIGHT*1.5\n#define OUT_WIDTH  WIDTH*1.5\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n// Bilinear image scaling (HWC). Matches PyTorch align_corners=false mapping.\n__global__ void image_scale_bilinear_kernel(const float* __restrict__ in,\n                                            float* __restrict__ out,\n                                            int inH, int inW, int C,\n                                            int outH, int outW) {\n    int ow = blockIdx.x * blockDim.x + threadIdx.x;\n    int oh = blockIdx.y * blockDim.y + threadIdx.y;\n    if (ow >= outW || oh >= outH) return;\n\n    // align_corners = false mapping:\n    // in_x = (ow + 0.5) * (inW / outW) - 0.5\n    // in_y = (oh + 0.5) * (inH / outH) - 0.5\n    float scale_x = static_cast<float>(inW) / static_cast<float>(outW);\n    float scale_y = static_cast<float>(inH) / static_cast<float>(outH);\n    float in_x = (ow + 0.5f) * scale_x - 0.5f;\n    float in_y = (oh + 0.5f) * scale_y - 0.5f;\n\n    int x0 = static_cast<int>(floorf(in_x));\n    int y0 = static_cast<int>(floorf(in_y));\n    int x1 = x0 + 1;\n    int y1 = y0 + 1;\n\n    float dx = in_x - x0;\n    float dy = in_y - y0;\n\n    // Clamp sampling coords\n    x0 = max(0, min(x0, inW - 1));\n    x1 = max(0, min(x1, inW - 1));\n    y0 = max(0, min(y0, inH - 1));\n    y1 = max(0, min(y1, inH - 1));\n\n    float w00 = (1.f - dx) * (1.f - dy);\n    float w01 = (1.f - dx) * (      dy);\n    float w10 = (      dx) * (1.f - dy);\n    float w11 = (      dx) * (      dy);\n\n    // Loop channels (HWC)\n    for (int c = 0; c < C; ++c) {\n        float v00 = in[idx_hwc(y0, x0, c, inH, inW, C)];\n        float v01 = in[idx_hwc(y1, x0, c, inH, inW, C)];\n        float v10 = in[idx_hwc(y0, x1, c, inH, inW, C)];\n        float v11 = in[idx_hwc(y1, x1, c, inH, inW, C)];\n\n        float val = w00 * v00 + w01 * v01 + w10 * v10 + w11 * v11;\n        out[idx_hwc(oh, ow, c, outH, outW, C)] = val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int inH = HEIGHT, inW = WIDTH, C = CHANNELS;\n    const int outH = OUT_HEIGHT, outW = OUT_WIDTH;\n\n    size_t in_elems  = static_cast<size_t>(inH) * inW * C;\n    size_t out_elems = static_cast<size_t>(outH) * outW * C;\n\n    float* h_input  = new float[in_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_in, *d_out;\n    cudaMalloc(&d_in,  in_elems  * sizeof(float));\n    cudaMalloc(&d_out, out_elems * sizeof(float));\n    cudaMemcpy(d_in, h_input, in_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((outW + block.x - 1) / block.x,\n              (outH + block.y - 1) / block.y);\n\n    image_scale_bilinear_kernel<<<grid, block>>>(d_in, d_out, inH, inW, C, outH, outW);\n    cudaMemcpy(h_output, d_out, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_scaled.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\nH, W, C = 2048, 2048, 3\nOUT_H, OUT_W = int(H*1.5), int(W*1.5)  # must match CUDA\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random input image (HWC, float32)\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Save input\nimg.numpy().tofile(\"data/img_input.bin\")\n\n# Reference bilinear scaling using PyTorch (align_corners=False)\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()  # [1, C, H, W]\ny_nchw = F.interpolate(x_nchw, size=(OUT_H, OUT_W), mode=\"bilinear\", align_corners=False)\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()  # [OUT_H, OUT_W, C]\n\n# Save reference\ny_hwc.numpy().tofile(\"data/img_scaled_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 2048, 2048, 3\n    OUT_H, OUT_W = int(H*1.5), int(W*1.5)\n    total = OUT_H * OUT_W * C\n    out_file = \"./data/img_scaled.bin\"\n    ref_file = \"./data/img_scaled_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Image_Scaling. Scale an input image tensor of shape (2048, 2048, 3) with float32 values to an output tensor of shape (3072, 3072, 3) using bilinear interpolation. The kernel must map each output pixel to a continuous coordinate in the input space using the formula: input_x = (output_x + 0.5) * (input_width / output_width) - 0.5 and input_y = (output_y + 0.5) * (input_height / output_height) - 0.5. For each output pixel, compute weights from four nearest input pixels (clamped to image boundaries) and calculate a weighted average across all three color channels independently.", "level2_prompt": "Image_Scaling: Perform bilinear interpolation to resize a 2048x2048x3 input image to 3072x3072x3. For each output pixel location (oh, ow), compute fractional input coordinates, determine four surrounding integer coordinates (clamped within input bounds), calculate bilinear weights from fractional parts, and compute channel-wise weighted averages of input pixel values.", "level3_prompt": "Scale an image from 2048x2048 to 3072x3072 using bilinear interpolation."}
{"id": 449, "task_name": "Image_Scaling", "task_description": "Compute the Image_Scaling kernel on GPU using CUDA.", "inputs": [{"name": "img_input", "dtype": "float32", "shape": "(4096, 4096, 3)"}], "outputs": [{"name": "img_scaled", "dtype": "float32", "shape": "(6144, 6144, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n\n#define HEIGHT 4096\n#define WIDTH  4096\n#define CHANNELS 3\n\n// Target (scaled) size\n#define OUT_HEIGHT HEIGHT*1.5\n#define OUT_WIDTH  WIDTH*1.5\n\n__device__ __forceinline__ int idx_hwc(int h, int w, int c, int H, int W, int C) {\n    return (h * W + w) * C + c;\n}\n\n// Bilinear image scaling (HWC). Matches PyTorch align_corners=false mapping.\n__global__ void image_scale_bilinear_kernel(const float* __restrict__ in,\n                                            float* __restrict__ out,\n                                            int inH, int inW, int C,\n                                            int outH, int outW) {\n    int ow = blockIdx.x * blockDim.x + threadIdx.x;\n    int oh = blockIdx.y * blockDim.y + threadIdx.y;\n    if (ow >= outW || oh >= outH) return;\n\n    // align_corners = false mapping:\n    // in_x = (ow + 0.5) * (inW / outW) - 0.5\n    // in_y = (oh + 0.5) * (inH / outH) - 0.5\n    float scale_x = static_cast<float>(inW) / static_cast<float>(outW);\n    float scale_y = static_cast<float>(inH) / static_cast<float>(outH);\n    float in_x = (ow + 0.5f) * scale_x - 0.5f;\n    float in_y = (oh + 0.5f) * scale_y - 0.5f;\n\n    int x0 = static_cast<int>(floorf(in_x));\n    int y0 = static_cast<int>(floorf(in_y));\n    int x1 = x0 + 1;\n    int y1 = y0 + 1;\n\n    float dx = in_x - x0;\n    float dy = in_y - y0;\n\n    // Clamp sampling coords\n    x0 = max(0, min(x0, inW - 1));\n    x1 = max(0, min(x1, inW - 1));\n    y0 = max(0, min(y0, inH - 1));\n    y1 = max(0, min(y1, inH - 1));\n\n    float w00 = (1.f - dx) * (1.f - dy);\n    float w01 = (1.f - dx) * (      dy);\n    float w10 = (      dx) * (1.f - dy);\n    float w11 = (      dx) * (      dy);\n\n    // Loop channels (HWC)\n    for (int c = 0; c < C; ++c) {\n        float v00 = in[idx_hwc(y0, x0, c, inH, inW, C)];\n        float v01 = in[idx_hwc(y1, x0, c, inH, inW, C)];\n        float v10 = in[idx_hwc(y0, x1, c, inH, inW, C)];\n        float v11 = in[idx_hwc(y1, x1, c, inH, inW, C)];\n\n        float val = w00 * v00 + w01 * v01 + w10 * v10 + w11 * v11;\n        out[idx_hwc(oh, ow, c, outH, outW, C)] = val;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    const int inH = HEIGHT, inW = WIDTH, C = CHANNELS;\n    const int outH = OUT_HEIGHT, outW = OUT_WIDTH;\n\n    size_t in_elems  = static_cast<size_t>(inH) * inW * C;\n    size_t out_elems = static_cast<size_t>(outH) * outW * C;\n\n    float* h_input  = new float[in_elems];\n    float* h_output = new float[out_elems];\n\n    std::string input_file = \"./data/img_input.bin\";\n    read_binary(input_file, h_input, in_elems);\n\n    float *d_in, *d_out;\n    cudaMalloc(&d_in,  in_elems  * sizeof(float));\n    cudaMalloc(&d_out, out_elems * sizeof(float));\n    cudaMemcpy(d_in, h_input, in_elems * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(16, 16);\n    dim3 grid((outW + block.x - 1) / block.x,\n              (outH + block.y - 1) / block.y);\n\n    image_scale_bilinear_kernel<<<grid, block>>>(d_in, d_out, inH, inW, C, outH, outW);\n    cudaMemcpy(h_output, d_out, out_elems * sizeof(float), cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"./data/img_scaled.bin\";\n    write_binary(out_file, h_output, out_elems);\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    delete[] h_input;\n    delete[] h_output;\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\n\nH, W, C = 4096, 4096, 3\nOUT_H, OUT_W = int(H*1.5), int(W*1.5)  # must match CUDA\nseed = 123\ntorch.manual_seed(seed)\nnp.random.seed(seed)\n\nos.makedirs(\"data\", exist_ok=True)\n\n# Random input image (HWC, float32)\nimg = torch.randn(H, W, C, dtype=torch.float32)\n\n# Save input\nimg.numpy().tofile(\"data/img_input.bin\")\n\n# Reference bilinear scaling using PyTorch (align_corners=False)\nx_nchw = img.permute(2, 0, 1).unsqueeze(0).contiguous()  # [1, C, H, W]\ny_nchw = F.interpolate(x_nchw, size=(OUT_H, OUT_W), mode=\"bilinear\", align_corners=False)\ny_hwc = y_nchw.squeeze(0).permute(1, 2, 0).contiguous()  # [OUT_H, OUT_W, C]\n\n# Save reference\ny_hwc.numpy().tofile(\"data/img_scaled_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    out = read_binary(output_file, size)\n    ref = read_binary(ref_file, size)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    H, W, C = 4096, 4096, 3\n    OUT_H, OUT_W = int(H*1.5), int(W*1.5)\n    total = OUT_H * OUT_W * C\n    out_file = \"./data/img_scaled.bin\"\n    ref_file = \"./data/img_scaled_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Image_Scaling. Scale an image from 4096x4096x3 to 6144x6144x3 using bilinear interpolation. The input is a float32 tensor of shape (4096, 4096, 3) representing an RGB image in HWC format. The output must be a float32 tensor of shape (6144, 6144, 3). The kernel must implement coordinate mapping equivalent to PyTorch's align_corners=False setting: for each output pixel, compute input coordinates as (ow + 0.5) * (inW/outW) - 0.5 and (oh + 0.5) * (inH/outH) - 0.5. Sampling coordinates must be clamped to input boundaries, and each output pixel must be a weighted average of four nearest input pixels based on fractional coordinates.", "level2_prompt": "Image_Scaling: Scale an image from 4096x4096 to 6144x6144 using bilinear interpolation. For each output pixel (oh, ow), compute corresponding input coordinates (in_x, in_y) using scaling ratios. Take the four nearest input pixels (floor(in_x), floor(in_y)) and neighbors. Compute weights from fractional differences and clamp coordinates to image boundaries. Output pixel values are weighted averages of input pixels for each color channel.", "level3_prompt": "Scale an image from 4096x4096x3 to 6144x6144x3 using bilinear interpolation."}
{"id": 450, "task_name": "Stereo_Disparity", "task_description": "Compute the Stereo_Disparity kernel on GPU using CUDA.", "inputs": [{"name": "left", "dtype": "uint32", "shape": "(256, 256)"}, {"name": "right", "dtype": "uint32", "shape": "(256, 256)"}], "outputs": [{"name": "output", "dtype": "uint32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Configuration Macros based on Kernel Logic Analysis\n// ----------------------------------------------------------------------------\n#define RAD 8\n#define STEPS 3\n#define blockSize_x 32\n#define blockSize_y 16\n\n// ----------------------------------------------------------------------------\n// Helper: Software implementation of __usad4\n// Computes sum of absolute differences of 4 bytes\n// ----------------------------------------------------------------------------\n__device__ inline unsigned int my_usad4(unsigned int A, unsigned int B) {\n    unsigned int result = 0;\n    result += abs((int)(A & 0xFF) - (int)(B & 0xFF));\n    result += abs((int)((A >> 8) & 0xFF) - (int)((B >> 8) & 0xFF));\n    result += abs((int)((A >> 16) & 0xFF) - (int)((B >> 16) & 0xFF));\n    result += abs((int)((A >> 24) & 0xFF) - (int)((B >> 24) & 0xFF));\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void stereoDisparityKernel(unsigned int        *g_img0,\n                                      unsigned int        *g_img1,\n                                      unsigned int        *g_odata,\n                                      int                  w,\n                                      int                  h,\n                                      int                  minDisparity,\n                                      int                  maxDisparity,\n                                      cudaTextureObject_t  tex2Dleft,\n                                      cudaTextureObject_t  tex2Dright)\n{\n    cg::thread_block cta = cg::this_thread_block();\n    const int          tidx = blockDim.x * blockIdx.x + threadIdx.x;\n    const int          tidy = blockDim.y * blockIdx.y + threadIdx.y;\n    const unsigned int sidx = threadIdx.x + RAD;\n    const unsigned int sidy = threadIdx.y + RAD;\n\n    unsigned int            imLeft;\n    unsigned int            imRight;\n    unsigned int            cost;\n    unsigned int            bestCost      = 9999999;\n    unsigned int            bestDisparity = 0;\n    __shared__ unsigned int diff[blockSize_y + 2 * RAD][blockSize_x + 2 * RAD];\n\n    unsigned int imLeftA[STEPS];\n    unsigned int imLeftB[STEPS];\n\n    for (int i = 0; i < STEPS; i++) {\n        int offset = -RAD + i * RAD;\n        imLeftA[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD, tidy + offset);\n        imLeftB[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD + blockSize_x, tidy + offset);\n    }\n\n    for (int d = minDisparity; d <= maxDisparity; d++) {\n        // LEFT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            imLeft = imLeftA[i];\n            imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + d, tidy + offset);\n            cost = my_usad4(imLeft, imRight); // Replaced __usad4\n            diff[sidy + offset][sidx - RAD] = cost;\n        }\n\n        // RIGHT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            if (threadIdx.x < 2 * RAD) {\n                imLeft = imLeftB[i];\n                imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + blockSize_x + d, tidy + offset);\n                cost = my_usad4(imLeft, imRight); // Replaced __usad4\n                diff[sidy + offset][sidx - RAD + blockSize_x] = cost;\n            }\n        }\n\n        cg::sync(cta);\n\n        // sum cost horizontally\n        #pragma unroll\n        for (int j = 0; j < STEPS; j++) {\n            int offset = -RAD + j * RAD;\n            cost = 0;\n            #pragma unroll\n            for (int i = -RAD; i <= RAD; i++) {\n                cost += diff[sidy + offset][sidx + i];\n            }\n            cg::sync(cta);\n            diff[sidy + offset][sidx] = cost;\n            cg::sync(cta);\n        }\n\n        // sum cost vertically\n        cost = 0;\n        #pragma unroll\n        for (int i = -RAD; i <= RAD; i++) {\n            cost += diff[sidy + i][sidx];\n        }\n\n        if (cost < bestCost) {\n            bestCost = cost;\n            bestDisparity = d + 8;\n        }\n\n        cg::sync(cta);\n    }\n\n    if (tidy < h && tidx < w) {\n        g_odata[tidy * w + tidx] = bestDisparity;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Host Code\n// ----------------------------------------------------------------------------\n\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\ncudaTextureObject_t createTextureObject(cudaArray* cuArray) {\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp;\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint;\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0;\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n    return texObj;\n}\n\nint main() {\n    const int w = 256;\n    const int h = 256;\n    const int minDisparity = 0;\n    const int maxDisparity = 16;\n    size_t img_bytes = w * h * sizeof(unsigned int);\n\n    unsigned int* h_img0 = new unsigned int[w * h];\n    unsigned int* h_img1 = new unsigned int[w * h];\n    unsigned int* h_odata = new unsigned int[w * h];\n\n    read_binary(\"data/left.bin\", h_img0, img_bytes);\n    read_binary(\"data/right.bin\", h_img1, img_bytes);\n\n    unsigned int *d_odata;\n    cudaMalloc(&d_odata, img_bytes);\n\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindUnsigned);\n    cudaArray *cuArrayLeft, *cuArrayRight;\n    \n    cudaMallocArray(&cuArrayLeft, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayLeft, 0, 0, h_img0, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texLeft = createTextureObject(cuArrayLeft);\n\n    cudaMallocArray(&cuArrayRight, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayRight, 0, 0, h_img1, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texRight = createTextureObject(cuArrayRight);\n\n    dim3 dimBlock(blockSize_x, blockSize_y);\n    dim3 dimGrid((w + dimBlock.x - 1) / dimBlock.x, (h + dimBlock.y - 1) / dimBlock.y);\n\n    stereoDisparityKernel<<<dimGrid, dimBlock>>>(\n        nullptr, nullptr, d_odata,\n        w, h,\n        minDisparity, maxDisparity,\n        texLeft, texRight\n    );\n\n    cudaMemcpy(h_odata, d_odata, img_bytes, cudaMemcpyDeviceToHost);\n    write_binary(\"data/output.bin\", h_odata, img_bytes);\n\n    cudaDestroyTextureObject(texLeft);\n    cudaDestroyTextureObject(texRight);\n    cudaFreeArray(cuArrayLeft);\n    cudaFreeArray(cuArrayRight);\n    cudaFree(d_odata);\n    delete[] h_img0;\n    delete[] h_img1;\n    delete[] h_odata;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Configuration\nW = 256\nH = 256\nSEED = 42\n\nnp.random.seed(SEED)\n\n# Generate random texture (Left Image)\nleft_img = np.random.randint(0, 0xFFFFFFFF, (H, W), dtype=np.uint32)\n\n# Create Right image with CONSTANT disparity.\n# Block matching fails at disparity discontinuities (occlusions).\n# To verify the kernel implementation mechanics, we use a uniform disparity.\nCONSTANT_DISP = 4 \n\nright_img = np.zeros_like(left_img)\ngt_disparity = np.full((H, W), CONSTANT_DISP, dtype=np.uint32)\n\n# Right(x, y) = Left(x - d, y)\n# We simulate the texture clamp behavior of the kernel\nfor y in range(H):\n    for x in range(W):\n        src_x = x - CONSTANT_DISP\n        # Clamp to border (0, W-1)\n        src_x = min(max(src_x, 0), W - 1)\n        right_img[y, x] = left_img[y, src_x]\n\n# Kernel output logic: returns d + 8\nexpected_output = gt_disparity + 8\n\nos.makedirs(\"data\", exist_ok=True)\nleft_img.tofile(\"data/left.bin\")\nright_img.tofile(\"data/right.bin\")\nexpected_output.tofile(\"data/ref_output.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=0):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files\")\n        return False\n    \n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output.astype(np.int32) - reference.astype(np.int32))\n    max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    W = 256\n    H = 256\n    \n    out_file = \"data/output.bin\"\n    ref_file = \"data/ref_output.bin\"\n    \n    # Exact match expected for constant disparity\n    if compare_outputs(out_file, ref_file, W*H):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Stereo_Disparity. Given two input images, left and right, each of size 256x256 with uint32 data type, compute a disparity map output of size 65536 (flattened 256x256) with uint32 data type. For each pixel in the left image, compute the disparity by comparing it to the right image across a fixed range of candidate disparities (0 to 16). For each candidate disparity, calculate the sum of absolute differences (SAD) over a 17x17 window centered at the pixel. The candidate disparity that minimizes the SAD cost is selected, and 8 is added to it to form the output value for that pixel. The kernel must handle image borders by clamping out-of-bound accesses.", "level2_prompt": "Task: Stereo_Disparity. For each pixel in the left image, compute the disparity by comparing it to the right image. For each candidate disparity in a fixed range (0 to 16), calculate the sum of absolute differences between a 17x17 window in the left image and the corresponding window shifted by the candidate disparity in the right image. The disparity that minimizes this sum is chosen, and 8 is added to it to produce the output value.", "level3_prompt": "Compute the stereo disparity between two images."}
{"id": 451, "task_name": "Stereo_Disparity", "task_description": "Compute the Stereo_Disparity kernel on GPU using CUDA.", "inputs": [{"name": "left", "dtype": "uint32", "shape": "(512, 512)"}, {"name": "right", "dtype": "uint32", "shape": "(512, 512)"}], "outputs": [{"name": "output", "dtype": "uint32", "shape": "(512, 512)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Configuration Macros based on Kernel Logic Analysis\n// ----------------------------------------------------------------------------\n#define RAD 8\n#define STEPS 3\n#define blockSize_x 32\n#define blockSize_y 16\n\n// ----------------------------------------------------------------------------\n// Helper: Software implementation of __usad4\n// Computes sum of absolute differences of 4 bytes\n// ----------------------------------------------------------------------------\n__device__ inline unsigned int my_usad4(unsigned int A, unsigned int B) {\n    unsigned int result = 0;\n    result += abs((int)(A & 0xFF) - (int)(B & 0xFF));\n    result += abs((int)((A >> 8) & 0xFF) - (int)((B >> 8) & 0xFF));\n    result += abs((int)((A >> 16) & 0xFF) - (int)((B >> 16) & 0xFF));\n    result += abs((int)((A >> 24) & 0xFF) - (int)((B >> 24) & 0xFF));\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void stereoDisparityKernel(unsigned int        *g_img0,\n                                      unsigned int        *g_img1,\n                                      unsigned int        *g_odata,\n                                      int                  w,\n                                      int                  h,\n                                      int                  minDisparity,\n                                      int                  maxDisparity,\n                                      cudaTextureObject_t  tex2Dleft,\n                                      cudaTextureObject_t  tex2Dright)\n{\n    cg::thread_block cta = cg::this_thread_block();\n    const int          tidx = blockDim.x * blockIdx.x + threadIdx.x;\n    const int          tidy = blockDim.y * blockIdx.y + threadIdx.y;\n    const unsigned int sidx = threadIdx.x + RAD;\n    const unsigned int sidy = threadIdx.y + RAD;\n\n    unsigned int            imLeft;\n    unsigned int            imRight;\n    unsigned int            cost;\n    unsigned int            bestCost      = 9999999;\n    unsigned int            bestDisparity = 0;\n    __shared__ unsigned int diff[blockSize_y + 2 * RAD][blockSize_x + 2 * RAD];\n\n    unsigned int imLeftA[STEPS];\n    unsigned int imLeftB[STEPS];\n\n    for (int i = 0; i < STEPS; i++) {\n        int offset = -RAD + i * RAD;\n        imLeftA[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD, tidy + offset);\n        imLeftB[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD + blockSize_x, tidy + offset);\n    }\n\n    for (int d = minDisparity; d <= maxDisparity; d++) {\n        // LEFT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            imLeft = imLeftA[i];\n            imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + d, tidy + offset);\n            cost = my_usad4(imLeft, imRight); // Replaced __usad4\n            diff[sidy + offset][sidx - RAD] = cost;\n        }\n\n        // RIGHT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            if (threadIdx.x < 2 * RAD) {\n                imLeft = imLeftB[i];\n                imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + blockSize_x + d, tidy + offset);\n                cost = my_usad4(imLeft, imRight); // Replaced __usad4\n                diff[sidy + offset][sidx - RAD + blockSize_x] = cost;\n            }\n        }\n\n        cg::sync(cta);\n\n        // sum cost horizontally\n        #pragma unroll\n        for (int j = 0; j < STEPS; j++) {\n            int offset = -RAD + j * RAD;\n            cost = 0;\n            #pragma unroll\n            for (int i = -RAD; i <= RAD; i++) {\n                cost += diff[sidy + offset][sidx + i];\n            }\n            cg::sync(cta);\n            diff[sidy + offset][sidx] = cost;\n            cg::sync(cta);\n        }\n\n        // sum cost vertically\n        cost = 0;\n        #pragma unroll\n        for (int i = -RAD; i <= RAD; i++) {\n            cost += diff[sidy + i][sidx];\n        }\n\n        if (cost < bestCost) {\n            bestCost = cost;\n            bestDisparity = d + 8;\n        }\n\n        cg::sync(cta);\n    }\n\n    if (tidy < h && tidx < w) {\n        g_odata[tidy * w + tidx] = bestDisparity;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Host Code\n// ----------------------------------------------------------------------------\n\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\ncudaTextureObject_t createTextureObject(cudaArray* cuArray) {\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp;\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint;\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0;\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n    return texObj;\n}\n\nint main() {\n    const int w = 512;\n    const int h = 512;\n    const int minDisparity = 0;\n    const int maxDisparity = 16;\n    size_t img_bytes = w * h * sizeof(unsigned int);\n\n    unsigned int* h_img0 = new unsigned int[w * h];\n    unsigned int* h_img1 = new unsigned int[w * h];\n    unsigned int* h_odata = new unsigned int[w * h];\n\n    read_binary(\"data/left.bin\", h_img0, img_bytes);\n    read_binary(\"data/right.bin\", h_img1, img_bytes);\n\n    unsigned int *d_odata;\n    cudaMalloc(&d_odata, img_bytes);\n\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindUnsigned);\n    cudaArray *cuArrayLeft, *cuArrayRight;\n    \n    cudaMallocArray(&cuArrayLeft, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayLeft, 0, 0, h_img0, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texLeft = createTextureObject(cuArrayLeft);\n\n    cudaMallocArray(&cuArrayRight, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayRight, 0, 0, h_img1, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texRight = createTextureObject(cuArrayRight);\n\n    dim3 dimBlock(blockSize_x, blockSize_y);\n    dim3 dimGrid((w + dimBlock.x - 1) / dimBlock.x, (h + dimBlock.y - 1) / dimBlock.y);\n\n    stereoDisparityKernel<<<dimGrid, dimBlock>>>(\n        nullptr, nullptr, d_odata,\n        w, h,\n        minDisparity, maxDisparity,\n        texLeft, texRight\n    );\n\n    cudaMemcpy(h_odata, d_odata, img_bytes, cudaMemcpyDeviceToHost);\n    write_binary(\"data/output.bin\", h_odata, img_bytes);\n\n    cudaDestroyTextureObject(texLeft);\n    cudaDestroyTextureObject(texRight);\n    cudaFreeArray(cuArrayLeft);\n    cudaFreeArray(cuArrayRight);\n    cudaFree(d_odata);\n    delete[] h_img0;\n    delete[] h_img1;\n    delete[] h_odata;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Configuration\nW = 512\nH = 512\nSEED = 42\n\nnp.random.seed(SEED)\n\n# Generate random texture (Left Image)\nleft_img = np.random.randint(0, 0xFFFFFFFF, (H, W), dtype=np.uint32)\n\n# Create Right image with CONSTANT disparity.\n# Block matching fails at disparity discontinuities (occlusions).\n# To verify the kernel implementation mechanics, we use a uniform disparity.\nCONSTANT_DISP = 4 \n\nright_img = np.zeros_like(left_img)\ngt_disparity = np.full((H, W), CONSTANT_DISP, dtype=np.uint32)\n\n# Right(x, y) = Left(x - d, y)\n# We simulate the texture clamp behavior of the kernel\nfor y in range(H):\n    for x in range(W):\n        src_x = x - CONSTANT_DISP\n        # Clamp to border (0, W-1)\n        src_x = min(max(src_x, 0), W - 1)\n        right_img[y, x] = left_img[y, src_x]\n\n# Kernel output logic: returns d + 8\nexpected_output = gt_disparity + 8\n\nos.makedirs(\"data\", exist_ok=True)\nleft_img.tofile(\"data/left.bin\")\nright_img.tofile(\"data/right.bin\")\nexpected_output.tofile(\"data/ref_output.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=0):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files\")\n        return False\n    \n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output.astype(np.int32) - reference.astype(np.int32))\n    max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    W = 512\n    H = 512\n    \n    out_file = \"data/output.bin\"\n    ref_file = \"data/ref_output.bin\"\n    \n    # Exact match expected for constant disparity\n    if compare_outputs(out_file, ref_file, W*H):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Stereo Disparity: Compute a disparity map between two stereo images. Inputs include a 512x512 left image and a 512x512 right image, both as uint32 tensors. The output is a 512x512 uint32 disparity map. For each pixel, search horizontally across a predefined disparity range (0 to 16) to find the best match between images. Matching is evaluated using sum of absolute differences (SAD) over a 17x17 window (radius 8). The kernel must use shared memory for intermediate calculations and synchronize threads. The final disparity value is the best match position plus 8.", "level2_prompt": "Stereo Disparity: For each pixel coordinate, compute the optimal horizontal displacement between left and right images. Iterate through disparity values (0 to 16), calculate window-based SAD costs by comparing 4-byte components, aggregate costs horizontally then vertically, and select the disparity with minimum cost. Add 8 to the selected disparity before output.", "level3_prompt": "Compute the Stereo_Disparity kernel on GPU using CUDA."}
{"id": 452, "task_name": "Stereo_Disparity", "task_description": "Compute the Stereo_Disparity kernel on GPU using CUDA.", "inputs": [{"name": "left", "dtype": "uint32", "shape": "(1024, 1024)"}, {"name": "right", "dtype": "uint32", "shape": "(1024, 1024)"}], "outputs": [{"name": "output", "dtype": "uint32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Configuration Macros based on Kernel Logic Analysis\n// ----------------------------------------------------------------------------\n#define RAD 8\n#define STEPS 3\n#define blockSize_x 32\n#define blockSize_y 16\n\n// ----------------------------------------------------------------------------\n// Helper: Software implementation of __usad4\n// Computes sum of absolute differences of 4 bytes\n// ----------------------------------------------------------------------------\n__device__ inline unsigned int my_usad4(unsigned int A, unsigned int B) {\n    unsigned int result = 0;\n    result += abs((int)(A & 0xFF) - (int)(B & 0xFF));\n    result += abs((int)((A >> 8) & 0xFF) - (int)((B >> 8) & 0xFF));\n    result += abs((int)((A >> 16) & 0xFF) - (int)((B >> 16) & 0xFF));\n    result += abs((int)((A >> 24) & 0xFF) - (int)((B >> 24) & 0xFF));\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void stereoDisparityKernel(unsigned int        *g_img0,\n                                      unsigned int        *g_img1,\n                                      unsigned int        *g_odata,\n                                      int                  w,\n                                      int                  h,\n                                      int                  minDisparity,\n                                      int                  maxDisparity,\n                                      cudaTextureObject_t  tex2Dleft,\n                                      cudaTextureObject_t  tex2Dright)\n{\n    cg::thread_block cta = cg::this_thread_block();\n    const int          tidx = blockDim.x * blockIdx.x + threadIdx.x;\n    const int          tidy = blockDim.y * blockIdx.y + threadIdx.y;\n    const unsigned int sidx = threadIdx.x + RAD;\n    const unsigned int sidy = threadIdx.y + RAD;\n\n    unsigned int            imLeft;\n    unsigned int            imRight;\n    unsigned int            cost;\n    unsigned int            bestCost      = 9999999;\n    unsigned int            bestDisparity = 0;\n    __shared__ unsigned int diff[blockSize_y + 2 * RAD][blockSize_x + 2 * RAD];\n\n    unsigned int imLeftA[STEPS];\n    unsigned int imLeftB[STEPS];\n\n    for (int i = 0; i < STEPS; i++) {\n        int offset = -RAD + i * RAD;\n        imLeftA[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD, tidy + offset);\n        imLeftB[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD + blockSize_x, tidy + offset);\n    }\n\n    for (int d = minDisparity; d <= maxDisparity; d++) {\n        // LEFT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            imLeft = imLeftA[i];\n            imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + d, tidy + offset);\n            cost = my_usad4(imLeft, imRight); // Replaced __usad4\n            diff[sidy + offset][sidx - RAD] = cost;\n        }\n\n        // RIGHT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            if (threadIdx.x < 2 * RAD) {\n                imLeft = imLeftB[i];\n                imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + blockSize_x + d, tidy + offset);\n                cost = my_usad4(imLeft, imRight); // Replaced __usad4\n                diff[sidy + offset][sidx - RAD + blockSize_x] = cost;\n            }\n        }\n\n        cg::sync(cta);\n\n        // sum cost horizontally\n        #pragma unroll\n        for (int j = 0; j < STEPS; j++) {\n            int offset = -RAD + j * RAD;\n            cost = 0;\n            #pragma unroll\n            for (int i = -RAD; i <= RAD; i++) {\n                cost += diff[sidy + offset][sidx + i];\n            }\n            cg::sync(cta);\n            diff[sidy + offset][sidx] = cost;\n            cg::sync(cta);\n        }\n\n        // sum cost vertically\n        cost = 0;\n        #pragma unroll\n        for (int i = -RAD; i <= RAD; i++) {\n            cost += diff[sidy + i][sidx];\n        }\n\n        if (cost < bestCost) {\n            bestCost = cost;\n            bestDisparity = d + 8;\n        }\n\n        cg::sync(cta);\n    }\n\n    if (tidy < h && tidx < w) {\n        g_odata[tidy * w + tidx] = bestDisparity;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Host Code\n// ----------------------------------------------------------------------------\n\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\ncudaTextureObject_t createTextureObject(cudaArray* cuArray) {\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp;\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint;\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0;\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n    return texObj;\n}\n\nint main() {\n    const int w = 1024;\n    const int h = 1024;\n    const int minDisparity = 0;\n    const int maxDisparity = 16;\n    size_t img_bytes = w * h * sizeof(unsigned int);\n\n    unsigned int* h_img0 = new unsigned int[w * h];\n    unsigned int* h_img1 = new unsigned int[w * h];\n    unsigned int* h_odata = new unsigned int[w * h];\n\n    read_binary(\"data/left.bin\", h_img0, img_bytes);\n    read_binary(\"data/right.bin\", h_img1, img_bytes);\n\n    unsigned int *d_odata;\n    cudaMalloc(&d_odata, img_bytes);\n\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindUnsigned);\n    cudaArray *cuArrayLeft, *cuArrayRight;\n    \n    cudaMallocArray(&cuArrayLeft, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayLeft, 0, 0, h_img0, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texLeft = createTextureObject(cuArrayLeft);\n\n    cudaMallocArray(&cuArrayRight, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayRight, 0, 0, h_img1, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texRight = createTextureObject(cuArrayRight);\n\n    dim3 dimBlock(blockSize_x, blockSize_y);\n    dim3 dimGrid((w + dimBlock.x - 1) / dimBlock.x, (h + dimBlock.y - 1) / dimBlock.y);\n\n    stereoDisparityKernel<<<dimGrid, dimBlock>>>(\n        nullptr, nullptr, d_odata,\n        w, h,\n        minDisparity, maxDisparity,\n        texLeft, texRight\n    );\n\n    cudaMemcpy(h_odata, d_odata, img_bytes, cudaMemcpyDeviceToHost);\n    write_binary(\"data/output.bin\", h_odata, img_bytes);\n\n    cudaDestroyTextureObject(texLeft);\n    cudaDestroyTextureObject(texRight);\n    cudaFreeArray(cuArrayLeft);\n    cudaFreeArray(cuArrayRight);\n    cudaFree(d_odata);\n    delete[] h_img0;\n    delete[] h_img1;\n    delete[] h_odata;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Configuration\nW = 1024\nH = 1024\nSEED = 42\n\nnp.random.seed(SEED)\n\n# Generate random texture (Left Image)\nleft_img = np.random.randint(0, 0xFFFFFFFF, (H, W), dtype=np.uint32)\n\n# Create Right image with CONSTANT disparity.\n# Block matching fails at disparity discontinuities (occlusions).\n# To verify the kernel implementation mechanics, we use a uniform disparity.\nCONSTANT_DISP = 4 \n\nright_img = np.zeros_like(left_img)\ngt_disparity = np.full((H, W), CONSTANT_DISP, dtype=np.uint32)\n\n# Right(x, y) = Left(x - d, y)\n# We simulate the texture clamp behavior of the kernel\nfor y in range(H):\n    for x in range(W):\n        src_x = x - CONSTANT_DISP\n        # Clamp to border (0, W-1)\n        src_x = min(max(src_x, 0), W - 1)\n        right_img[y, x] = left_img[y, src_x]\n\n# Kernel output logic: returns d + 8\nexpected_output = gt_disparity + 8\n\nos.makedirs(\"data\", exist_ok=True)\nleft_img.tofile(\"data/left.bin\")\nright_img.tofile(\"data/right.bin\")\nexpected_output.tofile(\"data/ref_output.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=0):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files\")\n        return False\n    \n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output.astype(np.int32) - reference.astype(np.int32))\n    max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    W = 1024\n    H = 1024\n    \n    out_file = \"data/output.bin\"\n    ref_file = \"data/ref_output.bin\"\n    \n    # Exact match expected for constant disparity\n    if compare_outputs(out_file, ref_file, W*H):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for stereo disparity calculation. The kernel takes two input images, left and right, each of size 1024x1024 with uint32 data type. For each pixel in the left image, compute the optimal horizontal disparity by comparing it with shifted pixels in the right image. The disparity search range is from minDisparity (0) to maxDisparity (16). For each candidate disparity, compute the sum of absolute differences (SAD) over a 17x17 window centered on the pixel. The output should be a flattened array of 1048576 uint32 values where each element is the optimal disparity plus 8. Use shared memory for intermediate calculations and ensure thread synchronization.", "level2_prompt": "Compute stereo disparity between two images. For each pixel position (x,y) in the left image, evaluate all horizontal shifts (disparities) from 0 to 16. For each disparity d, calculate the sum of absolute differences between the left image at (x,y) and right image at (x+d,y) over a 17x17 neighborhood. Select the disparity with minimal SAD and output d+8 for each pixel.", "level3_prompt": "Compute the Stereo_Disparity kernel on GPU using CUDA."}
{"id": 453, "task_name": "Stereo_Disparity", "task_description": "Compute the Stereo_Disparity kernel on GPU using CUDA.", "inputs": [{"name": "left", "dtype": "uint32", "shape": "(2048, 2048)"}, {"name": "right", "dtype": "uint32", "shape": "(2048, 2048)"}], "outputs": [{"name": "output", "dtype": "uint32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Configuration Macros based on Kernel Logic Analysis\n// ----------------------------------------------------------------------------\n#define RAD 8\n#define STEPS 3\n#define blockSize_x 32\n#define blockSize_y 16\n\n// ----------------------------------------------------------------------------\n// Helper: Software implementation of __usad4\n// Computes sum of absolute differences of 4 bytes\n// ----------------------------------------------------------------------------\n__device__ inline unsigned int my_usad4(unsigned int A, unsigned int B) {\n    unsigned int result = 0;\n    result += abs((int)(A & 0xFF) - (int)(B & 0xFF));\n    result += abs((int)((A >> 8) & 0xFF) - (int)((B >> 8) & 0xFF));\n    result += abs((int)((A >> 16) & 0xFF) - (int)((B >> 16) & 0xFF));\n    result += abs((int)((A >> 24) & 0xFF) - (int)((B >> 24) & 0xFF));\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void stereoDisparityKernel(unsigned int        *g_img0,\n                                      unsigned int        *g_img1,\n                                      unsigned int        *g_odata,\n                                      int                  w,\n                                      int                  h,\n                                      int                  minDisparity,\n                                      int                  maxDisparity,\n                                      cudaTextureObject_t  tex2Dleft,\n                                      cudaTextureObject_t  tex2Dright)\n{\n    cg::thread_block cta = cg::this_thread_block();\n    const int          tidx = blockDim.x * blockIdx.x + threadIdx.x;\n    const int          tidy = blockDim.y * blockIdx.y + threadIdx.y;\n    const unsigned int sidx = threadIdx.x + RAD;\n    const unsigned int sidy = threadIdx.y + RAD;\n\n    unsigned int            imLeft;\n    unsigned int            imRight;\n    unsigned int            cost;\n    unsigned int            bestCost      = 9999999;\n    unsigned int            bestDisparity = 0;\n    __shared__ unsigned int diff[blockSize_y + 2 * RAD][blockSize_x + 2 * RAD];\n\n    unsigned int imLeftA[STEPS];\n    unsigned int imLeftB[STEPS];\n\n    for (int i = 0; i < STEPS; i++) {\n        int offset = -RAD + i * RAD;\n        imLeftA[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD, tidy + offset);\n        imLeftB[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD + blockSize_x, tidy + offset);\n    }\n\n    for (int d = minDisparity; d <= maxDisparity; d++) {\n        // LEFT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            imLeft = imLeftA[i];\n            imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + d, tidy + offset);\n            cost = my_usad4(imLeft, imRight); // Replaced __usad4\n            diff[sidy + offset][sidx - RAD] = cost;\n        }\n\n        // RIGHT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            if (threadIdx.x < 2 * RAD) {\n                imLeft = imLeftB[i];\n                imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + blockSize_x + d, tidy + offset);\n                cost = my_usad4(imLeft, imRight); // Replaced __usad4\n                diff[sidy + offset][sidx - RAD + blockSize_x] = cost;\n            }\n        }\n\n        cg::sync(cta);\n\n        // sum cost horizontally\n        #pragma unroll\n        for (int j = 0; j < STEPS; j++) {\n            int offset = -RAD + j * RAD;\n            cost = 0;\n            #pragma unroll\n            for (int i = -RAD; i <= RAD; i++) {\n                cost += diff[sidy + offset][sidx + i];\n            }\n            cg::sync(cta);\n            diff[sidy + offset][sidx] = cost;\n            cg::sync(cta);\n        }\n\n        // sum cost vertically\n        cost = 0;\n        #pragma unroll\n        for (int i = -RAD; i <= RAD; i++) {\n            cost += diff[sidy + i][sidx];\n        }\n\n        if (cost < bestCost) {\n            bestCost = cost;\n            bestDisparity = d + 8;\n        }\n\n        cg::sync(cta);\n    }\n\n    if (tidy < h && tidx < w) {\n        g_odata[tidy * w + tidx] = bestDisparity;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Host Code\n// ----------------------------------------------------------------------------\n\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\ncudaTextureObject_t createTextureObject(cudaArray* cuArray) {\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp;\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint;\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0;\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n    return texObj;\n}\n\nint main() {\n    const int w = 2048;\n    const int h = 2048;\n    const int minDisparity = 0;\n    const int maxDisparity = 16;\n    size_t img_bytes = w * h * sizeof(unsigned int);\n\n    unsigned int* h_img0 = new unsigned int[w * h];\n    unsigned int* h_img1 = new unsigned int[w * h];\n    unsigned int* h_odata = new unsigned int[w * h];\n\n    read_binary(\"data/left.bin\", h_img0, img_bytes);\n    read_binary(\"data/right.bin\", h_img1, img_bytes);\n\n    unsigned int *d_odata;\n    cudaMalloc(&d_odata, img_bytes);\n\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindUnsigned);\n    cudaArray *cuArrayLeft, *cuArrayRight;\n    \n    cudaMallocArray(&cuArrayLeft, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayLeft, 0, 0, h_img0, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texLeft = createTextureObject(cuArrayLeft);\n\n    cudaMallocArray(&cuArrayRight, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayRight, 0, 0, h_img1, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texRight = createTextureObject(cuArrayRight);\n\n    dim3 dimBlock(blockSize_x, blockSize_y);\n    dim3 dimGrid((w + dimBlock.x - 1) / dimBlock.x, (h + dimBlock.y - 1) / dimBlock.y);\n\n    stereoDisparityKernel<<<dimGrid, dimBlock>>>(\n        nullptr, nullptr, d_odata,\n        w, h,\n        minDisparity, maxDisparity,\n        texLeft, texRight\n    );\n\n    cudaMemcpy(h_odata, d_odata, img_bytes, cudaMemcpyDeviceToHost);\n    write_binary(\"data/output.bin\", h_odata, img_bytes);\n\n    cudaDestroyTextureObject(texLeft);\n    cudaDestroyTextureObject(texRight);\n    cudaFreeArray(cuArrayLeft);\n    cudaFreeArray(cuArrayRight);\n    cudaFree(d_odata);\n    delete[] h_img0;\n    delete[] h_img1;\n    delete[] h_odata;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Configuration\nW = 2048\nH = 2048\nSEED = 42\n\nnp.random.seed(SEED)\n\n# Generate random texture (Left Image)\nleft_img = np.random.randint(0, 0xFFFFFFFF, (H, W), dtype=np.uint32)\n\n# Create Right image with CONSTANT disparity.\n# Block matching fails at disparity discontinuities (occlusions).\n# To verify the kernel implementation mechanics, we use a uniform disparity.\nCONSTANT_DISP = 4 \n\nright_img = np.zeros_like(left_img)\ngt_disparity = np.full((H, W), CONSTANT_DISP, dtype=np.uint32)\n\n# Right(x, y) = Left(x - d, y)\n# We simulate the texture clamp behavior of the kernel\nfor y in range(H):\n    for x in range(W):\n        src_x = x - CONSTANT_DISP\n        # Clamp to border (0, W-1)\n        src_x = min(max(src_x, 0), W - 1)\n        right_img[y, x] = left_img[y, src_x]\n\n# Kernel output logic: returns d + 8\nexpected_output = gt_disparity + 8\n\nos.makedirs(\"data\", exist_ok=True)\nleft_img.tofile(\"data/left.bin\")\nright_img.tofile(\"data/right.bin\")\nexpected_output.tofile(\"data/ref_output.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=0):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files\")\n        return False\n    \n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output.astype(np.int32) - reference.astype(np.int32))\n    max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    W = 2048\n    H = 2048\n    \n    out_file = \"data/output.bin\"\n    ref_file = \"data/ref_output.bin\"\n    \n    # Exact match expected for constant disparity\n    if compare_outputs(out_file, ref_file, W*H):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Stereo_Disparity. Compute a disparity map between two stereo images. The inputs are two 2048x2048 uint32 images representing left and right views. The output is a flattened 4194304-element uint32 array representing per-pixel disparity values. For each pixel position, compare 17x17 windows between left and right images across a disparity search range. Compute byte-wise sum of absolute differences (SAD) for uint32 values (each treated as four bytes), aggregate costs horizontally and vertically within the window, and select the disparity with minimal cost. The final disparity value must be the minimal cost disparity plus 8. The kernel must handle border clamping and use a fixed window radius of 8.", "level2_prompt": "Task: Stereo_Disparity. For each pixel coordinate (x,y), search across a disparity range to find the shift d that minimizes the sum of absolute differences between 17x17 windows in left and right images. Each uint32 pixel value is decomposed into four byte components for SAD computation. The minimal cost disparity is offset by +8 for the output value.", "level3_prompt": "Compute the Stereo_Disparity kernel on GPU using CUDA."}
{"id": 454, "task_name": "Stereo_Disparity", "task_description": "Compute the Stereo_Disparity kernel on GPU using CUDA.", "inputs": [{"name": "left", "dtype": "uint32", "shape": "(4096, 4096)"}, {"name": "right", "dtype": "uint32", "shape": "(4096, 4096)"}], "outputs": [{"name": "output", "dtype": "uint32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Configuration Macros based on Kernel Logic Analysis\n// ----------------------------------------------------------------------------\n#define RAD 8\n#define STEPS 3\n#define blockSize_x 32\n#define blockSize_y 16\n\n// ----------------------------------------------------------------------------\n// Helper: Software implementation of __usad4\n// Computes sum of absolute differences of 4 bytes\n// ----------------------------------------------------------------------------\n__device__ inline unsigned int my_usad4(unsigned int A, unsigned int B) {\n    unsigned int result = 0;\n    result += abs((int)(A & 0xFF) - (int)(B & 0xFF));\n    result += abs((int)((A >> 8) & 0xFF) - (int)((B >> 8) & 0xFF));\n    result += abs((int)((A >> 16) & 0xFF) - (int)((B >> 16) & 0xFF));\n    result += abs((int)((A >> 24) & 0xFF) - (int)((B >> 24) & 0xFF));\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void stereoDisparityKernel(unsigned int        *g_img0,\n                                      unsigned int        *g_img1,\n                                      unsigned int        *g_odata,\n                                      int                  w,\n                                      int                  h,\n                                      int                  minDisparity,\n                                      int                  maxDisparity,\n                                      cudaTextureObject_t  tex2Dleft,\n                                      cudaTextureObject_t  tex2Dright)\n{\n    cg::thread_block cta = cg::this_thread_block();\n    const int          tidx = blockDim.x * blockIdx.x + threadIdx.x;\n    const int          tidy = blockDim.y * blockIdx.y + threadIdx.y;\n    const unsigned int sidx = threadIdx.x + RAD;\n    const unsigned int sidy = threadIdx.y + RAD;\n\n    unsigned int            imLeft;\n    unsigned int            imRight;\n    unsigned int            cost;\n    unsigned int            bestCost      = 9999999;\n    unsigned int            bestDisparity = 0;\n    __shared__ unsigned int diff[blockSize_y + 2 * RAD][blockSize_x + 2 * RAD];\n\n    unsigned int imLeftA[STEPS];\n    unsigned int imLeftB[STEPS];\n\n    for (int i = 0; i < STEPS; i++) {\n        int offset = -RAD + i * RAD;\n        imLeftA[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD, tidy + offset);\n        imLeftB[i] = tex2D<unsigned int>(tex2Dleft, tidx - RAD + blockSize_x, tidy + offset);\n    }\n\n    for (int d = minDisparity; d <= maxDisparity; d++) {\n        // LEFT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            imLeft = imLeftA[i];\n            imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + d, tidy + offset);\n            cost = my_usad4(imLeft, imRight); // Replaced __usad4\n            diff[sidy + offset][sidx - RAD] = cost;\n        }\n\n        // RIGHT\n        #pragma unroll\n        for (int i = 0; i < STEPS; i++) {\n            int offset = -RAD + i * RAD;\n            if (threadIdx.x < 2 * RAD) {\n                imLeft = imLeftB[i];\n                imRight = tex2D<unsigned int>(tex2Dright, tidx - RAD + blockSize_x + d, tidy + offset);\n                cost = my_usad4(imLeft, imRight); // Replaced __usad4\n                diff[sidy + offset][sidx - RAD + blockSize_x] = cost;\n            }\n        }\n\n        cg::sync(cta);\n\n        // sum cost horizontally\n        #pragma unroll\n        for (int j = 0; j < STEPS; j++) {\n            int offset = -RAD + j * RAD;\n            cost = 0;\n            #pragma unroll\n            for (int i = -RAD; i <= RAD; i++) {\n                cost += diff[sidy + offset][sidx + i];\n            }\n            cg::sync(cta);\n            diff[sidy + offset][sidx] = cost;\n            cg::sync(cta);\n        }\n\n        // sum cost vertically\n        cost = 0;\n        #pragma unroll\n        for (int i = -RAD; i <= RAD; i++) {\n            cost += diff[sidy + i][sidx];\n        }\n\n        if (cost < bestCost) {\n            bestCost = cost;\n            bestDisparity = d + 8;\n        }\n\n        cg::sync(cta);\n    }\n\n    if (tidy < h && tidx < w) {\n        g_odata[tidy * w + tidx] = bestDisparity;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Host Code\n// ----------------------------------------------------------------------------\n\nvoid read_binary(const std::string& filename, void* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size);\n    out.close();\n}\n\ncudaTextureObject_t createTextureObject(cudaArray* cuArray) {\n    struct cudaResourceDesc resDesc;\n    memset(&resDesc, 0, sizeof(resDesc));\n    resDesc.resType = cudaResourceTypeArray;\n    resDesc.res.array.array = cuArray;\n\n    struct cudaTextureDesc texDesc;\n    memset(&texDesc, 0, sizeof(texDesc));\n    texDesc.addressMode[0] = cudaAddressModeClamp;\n    texDesc.addressMode[1] = cudaAddressModeClamp;\n    texDesc.filterMode = cudaFilterModePoint;\n    texDesc.readMode = cudaReadModeElementType;\n    texDesc.normalizedCoords = 0;\n\n    cudaTextureObject_t texObj = 0;\n    cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n    return texObj;\n}\n\nint main() {\n    const int w = 4096;\n    const int h = 4096;\n    const int minDisparity = 0;\n    const int maxDisparity = 16;\n    size_t img_bytes = w * h * sizeof(unsigned int);\n\n    unsigned int* h_img0 = new unsigned int[w * h];\n    unsigned int* h_img1 = new unsigned int[w * h];\n    unsigned int* h_odata = new unsigned int[w * h];\n\n    read_binary(\"data/left.bin\", h_img0, img_bytes);\n    read_binary(\"data/right.bin\", h_img1, img_bytes);\n\n    unsigned int *d_odata;\n    cudaMalloc(&d_odata, img_bytes);\n\n    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindUnsigned);\n    cudaArray *cuArrayLeft, *cuArrayRight;\n    \n    cudaMallocArray(&cuArrayLeft, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayLeft, 0, 0, h_img0, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texLeft = createTextureObject(cuArrayLeft);\n\n    cudaMallocArray(&cuArrayRight, &channelDesc, w, h);\n    cudaMemcpy2DToArray(cuArrayRight, 0, 0, h_img1, w * sizeof(unsigned int), w * sizeof(unsigned int), h, cudaMemcpyHostToDevice);\n    cudaTextureObject_t texRight = createTextureObject(cuArrayRight);\n\n    dim3 dimBlock(blockSize_x, blockSize_y);\n    dim3 dimGrid((w + dimBlock.x - 1) / dimBlock.x, (h + dimBlock.y - 1) / dimBlock.y);\n\n    stereoDisparityKernel<<<dimGrid, dimBlock>>>(\n        nullptr, nullptr, d_odata,\n        w, h,\n        minDisparity, maxDisparity,\n        texLeft, texRight\n    );\n\n    cudaMemcpy(h_odata, d_odata, img_bytes, cudaMemcpyDeviceToHost);\n    write_binary(\"data/output.bin\", h_odata, img_bytes);\n\n    cudaDestroyTextureObject(texLeft);\n    cudaDestroyTextureObject(texRight);\n    cudaFreeArray(cuArrayLeft);\n    cudaFreeArray(cuArrayRight);\n    cudaFree(d_odata);\n    delete[] h_img0;\n    delete[] h_img1;\n    delete[] h_odata;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Configuration\nW = 4096\nH = 4096\nSEED = 42\n\nnp.random.seed(SEED)\n\n# Generate random texture (Left Image)\nleft_img = np.random.randint(0, 0xFFFFFFFF, (H, W), dtype=np.uint32)\n\n# Create Right image with CONSTANT disparity.\n# Block matching fails at disparity discontinuities (occlusions).\n# To verify the kernel implementation mechanics, we use a uniform disparity.\nCONSTANT_DISP = 4 \n\nright_img = np.zeros_like(left_img)\ngt_disparity = np.full((H, W), CONSTANT_DISP, dtype=np.uint32)\n\n# Right(x, y) = Left(x - d, y)\n# We simulate the texture clamp behavior of the kernel\nfor y in range(H):\n    for x in range(W):\n        src_x = x - CONSTANT_DISP\n        # Clamp to border (0, W-1)\n        src_x = min(max(src_x, 0), W - 1)\n        right_img[y, x] = left_img[y, src_x]\n\n# Kernel output logic: returns d + 8\nexpected_output = gt_disparity + 8\n\nos.makedirs(\"data\", exist_ok=True)\nleft_img.tofile(\"data/left.bin\")\nright_img.tofile(\"data/right.bin\")\nexpected_output.tofile(\"data/ref_output.bin\")\n\n# print(\"Data generated.\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.uint32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=0):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing files\")\n        return False\n    \n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output.astype(np.int32) - reference.astype(np.int32))\n    max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    return max_diff <= tolerance\n\nif __name__ == \"__main__\":\n    W = 4096\n    H = 4096\n    \n    out_file = \"data/output.bin\"\n    ref_file = \"data/ref_output.bin\"\n    \n    # Exact match expected for constant disparity\n    if compare_outputs(out_file, ref_file, W*H):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Stereo_Disparity. Compute a disparity map from two input images. The inputs are two 4096x4096 images (left and right) of type uint32. The output is a flattened disparity map of 16777216 elements (4096x4096) of type uint32. For each pixel in the left image, search over a fixed disparity range (0-16) to find the best-matching pixel in the right image by computing the sum of absolute differences of 4 color channels over a 17x17 window. The best disparity (minimum cost) must be found and incremented by 8 in the output. Thread synchronization and shared memory must be used for intermediate cost calculations.", "level2_prompt": "Task: Stereo_Disparity. For each pixel position, compare left and right images across a disparity range. Compute per-pixel costs using sum of absolute differences of 4 color channels. Aggregate costs over a fixed window around each pixel. Select the disparity with minimum aggregated cost and add 8 to it for the output map.", "level3_prompt": "Compute the stereo disparity map from two images."}
{"id": 455, "task_name": "Graph_Conv", "task_description": "Compute the Graph_Conv kernel on GPU using CUDA.", "inputs": [{"name": "x", "dtype": "float32", "shape": "(64, 8)"}, {"name": "edge_index", "dtype": "int32", "shape": "(2, 256)"}, {"name": "edge_weight", "dtype": "float32", "shape": "(256,)"}, {"name": "w", "dtype": "float32", "shape": "(8, 16)"}, {"name": "b", "dtype": "float32", "shape": "(16,)"}], "outputs": [{"name": "y_out", "dtype": "float32", "shape": "(64, 16)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\n#define N 64\n#define E 256\n#define FIN 8\n#define FOUT 16\n\nstatic inline void check_cuda(cudaError_t e, const char* msg) {\n    if (e != cudaSuccess) {\n        std::cerr << msg << \": \" << cudaGetErrorString(e) << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\n__global__ void graphconv_kernel(const float* __restrict__ X,\n                                        const int* __restrict__ edge_index,\n                                        const float* __restrict__ edge_weight,\n                                        const float* __restrict__ W,\n                                        const float* __restrict__ b,\n                                        float* __restrict__ Y) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N * FOUT;\n    if (idx >= total) return;\n\n    int i = idx / FOUT;        // dst node\n    int o = idx - i * FOUT;    // out channel\n\n    float acc = b[o];\n\n    // Y[i,o] = b[o] + sum_{k} ( sum_{e: dst(e)=i} w_e * X[src(e),k] ) * W[k,o]\n    // Expand:\n    // acc += sum_{e: dst=i} w_e * sum_{k} X[src,k] * W[k,o]\n    for (int e = 0; e < E; ++e) {\n        int s = edge_index[0 * E + e];\n        int d = edge_index[1 * E + e];\n        if (d != i) continue;\n\n        float w = edge_weight[e];\n        const float* x = X + (size_t)s * FIN;\n\n        float dot = 0.0f;\n        for (int k = 0; k < FIN; ++k) {\n            dot += x[k] * W[(size_t)k * FOUT + o];\n        }\n        acc += w * dot;\n    }\n\n    Y[(size_t)i * FOUT + o] = acc;\n}\n\nint main() {\n    const size_t x_bytes = (size_t)N * FIN * sizeof(float);\n    const size_t edge_index_bytes = (size_t)2 * E * sizeof(int);\n    const size_t edge_weight_bytes = (size_t)E * sizeof(float);\n    const size_t w_bytes = (size_t)FIN * FOUT * sizeof(float);\n    const size_t b_bytes = (size_t)FOUT * sizeof(float);\n    const size_t y_bytes = (size_t)N * FOUT * sizeof(float);\n\n    std::vector<float> h_X((size_t)N * FIN);\n    std::vector<int> h_edge_index((size_t)2 * E);\n    std::vector<float> h_edge_weight((size_t)E);\n    std::vector<float> h_W((size_t)FIN * FOUT);\n    std::vector<float> h_b((size_t)FOUT);\n    std::vector<float> h_Y((size_t)N * FOUT);\n\n    read_binary(\"data/x.bin\", h_X.data(), x_bytes);\n    read_binary(\"data/edge_index.bin\", h_edge_index.data(), edge_index_bytes);\n    read_binary(\"data/edge_weight.bin\", h_edge_weight.data(), edge_weight_bytes);\n    read_binary(\"data/w.bin\", h_W.data(), w_bytes);\n    read_binary(\"data/b.bin\", h_b.data(), b_bytes);\n\n    float *d_X = nullptr, *d_edge_weight = nullptr, *d_W = nullptr, *d_b = nullptr, *d_Y = nullptr;\n    int* d_edge_index = nullptr;\n\n    check_cuda(cudaMalloc(&d_X, x_bytes), \"cudaMalloc d_X\");\n    check_cuda(cudaMalloc(&d_edge_index, edge_index_bytes), \"cudaMalloc d_edge_index\");\n    check_cuda(cudaMalloc(&d_edge_weight, edge_weight_bytes), \"cudaMalloc d_edge_weight\");\n    check_cuda(cudaMalloc(&d_W, w_bytes), \"cudaMalloc d_W\");\n    check_cuda(cudaMalloc(&d_b, b_bytes), \"cudaMalloc d_b\");\n    check_cuda(cudaMalloc(&d_Y, y_bytes), \"cudaMalloc d_Y\");\n\n    check_cuda(cudaMemcpy(d_X, h_X.data(), x_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy X\");\n    check_cuda(cudaMemcpy(d_edge_index, h_edge_index.data(), edge_index_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_index\");\n    check_cuda(cudaMemcpy(d_edge_weight, h_edge_weight.data(), edge_weight_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_weight\");\n    check_cuda(cudaMemcpy(d_W, h_W.data(), w_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy W\");\n    check_cuda(cudaMemcpy(d_b, h_b.data(), b_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy b\");\n\n    int threads = 256;\n    int blocks = ((N * FOUT) + threads - 1) / threads;\n    graphconv_kernel<<<blocks, threads>>>(d_X, d_edge_index, d_edge_weight, d_W, d_b, d_Y);\n    check_cuda(cudaGetLastError(), \"graphconv_single_kernel launch\");\n    check_cuda(cudaDeviceSynchronize(), \"cudaDeviceSynchronize\");\n\n    check_cuda(cudaMemcpy(h_Y.data(), d_Y, y_bytes, cudaMemcpyDeviceToHost), \"cudaMemcpy Y\");\n    write_binary(\"data/y_out.bin\", h_Y.data(), y_bytes);\n\n    cudaFree(d_X);\n    cudaFree(d_edge_index);\n    cudaFree(d_edge_weight);\n    cudaFree(d_W);\n    cudaFree(d_b);\n    cudaFree(d_Y);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 64\nE = 256\nFIN = 8\nFOUT = 16\n\nnp.random.seed(42)\n\nX = (np.random.randn(N, FIN)).astype(np.float32)\nW = (np.random.randn(FIN, FOUT) * 10).astype(np.float32)\nb = (np.random.randn(FOUT) * 0.1).astype(np.float32)\n\nsrc = np.random.randint(0, N, size=E, dtype=np.int32)\ndst = np.random.randint(0, N, size=E, dtype=np.int32)\n\nedge_index = np.stack([src, dst], axis=0).astype(np.int32)\nedge_weight = (np.random.rand(E).astype(np.float32) * 2.0 - 1.0)\n\nagg = np.zeros((N, FIN), dtype=np.float32)\nfor e in range(E):\n    s = int(src[e])\n    d = int(dst[e])\n    w = edge_weight[e]\n    agg[d, :] += w * X[s, :]\n\nY = agg @ W + b\n\nX.tofile(\"data/x.bin\")\nedge_index.tofile(\"data/edge_index.bin\")\nedge_weight.tofile(\"data/edge_weight.bin\")\nW.tofile(\"data/w.bin\")\nb.tofile(\"data/b.bin\")\nY.astype(np.float32).tofile(\"data/y_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 64\nFOUT = 16\nSIZE = N * FOUT\n\nout_path = \"data/y_out.bin\"\nref_path = \"data/y_ref.bin\"\n\nif (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n    print(\"F\")\n    raise SystemExit(0)\n\ny_out = np.fromfile(out_path, dtype=np.float32, count=SIZE)\ny_ref = np.fromfile(ref_path, dtype=np.float32, count=SIZE)\n\nif y_out.shape != y_ref.shape:\n    print(\"F\")\n    raise SystemExit(0)\n\ndiff = np.abs(y_out - y_ref)\nok = np.all(diff <= 1e-2)\n\nprint(\"T\" if ok else \"F\")\n", "level1_prompt": "Implement a Graph Convolution kernel for a graph with 64 nodes and 256 edges. The kernel should compute output node features by aggregating messages from neighbor nodes. Inputs include: node features (64x8 float32), edge connections (2x256 int32), edge weights (256 float32), weight matrix (8x16 float32), and bias vector (16 float32). The output is a 64x16 float32 tensor. For each node, aggregate incoming edges by weighting source node features, apply linear transformation using the weight matrix, add bias, and store results.", "level2_prompt": "Perform graph convolution operation. For each node i and output channel o: initialize with bias b[o]. For each edge where destination is i, compute dot product between source node features and the o-th column of weight matrix W. Multiply by edge weight and accumulate. Output shape is 64x16.", "level3_prompt": "Compute the Graph_Conv kernel on GPU using CUDA."}
{"id": 456, "task_name": "Graph_Conv", "task_description": "Compute the Graph_Conv kernel on GPU using CUDA.", "inputs": [{"name": "x", "dtype": "float32", "shape": "(128, 16)"}, {"name": "edge_index", "dtype": "int32", "shape": "(2, 1024)"}, {"name": "edge_weight", "dtype": "float32", "shape": "(1024,)"}, {"name": "w", "dtype": "float32", "shape": "(16, 16)"}, {"name": "b", "dtype": "float32", "shape": "(16,)"}], "outputs": [{"name": "y_out", "dtype": "float32", "shape": "(2048,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\n#define N 128\n#define E 1024\n#define FIN 16\n#define FOUT 16\n\nstatic inline void check_cuda(cudaError_t e, const char* msg) {\n    if (e != cudaSuccess) {\n        std::cerr << msg << \": \" << cudaGetErrorString(e) << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\n__global__ void graphconv_kernel(const float* __restrict__ X,\n                                        const int* __restrict__ edge_index,\n                                        const float* __restrict__ edge_weight,\n                                        const float* __restrict__ W,\n                                        const float* __restrict__ b,\n                                        float* __restrict__ Y) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N * FOUT;\n    if (idx >= total) return;\n\n    int i = idx / FOUT;        // dst node\n    int o = idx - i * FOUT;    // out channel\n\n    float acc = b[o];\n\n    // Y[i,o] = b[o] + sum_{k} ( sum_{e: dst(e)=i} w_e * X[src(e),k] ) * W[k,o]\n    // Expand:\n    // acc += sum_{e: dst=i} w_e * sum_{k} X[src,k] * W[k,o]\n    for (int e = 0; e < E; ++e) {\n        int s = edge_index[0 * E + e];\n        int d = edge_index[1 * E + e];\n        if (d != i) continue;\n\n        float w = edge_weight[e];\n        const float* x = X + (size_t)s * FIN;\n\n        float dot = 0.0f;\n        for (int k = 0; k < FIN; ++k) {\n            dot += x[k] * W[(size_t)k * FOUT + o];\n        }\n        acc += w * dot;\n    }\n\n    Y[(size_t)i * FOUT + o] = acc;\n}\n\nint main() {\n    const size_t x_bytes = (size_t)N * FIN * sizeof(float);\n    const size_t edge_index_bytes = (size_t)2 * E * sizeof(int);\n    const size_t edge_weight_bytes = (size_t)E * sizeof(float);\n    const size_t w_bytes = (size_t)FIN * FOUT * sizeof(float);\n    const size_t b_bytes = (size_t)FOUT * sizeof(float);\n    const size_t y_bytes = (size_t)N * FOUT * sizeof(float);\n\n    std::vector<float> h_X((size_t)N * FIN);\n    std::vector<int> h_edge_index((size_t)2 * E);\n    std::vector<float> h_edge_weight((size_t)E);\n    std::vector<float> h_W((size_t)FIN * FOUT);\n    std::vector<float> h_b((size_t)FOUT);\n    std::vector<float> h_Y((size_t)N * FOUT);\n\n    read_binary(\"data/x.bin\", h_X.data(), x_bytes);\n    read_binary(\"data/edge_index.bin\", h_edge_index.data(), edge_index_bytes);\n    read_binary(\"data/edge_weight.bin\", h_edge_weight.data(), edge_weight_bytes);\n    read_binary(\"data/w.bin\", h_W.data(), w_bytes);\n    read_binary(\"data/b.bin\", h_b.data(), b_bytes);\n\n    float *d_X = nullptr, *d_edge_weight = nullptr, *d_W = nullptr, *d_b = nullptr, *d_Y = nullptr;\n    int* d_edge_index = nullptr;\n\n    check_cuda(cudaMalloc(&d_X, x_bytes), \"cudaMalloc d_X\");\n    check_cuda(cudaMalloc(&d_edge_index, edge_index_bytes), \"cudaMalloc d_edge_index\");\n    check_cuda(cudaMalloc(&d_edge_weight, edge_weight_bytes), \"cudaMalloc d_edge_weight\");\n    check_cuda(cudaMalloc(&d_W, w_bytes), \"cudaMalloc d_W\");\n    check_cuda(cudaMalloc(&d_b, b_bytes), \"cudaMalloc d_b\");\n    check_cuda(cudaMalloc(&d_Y, y_bytes), \"cudaMalloc d_Y\");\n\n    check_cuda(cudaMemcpy(d_X, h_X.data(), x_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy X\");\n    check_cuda(cudaMemcpy(d_edge_index, h_edge_index.data(), edge_index_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_index\");\n    check_cuda(cudaMemcpy(d_edge_weight, h_edge_weight.data(), edge_weight_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_weight\");\n    check_cuda(cudaMemcpy(d_W, h_W.data(), w_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy W\");\n    check_cuda(cudaMemcpy(d_b, h_b.data(), b_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy b\");\n\n    int threads = 256;\n    int blocks = ((N * FOUT) + threads - 1) / threads;\n    graphconv_kernel<<<blocks, threads>>>(d_X, d_edge_index, d_edge_weight, d_W, d_b, d_Y);\n    check_cuda(cudaGetLastError(), \"graphconv_single_kernel launch\");\n    check_cuda(cudaDeviceSynchronize(), \"cudaDeviceSynchronize\");\n\n    check_cuda(cudaMemcpy(h_Y.data(), d_Y, y_bytes, cudaMemcpyDeviceToHost), \"cudaMemcpy Y\");\n    write_binary(\"data/y_out.bin\", h_Y.data(), y_bytes);\n\n    cudaFree(d_X);\n    cudaFree(d_edge_index);\n    cudaFree(d_edge_weight);\n    cudaFree(d_W);\n    cudaFree(d_b);\n    cudaFree(d_Y);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 128\nE = 1024\nFIN = 16\nFOUT = 16\n\nnp.random.seed(42)\n\nX = (np.random.randn(N, FIN)).astype(np.float32)\nW = (np.random.randn(FIN, FOUT) * 10).astype(np.float32)\nb = (np.random.randn(FOUT) * 0.1).astype(np.float32)\n\nsrc = np.random.randint(0, N, size=E, dtype=np.int32)\ndst = np.random.randint(0, N, size=E, dtype=np.int32)\n\nedge_index = np.stack([src, dst], axis=0).astype(np.int32)\nedge_weight = (np.random.rand(E).astype(np.float32) * 2.0 - 1.0)\n\nagg = np.zeros((N, FIN), dtype=np.float32)\nfor e in range(E):\n    s = int(src[e])\n    d = int(dst[e])\n    w = edge_weight[e]\n    agg[d, :] += w * X[s, :]\n\nY = agg @ W + b\n\nX.tofile(\"data/x.bin\")\nedge_index.tofile(\"data/edge_index.bin\")\nedge_weight.tofile(\"data/edge_weight.bin\")\nW.tofile(\"data/w.bin\")\nb.tofile(\"data/b.bin\")\nY.astype(np.float32).tofile(\"data/y_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 128\nFOUT = 16\nSIZE = N * FOUT\n\nout_path = \"data/y_out.bin\"\nref_path = \"data/y_ref.bin\"\n\nif (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n    print(\"F\")\n    raise SystemExit(0)\n\ny_out = np.fromfile(out_path, dtype=np.float32, count=SIZE)\ny_ref = np.fromfile(ref_path, dtype=np.float32, count=SIZE)\n\nif y_out.shape != y_ref.shape:\n    print(\"F\")\n    raise SystemExit(0)\n\ndiff = np.abs(y_out - y_ref)\nok = np.all(diff <= 1e-2)\n\nprint(\"T\" if ok else \"F\")\n", "level1_prompt": "Implement the Graph_Conv kernel. The kernel computes a graph convolution operation with 128 nodes and 1024 edges. Input tensor 'x' contains node features as float32 values in a (128, 16) shape. 'edge_index' provides directed edge connections as int32 indices in (2, 1024) shape where row 0 contains source nodes and row 1 contains destination nodes. 'edge_weight' contains float32 weights for each edge in (1024,) shape. Weight matrix 'w' is a float32 tensor of shape (16, 16), and bias 'b' is a float32 tensor of shape (16,). The output tensor 'y_out' must be a flattened float32 vector of 2048 elements (128 nodes × 16 features). The kernel must compute each output feature by: starting with the bias term, then for each incoming edge to a node, multiply the edge weight by the dot product between the source node's features and the corresponding weight matrix column.", "level2_prompt": "Graph_Conv computes a node feature transformation using graph connectivity. For each node and output feature: initialize with the bias value, then for every incoming edge, compute the dot product between the source node's features and the weight matrix column for that output feature, multiply by the edge weight, and accumulate. This transforms input features through neighborhood aggregation.", "level3_prompt": "Compute the Graph_Conv kernel for graph-structured data."}
{"id": 457, "task_name": "Graph_Conv", "task_description": "Compute the Graph_Conv kernel on GPU using CUDA.", "inputs": [{"name": "x", "dtype": "float32", "shape": "(256, 32)"}, {"name": "edge_index", "dtype": "int32", "shape": "(2, 4096)"}, {"name": "edge_weight", "dtype": "float32", "shape": "(4096,)"}, {"name": "w", "dtype": "float32", "shape": "(32, 32)"}, {"name": "b", "dtype": "float32", "shape": "(32,)"}], "outputs": [{"name": "y_out", "dtype": "float32", "shape": "(256, 32)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\n#define N 256\n#define E 4096\n#define FIN 32\n#define FOUT 32\n\nstatic inline void check_cuda(cudaError_t e, const char* msg) {\n    if (e != cudaSuccess) {\n        std::cerr << msg << \": \" << cudaGetErrorString(e) << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\n__global__ void graphconv_kernel(const float* __restrict__ X,\n                                        const int* __restrict__ edge_index,\n                                        const float* __restrict__ edge_weight,\n                                        const float* __restrict__ W,\n                                        const float* __restrict__ b,\n                                        float* __restrict__ Y) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N * FOUT;\n    if (idx >= total) return;\n\n    int i = idx / FOUT;        // dst node\n    int o = idx - i * FOUT;    // out channel\n\n    float acc = b[o];\n\n    // Y[i,o] = b[o] + sum_{k} ( sum_{e: dst(e)=i} w_e * X[src(e),k] ) * W[k,o]\n    // Expand:\n    // acc += sum_{e: dst=i} w_e * sum_{k} X[src,k] * W[k,o]\n    for (int e = 0; e < E; ++e) {\n        int s = edge_index[0 * E + e];\n        int d = edge_index[1 * E + e];\n        if (d != i) continue;\n\n        float w = edge_weight[e];\n        const float* x = X + (size_t)s * FIN;\n\n        float dot = 0.0f;\n        for (int k = 0; k < FIN; ++k) {\n            dot += x[k] * W[(size_t)k * FOUT + o];\n        }\n        acc += w * dot;\n    }\n\n    Y[(size_t)i * FOUT + o] = acc;\n}\n\nint main() {\n    const size_t x_bytes = (size_t)N * FIN * sizeof(float);\n    const size_t edge_index_bytes = (size_t)2 * E * sizeof(int);\n    const size_t edge_weight_bytes = (size_t)E * sizeof(float);\n    const size_t w_bytes = (size_t)FIN * FOUT * sizeof(float);\n    const size_t b_bytes = (size_t)FOUT * sizeof(float);\n    const size_t y_bytes = (size_t)N * FOUT * sizeof(float);\n\n    std::vector<float> h_X((size_t)N * FIN);\n    std::vector<int> h_edge_index((size_t)2 * E);\n    std::vector<float> h_edge_weight((size_t)E);\n    std::vector<float> h_W((size_t)FIN * FOUT);\n    std::vector<float> h_b((size_t)FOUT);\n    std::vector<float> h_Y((size_t)N * FOUT);\n\n    read_binary(\"data/x.bin\", h_X.data(), x_bytes);\n    read_binary(\"data/edge_index.bin\", h_edge_index.data(), edge_index_bytes);\n    read_binary(\"data/edge_weight.bin\", h_edge_weight.data(), edge_weight_bytes);\n    read_binary(\"data/w.bin\", h_W.data(), w_bytes);\n    read_binary(\"data/b.bin\", h_b.data(), b_bytes);\n\n    float *d_X = nullptr, *d_edge_weight = nullptr, *d_W = nullptr, *d_b = nullptr, *d_Y = nullptr;\n    int* d_edge_index = nullptr;\n\n    check_cuda(cudaMalloc(&d_X, x_bytes), \"cudaMalloc d_X\");\n    check_cuda(cudaMalloc(&d_edge_index, edge_index_bytes), \"cudaMalloc d_edge_index\");\n    check_cuda(cudaMalloc(&d_edge_weight, edge_weight_bytes), \"cudaMalloc d_edge_weight\");\n    check_cuda(cudaMalloc(&d_W, w_bytes), \"cudaMalloc d_W\");\n    check_cuda(cudaMalloc(&d_b, b_bytes), \"cudaMalloc d_b\");\n    check_cuda(cudaMalloc(&d_Y, y_bytes), \"cudaMalloc d_Y\");\n\n    check_cuda(cudaMemcpy(d_X, h_X.data(), x_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy X\");\n    check_cuda(cudaMemcpy(d_edge_index, h_edge_index.data(), edge_index_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_index\");\n    check_cuda(cudaMemcpy(d_edge_weight, h_edge_weight.data(), edge_weight_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_weight\");\n    check_cuda(cudaMemcpy(d_W, h_W.data(), w_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy W\");\n    check_cuda(cudaMemcpy(d_b, h_b.data(), b_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy b\");\n\n    int threads = 256;\n    int blocks = ((N * FOUT) + threads - 1) / threads;\n    graphconv_kernel<<<blocks, threads>>>(d_X, d_edge_index, d_edge_weight, d_W, d_b, d_Y);\n    check_cuda(cudaGetLastError(), \"graphconv_single_kernel launch\");\n    check_cuda(cudaDeviceSynchronize(), \"cudaDeviceSynchronize\");\n\n    check_cuda(cudaMemcpy(h_Y.data(), d_Y, y_bytes, cudaMemcpyDeviceToHost), \"cudaMemcpy Y\");\n    write_binary(\"data/y_out.bin\", h_Y.data(), y_bytes);\n\n    cudaFree(d_X);\n    cudaFree(d_edge_index);\n    cudaFree(d_edge_weight);\n    cudaFree(d_W);\n    cudaFree(d_b);\n    cudaFree(d_Y);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 256\nE = 4096\nFIN = 32\nFOUT = 32\n\nnp.random.seed(42)\n\nX = (np.random.randn(N, FIN)).astype(np.float32)\nW = (np.random.randn(FIN, FOUT) * 10).astype(np.float32)\nb = (np.random.randn(FOUT) * 0.1).astype(np.float32)\n\nsrc = np.random.randint(0, N, size=E, dtype=np.int32)\ndst = np.random.randint(0, N, size=E, dtype=np.int32)\n\nedge_index = np.stack([src, dst], axis=0).astype(np.int32)\nedge_weight = (np.random.rand(E).astype(np.float32) * 2.0 - 1.0)\n\nagg = np.zeros((N, FIN), dtype=np.float32)\nfor e in range(E):\n    s = int(src[e])\n    d = int(dst[e])\n    w = edge_weight[e]\n    agg[d, :] += w * X[s, :]\n\nY = agg @ W + b\n\nX.tofile(\"data/x.bin\")\nedge_index.tofile(\"data/edge_index.bin\")\nedge_weight.tofile(\"data/edge_weight.bin\")\nW.tofile(\"data/w.bin\")\nb.tofile(\"data/b.bin\")\nY.astype(np.float32).tofile(\"data/y_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 256\nFOUT = 32\nSIZE = N * FOUT\n\nout_path = \"data/y_out.bin\"\nref_path = \"data/y_ref.bin\"\n\nif (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n    print(\"F\")\n    raise SystemExit(0)\n\ny_out = np.fromfile(out_path, dtype=np.float32, count=SIZE)\ny_ref = np.fromfile(ref_path, dtype=np.float32, count=SIZE)\n\nif y_out.shape != y_ref.shape:\n    print(\"F\")\n    raise SystemExit(0)\n\ndiff = np.abs(y_out - y_ref)\nok = np.all(diff <= 1e-2)\n\nprint(\"T\" if ok else \"F\")\n", "level1_prompt": "Task name: Graph_Conv. Implement a graph convolution kernel that updates node features based on incoming edges. Inputs: x (float32, 256 nodes × 32 features), edge_index (int32, 2×4096 edges with [source, destination] pairs), edge_weight (float32, 4096 edge weights), w (float32, 32×32 weight matrix), b (float32, 32-element bias vector). Output: y_out (float32, 256×32 updated node features). For each node i and output feature o: initialize with bias b[o]; then for each incoming edge where destination = i, compute dot product between source node's features and w's o-th column, multiply by edge weight, and accumulate. Must handle exactly 256 nodes, 4096 edges, and 32 features.", "level2_prompt": "Graph_Conv: For each node i (0-255) and output feature o (0-31): y[i,o] = b[o] + ∑ₑ (edge_weight[e] × (∑ₖ x[s,k] × w[k,o])), where e iterates over edges with destination i, s is the source node of edge e, and k sums over input features (0-31).", "level3_prompt": "Compute the Graph_Conv kernel on GPU using CUDA."}
{"id": 458, "task_name": "Graph_Conv", "task_description": "Compute the Graph_Conv kernel on GPU using CUDA.", "inputs": [{"name": "x", "dtype": "float32", "shape": "(512, 64)"}, {"name": "edge_index", "dtype": "int32", "shape": "(2, 16384)"}, {"name": "edge_weight", "dtype": "float32", "shape": "(16384,)"}, {"name": "w", "dtype": "float32", "shape": "(64, 32)"}, {"name": "b", "dtype": "float32", "shape": "(32,)"}], "outputs": [{"name": "y_out", "dtype": "float32", "shape": "(512, 32)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\n#define N 512\n#define E 16384\n#define FIN 64\n#define FOUT 32\n\nstatic inline void check_cuda(cudaError_t e, const char* msg) {\n    if (e != cudaSuccess) {\n        std::cerr << msg << \": \" << cudaGetErrorString(e) << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\n__global__ void graphconv_kernel(const float* __restrict__ X,\n                                        const int* __restrict__ edge_index,\n                                        const float* __restrict__ edge_weight,\n                                        const float* __restrict__ W,\n                                        const float* __restrict__ b,\n                                        float* __restrict__ Y) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N * FOUT;\n    if (idx >= total) return;\n\n    int i = idx / FOUT;        // dst node\n    int o = idx - i * FOUT;    // out channel\n\n    float acc = b[o];\n\n    // Y[i,o] = b[o] + sum_{k} ( sum_{e: dst(e)=i} w_e * X[src(e),k] ) * W[k,o]\n    // Expand:\n    // acc += sum_{e: dst=i} w_e * sum_{k} X[src,k] * W[k,o]\n    for (int e = 0; e < E; ++e) {\n        int s = edge_index[0 * E + e];\n        int d = edge_index[1 * E + e];\n        if (d != i) continue;\n\n        float w = edge_weight[e];\n        const float* x = X + (size_t)s * FIN;\n\n        float dot = 0.0f;\n        for (int k = 0; k < FIN; ++k) {\n            dot += x[k] * W[(size_t)k * FOUT + o];\n        }\n        acc += w * dot;\n    }\n\n    Y[(size_t)i * FOUT + o] = acc;\n}\n\nint main() {\n    const size_t x_bytes = (size_t)N * FIN * sizeof(float);\n    const size_t edge_index_bytes = (size_t)2 * E * sizeof(int);\n    const size_t edge_weight_bytes = (size_t)E * sizeof(float);\n    const size_t w_bytes = (size_t)FIN * FOUT * sizeof(float);\n    const size_t b_bytes = (size_t)FOUT * sizeof(float);\n    const size_t y_bytes = (size_t)N * FOUT * sizeof(float);\n\n    std::vector<float> h_X((size_t)N * FIN);\n    std::vector<int> h_edge_index((size_t)2 * E);\n    std::vector<float> h_edge_weight((size_t)E);\n    std::vector<float> h_W((size_t)FIN * FOUT);\n    std::vector<float> h_b((size_t)FOUT);\n    std::vector<float> h_Y((size_t)N * FOUT);\n\n    read_binary(\"data/x.bin\", h_X.data(), x_bytes);\n    read_binary(\"data/edge_index.bin\", h_edge_index.data(), edge_index_bytes);\n    read_binary(\"data/edge_weight.bin\", h_edge_weight.data(), edge_weight_bytes);\n    read_binary(\"data/w.bin\", h_W.data(), w_bytes);\n    read_binary(\"data/b.bin\", h_b.data(), b_bytes);\n\n    float *d_X = nullptr, *d_edge_weight = nullptr, *d_W = nullptr, *d_b = nullptr, *d_Y = nullptr;\n    int* d_edge_index = nullptr;\n\n    check_cuda(cudaMalloc(&d_X, x_bytes), \"cudaMalloc d_X\");\n    check_cuda(cudaMalloc(&d_edge_index, edge_index_bytes), \"cudaMalloc d_edge_index\");\n    check_cuda(cudaMalloc(&d_edge_weight, edge_weight_bytes), \"cudaMalloc d_edge_weight\");\n    check_cuda(cudaMalloc(&d_W, w_bytes), \"cudaMalloc d_W\");\n    check_cuda(cudaMalloc(&d_b, b_bytes), \"cudaMalloc d_b\");\n    check_cuda(cudaMalloc(&d_Y, y_bytes), \"cudaMalloc d_Y\");\n\n    check_cuda(cudaMemcpy(d_X, h_X.data(), x_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy X\");\n    check_cuda(cudaMemcpy(d_edge_index, h_edge_index.data(), edge_index_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_index\");\n    check_cuda(cudaMemcpy(d_edge_weight, h_edge_weight.data(), edge_weight_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_weight\");\n    check_cuda(cudaMemcpy(d_W, h_W.data(), w_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy W\");\n    check_cuda(cudaMemcpy(d_b, h_b.data(), b_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy b\");\n\n    int threads = 256;\n    int blocks = ((N * FOUT) + threads - 1) / threads;\n    graphconv_kernel<<<blocks, threads>>>(d_X, d_edge_index, d_edge_weight, d_W, d_b, d_Y);\n    check_cuda(cudaGetLastError(), \"graphconv_single_kernel launch\");\n    check_cuda(cudaDeviceSynchronize(), \"cudaDeviceSynchronize\");\n\n    check_cuda(cudaMemcpy(h_Y.data(), d_Y, y_bytes, cudaMemcpyDeviceToHost), \"cudaMemcpy Y\");\n    write_binary(\"data/y_out.bin\", h_Y.data(), y_bytes);\n\n    cudaFree(d_X);\n    cudaFree(d_edge_index);\n    cudaFree(d_edge_weight);\n    cudaFree(d_W);\n    cudaFree(d_b);\n    cudaFree(d_Y);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 512\nE = 16384\nFIN = 64\nFOUT = 32\n\nnp.random.seed(42)\n\nX = (np.random.randn(N, FIN)).astype(np.float32)\nW = (np.random.randn(FIN, FOUT) * 10).astype(np.float32)\nb = (np.random.randn(FOUT) * 0.1).astype(np.float32)\n\nsrc = np.random.randint(0, N, size=E, dtype=np.int32)\ndst = np.random.randint(0, N, size=E, dtype=np.int32)\n\nedge_index = np.stack([src, dst], axis=0).astype(np.int32)\nedge_weight = (np.random.rand(E).astype(np.float32) * 2.0 - 1.0)\n\nagg = np.zeros((N, FIN), dtype=np.float32)\nfor e in range(E):\n    s = int(src[e])\n    d = int(dst[e])\n    w = edge_weight[e]\n    agg[d, :] += w * X[s, :]\n\nY = agg @ W + b\n\nX.tofile(\"data/x.bin\")\nedge_index.tofile(\"data/edge_index.bin\")\nedge_weight.tofile(\"data/edge_weight.bin\")\nW.tofile(\"data/w.bin\")\nb.tofile(\"data/b.bin\")\nY.astype(np.float32).tofile(\"data/y_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 512\nFOUT = 32\nSIZE = N * FOUT\n\nout_path = \"data/y_out.bin\"\nref_path = \"data/y_ref.bin\"\n\nif (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n    print(\"F\")\n    raise SystemExit(0)\n\ny_out = np.fromfile(out_path, dtype=np.float32, count=SIZE)\ny_ref = np.fromfile(ref_path, dtype=np.float32, count=SIZE)\n\nif y_out.shape != y_ref.shape:\n    print(\"F\")\n    raise SystemExit(0)\n\ndiff = np.abs(y_out - y_ref)\nok = np.all(diff <= 1e-2)\n\nprint(\"T\" if ok else \"F\")\n", "level1_prompt": "Task: Graph Convolution. Compute the output feature matrix for each node by aggregating weighted messages from its neighbors. Inputs include: x (node features, shape (512, 64), dtype float32), edge_index (edge list with source and destination indices, shape (2, 16384), dtype int32), edge_weight (edge weights, shape (16384,), dtype float32), w (weight matrix, shape (64, 32), dtype float32), and b (bias vector, shape (32,), dtype float32). Output: y_out (output features, shape (512, 32), dtype float32). Constraints: The graph has 512 nodes and 16384 edges; features transition from 64 to 32 dimensions; each node's output is computed by summing contributions only from edges where it is the destination node, starting with the bias term.", "level2_prompt": "Task: Graph Convolution. For each node i and output channel o, initialize the output to the bias term b[o]. Then, for each edge where the destination node is i, add the product of the edge weight and the dot product between the source node's feature vector and the corresponding column of the weight matrix w.", "level3_prompt": "Compute the graph convolution operation for node features and edge weights."}
{"id": 459, "task_name": "Graph_Conv", "task_description": "Compute the Graph_Conv kernel on GPU using CUDA.", "inputs": [{"name": "x", "dtype": "float32", "shape": "(1024, 64)"}, {"name": "edge_index", "dtype": "int32", "shape": "(2, 65536)"}, {"name": "edge_weight", "dtype": "float32", "shape": "(65536,)"}, {"name": "w", "dtype": "float32", "shape": "(64, 64)"}, {"name": "b", "dtype": "float32", "shape": "(64,)"}], "outputs": [{"name": "y_out", "dtype": "float32", "shape": "(65536,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n\n#define N 1024\n#define E 65536\n#define FIN 64\n#define FOUT 64\n\nstatic inline void check_cuda(cudaError_t e, const char* msg) {\n    if (e != cudaSuccess) {\n        std::cerr << msg << \": \" << cudaGetErrorString(e) << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\n__global__ void graphconv_kernel(const float* __restrict__ X,\n                                        const int* __restrict__ edge_index,\n                                        const float* __restrict__ edge_weight,\n                                        const float* __restrict__ W,\n                                        const float* __restrict__ b,\n                                        float* __restrict__ Y) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N * FOUT;\n    if (idx >= total) return;\n\n    int i = idx / FOUT;        // dst node\n    int o = idx - i * FOUT;    // out channel\n\n    float acc = b[o];\n\n    // Y[i,o] = b[o] + sum_{k} ( sum_{e: dst(e)=i} w_e * X[src(e),k] ) * W[k,o]\n    // Expand:\n    // acc += sum_{e: dst=i} w_e * sum_{k} X[src,k] * W[k,o]\n    for (int e = 0; e < E; ++e) {\n        int s = edge_index[0 * E + e];\n        int d = edge_index[1 * E + e];\n        if (d != i) continue;\n\n        float w = edge_weight[e];\n        const float* x = X + (size_t)s * FIN;\n\n        float dot = 0.0f;\n        for (int k = 0; k < FIN; ++k) {\n            dot += x[k] * W[(size_t)k * FOUT + o];\n        }\n        acc += w * dot;\n    }\n\n    Y[(size_t)i * FOUT + o] = acc;\n}\n\nint main() {\n    const size_t x_bytes = (size_t)N * FIN * sizeof(float);\n    const size_t edge_index_bytes = (size_t)2 * E * sizeof(int);\n    const size_t edge_weight_bytes = (size_t)E * sizeof(float);\n    const size_t w_bytes = (size_t)FIN * FOUT * sizeof(float);\n    const size_t b_bytes = (size_t)FOUT * sizeof(float);\n    const size_t y_bytes = (size_t)N * FOUT * sizeof(float);\n\n    std::vector<float> h_X((size_t)N * FIN);\n    std::vector<int> h_edge_index((size_t)2 * E);\n    std::vector<float> h_edge_weight((size_t)E);\n    std::vector<float> h_W((size_t)FIN * FOUT);\n    std::vector<float> h_b((size_t)FOUT);\n    std::vector<float> h_Y((size_t)N * FOUT);\n\n    read_binary(\"data/x.bin\", h_X.data(), x_bytes);\n    read_binary(\"data/edge_index.bin\", h_edge_index.data(), edge_index_bytes);\n    read_binary(\"data/edge_weight.bin\", h_edge_weight.data(), edge_weight_bytes);\n    read_binary(\"data/w.bin\", h_W.data(), w_bytes);\n    read_binary(\"data/b.bin\", h_b.data(), b_bytes);\n\n    float *d_X = nullptr, *d_edge_weight = nullptr, *d_W = nullptr, *d_b = nullptr, *d_Y = nullptr;\n    int* d_edge_index = nullptr;\n\n    check_cuda(cudaMalloc(&d_X, x_bytes), \"cudaMalloc d_X\");\n    check_cuda(cudaMalloc(&d_edge_index, edge_index_bytes), \"cudaMalloc d_edge_index\");\n    check_cuda(cudaMalloc(&d_edge_weight, edge_weight_bytes), \"cudaMalloc d_edge_weight\");\n    check_cuda(cudaMalloc(&d_W, w_bytes), \"cudaMalloc d_W\");\n    check_cuda(cudaMalloc(&d_b, b_bytes), \"cudaMalloc d_b\");\n    check_cuda(cudaMalloc(&d_Y, y_bytes), \"cudaMalloc d_Y\");\n\n    check_cuda(cudaMemcpy(d_X, h_X.data(), x_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy X\");\n    check_cuda(cudaMemcpy(d_edge_index, h_edge_index.data(), edge_index_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_index\");\n    check_cuda(cudaMemcpy(d_edge_weight, h_edge_weight.data(), edge_weight_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy edge_weight\");\n    check_cuda(cudaMemcpy(d_W, h_W.data(), w_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy W\");\n    check_cuda(cudaMemcpy(d_b, h_b.data(), b_bytes, cudaMemcpyHostToDevice), \"cudaMemcpy b\");\n\n    int threads = 256;\n    int blocks = ((N * FOUT) + threads - 1) / threads;\n    graphconv_kernel<<<blocks, threads>>>(d_X, d_edge_index, d_edge_weight, d_W, d_b, d_Y);\n    check_cuda(cudaGetLastError(), \"graphconv_single_kernel launch\");\n    check_cuda(cudaDeviceSynchronize(), \"cudaDeviceSynchronize\");\n\n    check_cuda(cudaMemcpy(h_Y.data(), d_Y, y_bytes, cudaMemcpyDeviceToHost), \"cudaMemcpy Y\");\n    write_binary(\"data/y_out.bin\", h_Y.data(), y_bytes);\n\n    cudaFree(d_X);\n    cudaFree(d_edge_index);\n    cudaFree(d_edge_weight);\n    cudaFree(d_W);\n    cudaFree(d_b);\n    cudaFree(d_Y);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nN = 1024\nE = 65536\nFIN = 64\nFOUT = 64\n\nnp.random.seed(42)\n\nX = (np.random.randn(N, FIN)).astype(np.float32)\nW = (np.random.randn(FIN, FOUT) * 10).astype(np.float32)\nb = (np.random.randn(FOUT) * 0.1).astype(np.float32)\n\nsrc = np.random.randint(0, N, size=E, dtype=np.int32)\ndst = np.random.randint(0, N, size=E, dtype=np.int32)\n\nedge_index = np.stack([src, dst], axis=0).astype(np.int32)\nedge_weight = (np.random.rand(E).astype(np.float32) * 2.0 - 1.0)\n\nagg = np.zeros((N, FIN), dtype=np.float32)\nfor e in range(E):\n    s = int(src[e])\n    d = int(dst[e])\n    w = edge_weight[e]\n    agg[d, :] += w * X[s, :]\n\nY = agg @ W + b\n\nX.tofile(\"data/x.bin\")\nedge_index.tofile(\"data/edge_index.bin\")\nedge_weight.tofile(\"data/edge_weight.bin\")\nW.tofile(\"data/w.bin\")\nb.tofile(\"data/b.bin\")\nY.astype(np.float32).tofile(\"data/y_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\nN = 1024\nFOUT = 64\nSIZE = N * FOUT\n\nout_path = \"data/y_out.bin\"\nref_path = \"data/y_ref.bin\"\n\nif (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n    print(\"F\")\n    raise SystemExit(0)\n\ny_out = np.fromfile(out_path, dtype=np.float32, count=SIZE)\ny_ref = np.fromfile(ref_path, dtype=np.float32, count=SIZE)\n\nif y_out.shape != y_ref.shape:\n    print(\"F\")\n    raise SystemExit(0)\n\ndiff = np.abs(y_out - y_ref)\nok = np.all(diff <= 1e-2)\n\nprint(\"T\" if ok else \"F\")\n", "level1_prompt": "Task: Graph_Conv. Compute a graph convolution operation where each node's features are updated by aggregating weighted features from its neighbors. Inputs include: node features tensor 'x' (1024 nodes × 64 features, float32), edge connection tensor 'edge_index' (2 × 65536 edges, int32, with row0 as source nodes and row1 as destination nodes), edge weights tensor 'edge_weight' (65536 weights, float32), weight matrix 'w' (64 input features × 64 output features, float32), and bias vector 'b' (64 elements, float32). Output is a flattened tensor 'y_out' (65536 elements, float32) representing updated node features (1024 × 64). Constraints: For each node and output feature, accumulate bias term plus weighted sum of dot products between neighbor features and weight matrix columns. Must handle all 65536 edges and 1024 nodes.", "level2_prompt": "Task: Graph_Conv. For each destination node i and output feature o: initialize result with bias term b[o]. For every edge e where destination node equals i: compute dot product between source node's feature vector and o-th column of weight matrix w. Multiply dot product by edge_weight[e] and add to result. Store final result for node i and feature o in output array.", "level3_prompt": "Compute graph convolution operation for node feature transformation using neighbor aggregation."}
{"id": 460, "task_name": "DB4_Wavelet_Transform", "task_description": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA.", "inputs": [{"name": "in", "dtype": "float32", "shape": "(1024,)"}, {"name": "lo", "dtype": "float32", "shape": "(4,)"}, {"name": "hi", "dtype": "float32", "shape": "(4,)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(1024,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n__global__ void k_db4Wavelet(const float* input_d, float* output_d, int numSamples,\n                             const float* db4LoFilter_d, const float* db4HiFilter_d) {\n    int t = blockIdx.x * blockDim.x + threadIdx.x;\n    int half = numSamples >> 1;\n    if (t >= half) return;\n\n    int base = t << 1;\n\n    extern __shared__ float sh[];\n    float* shIn = sh;\n\n    int i0 = base + 0;\n    int i1 = base + 1;\n    int i2 = base + 2;\n    int i3 = base + 3;\n\n    if (i0 >= numSamples) i0 = numSamples - 1;\n    if (i1 >= numSamples) i1 = numSamples - 1;\n    if (i2 >= numSamples) i2 = numSamples - 1;\n    if (i3 >= numSamples) i3 = numSamples - 1;\n\n    int lane = threadIdx.x;\n    int off = lane * 4;\n    shIn[off + 0] = input_d[i0];\n    shIn[off + 1] = input_d[i1];\n    shIn[off + 2] = input_d[i2];\n    shIn[off + 3] = input_d[i3];\n    __syncthreads();\n\n    float s0 = shIn[off + 0];\n    float s1 = shIn[off + 1];\n    float s2 = shIn[off + 2];\n    float s3 = shIn[off + 3];\n\n    float a = db4LoFilter_d[0] * s0 + db4LoFilter_d[1] * s1 + db4LoFilter_d[2] * s2 + db4LoFilter_d[3] * s3;\n    float d = db4HiFilter_d[0] * s0 + db4HiFilter_d[1] * s1 + db4HiFilter_d[2] * s2 + db4HiFilter_d[3] * s3;\n\n    output_d[t] = a;\n    output_d[half + t] = d;\n}\n\nstatic void read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nstatic void write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    const int numSamples = 1024;\n    const int half = numSamples / 2;\n\n    const std::string in_file  = \"data/in.bin\";\n    const std::string lo_file  = \"data/lo.bin\";\n    const std::string hi_file  = \"data/hi.bin\";\n    const std::string out_file = \"data/out.bin\";\n\n    std::vector<float> h_in(numSamples);\n    std::vector<float> h_out(numSamples);\n    float h_lo[4], h_hi[4];\n\n    read_binary(in_file, h_in.data(), numSamples * sizeof(float));\n    read_binary(lo_file, h_lo, 4 * sizeof(float));\n    read_binary(hi_file, h_hi, 4 * sizeof(float));\n\n    float *d_in = nullptr, *d_out = nullptr, *d_lo = nullptr, *d_hi = nullptr;\n    cudaMalloc(&d_in,  numSamples * sizeof(float));\n    cudaMalloc(&d_out, numSamples * sizeof(float));\n    cudaMalloc(&d_lo,  4 * sizeof(float));\n    cudaMalloc(&d_hi,  4 * sizeof(float));\n\n    cudaMemcpy(d_in, h_in.data(), numSamples * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_lo, h_lo, 4 * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_hi, h_hi, 4 * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (half + threads - 1) / threads;\n    size_t shmem = (size_t)threads * 4 * sizeof(float);\n\n    k_db4Wavelet<<<blocks, threads, shmem>>>(d_in, d_out, numSamples, d_lo, d_hi);\n    cudaMemcpy(h_out.data(), d_out, numSamples * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(out_file, h_out.data(), numSamples * sizeof(float));\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    cudaFree(d_lo);\n    cudaFree(d_hi);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nnumSamples = 1024\nseed = 3\nrng = np.random.default_rng(seed)\n\nx = rng.random(numSamples, dtype=np.float32) * 100\n\ndb4Lo = np.array([0.4821, 0.8360, 0.2240, -0.1290], dtype=np.float32)\ndb4Hi = np.array([-0.1290, -0.2240, 0.8360, -0.4820], dtype=np.float32)\n\ndef clamp_idx(i, n):\n    if i < 0:\n        return 0\n    if i >= n:\n        return n - 1\n    return i\n\nhalf = numSamples // 2\napprox = np.empty(half, dtype=np.float32)\ndetail = np.empty(half, dtype=np.float32)\n\nfor t in range(half):\n    base = 2 * t\n    s0 = x[clamp_idx(base + 0, numSamples)]\n    s1 = x[clamp_idx(base + 1, numSamples)]\n    s2 = x[clamp_idx(base + 2, numSamples)]\n    s3 = x[clamp_idx(base + 3, numSamples)]\n    approx[t] = db4Lo[0] * s0 + db4Lo[1] * s1 + db4Lo[2] * s2 + db4Lo[3] * s3\n    detail[t] = db4Hi[0] * s0 + db4Hi[1] * s1 + db4Hi[2] * s2 + db4Hi[3] * s3\n\nout = np.empty(numSamples, dtype=np.float32)\nout[:half] = approx\nout[half:] = detail\n\nx.tofile(\"data/in.bin\")\ndb4Lo.tofile(\"data/lo.bin\")\ndb4Hi.tofile(\"data/hi.bin\")\nout.tofile(\"data/ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef check(out_path, ref_path, n, tol=1e-3):\n    if (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n        return False\n    out = read_f32(out_path, n)\n    ref = read_f32(ref_path, n)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return bool(np.all(diff <= tol))\n\nif __name__ == \"__main__\":\n    numSamples = 1024\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref.bin\"\n\n    ok = check(out_file, ref_file, numSamples, tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Task: DB4_Wavelet_Transform. Compute a 1D Daubechies 4 wavelet transform on an input signal. The input is a tensor 'in' with 1024 float32 values. Use two filter coefficient tensors: 'lo' (4 float32 values for low-pass filtering) and 'hi' (4 float32 values for high-pass filtering). Output a tensor 'out' with 1024 float32 values. The first half of the output contains approximation coefficients computed by applying the low-pass filter to overlapping 4-sample windows of the input. The second half contains detail coefficients computed by applying the high-pass filter to the same windows. Input indices beyond the signal length must be clamped to the last valid index.", "level2_prompt": "Task: DB4_Wavelet_Transform. For each position t in the first half of the output, compute two values: 1) Approximation coefficient = dot product of low-pass filter coefficients with input samples at indices [2t, 2t+1, 2t+2, 2t+3] (clamped to signal boundaries). 2) Detail coefficient = dot product of high-pass filter coefficients with the same input samples. Store approximation coefficients in the first half of the output and detail coefficients in the second half.", "level3_prompt": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA."}
{"id": 461, "task_name": "DB4_Wavelet_Transform", "task_description": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA.", "inputs": [{"name": "in", "dtype": "float32", "shape": "(2048,)"}, {"name": "lo", "dtype": "float32", "shape": "(4,)"}, {"name": "hi", "dtype": "float32", "shape": "(4,)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(2048,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n__global__ void k_db4Wavelet(const float* input_d, float* output_d, int numSamples,\n                             const float* db4LoFilter_d, const float* db4HiFilter_d) {\n    int t = blockIdx.x * blockDim.x + threadIdx.x;\n    int half = numSamples >> 1;\n    if (t >= half) return;\n\n    int base = t << 1;\n\n    extern __shared__ float sh[];\n    float* shIn = sh;\n\n    int i0 = base + 0;\n    int i1 = base + 1;\n    int i2 = base + 2;\n    int i3 = base + 3;\n\n    if (i0 >= numSamples) i0 = numSamples - 1;\n    if (i1 >= numSamples) i1 = numSamples - 1;\n    if (i2 >= numSamples) i2 = numSamples - 1;\n    if (i3 >= numSamples) i3 = numSamples - 1;\n\n    int lane = threadIdx.x;\n    int off = lane * 4;\n    shIn[off + 0] = input_d[i0];\n    shIn[off + 1] = input_d[i1];\n    shIn[off + 2] = input_d[i2];\n    shIn[off + 3] = input_d[i3];\n    __syncthreads();\n\n    float s0 = shIn[off + 0];\n    float s1 = shIn[off + 1];\n    float s2 = shIn[off + 2];\n    float s3 = shIn[off + 3];\n\n    float a = db4LoFilter_d[0] * s0 + db4LoFilter_d[1] * s1 + db4LoFilter_d[2] * s2 + db4LoFilter_d[3] * s3;\n    float d = db4HiFilter_d[0] * s0 + db4HiFilter_d[1] * s1 + db4HiFilter_d[2] * s2 + db4HiFilter_d[3] * s3;\n\n    output_d[t] = a;\n    output_d[half + t] = d;\n}\n\nstatic void read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nstatic void write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    const int numSamples = 2048;\n    const int half = numSamples / 2;\n\n    const std::string in_file  = \"data/in.bin\";\n    const std::string lo_file  = \"data/lo.bin\";\n    const std::string hi_file  = \"data/hi.bin\";\n    const std::string out_file = \"data/out.bin\";\n\n    std::vector<float> h_in(numSamples);\n    std::vector<float> h_out(numSamples);\n    float h_lo[4], h_hi[4];\n\n    read_binary(in_file, h_in.data(), numSamples * sizeof(float));\n    read_binary(lo_file, h_lo, 4 * sizeof(float));\n    read_binary(hi_file, h_hi, 4 * sizeof(float));\n\n    float *d_in = nullptr, *d_out = nullptr, *d_lo = nullptr, *d_hi = nullptr;\n    cudaMalloc(&d_in,  numSamples * sizeof(float));\n    cudaMalloc(&d_out, numSamples * sizeof(float));\n    cudaMalloc(&d_lo,  4 * sizeof(float));\n    cudaMalloc(&d_hi,  4 * sizeof(float));\n\n    cudaMemcpy(d_in, h_in.data(), numSamples * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_lo, h_lo, 4 * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_hi, h_hi, 4 * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (half + threads - 1) / threads;\n    size_t shmem = (size_t)threads * 4 * sizeof(float);\n\n    k_db4Wavelet<<<blocks, threads, shmem>>>(d_in, d_out, numSamples, d_lo, d_hi);\n    cudaMemcpy(h_out.data(), d_out, numSamples * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(out_file, h_out.data(), numSamples * sizeof(float));\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    cudaFree(d_lo);\n    cudaFree(d_hi);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nnumSamples = 2048\nseed = 3\nrng = np.random.default_rng(seed)\n\nx = rng.random(numSamples, dtype=np.float32) * 100\n\ndb4Lo = np.array([0.4821, 0.8360, 0.2240, -0.1290], dtype=np.float32)\ndb4Hi = np.array([-0.1290, -0.2240, 0.8360, -0.4820], dtype=np.float32)\n\ndef clamp_idx(i, n):\n    if i < 0:\n        return 0\n    if i >= n:\n        return n - 1\n    return i\n\nhalf = numSamples // 2\napprox = np.empty(half, dtype=np.float32)\ndetail = np.empty(half, dtype=np.float32)\n\nfor t in range(half):\n    base = 2 * t\n    s0 = x[clamp_idx(base + 0, numSamples)]\n    s1 = x[clamp_idx(base + 1, numSamples)]\n    s2 = x[clamp_idx(base + 2, numSamples)]\n    s3 = x[clamp_idx(base + 3, numSamples)]\n    approx[t] = db4Lo[0] * s0 + db4Lo[1] * s1 + db4Lo[2] * s2 + db4Lo[3] * s3\n    detail[t] = db4Hi[0] * s0 + db4Hi[1] * s1 + db4Hi[2] * s2 + db4Hi[3] * s3\n\nout = np.empty(numSamples, dtype=np.float32)\nout[:half] = approx\nout[half:] = detail\n\nx.tofile(\"data/in.bin\")\ndb4Lo.tofile(\"data/lo.bin\")\ndb4Hi.tofile(\"data/hi.bin\")\nout.tofile(\"data/ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef check(out_path, ref_path, n, tol=1e-3):\n    if (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n        return False\n    out = read_f32(out_path, n)\n    ref = read_f32(ref_path, n)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return bool(np.all(diff <= tol))\n\nif __name__ == \"__main__\":\n    numSamples = 2048\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref.bin\"\n\n    ok = check(out_file, ref_file, numSamples, tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Implement a GPU kernel for the DB4_Wavelet_Transform task. The kernel should compute a Daubechies 4 wavelet transform on an input signal of 2048 float32 values. Input includes the signal array and two filter coefficient arrays (4 float32 values each for low-pass and high-pass filters). The output must be a transformed signal of 2048 float32 values, where the first half contains approximation coefficients and the second half contains detail coefficients. The kernel must handle boundary conditions by clamping indices to valid positions when accessing input elements. Each thread should process non-overlapping pairs of output coefficients using a sliding window of four consecutive input samples.", "level2_prompt": "Perform a DB4 wavelet transform where each output pair (approximation and detail coefficient) is computed from four consecutive input samples. For position t, use samples at indices 2t, 2t+1, 2t+2, 2t+3 (clamped to input bounds). Approximation = dot product of low-pass filter with samples, detail = dot product of high-pass filter with samples. Store approximations in first half of output, details in second half.", "level3_prompt": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA."}
{"id": 462, "task_name": "DB4_Wavelet_Transform", "task_description": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA.", "inputs": [{"name": "in", "dtype": "float32", "shape": "(4096,)"}, {"name": "lo", "dtype": "float32", "shape": "(4,)"}, {"name": "hi", "dtype": "float32", "shape": "(4,)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(4096,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n__global__ void k_db4Wavelet(const float* input_d, float* output_d, int numSamples,\n                             const float* db4LoFilter_d, const float* db4HiFilter_d) {\n    int t = blockIdx.x * blockDim.x + threadIdx.x;\n    int half = numSamples >> 1;\n    if (t >= half) return;\n\n    int base = t << 1;\n\n    extern __shared__ float sh[];\n    float* shIn = sh;\n\n    int i0 = base + 0;\n    int i1 = base + 1;\n    int i2 = base + 2;\n    int i3 = base + 3;\n\n    if (i0 >= numSamples) i0 = numSamples - 1;\n    if (i1 >= numSamples) i1 = numSamples - 1;\n    if (i2 >= numSamples) i2 = numSamples - 1;\n    if (i3 >= numSamples) i3 = numSamples - 1;\n\n    int lane = threadIdx.x;\n    int off = lane * 4;\n    shIn[off + 0] = input_d[i0];\n    shIn[off + 1] = input_d[i1];\n    shIn[off + 2] = input_d[i2];\n    shIn[off + 3] = input_d[i3];\n    __syncthreads();\n\n    float s0 = shIn[off + 0];\n    float s1 = shIn[off + 1];\n    float s2 = shIn[off + 2];\n    float s3 = shIn[off + 3];\n\n    float a = db4LoFilter_d[0] * s0 + db4LoFilter_d[1] * s1 + db4LoFilter_d[2] * s2 + db4LoFilter_d[3] * s3;\n    float d = db4HiFilter_d[0] * s0 + db4HiFilter_d[1] * s1 + db4HiFilter_d[2] * s2 + db4HiFilter_d[3] * s3;\n\n    output_d[t] = a;\n    output_d[half + t] = d;\n}\n\nstatic void read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nstatic void write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    const int numSamples = 4096;\n    const int half = numSamples / 2;\n\n    const std::string in_file  = \"data/in.bin\";\n    const std::string lo_file  = \"data/lo.bin\";\n    const std::string hi_file  = \"data/hi.bin\";\n    const std::string out_file = \"data/out.bin\";\n\n    std::vector<float> h_in(numSamples);\n    std::vector<float> h_out(numSamples);\n    float h_lo[4], h_hi[4];\n\n    read_binary(in_file, h_in.data(), numSamples * sizeof(float));\n    read_binary(lo_file, h_lo, 4 * sizeof(float));\n    read_binary(hi_file, h_hi, 4 * sizeof(float));\n\n    float *d_in = nullptr, *d_out = nullptr, *d_lo = nullptr, *d_hi = nullptr;\n    cudaMalloc(&d_in,  numSamples * sizeof(float));\n    cudaMalloc(&d_out, numSamples * sizeof(float));\n    cudaMalloc(&d_lo,  4 * sizeof(float));\n    cudaMalloc(&d_hi,  4 * sizeof(float));\n\n    cudaMemcpy(d_in, h_in.data(), numSamples * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_lo, h_lo, 4 * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_hi, h_hi, 4 * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (half + threads - 1) / threads;\n    size_t shmem = (size_t)threads * 4 * sizeof(float);\n\n    k_db4Wavelet<<<blocks, threads, shmem>>>(d_in, d_out, numSamples, d_lo, d_hi);\n    cudaMemcpy(h_out.data(), d_out, numSamples * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(out_file, h_out.data(), numSamples * sizeof(float));\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    cudaFree(d_lo);\n    cudaFree(d_hi);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nnumSamples = 4096\nseed = 3\nrng = np.random.default_rng(seed)\n\nx = rng.random(numSamples, dtype=np.float32) * 100\n\ndb4Lo = np.array([0.4821, 0.8360, 0.2240, -0.1290], dtype=np.float32)\ndb4Hi = np.array([-0.1290, -0.2240, 0.8360, -0.4820], dtype=np.float32)\n\ndef clamp_idx(i, n):\n    if i < 0:\n        return 0\n    if i >= n:\n        return n - 1\n    return i\n\nhalf = numSamples // 2\napprox = np.empty(half, dtype=np.float32)\ndetail = np.empty(half, dtype=np.float32)\n\nfor t in range(half):\n    base = 2 * t\n    s0 = x[clamp_idx(base + 0, numSamples)]\n    s1 = x[clamp_idx(base + 1, numSamples)]\n    s2 = x[clamp_idx(base + 2, numSamples)]\n    s3 = x[clamp_idx(base + 3, numSamples)]\n    approx[t] = db4Lo[0] * s0 + db4Lo[1] * s1 + db4Lo[2] * s2 + db4Lo[3] * s3\n    detail[t] = db4Hi[0] * s0 + db4Hi[1] * s1 + db4Hi[2] * s2 + db4Hi[3] * s3\n\nout = np.empty(numSamples, dtype=np.float32)\nout[:half] = approx\nout[half:] = detail\n\nx.tofile(\"data/in.bin\")\ndb4Lo.tofile(\"data/lo.bin\")\ndb4Hi.tofile(\"data/hi.bin\")\nout.tofile(\"data/ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef check(out_path, ref_path, n, tol=1e-3):\n    if (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n        return False\n    out = read_f32(out_path, n)\n    ref = read_f32(ref_path, n)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return bool(np.all(diff <= tol))\n\nif __name__ == \"__main__\":\n    numSamples = 4096\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref.bin\"\n\n    ok = check(out_file, ref_file, numSamples, tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "DB4_Wavelet_Transform: Compute a Daubechies 4 wavelet transform on a 4096-element input signal. The kernel must process the input in overlapping segments of 4 elements, starting at every even index. For each segment, compute two coefficients: an approximation coefficient using the low-pass filter coefficients and a detail coefficient using the high-pass filter coefficients. If segment indices exceed the signal boundaries, clamp them to the nearest valid position. Store the 2048 approximation coefficients in the first half of the output and the 2048 detail coefficients in the second half. Inputs include a float32 signal (4096), low-pass coefficients (float32, 4), and high-pass coefficients (float32, 4). Output is a float32 array (4096).", "level2_prompt": "DB4_Wavelet_Transform: For each segment index t (0 ≤ t < 2048), take four consecutive signal elements starting at position 2t. Apply boundary clamping if indices exceed 4095. Compute approximation coefficient as dot product of the segment with low-pass filter coefficients. Compute detail coefficient as dot product with high-pass filter coefficients. Place approximation coefficients in output positions 0-2047 and detail coefficients in positions 2048-4095.", "level3_prompt": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA."}
{"id": 463, "task_name": "DB4_Wavelet_Transform", "task_description": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA.", "inputs": [{"name": "in", "dtype": "float32", "shape": "(8192,)"}, {"name": "lo", "dtype": "float32", "shape": "(4,)"}, {"name": "hi", "dtype": "float32", "shape": "(4,)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(8192,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n__global__ void k_db4Wavelet(const float* input_d, float* output_d, int numSamples,\n                             const float* db4LoFilter_d, const float* db4HiFilter_d) {\n    int t = blockIdx.x * blockDim.x + threadIdx.x;\n    int half = numSamples >> 1;\n    if (t >= half) return;\n\n    int base = t << 1;\n\n    extern __shared__ float sh[];\n    float* shIn = sh;\n\n    int i0 = base + 0;\n    int i1 = base + 1;\n    int i2 = base + 2;\n    int i3 = base + 3;\n\n    if (i0 >= numSamples) i0 = numSamples - 1;\n    if (i1 >= numSamples) i1 = numSamples - 1;\n    if (i2 >= numSamples) i2 = numSamples - 1;\n    if (i3 >= numSamples) i3 = numSamples - 1;\n\n    int lane = threadIdx.x;\n    int off = lane * 4;\n    shIn[off + 0] = input_d[i0];\n    shIn[off + 1] = input_d[i1];\n    shIn[off + 2] = input_d[i2];\n    shIn[off + 3] = input_d[i3];\n    __syncthreads();\n\n    float s0 = shIn[off + 0];\n    float s1 = shIn[off + 1];\n    float s2 = shIn[off + 2];\n    float s3 = shIn[off + 3];\n\n    float a = db4LoFilter_d[0] * s0 + db4LoFilter_d[1] * s1 + db4LoFilter_d[2] * s2 + db4LoFilter_d[3] * s3;\n    float d = db4HiFilter_d[0] * s0 + db4HiFilter_d[1] * s1 + db4HiFilter_d[2] * s2 + db4HiFilter_d[3] * s3;\n\n    output_d[t] = a;\n    output_d[half + t] = d;\n}\n\nstatic void read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nstatic void write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    const int numSamples = 8192;\n    const int half = numSamples / 2;\n\n    const std::string in_file  = \"data/in.bin\";\n    const std::string lo_file  = \"data/lo.bin\";\n    const std::string hi_file  = \"data/hi.bin\";\n    const std::string out_file = \"data/out.bin\";\n\n    std::vector<float> h_in(numSamples);\n    std::vector<float> h_out(numSamples);\n    float h_lo[4], h_hi[4];\n\n    read_binary(in_file, h_in.data(), numSamples * sizeof(float));\n    read_binary(lo_file, h_lo, 4 * sizeof(float));\n    read_binary(hi_file, h_hi, 4 * sizeof(float));\n\n    float *d_in = nullptr, *d_out = nullptr, *d_lo = nullptr, *d_hi = nullptr;\n    cudaMalloc(&d_in,  numSamples * sizeof(float));\n    cudaMalloc(&d_out, numSamples * sizeof(float));\n    cudaMalloc(&d_lo,  4 * sizeof(float));\n    cudaMalloc(&d_hi,  4 * sizeof(float));\n\n    cudaMemcpy(d_in, h_in.data(), numSamples * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_lo, h_lo, 4 * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_hi, h_hi, 4 * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (half + threads - 1) / threads;\n    size_t shmem = (size_t)threads * 4 * sizeof(float);\n\n    k_db4Wavelet<<<blocks, threads, shmem>>>(d_in, d_out, numSamples, d_lo, d_hi);\n    cudaMemcpy(h_out.data(), d_out, numSamples * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(out_file, h_out.data(), numSamples * sizeof(float));\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    cudaFree(d_lo);\n    cudaFree(d_hi);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nnumSamples = 8192\nseed = 3\nrng = np.random.default_rng(seed)\n\nx = rng.random(numSamples, dtype=np.float32) * 100\n\ndb4Lo = np.array([0.4821, 0.8360, 0.2240, -0.1290], dtype=np.float32)\ndb4Hi = np.array([-0.1290, -0.2240, 0.8360, -0.4820], dtype=np.float32)\n\ndef clamp_idx(i, n):\n    if i < 0:\n        return 0\n    if i >= n:\n        return n - 1\n    return i\n\nhalf = numSamples // 2\napprox = np.empty(half, dtype=np.float32)\ndetail = np.empty(half, dtype=np.float32)\n\nfor t in range(half):\n    base = 2 * t\n    s0 = x[clamp_idx(base + 0, numSamples)]\n    s1 = x[clamp_idx(base + 1, numSamples)]\n    s2 = x[clamp_idx(base + 2, numSamples)]\n    s3 = x[clamp_idx(base + 3, numSamples)]\n    approx[t] = db4Lo[0] * s0 + db4Lo[1] * s1 + db4Lo[2] * s2 + db4Lo[3] * s3\n    detail[t] = db4Hi[0] * s0 + db4Hi[1] * s1 + db4Hi[2] * s2 + db4Hi[3] * s3\n\nout = np.empty(numSamples, dtype=np.float32)\nout[:half] = approx\nout[half:] = detail\n\nx.tofile(\"data/in.bin\")\ndb4Lo.tofile(\"data/lo.bin\")\ndb4Hi.tofile(\"data/hi.bin\")\nout.tofile(\"data/ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef check(out_path, ref_path, n, tol=1e-3):\n    if (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n        return False\n    out = read_f32(out_path, n)\n    ref = read_f32(ref_path, n)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return bool(np.all(diff <= tol))\n\nif __name__ == \"__main__\":\n    numSamples = 8192\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref.bin\"\n\n    ok = check(out_file, ref_file, numSamples, tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Task: DB4_Wavelet_Transform. Perform a Daubechies 4 wavelet transform on an input signal. Input includes a 8192-element float32 signal array, a 4-element float32 low-pass filter coefficient array, and a 4-element float32 high-pass filter coefficient array. Output must be a 8192-element float32 array. The first half of the output contains approximation coefficients calculated by applying the low-pass filter to overlapping 4-sample blocks. The second half contains detail coefficients calculated by applying the high-pass filter to the same blocks. Input indices must be clamped to the signal boundaries when exceeding array limits. The kernel must process the entire signal using half as many threads as input samples.", "level2_prompt": "Task: DB4_Wavelet_Transform. Apply Daubechies wavelet decomposition to an input signal using two 4-tap filters. For each position t in the first half of the output, process four consecutive input samples starting at index 2t. Clamp indices to valid signal positions. Compute approximation coefficients using low-pass filter coefficients and store in output's first half. Compute detail coefficients using high-pass filter coefficients and store in output's second half.", "level3_prompt": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA."}
{"id": 464, "task_name": "DB4_Wavelet_Transform", "task_description": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA.", "inputs": [{"name": "in", "dtype": "float32", "shape": "(16384,)"}, {"name": "lo", "dtype": "float32", "shape": "(4,)"}, {"name": "hi", "dtype": "float32", "shape": "(4,)"}], "outputs": [{"name": "out", "dtype": "float32", "shape": "(16384,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n__global__ void k_db4Wavelet(const float* input_d, float* output_d, int numSamples,\n                             const float* db4LoFilter_d, const float* db4HiFilter_d) {\n    int t = blockIdx.x * blockDim.x + threadIdx.x;\n    int half = numSamples >> 1;\n    if (t >= half) return;\n\n    int base = t << 1;\n\n    extern __shared__ float sh[];\n    float* shIn = sh;\n\n    int i0 = base + 0;\n    int i1 = base + 1;\n    int i2 = base + 2;\n    int i3 = base + 3;\n\n    if (i0 >= numSamples) i0 = numSamples - 1;\n    if (i1 >= numSamples) i1 = numSamples - 1;\n    if (i2 >= numSamples) i2 = numSamples - 1;\n    if (i3 >= numSamples) i3 = numSamples - 1;\n\n    int lane = threadIdx.x;\n    int off = lane * 4;\n    shIn[off + 0] = input_d[i0];\n    shIn[off + 1] = input_d[i1];\n    shIn[off + 2] = input_d[i2];\n    shIn[off + 3] = input_d[i3];\n    __syncthreads();\n\n    float s0 = shIn[off + 0];\n    float s1 = shIn[off + 1];\n    float s2 = shIn[off + 2];\n    float s3 = shIn[off + 3];\n\n    float a = db4LoFilter_d[0] * s0 + db4LoFilter_d[1] * s1 + db4LoFilter_d[2] * s2 + db4LoFilter_d[3] * s3;\n    float d = db4HiFilter_d[0] * s0 + db4HiFilter_d[1] * s1 + db4HiFilter_d[2] * s2 + db4HiFilter_d[3] * s3;\n\n    output_d[t] = a;\n    output_d[half + t] = d;\n}\n\nstatic void read_binary(const std::string& filename, void* data, size_t bytes) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), bytes);\n    in.close();\n}\n\nstatic void write_binary(const std::string& filename, const void* data, size_t bytes) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), bytes);\n    out.close();\n}\n\nint main() {\n    const int numSamples = 16384;\n    const int half = numSamples / 2;\n\n    const std::string in_file  = \"data/in.bin\";\n    const std::string lo_file  = \"data/lo.bin\";\n    const std::string hi_file  = \"data/hi.bin\";\n    const std::string out_file = \"data/out.bin\";\n\n    std::vector<float> h_in(numSamples);\n    std::vector<float> h_out(numSamples);\n    float h_lo[4], h_hi[4];\n\n    read_binary(in_file, h_in.data(), numSamples * sizeof(float));\n    read_binary(lo_file, h_lo, 4 * sizeof(float));\n    read_binary(hi_file, h_hi, 4 * sizeof(float));\n\n    float *d_in = nullptr, *d_out = nullptr, *d_lo = nullptr, *d_hi = nullptr;\n    cudaMalloc(&d_in,  numSamples * sizeof(float));\n    cudaMalloc(&d_out, numSamples * sizeof(float));\n    cudaMalloc(&d_lo,  4 * sizeof(float));\n    cudaMalloc(&d_hi,  4 * sizeof(float));\n\n    cudaMemcpy(d_in, h_in.data(), numSamples * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_lo, h_lo, 4 * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_hi, h_hi, 4 * sizeof(float), cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (half + threads - 1) / threads;\n    size_t shmem = (size_t)threads * 4 * sizeof(float);\n\n    k_db4Wavelet<<<blocks, threads, shmem>>>(d_in, d_out, numSamples, d_lo, d_hi);\n    cudaMemcpy(h_out.data(), d_out, numSamples * sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary(out_file, h_out.data(), numSamples * sizeof(float));\n\n    cudaFree(d_in);\n    cudaFree(d_out);\n    cudaFree(d_lo);\n    cudaFree(d_hi);\n\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\n\nnumSamples = 16384\nseed = 3\nrng = np.random.default_rng(seed)\n\nx = rng.random(numSamples, dtype=np.float32) * 100\n\ndb4Lo = np.array([0.4821, 0.8360, 0.2240, -0.1290], dtype=np.float32)\ndb4Hi = np.array([-0.1290, -0.2240, 0.8360, -0.4820], dtype=np.float32)\n\ndef clamp_idx(i, n):\n    if i < 0:\n        return 0\n    if i >= n:\n        return n - 1\n    return i\n\nhalf = numSamples // 2\napprox = np.empty(half, dtype=np.float32)\ndetail = np.empty(half, dtype=np.float32)\n\nfor t in range(half):\n    base = 2 * t\n    s0 = x[clamp_idx(base + 0, numSamples)]\n    s1 = x[clamp_idx(base + 1, numSamples)]\n    s2 = x[clamp_idx(base + 2, numSamples)]\n    s3 = x[clamp_idx(base + 3, numSamples)]\n    approx[t] = db4Lo[0] * s0 + db4Lo[1] * s1 + db4Lo[2] * s2 + db4Lo[3] * s3\n    detail[t] = db4Hi[0] * s0 + db4Hi[1] * s1 + db4Hi[2] * s2 + db4Hi[3] * s3\n\nout = np.empty(numSamples, dtype=np.float32)\nout[:half] = approx\nout[half:] = detail\n\nx.tofile(\"data/in.bin\")\ndb4Lo.tofile(\"data/lo.bin\")\ndb4Hi.tofile(\"data/hi.bin\")\nout.tofile(\"data/ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef check(out_path, ref_path, n, tol=1e-3):\n    if (not os.path.exists(out_path)) or (not os.path.exists(ref_path)):\n        return False\n    out = read_f32(out_path, n)\n    ref = read_f32(ref_path, n)\n    if out.shape != ref.shape:\n        return False\n    diff = np.abs(out - ref)\n    return bool(np.all(diff <= tol))\n\nif __name__ == \"__main__\":\n    numSamples = 16384\n    out_file = \"data/out.bin\"\n    ref_file = \"data/ref.bin\"\n\n    ok = check(out_file, ref_file, numSamples, tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Implement the DB4_Wavelet_Transform kernel. The kernel must compute a Daubechies 4 wavelet transform on a 16384-element input signal. Inputs include: (1) a float32 tensor 'in' of shape (16384,) containing the input signal, (2) a float32 tensor 'lo' of shape (4,) with low-pass filter coefficients, and (3) a float32 tensor 'hi' of shape (4,) with high-pass filter coefficients. The output is a float32 tensor 'out' of shape (16384,) where the first half contains approximation coefficients and the second half contains detail coefficients. For each block of four consecutive input samples starting at even indices, compute one approximation and one detail coefficient. When indices exceed the input bounds, clamp them to the last valid index. The kernel must process all blocks in parallel.", "level2_prompt": "Perform a Daubechies 4 wavelet transform. For each block of four consecutive samples starting at even indices in the input signal, calculate two coefficients: (1) an approximation coefficient as a dot product of the samples with low-pass filter coefficients, and (2) a detail coefficient as a dot product with high-pass filter coefficients. Store approximation coefficients in the first half of the output and detail coefficients in the second half. Handle out-of-bound indices by clamping to the last input element.", "level3_prompt": "Compute the DB4_Wavelet_Transform kernel on GPU using CUDA."}
{"id": 465, "task_name": "PSNR", "task_description": "Compute the PSNR kernel on GPU using CUDA.", "inputs": [{"name": "inputImage", "dtype": "float32", "shape": "(65536,)"}, {"name": "compressedInputImage", "dtype": "float32", "shape": "(65536,)"}], "outputs": [{"name": "psnr_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cmath>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <string>\n\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE 32\n#endif\n\n__device__ __forceinline__ float blockReduceSum(float val, float* sdata) {\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n    sdata[tid] = val;\n    __syncthreads();\n\n    for (int stride = nthreads / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) sdata[tid] += sdata[tid + stride];\n        __syncthreads();\n    }\n    return sdata[0];\n}\n\n__global__ void k_peakSignalToNoiseRatio(float *inputImage, float *compressedInputImage,\n                                         float *peakToNoiseRatio,\n                                         const int imageWidth, const int imageHeight) {\n    extern __shared__ float sdata[];\n\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n\n    int N = imageWidth * imageHeight;\n\n    float local = 0.0f;\n    for (int idx = tid; idx < N; idx += nthreads) {\n        float d = inputImage[idx] - compressedInputImage[idx];\n        local += d * d;\n    }\n\n    float sse = blockReduceSum(local, sdata);\n\n    if (tid == 0) {\n        float mse = sse / (float)N;\n        float psnr = 10.0f * log10f(1.0f / mse);\n        peakToNoiseRatio[0] = psnr;\n    }\n}\n\nstatic void read_binary_f32(const std::string& filename, float* data, size_t count) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), (std::streamsize)(count * sizeof(float)));\n    in.close();\n}\n\nstatic void write_binary_f32(const std::string& filename, const float* data, size_t count) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), (std::streamsize)(count * sizeof(float)));\n    out.close();\n}\n\nint main() {\n    const int W = 256;\n    const int H = 256;\n    const int N = W * H;\n\n    float* h_in = (float*)malloc((size_t)N * sizeof(float));\n    float* h_cmp = (float*)malloc((size_t)N * sizeof(float));\n    float  h_out = 0.0f;\n\n    read_binary_f32(\"data/inputImage.bin\", h_in, (size_t)N);\n    read_binary_f32(\"data/compressedInputImage.bin\", h_cmp, (size_t)N);\n\n    float *d_in = nullptr, *d_cmp = nullptr, *d_psnr = nullptr;\n    cudaMalloc(&d_in, (size_t)N * sizeof(float));\n    cudaMalloc(&d_cmp, (size_t)N * sizeof(float));\n    cudaMalloc(&d_psnr, sizeof(float));\n\n    cudaMemcpy(d_in, h_in, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_cmp, h_cmp, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(BLOCK_SIZE, BLOCK_SIZE, 1);\n    dim3 grid(1, 1, 1);\n    size_t smem = (size_t)(BLOCK_SIZE * BLOCK_SIZE) * sizeof(float);\n\n    k_peakSignalToNoiseRatio<<<grid, block, smem>>>(d_in, d_cmp, d_psnr, W, H);\n\n    cudaMemcpy(&h_out, d_psnr, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary_f32(\"data/psnr_out.bin\", &h_out, 1);\n\n    cudaFree(d_in);\n    cudaFree(d_cmp);\n    cudaFree(d_psnr);\n    free(h_in);\n    free(h_cmp);\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nW = 256\nH = 256\nN = W * H\n\nimage_a = np.random.rand(N).astype(np.float32) * 10\nimage_b = np.random.rand(N).astype(np.float32) * 20\n\ndiff = image_a - image_b\nmse = float(np.mean(diff * diff))\npsnr = np.float32(10.0 * np.log10(1.0 / mse))\n\nimage_a.tofile(\"data/inputImage.bin\")\nimage_b.tofile(\"data/compressedInputImage.bin\")\nnp.array([psnr], dtype=np.float32).tofile(\"data/psnr_ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef compare_scalar(out_path, ref_path, tol=1e-3):\n    if not os.path.exists(out_path) or not os.path.exists(ref_path):\n        return False\n    out = read_f32(out_path, 1)\n    ref = read_f32(ref_path, 1)\n    if out.shape != ref.shape:\n        return False\n    return bool(np.abs(out[0] - ref[0]) <= tol)\n\nif __name__ == \"__main__\":\n    ok = compare_scalar(\"data/psnr_out.bin\", \"data/psnr_ref.bin\", tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Compute the Peak Signal-to-Noise Ratio (PSNR) between two images. The inputs are two one-dimensional float32 arrays, each with 65536 elements, representing the original and compressed images. The output is a single float32 scalar value. The kernel must calculate the mean squared error (MSE) by summing the squared differences between corresponding elements of the input arrays, then compute PSNR as 10 * log10(1 / MSE). The computation must handle all 65536 elements correctly.", "level2_prompt": "Calculate the Peak Signal-to-Noise Ratio (PSNR) between two images. For two input arrays of equal length, compute the sum of squared differences between corresponding elements. Divide this sum by the total number of elements to get the mean squared error. Then compute the PSNR value as 10 times the base-10 logarithm of the reciprocal of the mean squared error.", "level3_prompt": "Compute the PSNR kernel on GPU using CUDA."}
{"id": 466, "task_name": "PSNR", "task_description": "Compute the PSNR kernel on GPU using CUDA.", "inputs": [{"name": "inputImage", "dtype": "float32", "shape": "(262144,)"}, {"name": "compressedInputImage", "dtype": "float32", "shape": "(262144,)"}], "outputs": [{"name": "psnr_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cmath>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <string>\n\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE 32\n#endif\n\n__device__ __forceinline__ float blockReduceSum(float val, float* sdata) {\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n    sdata[tid] = val;\n    __syncthreads();\n\n    for (int stride = nthreads / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) sdata[tid] += sdata[tid + stride];\n        __syncthreads();\n    }\n    return sdata[0];\n}\n\n__global__ void k_peakSignalToNoiseRatio(float *inputImage, float *compressedInputImage,\n                                         float *peakToNoiseRatio,\n                                         const int imageWidth, const int imageHeight) {\n    extern __shared__ float sdata[];\n\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n\n    int N = imageWidth * imageHeight;\n\n    float local = 0.0f;\n    for (int idx = tid; idx < N; idx += nthreads) {\n        float d = inputImage[idx] - compressedInputImage[idx];\n        local += d * d;\n    }\n\n    float sse = blockReduceSum(local, sdata);\n\n    if (tid == 0) {\n        float mse = sse / (float)N;\n        float psnr = 10.0f * log10f(1.0f / mse);\n        peakToNoiseRatio[0] = psnr;\n    }\n}\n\nstatic void read_binary_f32(const std::string& filename, float* data, size_t count) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), (std::streamsize)(count * sizeof(float)));\n    in.close();\n}\n\nstatic void write_binary_f32(const std::string& filename, const float* data, size_t count) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), (std::streamsize)(count * sizeof(float)));\n    out.close();\n}\n\nint main() {\n    const int W = 512;\n    const int H = 512;\n    const int N = W * H;\n\n    float* h_in = (float*)malloc((size_t)N * sizeof(float));\n    float* h_cmp = (float*)malloc((size_t)N * sizeof(float));\n    float  h_out = 0.0f;\n\n    read_binary_f32(\"data/inputImage.bin\", h_in, (size_t)N);\n    read_binary_f32(\"data/compressedInputImage.bin\", h_cmp, (size_t)N);\n\n    float *d_in = nullptr, *d_cmp = nullptr, *d_psnr = nullptr;\n    cudaMalloc(&d_in, (size_t)N * sizeof(float));\n    cudaMalloc(&d_cmp, (size_t)N * sizeof(float));\n    cudaMalloc(&d_psnr, sizeof(float));\n\n    cudaMemcpy(d_in, h_in, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_cmp, h_cmp, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(BLOCK_SIZE, BLOCK_SIZE, 1);\n    dim3 grid(1, 1, 1);\n    size_t smem = (size_t)(BLOCK_SIZE * BLOCK_SIZE) * sizeof(float);\n\n    k_peakSignalToNoiseRatio<<<grid, block, smem>>>(d_in, d_cmp, d_psnr, W, H);\n\n    cudaMemcpy(&h_out, d_psnr, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary_f32(\"data/psnr_out.bin\", &h_out, 1);\n\n    cudaFree(d_in);\n    cudaFree(d_cmp);\n    cudaFree(d_psnr);\n    free(h_in);\n    free(h_cmp);\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nW = 512\nH = 512\nN = W * H\n\nimage_a = np.random.rand(N).astype(np.float32) * 10\nimage_b = np.random.rand(N).astype(np.float32) * 20\n\ndiff = image_a - image_b\nmse = float(np.mean(diff * diff))\npsnr = np.float32(10.0 * np.log10(1.0 / mse))\n\nimage_a.tofile(\"data/inputImage.bin\")\nimage_b.tofile(\"data/compressedInputImage.bin\")\nnp.array([psnr], dtype=np.float32).tofile(\"data/psnr_ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef compare_scalar(out_path, ref_path, tol=1e-3):\n    if not os.path.exists(out_path) or not os.path.exists(ref_path):\n        return False\n    out = read_f32(out_path, 1)\n    ref = read_f32(ref_path, 1)\n    if out.shape != ref.shape:\n        return False\n    return bool(np.abs(out[0] - ref[0]) <= tol)\n\nif __name__ == \"__main__\":\n    ok = compare_scalar(\"data/psnr_out.bin\", \"data/psnr_ref.bin\", tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Compute the Peak Signal-to-Noise Ratio (PSNR) between two images. The inputs are two float32 tensors named 'inputImage' and 'compressedInputImage', each with 262144 elements. The output is a single float32 value named 'psnr_out'. The kernel must calculate the sum of squared differences between corresponding elements of the input tensors, then compute the mean squared error by dividing this sum by the number of elements, and finally derive the PSNR using the formula 10 * log10(1 / mean squared error). The inputs must be of the same size and shape, and the computation requires a reduction step to sum the squared differences across all elements.", "level2_prompt": "Calculate the PSNR by summing the squared differences between each pair of elements in two input tensors, averaging this sum to get the mean squared error, and then applying the formula PSNR = 10 * log10(1 / mean squared error).", "level3_prompt": "Compute the PSNR kernel on GPU using CUDA."}
{"id": 467, "task_name": "PSNR", "task_description": "Compute the PSNR kernel on GPU using CUDA.", "inputs": [{"name": "inputImage", "dtype": "float32", "shape": "(1048576,)"}, {"name": "compressedInputImage", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "psnr_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cmath>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <string>\n\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE 32\n#endif\n\n__device__ __forceinline__ float blockReduceSum(float val, float* sdata) {\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n    sdata[tid] = val;\n    __syncthreads();\n\n    for (int stride = nthreads / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) sdata[tid] += sdata[tid + stride];\n        __syncthreads();\n    }\n    return sdata[0];\n}\n\n__global__ void k_peakSignalToNoiseRatio(float *inputImage, float *compressedInputImage,\n                                         float *peakToNoiseRatio,\n                                         const int imageWidth, const int imageHeight) {\n    extern __shared__ float sdata[];\n\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n\n    int N = imageWidth * imageHeight;\n\n    float local = 0.0f;\n    for (int idx = tid; idx < N; idx += nthreads) {\n        float d = inputImage[idx] - compressedInputImage[idx];\n        local += d * d;\n    }\n\n    float sse = blockReduceSum(local, sdata);\n\n    if (tid == 0) {\n        float mse = sse / (float)N;\n        float psnr = 10.0f * log10f(1.0f / mse);\n        peakToNoiseRatio[0] = psnr;\n    }\n}\n\nstatic void read_binary_f32(const std::string& filename, float* data, size_t count) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), (std::streamsize)(count * sizeof(float)));\n    in.close();\n}\n\nstatic void write_binary_f32(const std::string& filename, const float* data, size_t count) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), (std::streamsize)(count * sizeof(float)));\n    out.close();\n}\n\nint main() {\n    const int W = 1024;\n    const int H = 1024;\n    const int N = W * H;\n\n    float* h_in = (float*)malloc((size_t)N * sizeof(float));\n    float* h_cmp = (float*)malloc((size_t)N * sizeof(float));\n    float  h_out = 0.0f;\n\n    read_binary_f32(\"data/inputImage.bin\", h_in, (size_t)N);\n    read_binary_f32(\"data/compressedInputImage.bin\", h_cmp, (size_t)N);\n\n    float *d_in = nullptr, *d_cmp = nullptr, *d_psnr = nullptr;\n    cudaMalloc(&d_in, (size_t)N * sizeof(float));\n    cudaMalloc(&d_cmp, (size_t)N * sizeof(float));\n    cudaMalloc(&d_psnr, sizeof(float));\n\n    cudaMemcpy(d_in, h_in, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_cmp, h_cmp, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(BLOCK_SIZE, BLOCK_SIZE, 1);\n    dim3 grid(1, 1, 1);\n    size_t smem = (size_t)(BLOCK_SIZE * BLOCK_SIZE) * sizeof(float);\n\n    k_peakSignalToNoiseRatio<<<grid, block, smem>>>(d_in, d_cmp, d_psnr, W, H);\n\n    cudaMemcpy(&h_out, d_psnr, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary_f32(\"data/psnr_out.bin\", &h_out, 1);\n\n    cudaFree(d_in);\n    cudaFree(d_cmp);\n    cudaFree(d_psnr);\n    free(h_in);\n    free(h_cmp);\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nW = 1024\nH = 1024\nN = W * H\n\nimage_a = np.random.rand(N).astype(np.float32) * 10\nimage_b = np.random.rand(N).astype(np.float32) * 20\n\ndiff = image_a - image_b\nmse = float(np.mean(diff * diff))\npsnr = np.float32(10.0 * np.log10(1.0 / mse))\n\nimage_a.tofile(\"data/inputImage.bin\")\nimage_b.tofile(\"data/compressedInputImage.bin\")\nnp.array([psnr], dtype=np.float32).tofile(\"data/psnr_ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef compare_scalar(out_path, ref_path, tol=1e-3):\n    if not os.path.exists(out_path) or not os.path.exists(ref_path):\n        return False\n    out = read_f32(out_path, 1)\n    ref = read_f32(ref_path, 1)\n    if out.shape != ref.shape:\n        return False\n    return bool(np.abs(out[0] - ref[0]) <= tol)\n\nif __name__ == \"__main__\":\n    ok = compare_scalar(\"data/psnr_out.bin\", \"data/psnr_ref.bin\", tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Compute the Peak Signal-to-Noise Ratio (PSNR) between two input images. The inputs are two one-dimensional tensors of 1048576 float32 values each, representing the original and compressed images. The output is a single float32 value. The PSNR is computed by first calculating the mean squared error (MSE) between the two images and then applying the formula: PSNR = 10 * log10(1 / MSE). The kernel must compute the sum of squared differences (SSE) for every corresponding element in the two arrays, then divide by the total number of elements to get the MSE, and finally compute the PSNR.", "level2_prompt": "Given two arrays A and B of length N, compute the PSNR as: PSNR = 10 * log10(1 / ( (1/N) * sum_{i=0}^{N-1} (A[i] - B[i])^2 )).", "level3_prompt": "Compute the PSNR kernel on GPU using CUDA."}
{"id": 468, "task_name": "PSNR", "task_description": "Compute the PSNR kernel on GPU using CUDA.", "inputs": [{"name": "inputImage", "dtype": "float32", "shape": "(4194304,)"}, {"name": "compressedInputImage", "dtype": "float32", "shape": "(4194304,)"}], "outputs": [{"name": "psnr_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cmath>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <string>\n\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE 32\n#endif\n\n__device__ __forceinline__ float blockReduceSum(float val, float* sdata) {\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n    sdata[tid] = val;\n    __syncthreads();\n\n    for (int stride = nthreads / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) sdata[tid] += sdata[tid + stride];\n        __syncthreads();\n    }\n    return sdata[0];\n}\n\n__global__ void k_peakSignalToNoiseRatio(float *inputImage, float *compressedInputImage,\n                                         float *peakToNoiseRatio,\n                                         const int imageWidth, const int imageHeight) {\n    extern __shared__ float sdata[];\n\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n\n    int N = imageWidth * imageHeight;\n\n    float local = 0.0f;\n    for (int idx = tid; idx < N; idx += nthreads) {\n        float d = inputImage[idx] - compressedInputImage[idx];\n        local += d * d;\n    }\n\n    float sse = blockReduceSum(local, sdata);\n\n    if (tid == 0) {\n        float mse = sse / (float)N;\n        float psnr = 10.0f * log10f(1.0f / mse);\n        peakToNoiseRatio[0] = psnr;\n    }\n}\n\nstatic void read_binary_f32(const std::string& filename, float* data, size_t count) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), (std::streamsize)(count * sizeof(float)));\n    in.close();\n}\n\nstatic void write_binary_f32(const std::string& filename, const float* data, size_t count) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), (std::streamsize)(count * sizeof(float)));\n    out.close();\n}\n\nint main() {\n    const int W = 2048;\n    const int H = 2048;\n    const int N = W * H;\n\n    float* h_in = (float*)malloc((size_t)N * sizeof(float));\n    float* h_cmp = (float*)malloc((size_t)N * sizeof(float));\n    float  h_out = 0.0f;\n\n    read_binary_f32(\"data/inputImage.bin\", h_in, (size_t)N);\n    read_binary_f32(\"data/compressedInputImage.bin\", h_cmp, (size_t)N);\n\n    float *d_in = nullptr, *d_cmp = nullptr, *d_psnr = nullptr;\n    cudaMalloc(&d_in, (size_t)N * sizeof(float));\n    cudaMalloc(&d_cmp, (size_t)N * sizeof(float));\n    cudaMalloc(&d_psnr, sizeof(float));\n\n    cudaMemcpy(d_in, h_in, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_cmp, h_cmp, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(BLOCK_SIZE, BLOCK_SIZE, 1);\n    dim3 grid(1, 1, 1);\n    size_t smem = (size_t)(BLOCK_SIZE * BLOCK_SIZE) * sizeof(float);\n\n    k_peakSignalToNoiseRatio<<<grid, block, smem>>>(d_in, d_cmp, d_psnr, W, H);\n\n    cudaMemcpy(&h_out, d_psnr, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary_f32(\"data/psnr_out.bin\", &h_out, 1);\n\n    cudaFree(d_in);\n    cudaFree(d_cmp);\n    cudaFree(d_psnr);\n    free(h_in);\n    free(h_cmp);\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nW = 2048\nH = 2048\nN = W * H\n\nimage_a = np.random.rand(N).astype(np.float32) * 10\nimage_b = np.random.rand(N).astype(np.float32) * 20\n\ndiff = image_a - image_b\nmse = float(np.mean(diff * diff))\npsnr = np.float32(10.0 * np.log10(1.0 / mse))\n\nimage_a.tofile(\"data/inputImage.bin\")\nimage_b.tofile(\"data/compressedInputImage.bin\")\nnp.array([psnr], dtype=np.float32).tofile(\"data/psnr_ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef compare_scalar(out_path, ref_path, tol=1e-3):\n    if not os.path.exists(out_path) or not os.path.exists(ref_path):\n        return False\n    out = read_f32(out_path, 1)\n    ref = read_f32(ref_path, 1)\n    if out.shape != ref.shape:\n        return False\n    return bool(np.abs(out[0] - ref[0]) <= tol)\n\nif __name__ == \"__main__\":\n    ok = compare_scalar(\"data/psnr_out.bin\", \"data/psnr_ref.bin\", tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Compute the Peak Signal-to-Noise Ratio (PSNR) between two images. The inputs are two 1D float32 tensors of shape (4194304,) representing the original and compressed images. The output is a single float32 value in a tensor of shape (1,). PSNR is calculated by first computing the sum of squared differences between corresponding pixels, then deriving the mean squared error (MSE) by dividing the sum by the total number of pixels. Finally, compute PSNR as 10 times the base-10 logarithm of (1 divided by MSE). The peak signal value is 1.0.", "level2_prompt": "Calculate the Peak Signal-to-Noise Ratio (PSNR) between two arrays. Given two arrays A and B of equal length N, compute the squared difference for each element (A_i - B_i)^2, sum these squared differences, and divide by N to get the mean squared error (MSE). Then compute PSNR as 10 * log10(1 / MSE).", "level3_prompt": "Compute the PSNR between two images."}
{"id": 469, "task_name": "PSNR", "task_description": "Compute the PSNR kernel on GPU using CUDA.", "inputs": [{"name": "inputImage", "dtype": "float32", "shape": "(16777216,)"}, {"name": "compressedInputImage", "dtype": "float32", "shape": "(16777216,)"}], "outputs": [{"name": "psnr_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cmath>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <string>\n\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE 32\n#endif\n\n__device__ __forceinline__ float blockReduceSum(float val, float* sdata) {\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n    sdata[tid] = val;\n    __syncthreads();\n\n    for (int stride = nthreads / 2; stride > 0; stride >>= 1) {\n        if (tid < stride) sdata[tid] += sdata[tid + stride];\n        __syncthreads();\n    }\n    return sdata[0];\n}\n\n__global__ void k_peakSignalToNoiseRatio(float *inputImage, float *compressedInputImage,\n                                         float *peakToNoiseRatio,\n                                         const int imageWidth, const int imageHeight) {\n    extern __shared__ float sdata[];\n\n    int tid = threadIdx.y * blockDim.x + threadIdx.x;\n    int nthreads = blockDim.x * blockDim.y;\n\n    int N = imageWidth * imageHeight;\n\n    float local = 0.0f;\n    for (int idx = tid; idx < N; idx += nthreads) {\n        float d = inputImage[idx] - compressedInputImage[idx];\n        local += d * d;\n    }\n\n    float sse = blockReduceSum(local, sdata);\n\n    if (tid == 0) {\n        float mse = sse / (float)N;\n        float psnr = 10.0f * log10f(1.0f / mse);\n        peakToNoiseRatio[0] = psnr;\n    }\n}\n\nstatic void read_binary_f32(const std::string& filename, float* data, size_t count) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Cannot open: \" << filename << std::endl;\n        std::exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), (std::streamsize)(count * sizeof(float)));\n    in.close();\n}\n\nstatic void write_binary_f32(const std::string& filename, const float* data, size_t count) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Cannot write: \" << filename << std::endl;\n        std::exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), (std::streamsize)(count * sizeof(float)));\n    out.close();\n}\n\nint main() {\n    const int W = 4096;\n    const int H = 4096;\n    const int N = W * H;\n\n    float* h_in = (float*)malloc((size_t)N * sizeof(float));\n    float* h_cmp = (float*)malloc((size_t)N * sizeof(float));\n    float  h_out = 0.0f;\n\n    read_binary_f32(\"data/inputImage.bin\", h_in, (size_t)N);\n    read_binary_f32(\"data/compressedInputImage.bin\", h_cmp, (size_t)N);\n\n    float *d_in = nullptr, *d_cmp = nullptr, *d_psnr = nullptr;\n    cudaMalloc(&d_in, (size_t)N * sizeof(float));\n    cudaMalloc(&d_cmp, (size_t)N * sizeof(float));\n    cudaMalloc(&d_psnr, sizeof(float));\n\n    cudaMemcpy(d_in, h_in, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_cmp, h_cmp, (size_t)N * sizeof(float), cudaMemcpyHostToDevice);\n\n    dim3 block(BLOCK_SIZE, BLOCK_SIZE, 1);\n    dim3 grid(1, 1, 1);\n    size_t smem = (size_t)(BLOCK_SIZE * BLOCK_SIZE) * sizeof(float);\n\n    k_peakSignalToNoiseRatio<<<grid, block, smem>>>(d_in, d_cmp, d_psnr, W, H);\n\n    cudaMemcpy(&h_out, d_psnr, sizeof(float), cudaMemcpyDeviceToHost);\n\n    write_binary_f32(\"data/psnr_out.bin\", &h_out, 1);\n\n    cudaFree(d_in);\n    cudaFree(d_cmp);\n    cudaFree(d_psnr);\n    free(h_in);\n    free(h_cmp);\n    return 0;\n}\n", "gen.py": "import os\nimport numpy as np\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nW = 4096\nH = 4096\nN = W * H\n\nimage_a = np.random.rand(N).astype(np.float32) * 10\nimage_b = np.random.rand(N).astype(np.float32) * 20\n\ndiff = image_a - image_b\nmse = float(np.mean(diff * diff))\npsnr = np.float32(10.0 * np.log10(1.0 / mse))\n\nimage_a.tofile(\"data/inputImage.bin\")\nimage_b.tofile(\"data/compressedInputImage.bin\")\nnp.array([psnr], dtype=np.float32).tofile(\"data/psnr_ref.bin\")\n", "compare.py": "import os\nimport numpy as np\n\ndef read_f32(path, count):\n    return np.fromfile(path, dtype=np.float32, count=count)\n\ndef compare_scalar(out_path, ref_path, tol=1e-3):\n    if not os.path.exists(out_path) or not os.path.exists(ref_path):\n        return False\n    out = read_f32(out_path, 1)\n    ref = read_f32(ref_path, 1)\n    if out.shape != ref.shape:\n        return False\n    return bool(np.abs(out[0] - ref[0]) <= tol)\n\nif __name__ == \"__main__\":\n    ok = compare_scalar(\"data/psnr_out.bin\", \"data/psnr_ref.bin\", tol=1e-3)\n    print(\"T\" if ok else \"F\")\n", "level1_prompt": "Implement a CUDA kernel to compute the Peak Signal-to-Noise Ratio (PSNR) between two images. The inputs are two 1D float32 tensors named 'inputImage' and 'compressedInputImage', each with 16777216 elements representing flattened image pixel values. The output is a single float32 scalar named 'psnr_out'. The kernel must calculate the sum of squared differences between corresponding elements, compute the mean squared error, and derive the PSNR using the formula 10 * log10(1 / MSE). Ensure the implementation handles the large dataset efficiently through parallel reduction.", "level2_prompt": "Compute the Peak Signal-to-Noise Ratio (PSNR) between two images. Given two float32 arrays A and B of length N, calculate SSE = Σ(Aᵢ - Bᵢ)², then MSE = SSE / N. Finally, compute PSNR = 10 × log₁₀(1 / MSE). Output the result as a single float32 value.", "level3_prompt": "Compute the PSNR kernel on GPU using CUDA."}
{"id": 470, "task_name": "Black_Scholes", "task_description": "Compute the Black_Scholes kernel on GPU using CUDA.", "inputs": [{"name": "stock_price", "dtype": "float32", "shape": "(1048576,)"}, {"name": "option_strike", "dtype": "float32", "shape": "(1048576,)"}, {"name": "option_years", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "call_out", "dtype": "float32", "shape": "(1048576,)"}, {"name": "put_out", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <math.h>\n\n#define OPT_N 1048576\n#define RISKFREE 0.02f\n#define VOLATILITY 0.30f\n\n////////////////////////////////////////////////////////////////////////////////\n// Polynomial approximation of cumulative normal distribution function\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline float cndGPU(float d)\n{\n    const float A1       = 0.31938153f;\n    const float A2       = -0.356563782f;\n    const float A3       = 1.781477937f;\n    const float A4       = -1.821255978f;\n    const float A5       = 1.330274429f;\n    const float RSQRT2PI = 0.39894228040143267793994605993438f;\n\n    float K = __fdividef(1.0f, (1.0f + 0.2316419f * fabsf(d)));\n\n    float cnd = RSQRT2PI * __expf(-0.5f * d * d) * (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5)))));\n\n    if (d > 0)\n        cnd = 1.0f - cnd;\n\n    return cnd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Black-Scholes formula for both call and put\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline void BlackScholesBodyGPU(float &CallResult,\n                                           float &PutResult,\n                                           float  S, // Stock price\n                                           float  X, // Option strike\n                                           float  T, // Option years\n                                           float  R, // Riskless rate\n                                           float  V  // Volatility rate\n)\n{\n    float sqrtT, expRT;\n    float d1, d2, CNDD1, CNDD2;\n\n    sqrtT = __fdividef(1.0F, rsqrtf(T));\n    d1    = __fdividef(__logf(S / X) + (R + 0.5f * V * V) * T, V * sqrtT);\n    d2    = d1 - V * sqrtT;\n\n    CNDD1 = cndGPU(d1);\n    CNDD2 = cndGPU(d2);\n\n    // Calculate Call and Put simultaneously\n    expRT      = __expf(-R * T);\n    CallResult = S * CNDD1 - X * expRT * CNDD2;\n    PutResult  = X * expRT * (1.0f - CNDD2) - S * (1.0f - CNDD1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Process an array of optN options on GPU\n////////////////////////////////////////////////////////////////////////////////\n__global__ void BlackScholesGPU(float2 *__restrict d_CallResult,\n                                                       float2 *__restrict d_PutResult,\n                                                       float2 *__restrict d_StockPrice,\n                                                       float2 *__restrict d_OptionStrike,\n                                                       float2 *__restrict d_OptionYears,\n                                                       float Riskfree,\n                                                       float Volatility,\n                                                       int   optN)\n{\n    const int opt = blockDim.x * blockIdx.x + threadIdx.x;\n\n    // Calculating 2 options per thread to increase ILP\n    if (opt < (optN / 2)) {\n        float callResult1, callResult2;\n        float putResult1, putResult2;\n        \n        // Process first element of float2\n        BlackScholesBodyGPU(callResult1,\n                            putResult1,\n                            d_StockPrice[opt].x,\n                            d_OptionStrike[opt].x,\n                            d_OptionYears[opt].x,\n                            Riskfree,\n                            Volatility);\n        \n        // Process second element of float2\n        BlackScholesBodyGPU(callResult2,\n                            putResult2,\n                            d_StockPrice[opt].y,\n                            d_OptionStrike[opt].y,\n                            d_OptionYears[opt].y,\n                            Riskfree,\n                            Volatility);\n                            \n        d_CallResult[opt] = make_float2(callResult1, callResult2);\n        d_PutResult[opt]  = make_float2(putResult1, putResult2);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int optN = OPT_N;\n    size_t bytes = optN * sizeof(float);\n\n    float *h_S = new float[optN];\n    float *h_X = new float[optN];\n    float *h_T = new float[optN];\n    float *h_Call = new float[optN];\n    float *h_Put = new float[optN];\n\n    read_binary(\"data/stock_price.bin\", h_S, optN);\n    read_binary(\"data/option_strike.bin\", h_X, optN);\n    read_binary(\"data/option_years.bin\", h_T, optN);\n\n    float *d_S, *d_X, *d_T, *d_Call, *d_Put;\n    cudaMalloc(&d_S, bytes);\n    cudaMalloc(&d_X, bytes);\n    cudaMalloc(&d_T, bytes);\n    cudaMalloc(&d_Call, bytes);\n    cudaMalloc(&d_Put, bytes);\n\n    cudaMemcpy(d_S, h_S, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_X, h_X, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_T, h_T, bytes, cudaMemcpyHostToDevice);\n\n    // Launch configuration\n    // Since we process 2 options per thread using float2\n    int threads = 128;\n    int blocks = (optN / 2 + threads - 1) / threads;\n\n    // Cast float* to float2* for the kernel\n    BlackScholesGPU<<<blocks, threads>>>(\n        (float2*)d_Call,\n        (float2*)d_Put,\n        (float2*)d_S,\n        (float2*)d_X,\n        (float2*)d_T,\n        RISKFREE,\n        VOLATILITY,\n        optN\n    );\n\n    cudaMemcpy(h_Call, d_Call, bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_Put, d_Put, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/call_out.bin\", h_Call, optN);\n    write_binary(\"data/put_out.bin\", h_Put, optN);\n\n    cudaFree(d_S);\n    cudaFree(d_X);\n    cudaFree(d_T);\n    cudaFree(d_Call);\n    cudaFree(d_Put);\n    delete[] h_S;\n    delete[] h_X;\n    delete[] h_T;\n    delete[] h_Call;\n    delete[] h_Put;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport scipy.stats as si\nimport os\n\ndef black_scholes_reference(S, X, T, r, v):\n    d1 = (np.log(S / X) + (r + 0.5 * v**2) * T) / (v * np.sqrt(T))\n    d2 = d1 - v * np.sqrt(T)\n    \n    # Cumulative normal distribution\n    call = S * si.norm.cdf(d1) - X * np.exp(-r * T) * si.norm.cdf(d2)\n    put = X * np.exp(-r * T) * si.norm.cdf(-d2) - S * si.norm.cdf(-d1)\n    \n    return call.astype(np.float32), put.astype(np.float32)\n\nif __name__ == \"__main__\":\n    os.makedirs(\"data\", exist_ok=True)\n    \n    opt_n = 1048576  # Must be even for float2 optimization\n    r = 0.02\n    v = 0.30\n\n    np.random.seed(42)\n    S = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    X = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    T = np.random.uniform(0.1, 2.0, opt_n).astype(np.float32)\n\n    call_ref, put_ref = black_scholes_reference(S, X, T, r, v)\n\n    S.tofile(\"data/stock_price.bin\")\n    X.tofile(\"data/option_strike.bin\")\n    T.tofile(\"data/option_years.bin\")\n    call_ref.tofile(\"data/call_ref.bin\")\n    put_ref.tofile(\"data/put_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    # Use higher tolerance because GPU uses polynomial approximation for CDF\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    opt_n = 1048576\n\n    c_file = \"data/call_out.bin\"\n    c_ref = \"data/call_ref.bin\"\n    \n    p_file = \"data/put_out.bin\"\n    p_ref = \"data/put_ref.bin\"\n\n    c_ok = compare_outputs(c_file, c_ref, opt_n)\n    p_ok = compare_outputs(p_file, p_ref, opt_n)\n\n    if c_ok and p_ok:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Black_Scholes kernel for pricing European options. The kernel must compute call and put option prices using the Black-Scholes model. Inputs include three float32 vectors of length 1048576: stock_price (current stock price), option_strike (strike price), and option_years (time to expiration in years). Outputs are two float32 vectors of length 1048576: call_out (call option prices) and put_out (put option prices). The risk-free rate is fixed at 0.02 and volatility at 0.30. The kernel must use a polynomial approximation for the cumulative normal distribution function and process two options per thread for efficiency. The total number of options must be even.", "level2_prompt": "Compute European option prices using the Black-Scholes formula. For each option, calculate d1 = (ln(S/X) + (r + 0.5v²)T) / (v√T) and d2 = d1 - v√T. Then compute call price as S·CND(d1) - X·e^(-rT)·CND(d2) and put price as X·e^(-rT)·CND(-d2) - S·CND(-d1), where CND is a polynomial approximation of the cumulative normal distribution. Risk-free rate r=0.02 and volatility v=0.30 are constant for all options.", "level3_prompt": "Compute the Black_Scholes kernel on GPU using CUDA."}
{"id": 471, "task_name": "Black_Scholes", "task_description": "Compute the Black_Scholes kernel on GPU using CUDA.", "inputs": [{"name": "stock_price", "dtype": "float32", "shape": "(2097152,)"}, {"name": "option_strike", "dtype": "float32", "shape": "(2097152,)"}, {"name": "option_years", "dtype": "float32", "shape": "(2097152,)"}], "outputs": [{"name": "call_out", "dtype": "float32", "shape": "(2097152,)"}, {"name": "put_out", "dtype": "float32", "shape": "(2097152,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <math.h>\n\n#define OPT_N 2097152\n#define RISKFREE 0.02f\n#define VOLATILITY 0.30f\n\n////////////////////////////////////////////////////////////////////////////////\n// Polynomial approximation of cumulative normal distribution function\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline float cndGPU(float d)\n{\n    const float A1       = 0.31938153f;\n    const float A2       = -0.356563782f;\n    const float A3       = 1.781477937f;\n    const float A4       = -1.821255978f;\n    const float A5       = 1.330274429f;\n    const float RSQRT2PI = 0.39894228040143267793994605993438f;\n\n    float K = __fdividef(1.0f, (1.0f + 0.2316419f * fabsf(d)));\n\n    float cnd = RSQRT2PI * __expf(-0.5f * d * d) * (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5)))));\n\n    if (d > 0)\n        cnd = 1.0f - cnd;\n\n    return cnd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Black-Scholes formula for both call and put\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline void BlackScholesBodyGPU(float &CallResult,\n                                           float &PutResult,\n                                           float  S, // Stock price\n                                           float  X, // Option strike\n                                           float  T, // Option years\n                                           float  R, // Riskless rate\n                                           float  V  // Volatility rate\n)\n{\n    float sqrtT, expRT;\n    float d1, d2, CNDD1, CNDD2;\n\n    sqrtT = __fdividef(1.0F, rsqrtf(T));\n    d1    = __fdividef(__logf(S / X) + (R + 0.5f * V * V) * T, V * sqrtT);\n    d2    = d1 - V * sqrtT;\n\n    CNDD1 = cndGPU(d1);\n    CNDD2 = cndGPU(d2);\n\n    // Calculate Call and Put simultaneously\n    expRT      = __expf(-R * T);\n    CallResult = S * CNDD1 - X * expRT * CNDD2;\n    PutResult  = X * expRT * (1.0f - CNDD2) - S * (1.0f - CNDD1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Process an array of optN options on GPU\n////////////////////////////////////////////////////////////////////////////////\n__global__ void BlackScholesGPU(float2 *__restrict d_CallResult,\n                                                       float2 *__restrict d_PutResult,\n                                                       float2 *__restrict d_StockPrice,\n                                                       float2 *__restrict d_OptionStrike,\n                                                       float2 *__restrict d_OptionYears,\n                                                       float Riskfree,\n                                                       float Volatility,\n                                                       int   optN)\n{\n    const int opt = blockDim.x * blockIdx.x + threadIdx.x;\n\n    // Calculating 2 options per thread to increase ILP\n    if (opt < (optN / 2)) {\n        float callResult1, callResult2;\n        float putResult1, putResult2;\n        \n        // Process first element of float2\n        BlackScholesBodyGPU(callResult1,\n                            putResult1,\n                            d_StockPrice[opt].x,\n                            d_OptionStrike[opt].x,\n                            d_OptionYears[opt].x,\n                            Riskfree,\n                            Volatility);\n        \n        // Process second element of float2\n        BlackScholesBodyGPU(callResult2,\n                            putResult2,\n                            d_StockPrice[opt].y,\n                            d_OptionStrike[opt].y,\n                            d_OptionYears[opt].y,\n                            Riskfree,\n                            Volatility);\n                            \n        d_CallResult[opt] = make_float2(callResult1, callResult2);\n        d_PutResult[opt]  = make_float2(putResult1, putResult2);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int optN = OPT_N;\n    size_t bytes = optN * sizeof(float);\n\n    float *h_S = new float[optN];\n    float *h_X = new float[optN];\n    float *h_T = new float[optN];\n    float *h_Call = new float[optN];\n    float *h_Put = new float[optN];\n\n    read_binary(\"data/stock_price.bin\", h_S, optN);\n    read_binary(\"data/option_strike.bin\", h_X, optN);\n    read_binary(\"data/option_years.bin\", h_T, optN);\n\n    float *d_S, *d_X, *d_T, *d_Call, *d_Put;\n    cudaMalloc(&d_S, bytes);\n    cudaMalloc(&d_X, bytes);\n    cudaMalloc(&d_T, bytes);\n    cudaMalloc(&d_Call, bytes);\n    cudaMalloc(&d_Put, bytes);\n\n    cudaMemcpy(d_S, h_S, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_X, h_X, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_T, h_T, bytes, cudaMemcpyHostToDevice);\n\n    // Launch configuration\n    // Since we process 2 options per thread using float2\n    int threads = 128;\n    int blocks = (optN / 2 + threads - 1) / threads;\n\n    // Cast float* to float2* for the kernel\n    BlackScholesGPU<<<blocks, threads>>>(\n        (float2*)d_Call,\n        (float2*)d_Put,\n        (float2*)d_S,\n        (float2*)d_X,\n        (float2*)d_T,\n        RISKFREE,\n        VOLATILITY,\n        optN\n    );\n\n    cudaMemcpy(h_Call, d_Call, bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_Put, d_Put, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/call_out.bin\", h_Call, optN);\n    write_binary(\"data/put_out.bin\", h_Put, optN);\n\n    cudaFree(d_S);\n    cudaFree(d_X);\n    cudaFree(d_T);\n    cudaFree(d_Call);\n    cudaFree(d_Put);\n    delete[] h_S;\n    delete[] h_X;\n    delete[] h_T;\n    delete[] h_Call;\n    delete[] h_Put;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport scipy.stats as si\nimport os\n\ndef black_scholes_reference(S, X, T, r, v):\n    d1 = (np.log(S / X) + (r + 0.5 * v**2) * T) / (v * np.sqrt(T))\n    d2 = d1 - v * np.sqrt(T)\n    \n    # Cumulative normal distribution\n    call = S * si.norm.cdf(d1) - X * np.exp(-r * T) * si.norm.cdf(d2)\n    put = X * np.exp(-r * T) * si.norm.cdf(-d2) - S * si.norm.cdf(-d1)\n    \n    return call.astype(np.float32), put.astype(np.float32)\n\nif __name__ == \"__main__\":\n    os.makedirs(\"data\", exist_ok=True)\n    \n    opt_n = 2097152  # Must be even for float2 optimization\n    r = 0.02\n    v = 0.30\n\n    np.random.seed(42)\n    S = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    X = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    T = np.random.uniform(0.1, 2.0, opt_n).astype(np.float32)\n\n    call_ref, put_ref = black_scholes_reference(S, X, T, r, v)\n\n    S.tofile(\"data/stock_price.bin\")\n    X.tofile(\"data/option_strike.bin\")\n    T.tofile(\"data/option_years.bin\")\n    call_ref.tofile(\"data/call_ref.bin\")\n    put_ref.tofile(\"data/put_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    # Use higher tolerance because GPU uses polynomial approximation for CDF\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    opt_n = 2097152\n\n    c_file = \"data/call_out.bin\"\n    c_ref = \"data/call_ref.bin\"\n    \n    p_file = \"data/put_out.bin\"\n    p_ref = \"data/put_ref.bin\"\n\n    c_ok = compare_outputs(c_file, c_ref, opt_n)\n    p_ok = compare_outputs(p_file, p_ref, opt_n)\n\n    if c_ok and p_ok:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Black_Scholes. Implement a CUDA kernel to compute call and put option prices using the Black-Scholes model for a batch of 2097152 options. Inputs include three float32 tensors of shape (2097152,): stock_price, option_strike, and option_years. Outputs are two float32 tensors of the same shape: call_out and put_out. The kernel must use a fixed risk-free rate of 0.02 and volatility rate of 0.30. It must employ a polynomial approximation for the cumulative normal distribution function and process two options per thread for efficiency.", "level2_prompt": "Task: Black_Scholes. For each option, calculate call and put prices using the Black-Scholes formula. Given stock price S, strike price X, and time to maturity T, compute d1 = (ln(S/X) + (R + 0.5*V²)*T) / (V*sqrt(T)) and d2 = d1 - V*sqrt(T), where R=0.02 and V=0.30. Then evaluate the cumulative normal distribution for d1 and d2. The call price is S*CND(d1) - X*exp(-R*T)*CND(d2), and the put price is X*exp(-R*T)*CND(-d2) - S*CND(-d1).", "level3_prompt": "Compute the Black_Scholes kernel on GPU using CUDA."}
{"id": 472, "task_name": "Black_Scholes", "task_description": "Compute the Black_Scholes kernel on GPU using CUDA.", "inputs": [{"name": "stock_price", "dtype": "float32", "shape": "(4194304,)"}, {"name": "option_strike", "dtype": "float32", "shape": "(4194304,)"}, {"name": "option_years", "dtype": "float32", "shape": "(4194304,)"}], "outputs": [{"name": "call_out", "dtype": "float32", "shape": "(4194304,)"}, {"name": "put_out", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <math.h>\n\n#define OPT_N 4194304\n#define RISKFREE 0.02f\n#define VOLATILITY 0.30f\n\n////////////////////////////////////////////////////////////////////////////////\n// Polynomial approximation of cumulative normal distribution function\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline float cndGPU(float d)\n{\n    const float A1       = 0.31938153f;\n    const float A2       = -0.356563782f;\n    const float A3       = 1.781477937f;\n    const float A4       = -1.821255978f;\n    const float A5       = 1.330274429f;\n    const float RSQRT2PI = 0.39894228040143267793994605993438f;\n\n    float K = __fdividef(1.0f, (1.0f + 0.2316419f * fabsf(d)));\n\n    float cnd = RSQRT2PI * __expf(-0.5f * d * d) * (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5)))));\n\n    if (d > 0)\n        cnd = 1.0f - cnd;\n\n    return cnd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Black-Scholes formula for both call and put\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline void BlackScholesBodyGPU(float &CallResult,\n                                           float &PutResult,\n                                           float  S, // Stock price\n                                           float  X, // Option strike\n                                           float  T, // Option years\n                                           float  R, // Riskless rate\n                                           float  V  // Volatility rate\n)\n{\n    float sqrtT, expRT;\n    float d1, d2, CNDD1, CNDD2;\n\n    sqrtT = __fdividef(1.0F, rsqrtf(T));\n    d1    = __fdividef(__logf(S / X) + (R + 0.5f * V * V) * T, V * sqrtT);\n    d2    = d1 - V * sqrtT;\n\n    CNDD1 = cndGPU(d1);\n    CNDD2 = cndGPU(d2);\n\n    // Calculate Call and Put simultaneously\n    expRT      = __expf(-R * T);\n    CallResult = S * CNDD1 - X * expRT * CNDD2;\n    PutResult  = X * expRT * (1.0f - CNDD2) - S * (1.0f - CNDD1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Process an array of optN options on GPU\n////////////////////////////////////////////////////////////////////////////////\n__global__ void BlackScholesGPU(float2 *__restrict d_CallResult,\n                                                       float2 *__restrict d_PutResult,\n                                                       float2 *__restrict d_StockPrice,\n                                                       float2 *__restrict d_OptionStrike,\n                                                       float2 *__restrict d_OptionYears,\n                                                       float Riskfree,\n                                                       float Volatility,\n                                                       int   optN)\n{\n    const int opt = blockDim.x * blockIdx.x + threadIdx.x;\n\n    // Calculating 2 options per thread to increase ILP\n    if (opt < (optN / 2)) {\n        float callResult1, callResult2;\n        float putResult1, putResult2;\n        \n        // Process first element of float2\n        BlackScholesBodyGPU(callResult1,\n                            putResult1,\n                            d_StockPrice[opt].x,\n                            d_OptionStrike[opt].x,\n                            d_OptionYears[opt].x,\n                            Riskfree,\n                            Volatility);\n        \n        // Process second element of float2\n        BlackScholesBodyGPU(callResult2,\n                            putResult2,\n                            d_StockPrice[opt].y,\n                            d_OptionStrike[opt].y,\n                            d_OptionYears[opt].y,\n                            Riskfree,\n                            Volatility);\n                            \n        d_CallResult[opt] = make_float2(callResult1, callResult2);\n        d_PutResult[opt]  = make_float2(putResult1, putResult2);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int optN = OPT_N;\n    size_t bytes = optN * sizeof(float);\n\n    float *h_S = new float[optN];\n    float *h_X = new float[optN];\n    float *h_T = new float[optN];\n    float *h_Call = new float[optN];\n    float *h_Put = new float[optN];\n\n    read_binary(\"data/stock_price.bin\", h_S, optN);\n    read_binary(\"data/option_strike.bin\", h_X, optN);\n    read_binary(\"data/option_years.bin\", h_T, optN);\n\n    float *d_S, *d_X, *d_T, *d_Call, *d_Put;\n    cudaMalloc(&d_S, bytes);\n    cudaMalloc(&d_X, bytes);\n    cudaMalloc(&d_T, bytes);\n    cudaMalloc(&d_Call, bytes);\n    cudaMalloc(&d_Put, bytes);\n\n    cudaMemcpy(d_S, h_S, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_X, h_X, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_T, h_T, bytes, cudaMemcpyHostToDevice);\n\n    // Launch configuration\n    // Since we process 2 options per thread using float2\n    int threads = 128;\n    int blocks = (optN / 2 + threads - 1) / threads;\n\n    // Cast float* to float2* for the kernel\n    BlackScholesGPU<<<blocks, threads>>>(\n        (float2*)d_Call,\n        (float2*)d_Put,\n        (float2*)d_S,\n        (float2*)d_X,\n        (float2*)d_T,\n        RISKFREE,\n        VOLATILITY,\n        optN\n    );\n\n    cudaMemcpy(h_Call, d_Call, bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_Put, d_Put, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/call_out.bin\", h_Call, optN);\n    write_binary(\"data/put_out.bin\", h_Put, optN);\n\n    cudaFree(d_S);\n    cudaFree(d_X);\n    cudaFree(d_T);\n    cudaFree(d_Call);\n    cudaFree(d_Put);\n    delete[] h_S;\n    delete[] h_X;\n    delete[] h_T;\n    delete[] h_Call;\n    delete[] h_Put;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport scipy.stats as si\nimport os\n\ndef black_scholes_reference(S, X, T, r, v):\n    d1 = (np.log(S / X) + (r + 0.5 * v**2) * T) / (v * np.sqrt(T))\n    d2 = d1 - v * np.sqrt(T)\n    \n    # Cumulative normal distribution\n    call = S * si.norm.cdf(d1) - X * np.exp(-r * T) * si.norm.cdf(d2)\n    put = X * np.exp(-r * T) * si.norm.cdf(-d2) - S * si.norm.cdf(-d1)\n    \n    return call.astype(np.float32), put.astype(np.float32)\n\nif __name__ == \"__main__\":\n    os.makedirs(\"data\", exist_ok=True)\n    \n    opt_n = 4194304  # Must be even for float2 optimization\n    r = 0.02\n    v = 0.30\n\n    np.random.seed(42)\n    S = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    X = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    T = np.random.uniform(0.1, 2.0, opt_n).astype(np.float32)\n\n    call_ref, put_ref = black_scholes_reference(S, X, T, r, v)\n\n    S.tofile(\"data/stock_price.bin\")\n    X.tofile(\"data/option_strike.bin\")\n    T.tofile(\"data/option_years.bin\")\n    call_ref.tofile(\"data/call_ref.bin\")\n    put_ref.tofile(\"data/put_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    # Use higher tolerance because GPU uses polynomial approximation for CDF\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    opt_n = 4194304\n\n    c_file = \"data/call_out.bin\"\n    c_ref = \"data/call_ref.bin\"\n    \n    p_file = \"data/put_out.bin\"\n    p_ref = \"data/put_ref.bin\"\n\n    c_ok = compare_outputs(c_file, c_ref, opt_n)\n    p_ok = compare_outputs(p_file, p_ref, opt_n)\n\n    if c_ok and p_ok:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Black_Scholes kernel to compute call and put option prices using the Black-Scholes model. Inputs include three float32 vectors of length 4194304: stock_price, option_strike, and option_years. Outputs must be two float32 vectors of length 4194304: call_out for call option prices and put_out for put option prices. The kernel must use a polynomial approximation for the cumulative normal distribution function with fixed constants (A1-A5 and RSQRT2PI), process two options per thread for increased ILP, and use fixed risk-free rate (0.02) and volatility (0.30) parameters. Input size must be even.", "level2_prompt": "Compute Black-Scholes option prices where each thread calculates two options. For each option, compute d1 = (ln(S/X) + (r + 0.5*v²)*T) / (v*sqrt(T)) and d2 = d1 - v*sqrt(T). Then calculate call price = S*CND(d1) - X*exp(-r*T)*CND(d2) and put price = X*exp(-r*T)*CND(-d2) - S*CND(-d1), where CND is a polynomial approximation of the cumulative normal distribution function using specified constants.", "level3_prompt": "Compute the Black-Scholes option pricing model for call and put options."}
{"id": 473, "task_name": "Black_Scholes", "task_description": "Compute the Black_Scholes kernel on GPU using CUDA.", "inputs": [{"name": "stock_price", "dtype": "float32", "shape": "(8388608,)"}, {"name": "option_strike", "dtype": "float32", "shape": "(8388608,)"}, {"name": "option_years", "dtype": "float32", "shape": "(8388608,)"}], "outputs": [{"name": "call_out", "dtype": "float32", "shape": "(8388608,)"}, {"name": "put_out", "dtype": "float32", "shape": "(8388608,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <math.h>\n\n#define OPT_N 8388608\n#define RISKFREE 0.02f\n#define VOLATILITY 0.30f\n\n////////////////////////////////////////////////////////////////////////////////\n// Polynomial approximation of cumulative normal distribution function\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline float cndGPU(float d)\n{\n    const float A1       = 0.31938153f;\n    const float A2       = -0.356563782f;\n    const float A3       = 1.781477937f;\n    const float A4       = -1.821255978f;\n    const float A5       = 1.330274429f;\n    const float RSQRT2PI = 0.39894228040143267793994605993438f;\n\n    float K = __fdividef(1.0f, (1.0f + 0.2316419f * fabsf(d)));\n\n    float cnd = RSQRT2PI * __expf(-0.5f * d * d) * (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5)))));\n\n    if (d > 0)\n        cnd = 1.0f - cnd;\n\n    return cnd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Black-Scholes formula for both call and put\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline void BlackScholesBodyGPU(float &CallResult,\n                                           float &PutResult,\n                                           float  S, // Stock price\n                                           float  X, // Option strike\n                                           float  T, // Option years\n                                           float  R, // Riskless rate\n                                           float  V  // Volatility rate\n)\n{\n    float sqrtT, expRT;\n    float d1, d2, CNDD1, CNDD2;\n\n    sqrtT = __fdividef(1.0F, rsqrtf(T));\n    d1    = __fdividef(__logf(S / X) + (R + 0.5f * V * V) * T, V * sqrtT);\n    d2    = d1 - V * sqrtT;\n\n    CNDD1 = cndGPU(d1);\n    CNDD2 = cndGPU(d2);\n\n    // Calculate Call and Put simultaneously\n    expRT      = __expf(-R * T);\n    CallResult = S * CNDD1 - X * expRT * CNDD2;\n    PutResult  = X * expRT * (1.0f - CNDD2) - S * (1.0f - CNDD1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Process an array of optN options on GPU\n////////////////////////////////////////////////////////////////////////////////\n__global__ void BlackScholesGPU(float2 *__restrict d_CallResult,\n                                                       float2 *__restrict d_PutResult,\n                                                       float2 *__restrict d_StockPrice,\n                                                       float2 *__restrict d_OptionStrike,\n                                                       float2 *__restrict d_OptionYears,\n                                                       float Riskfree,\n                                                       float Volatility,\n                                                       int   optN)\n{\n    const int opt = blockDim.x * blockIdx.x + threadIdx.x;\n\n    // Calculating 2 options per thread to increase ILP\n    if (opt < (optN / 2)) {\n        float callResult1, callResult2;\n        float putResult1, putResult2;\n        \n        // Process first element of float2\n        BlackScholesBodyGPU(callResult1,\n                            putResult1,\n                            d_StockPrice[opt].x,\n                            d_OptionStrike[opt].x,\n                            d_OptionYears[opt].x,\n                            Riskfree,\n                            Volatility);\n        \n        // Process second element of float2\n        BlackScholesBodyGPU(callResult2,\n                            putResult2,\n                            d_StockPrice[opt].y,\n                            d_OptionStrike[opt].y,\n                            d_OptionYears[opt].y,\n                            Riskfree,\n                            Volatility);\n                            \n        d_CallResult[opt] = make_float2(callResult1, callResult2);\n        d_PutResult[opt]  = make_float2(putResult1, putResult2);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int optN = OPT_N;\n    size_t bytes = optN * sizeof(float);\n\n    float *h_S = new float[optN];\n    float *h_X = new float[optN];\n    float *h_T = new float[optN];\n    float *h_Call = new float[optN];\n    float *h_Put = new float[optN];\n\n    read_binary(\"data/stock_price.bin\", h_S, optN);\n    read_binary(\"data/option_strike.bin\", h_X, optN);\n    read_binary(\"data/option_years.bin\", h_T, optN);\n\n    float *d_S, *d_X, *d_T, *d_Call, *d_Put;\n    cudaMalloc(&d_S, bytes);\n    cudaMalloc(&d_X, bytes);\n    cudaMalloc(&d_T, bytes);\n    cudaMalloc(&d_Call, bytes);\n    cudaMalloc(&d_Put, bytes);\n\n    cudaMemcpy(d_S, h_S, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_X, h_X, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_T, h_T, bytes, cudaMemcpyHostToDevice);\n\n    // Launch configuration\n    // Since we process 2 options per thread using float2\n    int threads = 128;\n    int blocks = (optN / 2 + threads - 1) / threads;\n\n    // Cast float* to float2* for the kernel\n    BlackScholesGPU<<<blocks, threads>>>(\n        (float2*)d_Call,\n        (float2*)d_Put,\n        (float2*)d_S,\n        (float2*)d_X,\n        (float2*)d_T,\n        RISKFREE,\n        VOLATILITY,\n        optN\n    );\n\n    cudaMemcpy(h_Call, d_Call, bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_Put, d_Put, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/call_out.bin\", h_Call, optN);\n    write_binary(\"data/put_out.bin\", h_Put, optN);\n\n    cudaFree(d_S);\n    cudaFree(d_X);\n    cudaFree(d_T);\n    cudaFree(d_Call);\n    cudaFree(d_Put);\n    delete[] h_S;\n    delete[] h_X;\n    delete[] h_T;\n    delete[] h_Call;\n    delete[] h_Put;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport scipy.stats as si\nimport os\n\ndef black_scholes_reference(S, X, T, r, v):\n    d1 = (np.log(S / X) + (r + 0.5 * v**2) * T) / (v * np.sqrt(T))\n    d2 = d1 - v * np.sqrt(T)\n    \n    # Cumulative normal distribution\n    call = S * si.norm.cdf(d1) - X * np.exp(-r * T) * si.norm.cdf(d2)\n    put = X * np.exp(-r * T) * si.norm.cdf(-d2) - S * si.norm.cdf(-d1)\n    \n    return call.astype(np.float32), put.astype(np.float32)\n\nif __name__ == \"__main__\":\n    os.makedirs(\"data\", exist_ok=True)\n    \n    opt_n = 8388608  # Must be even for float2 optimization\n    r = 0.02\n    v = 0.30\n\n    np.random.seed(42)\n    S = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    X = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    T = np.random.uniform(0.1, 2.0, opt_n).astype(np.float32)\n\n    call_ref, put_ref = black_scholes_reference(S, X, T, r, v)\n\n    S.tofile(\"data/stock_price.bin\")\n    X.tofile(\"data/option_strike.bin\")\n    T.tofile(\"data/option_years.bin\")\n    call_ref.tofile(\"data/call_ref.bin\")\n    put_ref.tofile(\"data/put_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    # Use higher tolerance because GPU uses polynomial approximation for CDF\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    opt_n = 8388608\n\n    c_file = \"data/call_out.bin\"\n    c_ref = \"data/call_ref.bin\"\n    \n    p_file = \"data/put_out.bin\"\n    p_ref = \"data/put_ref.bin\"\n\n    c_ok = compare_outputs(c_file, c_ref, opt_n)\n    p_ok = compare_outputs(p_file, p_ref, opt_n)\n\n    if c_ok and p_ok:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task Name: Black_Scholes\nCompute call and put option prices for 8,388,608 elements using the Black-Scholes model. Inputs include three one-dimensional float32 arrays: stock_price (current stock price), option_strike (strike price), and option_years (time to expiration in years). Outputs include two one-dimensional float32 arrays: call_out (call option price) and put_out (put option price).\n\nThe Black-Scholes formulas are defined as:\ncall = S * N(d1) - X * exp(-r*T) * N(d2)\nput = X * exp(-r*T) * N(-d2) - S * N(-d1)\nwhere:\nd1 = (ln(S/X) + (r + 0.5*v^2)*T) / (v*sqrt(T))\nd2 = d1 - v*sqrt(T)\n\nFixed parameters: risk-free rate r=0.02, volatility v=0.30. The cumulative normal distribution function N must be approximated using a polynomial. Results must be computed independently for each element.", "level2_prompt": "Task Name: Black_Scholes\nFor each input element, compute call and put option prices using the Black-Scholes formula with fixed risk-free rate (0.02) and volatility (0.30). Inputs are stock price, option strike price, and time to expiration. Outputs are call price and put price. The cumulative normal distribution is approximated via polynomial function.", "level3_prompt": "Compute the Black-Scholes option pricing for call and put options."}
{"id": 474, "task_name": "Black_Scholes", "task_description": "Compute the Black_Scholes kernel on GPU using CUDA.", "inputs": [{"name": "stock_price", "dtype": "float32", "shape": "(16777216,)"}, {"name": "option_strike", "dtype": "float32", "shape": "(16777216,)"}, {"name": "option_years", "dtype": "float32", "shape": "(16777216,)"}], "outputs": [{"name": "call_out", "dtype": "float32", "shape": "(16777216,)"}, {"name": "put_out", "dtype": "float32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <math.h>\n\n#define OPT_N 16777216\n#define RISKFREE 0.02f\n#define VOLATILITY 0.30f\n\n////////////////////////////////////////////////////////////////////////////////\n// Polynomial approximation of cumulative normal distribution function\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline float cndGPU(float d)\n{\n    const float A1       = 0.31938153f;\n    const float A2       = -0.356563782f;\n    const float A3       = 1.781477937f;\n    const float A4       = -1.821255978f;\n    const float A5       = 1.330274429f;\n    const float RSQRT2PI = 0.39894228040143267793994605993438f;\n\n    float K = __fdividef(1.0f, (1.0f + 0.2316419f * fabsf(d)));\n\n    float cnd = RSQRT2PI * __expf(-0.5f * d * d) * (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5)))));\n\n    if (d > 0)\n        cnd = 1.0f - cnd;\n\n    return cnd;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Black-Scholes formula for both call and put\n////////////////////////////////////////////////////////////////////////////////\n__device__ inline void BlackScholesBodyGPU(float &CallResult,\n                                           float &PutResult,\n                                           float  S, // Stock price\n                                           float  X, // Option strike\n                                           float  T, // Option years\n                                           float  R, // Riskless rate\n                                           float  V  // Volatility rate\n)\n{\n    float sqrtT, expRT;\n    float d1, d2, CNDD1, CNDD2;\n\n    sqrtT = __fdividef(1.0F, rsqrtf(T));\n    d1    = __fdividef(__logf(S / X) + (R + 0.5f * V * V) * T, V * sqrtT);\n    d2    = d1 - V * sqrtT;\n\n    CNDD1 = cndGPU(d1);\n    CNDD2 = cndGPU(d2);\n\n    // Calculate Call and Put simultaneously\n    expRT      = __expf(-R * T);\n    CallResult = S * CNDD1 - X * expRT * CNDD2;\n    PutResult  = X * expRT * (1.0f - CNDD2) - S * (1.0f - CNDD1);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Process an array of optN options on GPU\n////////////////////////////////////////////////////////////////////////////////\n__global__ void BlackScholesGPU(float2 *__restrict d_CallResult,\n                                                       float2 *__restrict d_PutResult,\n                                                       float2 *__restrict d_StockPrice,\n                                                       float2 *__restrict d_OptionStrike,\n                                                       float2 *__restrict d_OptionYears,\n                                                       float Riskfree,\n                                                       float Volatility,\n                                                       int   optN)\n{\n    const int opt = blockDim.x * blockIdx.x + threadIdx.x;\n\n    // Calculating 2 options per thread to increase ILP\n    if (opt < (optN / 2)) {\n        float callResult1, callResult2;\n        float putResult1, putResult2;\n        \n        // Process first element of float2\n        BlackScholesBodyGPU(callResult1,\n                            putResult1,\n                            d_StockPrice[opt].x,\n                            d_OptionStrike[opt].x,\n                            d_OptionYears[opt].x,\n                            Riskfree,\n                            Volatility);\n        \n        // Process second element of float2\n        BlackScholesBodyGPU(callResult2,\n                            putResult2,\n                            d_StockPrice[opt].y,\n                            d_OptionStrike[opt].y,\n                            d_OptionYears[opt].y,\n                            Riskfree,\n                            Volatility);\n                            \n        d_CallResult[opt] = make_float2(callResult1, callResult2);\n        d_PutResult[opt]  = make_float2(putResult1, putResult2);\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int optN = OPT_N;\n    size_t bytes = optN * sizeof(float);\n\n    float *h_S = new float[optN];\n    float *h_X = new float[optN];\n    float *h_T = new float[optN];\n    float *h_Call = new float[optN];\n    float *h_Put = new float[optN];\n\n    read_binary(\"data/stock_price.bin\", h_S, optN);\n    read_binary(\"data/option_strike.bin\", h_X, optN);\n    read_binary(\"data/option_years.bin\", h_T, optN);\n\n    float *d_S, *d_X, *d_T, *d_Call, *d_Put;\n    cudaMalloc(&d_S, bytes);\n    cudaMalloc(&d_X, bytes);\n    cudaMalloc(&d_T, bytes);\n    cudaMalloc(&d_Call, bytes);\n    cudaMalloc(&d_Put, bytes);\n\n    cudaMemcpy(d_S, h_S, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_X, h_X, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_T, h_T, bytes, cudaMemcpyHostToDevice);\n\n    // Launch configuration\n    // Since we process 2 options per thread using float2\n    int threads = 128;\n    int blocks = (optN / 2 + threads - 1) / threads;\n\n    // Cast float* to float2* for the kernel\n    BlackScholesGPU<<<blocks, threads>>>(\n        (float2*)d_Call,\n        (float2*)d_Put,\n        (float2*)d_S,\n        (float2*)d_X,\n        (float2*)d_T,\n        RISKFREE,\n        VOLATILITY,\n        optN\n    );\n\n    cudaMemcpy(h_Call, d_Call, bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_Put, d_Put, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"data/call_out.bin\", h_Call, optN);\n    write_binary(\"data/put_out.bin\", h_Put, optN);\n\n    cudaFree(d_S);\n    cudaFree(d_X);\n    cudaFree(d_T);\n    cudaFree(d_Call);\n    cudaFree(d_Put);\n    delete[] h_S;\n    delete[] h_X;\n    delete[] h_T;\n    delete[] h_Call;\n    delete[] h_Put;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport scipy.stats as si\nimport os\n\ndef black_scholes_reference(S, X, T, r, v):\n    d1 = (np.log(S / X) + (r + 0.5 * v**2) * T) / (v * np.sqrt(T))\n    d2 = d1 - v * np.sqrt(T)\n    \n    # Cumulative normal distribution\n    call = S * si.norm.cdf(d1) - X * np.exp(-r * T) * si.norm.cdf(d2)\n    put = X * np.exp(-r * T) * si.norm.cdf(-d2) - S * si.norm.cdf(-d1)\n    \n    return call.astype(np.float32), put.astype(np.float32)\n\nif __name__ == \"__main__\":\n    os.makedirs(\"data\", exist_ok=True)\n    \n    opt_n = 16777216  # Must be even for float2 optimization\n    r = 0.02\n    v = 0.30\n\n    np.random.seed(42)\n    S = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    X = np.random.uniform(10.0, 100.0, opt_n).astype(np.float32)\n    T = np.random.uniform(0.1, 2.0, opt_n).astype(np.float32)\n\n    call_ref, put_ref = black_scholes_reference(S, X, T, r, v)\n\n    S.tofile(\"data/stock_price.bin\")\n    X.tofile(\"data/option_strike.bin\")\n    T.tofile(\"data/option_years.bin\")\n    call_ref.tofile(\"data/call_ref.bin\")\n    put_ref.tofile(\"data/put_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-3):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    # Use higher tolerance because GPU uses polynomial approximation for CDF\n    diff = np.abs(output - reference)\n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    opt_n = 16777216\n\n    c_file = \"data/call_out.bin\"\n    c_ref = \"data/call_ref.bin\"\n    \n    p_file = \"data/put_out.bin\"\n    p_ref = \"data/put_ref.bin\"\n\n    c_ok = compare_outputs(c_file, c_ref, opt_n)\n    p_ok = compare_outputs(p_file, p_ref, opt_n)\n\n    if c_ok and p_ok:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: Black_Scholes. The kernel computes call and put option prices using the Black-Scholes model. Inputs are three float32 arrays of size 16777216: stock_price (current stock price), option_strike (strike price), and option_years (time to maturity). Outputs are two float32 arrays of size 16777216: call_out (call option price) and put_out (put option price). Constraints: Fixed risk-free rate of 0.02 and volatility of 0.30 must be used. The cumulative normal distribution function is approximated with a polynomial, and outputs must match a reference within a tolerance of 1e-3.", "level2_prompt": "Task name: Black_Scholes. For each element, compute call and put option prices using the Black-Scholes formula. Given stock price S, strike price X, and time T, calculate d1 = (ln(S/X) + (0.02 + 0.5 * 0.30^2) * T) / (0.30 * sqrt(T)), d2 = d1 - 0.30 * sqrt(T). Then, call price = S * CND(d1) - X * exp(-0.02 * T) * CND(d2), put price = X * exp(-0.02 * T) * CND(-d2) - S * CND(-d1), where CND is the cumulative normal distribution approximated by a polynomial.", "level3_prompt": "Compute the Black-Scholes kernel on GPU using CUDA."}
{"id": 475, "task_name": "DWT_Haar", "task_description": "Compute the DWT_Haar kernel on GPU using CUDA.", "inputs": [{"name": "signal", "dtype": "float32", "shape": "(512,)"}], "outputs": [{"name": "details_out", "dtype": "float32", "shape": "(512,)"}, {"name": "approx_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n#include <string>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants\n// ----------------------------------------------------------------------------\n#define INV_SQRT_2 0.70710678118654752440f\n#define LOG_NUM_BANKS 4 \n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void dwtHaar1D(float *id, float *od, float *approx_final,\n                          const unsigned int dlevels,\n                          const unsigned int slength_step_half,\n                          const int bdim) {\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n\n    // shared memory for part of the signal\n    extern __shared__ float shared[];\n\n    // thread runtime environment, 1D parametrization\n    const int gdim = gridDim.x;\n    const int bid = blockIdx.x;\n    const int tid = threadIdx.x;\n\n    // global thread id (w.r.t. to total data set)\n    const int tid_global = (bid * bdim) + tid;\n    unsigned int idata = (bid * (2 * bdim)) + tid;\n\n    // read data from global memory\n    shared[tid] = id[idata];\n    shared[tid + bdim] = id[idata + bdim];\n    cg::sync(cta);\n\n    // float data0 = shared[2 * tid];\n    // float data1 = shared[(2 * tid) + 1];\n    // To match bank conflict avoidance logic usually paired with this kernel:\n    // We read from shared, but the original code snippet implies a specific \n    // shared memory layout or direct register usage. \n    // Given the provided code reads from shared[2*tid], we proceed.\n    float data0 = shared[2 * tid];\n    float data1 = shared[(2 * tid) + 1];\n    cg::sync(cta);\n\n    // detail coefficient (Level 1)\n    od[tid_global + slength_step_half] = (data0 - data1) * INV_SQRT_2;\n\n    // offset to avoid bank conflicts\n    unsigned int atid = tid + (tid >> LOG_NUM_BANKS);\n\n    // approximation coefficient\n    shared[atid] = (data0 + data1) * INV_SQRT_2;\n\n    cg::sync(cta);\n\n    if (dlevels > 1) {\n        unsigned int offset_neighbor = 1;\n        unsigned int num_threads = bdim >> 1;\n        unsigned int idata0 = tid * 2;\n\n        for (unsigned int i = 1; i < dlevels; ++i) {\n            if (tid < num_threads) {\n                unsigned int idata1 = idata0 + offset_neighbor;\n                unsigned int g_wpos = (num_threads * gdim) + (bid * num_threads) + tid;\n\n                unsigned int c_idata0 = idata0 + (idata0 >> LOG_NUM_BANKS);\n                unsigned int c_idata1 = idata1 + (idata1 >> LOG_NUM_BANKS);\n\n                // detail coefficient\n                od[g_wpos] = (shared[c_idata0] - shared[c_idata1]) * INV_SQRT_2;\n\n                // approximation coefficient\n                shared[c_idata0] = (shared[c_idata0] + shared[c_idata1]) * INV_SQRT_2;\n\n                num_threads = num_threads >> 1;\n                offset_neighbor <<= 1;\n                idata0 = idata0 << 1;\n            }\n            cg::sync(cta);\n        }\n\n        if (0 == tid) {\n            approx_final[bid] = shared[0];\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    // Configuration\n    // We process a signal of length 512 using 1 block of 256 threads.\n    // The kernel processes 2 elements per thread initially.\n    const int SIGNAL_LENGTH = 512;\n    const int BLOCK_DIM = 256; \n    const int NUM_LEVELS = 9; // log2(512) = 9\n    const int GRID_DIM = 1;\n\n    size_t signal_bytes = SIGNAL_LENGTH * sizeof(float);\n    size_t approx_bytes = GRID_DIM * sizeof(float);\n\n    // Alloc Host\n    float* h_in = new float[SIGNAL_LENGTH];\n    float* h_out = new float[SIGNAL_LENGTH]; // Output details buffer\n    float* h_approx = new float[GRID_DIM];\n\n    // Read Input\n    read_binary(\"data/signal.bin\", h_in, SIGNAL_LENGTH);\n\n    // Alloc Device\n    float *d_in, *d_out, *d_approx;\n    cudaMalloc(&d_in, signal_bytes);\n    cudaMalloc(&d_out, signal_bytes); // Output details\n    cudaMalloc(&d_approx, approx_bytes);\n\n    cudaMemcpy(d_in, h_in, signal_bytes, cudaMemcpyHostToDevice);\n\n    // Launch Kernel\n    // Shared memory size calculation:\n    // We need enough space for the padded shared memory array.\n    // Max index is roughly 2 * BLOCK_DIM. \n    // With padding (>> 4), size approx: 512 + 32 = 544 floats.\n    // Safe margin: 1024 floats * 4 bytes\n    size_t shared_mem_size = 2048 * sizeof(float); \n\n    // slength_step_half is the offset for the first level details in the global array.\n    // For a single block processing 0..511, L1 details correspond to high freq, usually at 256..511.\n    unsigned int slength_step_half = SIGNAL_LENGTH / 2;\n\n    dwtHaar1D<<<GRID_DIM, BLOCK_DIM, shared_mem_size>>>(\n        d_in, \n        d_out, \n        d_approx, \n        NUM_LEVELS, \n        slength_step_half, \n        BLOCK_DIM\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read Back\n    cudaMemcpy(h_out, d_out, signal_bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_approx, d_approx, approx_bytes, cudaMemcpyDeviceToHost);\n\n    // Write Outputs\n    write_binary(\"data/details_out.bin\", h_out, SIGNAL_LENGTH);\n    write_binary(\"data/approx_out.bin\", h_approx, GRID_DIM);\n\n    // Cleanup\n    cudaFree(d_in); cudaFree(d_out); cudaFree(d_approx);\n    delete[] h_in; delete[] h_out; delete[] h_approx;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\n# Configuration\nSIGNAL_LENGTH = 512\nSEED = 42\n\nnp.random.seed(SEED)\n\ndef haar_1d_cpu_emulate_kernel(signal, levels):\n    # This emulates the specific memory layout and logic of the provided CUDA kernel\n    # signal: 1D array\n    # output: 1D array same size as signal (for details)\n    # approx_final: scalar (since we assume 1 block)\n    \n    output = np.zeros_like(signal)\n    \n    # In the kernel, initial data is loaded into shared memory\n    # Block Size = 256, processes 512 elements\n    bdim = len(signal) // 2\n    \n    # --- Level 1 ---\n    # Kernel: od[tid_global + slength_step_half] = (data0 - data1) * INV_SQRT_2;\n    # tid_global runs 0 to 255\n    # slength_step_half = 256\n    current_approx = []\n    inv_sqrt_2 = 1.0 / math.sqrt(2.0)\n    \n    for tid in range(bdim):\n        data0 = signal[2 * tid]\n        data1 = signal[2 * tid + 1]\n        \n        detail = (data0 - data1) * inv_sqrt_2\n        approx = (data0 + data1) * inv_sqrt_2\n        \n        # Store L1 detail\n        output[tid + 256] = detail\n        current_approx.append(approx)\n        \n    current_approx = np.array(current_approx) # Size 256\n    \n    # --- Subsequent Levels ---\n    # Logic: loop i from 1 to dlevels-1\n    # threads active: num_threads = bdim >> 1\n    \n    num_threads = bdim >> 1 # Starts at 128\n    grid_dim = 1\n    bid = 0\n    \n    for i in range(1, levels):\n        # Current approx size is 2 * num_threads\n        next_approx = []\n        \n        # Calculate offset in output for this level\n        # Kernel: g_wpos = (num_threads * gdim) + (bid * num_threads) + tid\n        # output_offset = num_threads\n        \n        for tid in range(num_threads):\n            # pair from current approximation\n            val0 = current_approx[2 * tid]\n            val1 = current_approx[2 * tid + 1]\n            \n            detail = (val0 - val1) * inv_sqrt_2\n            approx = (val0 + val1) * inv_sqrt_2\n            \n            # Write detail to specific location in global output\n            g_wpos = (num_threads * grid_dim) + (bid * num_threads) + tid\n            output[g_wpos] = detail\n            \n            next_approx.append(approx)\n            \n        current_approx = np.array(next_approx)\n        num_threads = num_threads >> 1\n        \n    return output, current_approx[0]\n\n# Generate Data\nsignal = np.random.randn(SIGNAL_LENGTH).astype(np.float32)\n\n# Compute Reference\ndetails_ref, approx_ref = haar_1d_cpu_emulate_kernel(signal, levels=9)\n\n# Save\nos.makedirs(\"data\", exist_ok=True)\nsignal.tofile(\"data/signal.bin\")\ndetails_ref.tofile(\"data/details_ref.bin\")\nnp.array([approx_ref], dtype=np.float32).tofile(\"data/approx_ref.bin\")\n\n# print(f\"Data generated. Approx Ref: {approx_ref}\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file: {output_file} or {ref_file}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output - reference)\n    # max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    # Note: Indices 0 to 1 are often left untouched by the logic for levels < 9\n    # Specifically, index 0 is empty in 'details' array based on the kernel logic \n    # (loop stops when num_threads=1, writing to index 1).\n    # We should mask index 0 if it's 0 in both or irrelevant.\n    # In this specific kernel logic, index 0 of od[] is never written to.\n    \n    # Check excluding index 0 (which is unused in the detail buffer)\n    if size > 1:\n        valid_diff = diff[1:]\n    else:\n        valid_diff = diff\n        \n    return np.all(valid_diff < tolerance)\n\nif __name__ == \"__main__\":\n    SIGNAL_LENGTH = 512\n    \n    # Check Details\n    # print(\"Checking Details...\")\n    d_out = \"data/details_out.bin\"\n    d_ref = \"data/details_ref.bin\"\n    d_pass = compare_outputs(d_out, d_ref, SIGNAL_LENGTH)\n    \n    # Check Final Approx\n    # print(\"Checking Approximation...\")\n    a_out = \"data/approx_out.bin\"\n    a_ref = \"data/approx_ref.bin\"\n    a_pass = compare_outputs(a_out, a_ref, 1)\n\n    if d_pass and a_pass:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a kernel for the Haar wavelet transform on a 1D signal. The input is a float32 tensor of shape (512,). The output consists of two tensors: a details_out tensor of float32 values with shape (512,), and an approx_out tensor of float32 values with shape (1,). The kernel must compute multi-level decomposition: at each level, pairs of elements are transformed into approximation and detail coefficients using the scaling factor 1/sqrt(2). The first-level details are stored in the second half of the output array. Subsequent levels recursively process the approximation coefficients from the previous level, storing details in decreasing segments of the output array. The final approximation coefficient must be stored in approx_out.", "level2_prompt": "Perform a multi-level Haar wavelet decomposition on a 512-element signal. At each decomposition level, transform adjacent element pairs (x, y) into approximation (x+y)/√2 and detail (x-y)/√2 coefficients. Store first-level details in the output's upper half. For subsequent levels, recursively apply the same transform to the approximation coefficients from the previous level, storing new details in progressively lower segments of the output array. Output the final approximation coefficient separately.", "level3_prompt": "Compute the DWT_Haar kernel on GPU using CUDA."}
{"id": 476, "task_name": "DWT_Haar", "task_description": "Compute the DWT_Haar kernel on GPU using CUDA.", "inputs": [{"name": "signal", "dtype": "float32", "shape": "(1024,)"}], "outputs": [{"name": "details_out", "dtype": "float32", "shape": "(1024,)"}, {"name": "approx_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n#include <string>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants\n// ----------------------------------------------------------------------------\n#define INV_SQRT_2 0.70710678118654752440f\n#define LOG_NUM_BANKS 4 \n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void dwtHaar1D(float *id, float *od, float *approx_final,\n                          const unsigned int dlevels,\n                          const unsigned int slength_step_half,\n                          const int bdim) {\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n\n    // shared memory for part of the signal\n    extern __shared__ float shared[];\n\n    // thread runtime environment, 1D parametrization\n    const int gdim = gridDim.x;\n    const int bid = blockIdx.x;\n    const int tid = threadIdx.x;\n\n    // global thread id (w.r.t. to total data set)\n    const int tid_global = (bid * bdim) + tid;\n    unsigned int idata = (bid * (2 * bdim)) + tid;\n\n    // read data from global memory\n    shared[tid] = id[idata];\n    shared[tid + bdim] = id[idata + bdim];\n    cg::sync(cta);\n\n    // float data0 = shared[2 * tid];\n    // float data1 = shared[(2 * tid) + 1];\n    // To match bank conflict avoidance logic usually paired with this kernel:\n    // We read from shared, but the original code snippet implies a specific \n    // shared memory layout or direct register usage. \n    // Given the provided code reads from shared[2*tid], we proceed.\n    float data0 = shared[2 * tid];\n    float data1 = shared[(2 * tid) + 1];\n    cg::sync(cta);\n\n    // detail coefficient (Level 1)\n    od[tid_global + slength_step_half] = (data0 - data1) * INV_SQRT_2;\n\n    // offset to avoid bank conflicts\n    unsigned int atid = tid + (tid >> LOG_NUM_BANKS);\n\n    // approximation coefficient\n    shared[atid] = (data0 + data1) * INV_SQRT_2;\n\n    cg::sync(cta);\n\n    if (dlevels > 1) {\n        unsigned int offset_neighbor = 1;\n        unsigned int num_threads = bdim >> 1;\n        unsigned int idata0 = tid * 2;\n\n        for (unsigned int i = 1; i < dlevels; ++i) {\n            if (tid < num_threads) {\n                unsigned int idata1 = idata0 + offset_neighbor;\n                unsigned int g_wpos = (num_threads * gdim) + (bid * num_threads) + tid;\n\n                unsigned int c_idata0 = idata0 + (idata0 >> LOG_NUM_BANKS);\n                unsigned int c_idata1 = idata1 + (idata1 >> LOG_NUM_BANKS);\n\n                // detail coefficient\n                od[g_wpos] = (shared[c_idata0] - shared[c_idata1]) * INV_SQRT_2;\n\n                // approximation coefficient\n                shared[c_idata0] = (shared[c_idata0] + shared[c_idata1]) * INV_SQRT_2;\n\n                num_threads = num_threads >> 1;\n                offset_neighbor <<= 1;\n                idata0 = idata0 << 1;\n            }\n            cg::sync(cta);\n        }\n\n        if (0 == tid) {\n            approx_final[bid] = shared[0];\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    // Configuration\n    // We process a signal of length 1024 using 1 block of 256 threads.\n    // The kernel processes 2 elements per thread initially.\n    const int SIGNAL_LENGTH = 1024;\n    const int BLOCK_DIM = SIGNAL_LENGTH / 2; \n    const int NUM_LEVELS = (int)log2(SIGNAL_LENGTH); // log2(1024) = 10\n    const int GRID_DIM = 1;\n\n    size_t signal_bytes = SIGNAL_LENGTH * sizeof(float);\n    size_t approx_bytes = GRID_DIM * sizeof(float);\n\n    // Alloc Host\n    float* h_in = new float[SIGNAL_LENGTH];\n    float* h_out = new float[SIGNAL_LENGTH]; // Output details buffer\n    float* h_approx = new float[GRID_DIM];\n\n    // Read Input\n    read_binary(\"data/signal.bin\", h_in, SIGNAL_LENGTH);\n\n    // Alloc Device\n    float *d_in, *d_out, *d_approx;\n    cudaMalloc(&d_in, signal_bytes);\n    cudaMalloc(&d_out, signal_bytes); // Output details\n    cudaMalloc(&d_approx, approx_bytes);\n\n    cudaMemcpy(d_in, h_in, signal_bytes, cudaMemcpyHostToDevice);\n\n    // Launch Kernel\n    // Shared memory size calculation:\n    // We need enough space for the padded shared memory array.\n    // Max index is roughly 2 * BLOCK_DIM. \n    // With padding (>> 4), size approx: 512 + 32 = 544 floats.\n    // Safe margin: 1024 floats * 4 bytes\n    // size_t shared_mem_size = 2048 * sizeof(float); \n    size_t shared_mem_size = (SIGNAL_LENGTH + (SIGNAL_LENGTH >> LOG_NUM_BANKS)) * sizeof(float);\n\n    // slength_step_half is the offset for the first level details in the global array.\n    // For a single block processing 0..511, L1 details correspond to high freq, usually at 256..511.\n    unsigned int slength_step_half = SIGNAL_LENGTH / 2;\n\n    dwtHaar1D<<<GRID_DIM, BLOCK_DIM, shared_mem_size>>>(\n        d_in, \n        d_out, \n        d_approx, \n        NUM_LEVELS, \n        slength_step_half, \n        BLOCK_DIM\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read Back\n    cudaMemcpy(h_out, d_out, signal_bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_approx, d_approx, approx_bytes, cudaMemcpyDeviceToHost);\n\n    // Write Outputs\n    write_binary(\"data/details_out.bin\", h_out, SIGNAL_LENGTH);\n    write_binary(\"data/approx_out.bin\", h_approx, GRID_DIM);\n\n    // Cleanup\n    cudaFree(d_in); cudaFree(d_out); cudaFree(d_approx);\n    delete[] h_in; delete[] h_out; delete[] h_approx;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\nSIGNAL_LENGTH = 1024\nNUM_LEVELS = int(math.log2(SIGNAL_LENGTH))\nINV_SQRT_2 = 0.70710678118654752440\n\ndef haar_1d_reference(signal):\n    \"\"\"\n    完全对应内核物理逻辑的递归模拟\n    \"\"\"\n    length = len(signal)\n    output_details = np.zeros(length, dtype=np.float32)\n    \n    # 模拟第一次迭代 (L1)\n    bdim = length // 2\n    temp_approx = np.zeros(bdim, dtype=np.float32)\n    \n    for tid in range(bdim):\n        d0 = signal[2 * tid]\n        d1 = signal[2 * tid + 1]\n        # 对应内核: od[tid_global + slength_step_half]\n        output_details[tid + bdim] = (d0 - d1) * INV_SQRT_2\n        temp_approx[tid] = (d0 + d1) * INV_SQRT_2\n        \n    # 模拟后续迭代 (L2 -> Lmax)\n    # 内核在后续步骤中是将结果写回 shared memory 再读取\n    # 注意: 内核中的 g_wpos = (num_threads * gdim) + (bid * num_threads) + tid\n    \n    current_data = temp_approx.copy()\n    num_threads = bdim // 2\n    \n    for i in range(1, NUM_LEVELS):\n        next_data = np.zeros(num_threads, dtype=np.float32)\n        for tid in range(num_threads):\n            # 这里的 pair 逻辑在内核中是跨步读取\n            idx0 = tid * 2\n            idx1 = idx0 + 1\n            \n            d0 = current_data[idx0]\n            d1 = current_data[idx1]\n            \n            detail = (d0 - d1) * INV_SQRT_2\n            approx = (d0 + d1) * INV_SQRT_2\n            \n            # 计算写入 od 的位置\n            g_wpos = num_threads + tid\n            output_details[g_wpos] = detail\n            next_data[tid] = approx\n            \n        current_data = next_data\n        num_threads //= 2\n        if num_threads == 0: break\n        \n    return output_details, current_data[0]\n\n# 生成\nsignal = np.random.randn(SIGNAL_LENGTH).astype(np.float32)\ndetails_ref, approx_ref = haar_1d_reference(signal)\n\nos.makedirs(\"data\", exist_ok=True)\nsignal.tofile(\"data/signal.bin\")\ndetails_ref.tofile(\"data/details_ref.bin\")\nnp.array([approx_ref], dtype=np.float32).tofile(\"data/approx_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file: {output_file} or {ref_file}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output - reference)\n    # max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    # Note: Indices 0 to 1 are often left untouched by the logic for levels < 9\n    # Specifically, index 0 is empty in 'details' array based on the kernel logic \n    # (loop stops when num_threads=1, writing to index 1).\n    # We should mask index 0 if it's 0 in both or irrelevant.\n    # In this specific kernel logic, index 0 of od[] is never written to.\n    \n    # Check excluding index 0 (which is unused in the detail buffer)\n    if size > 1:\n        valid_diff = diff[1:]\n    else:\n        valid_diff = diff\n        \n    return np.all(valid_diff < tolerance)\n\nif __name__ == \"__main__\":\n    SIGNAL_LENGTH = 1024\n    \n    # Check Details\n    # print(\"Checking Details...\")\n    d_out = \"data/details_out.bin\"\n    d_ref = \"data/details_ref.bin\"\n    d_pass = compare_outputs(d_out, d_ref, SIGNAL_LENGTH)\n    \n    # Check Final Approx\n    # print(\"Checking Approximation...\")\n    a_out = \"data/approx_out.bin\"\n    a_ref = \"data/approx_ref.bin\"\n    a_pass = compare_outputs(a_out, a_ref, 1)\n\n    if d_pass and a_pass:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the DWT_Haar kernel to compute the 1D Haar wavelet transform on a signal. The input is a 1024-element float32 signal tensor. The kernel must produce two outputs: a 1024-element float32 details_out tensor containing wavelet detail coefficients at multiple levels, and a single float32 approximation_out value representing the final approximation coefficient. The transform must be computed recursively over log2(1024)=10 levels, processing element pairs at each level. For each pair (x, y), compute detail as (x - y) * 1/√2 and approximation as (x + y) * 1/√2. The output must store first-level details in the second half of details_out, with subsequent levels stored in progressively lower indices. The kernel must avoid shared memory bank conflicts using appropriate padding.", "level2_prompt": "Compute the Haar wavelet transform for a 1024-element signal. Recursively apply pairwise operations over 10 levels: for each element pair (x, y) at level i, calculate detail coefficient d = (x - y)/√2 and approximation coefficient a = (x + y)/√2. Use approximation coefficients as input for the next level. Output all detail coefficients in a single 1024-element array, with level-1 details in indices 512-1023, level-2 in 256-511, etc., and output the final approximation coefficient as a scalar.", "level3_prompt": "Perform a 1D Haar discrete wavelet transform on a 1024-element signal to produce detail coefficients and a final approximation coefficient."}
{"id": 477, "task_name": "DWT_Haar", "task_description": "Compute the DWT_Haar kernel on GPU using CUDA.", "inputs": [{"name": "signal", "dtype": "float32", "shape": "(2048,)"}], "outputs": [{"name": "details_out", "dtype": "float32", "shape": "(2048,)"}, {"name": "approx_out", "dtype": "float32", "shape": "(1,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n#include <string>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants\n// ----------------------------------------------------------------------------\n#define INV_SQRT_2 0.70710678118654752440f\n#define LOG_NUM_BANKS 4 \n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void dwtHaar1D(float *id, float *od, float *approx_final,\n                          const unsigned int dlevels,\n                          const unsigned int slength_step_half,\n                          const int bdim) {\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n\n    // shared memory for part of the signal\n    extern __shared__ float shared[];\n\n    // thread runtime environment, 1D parametrization\n    const int gdim = gridDim.x;\n    const int bid = blockIdx.x;\n    const int tid = threadIdx.x;\n\n    // global thread id (w.r.t. to total data set)\n    const int tid_global = (bid * bdim) + tid;\n    unsigned int idata = (bid * (2 * bdim)) + tid;\n\n    // read data from global memory\n    shared[tid] = id[idata];\n    shared[tid + bdim] = id[idata + bdim];\n    cg::sync(cta);\n\n    // float data0 = shared[2 * tid];\n    // float data1 = shared[(2 * tid) + 1];\n    // To match bank conflict avoidance logic usually paired with this kernel:\n    // We read from shared, but the original code snippet implies a specific \n    // shared memory layout or direct register usage. \n    // Given the provided code reads from shared[2*tid], we proceed.\n    float data0 = shared[2 * tid];\n    float data1 = shared[(2 * tid) + 1];\n    cg::sync(cta);\n\n    // detail coefficient (Level 1)\n    od[tid_global + slength_step_half] = (data0 - data1) * INV_SQRT_2;\n\n    // offset to avoid bank conflicts\n    unsigned int atid = tid + (tid >> LOG_NUM_BANKS);\n\n    // approximation coefficient\n    shared[atid] = (data0 + data1) * INV_SQRT_2;\n\n    cg::sync(cta);\n\n    if (dlevels > 1) {\n        unsigned int offset_neighbor = 1;\n        unsigned int num_threads = bdim >> 1;\n        unsigned int idata0 = tid * 2;\n\n        for (unsigned int i = 1; i < dlevels; ++i) {\n            if (tid < num_threads) {\n                unsigned int idata1 = idata0 + offset_neighbor;\n                unsigned int g_wpos = (num_threads * gdim) + (bid * num_threads) + tid;\n\n                unsigned int c_idata0 = idata0 + (idata0 >> LOG_NUM_BANKS);\n                unsigned int c_idata1 = idata1 + (idata1 >> LOG_NUM_BANKS);\n\n                // detail coefficient\n                od[g_wpos] = (shared[c_idata0] - shared[c_idata1]) * INV_SQRT_2;\n\n                // approximation coefficient\n                shared[c_idata0] = (shared[c_idata0] + shared[c_idata1]) * INV_SQRT_2;\n\n                num_threads = num_threads >> 1;\n                offset_neighbor <<= 1;\n                idata0 = idata0 << 1;\n            }\n            cg::sync(cta);\n        }\n\n        if (0 == tid) {\n            approx_final[bid] = shared[0];\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    // Configuration\n    // We process a signal of length 1024 using 1 block of 256 threads.\n    // The kernel processes 2 elements per thread initially.\n    const int SIGNAL_LENGTH = 2048;\n    const int BLOCK_DIM = SIGNAL_LENGTH / 2; \n    const int NUM_LEVELS = (int)log2(SIGNAL_LENGTH); // log2(1024) = 10\n    const int GRID_DIM = 1;\n\n    size_t signal_bytes = SIGNAL_LENGTH * sizeof(float);\n    size_t approx_bytes = GRID_DIM * sizeof(float);\n\n    // Alloc Host\n    float* h_in = new float[SIGNAL_LENGTH];\n    float* h_out = new float[SIGNAL_LENGTH]; // Output details buffer\n    float* h_approx = new float[GRID_DIM];\n\n    // Read Input\n    read_binary(\"data/signal.bin\", h_in, SIGNAL_LENGTH);\n\n    // Alloc Device\n    float *d_in, *d_out, *d_approx;\n    cudaMalloc(&d_in, signal_bytes);\n    cudaMalloc(&d_out, signal_bytes); // Output details\n    cudaMalloc(&d_approx, approx_bytes);\n\n    cudaMemcpy(d_in, h_in, signal_bytes, cudaMemcpyHostToDevice);\n\n    // Launch Kernel\n    // Shared memory size calculation:\n    // We need enough space for the padded shared memory array.\n    // Max index is roughly 2 * BLOCK_DIM. \n    // With padding (>> 4), size approx: 512 + 32 = 544 floats.\n    // Safe margin: 1024 floats * 4 bytes\n    // size_t shared_mem_size = 2048 * sizeof(float); \n    size_t shared_mem_size = (SIGNAL_LENGTH + (SIGNAL_LENGTH >> LOG_NUM_BANKS)) * sizeof(float);\n\n    // slength_step_half is the offset for the first level details in the global array.\n    // For a single block processing 0..511, L1 details correspond to high freq, usually at 256..511.\n    unsigned int slength_step_half = SIGNAL_LENGTH / 2;\n\n    dwtHaar1D<<<GRID_DIM, BLOCK_DIM, shared_mem_size>>>(\n        d_in, \n        d_out, \n        d_approx, \n        NUM_LEVELS, \n        slength_step_half, \n        BLOCK_DIM\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read Back\n    cudaMemcpy(h_out, d_out, signal_bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_approx, d_approx, approx_bytes, cudaMemcpyDeviceToHost);\n\n    // Write Outputs\n    write_binary(\"data/details_out.bin\", h_out, SIGNAL_LENGTH);\n    write_binary(\"data/approx_out.bin\", h_approx, GRID_DIM);\n\n    // Cleanup\n    cudaFree(d_in); cudaFree(d_out); cudaFree(d_approx);\n    delete[] h_in; delete[] h_out; delete[] h_approx;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\nSIGNAL_LENGTH = 2048\nNUM_LEVELS = int(math.log2(SIGNAL_LENGTH))\nINV_SQRT_2 = 0.70710678118654752440\n\ndef haar_1d_reference(signal):\n    \"\"\"\n    完全对应内核物理逻辑的递归模拟\n    \"\"\"\n    length = len(signal)\n    output_details = np.zeros(length, dtype=np.float32)\n    \n    # 模拟第一次迭代 (L1)\n    bdim = length // 2\n    temp_approx = np.zeros(bdim, dtype=np.float32)\n    \n    for tid in range(bdim):\n        d0 = signal[2 * tid]\n        d1 = signal[2 * tid + 1]\n        # 对应内核: od[tid_global + slength_step_half]\n        output_details[tid + bdim] = (d0 - d1) * INV_SQRT_2\n        temp_approx[tid] = (d0 + d1) * INV_SQRT_2\n        \n    # 模拟后续迭代 (L2 -> Lmax)\n    # 内核在后续步骤中是将结果写回 shared memory 再读取\n    # 注意: 内核中的 g_wpos = (num_threads * gdim) + (bid * num_threads) + tid\n    \n    current_data = temp_approx.copy()\n    num_threads = bdim // 2\n    \n    for i in range(1, NUM_LEVELS):\n        next_data = np.zeros(num_threads, dtype=np.float32)\n        for tid in range(num_threads):\n            # 这里的 pair 逻辑在内核中是跨步读取\n            idx0 = tid * 2\n            idx1 = idx0 + 1\n            \n            d0 = current_data[idx0]\n            d1 = current_data[idx1]\n            \n            detail = (d0 - d1) * INV_SQRT_2\n            approx = (d0 + d1) * INV_SQRT_2\n            \n            # 计算写入 od 的位置\n            g_wpos = num_threads + tid\n            output_details[g_wpos] = detail\n            next_data[tid] = approx\n            \n        current_data = next_data\n        num_threads //= 2\n        if num_threads == 0: break\n        \n    return output_details, current_data[0]\n\n# 生成\nsignal = np.random.randn(SIGNAL_LENGTH).astype(np.float32)\ndetails_ref, approx_ref = haar_1d_reference(signal)\n\nos.makedirs(\"data\", exist_ok=True)\nsignal.tofile(\"data/signal.bin\")\ndetails_ref.tofile(\"data/details_ref.bin\")\nnp.array([approx_ref], dtype=np.float32).tofile(\"data/approx_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(f\"Missing file: {output_file} or {ref_file}\")\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n        \n    diff = np.abs(output - reference)\n    # max_diff = np.max(diff)\n    # print(f\"Max Diff: {max_diff}\")\n    \n    # Note: Indices 0 to 1 are often left untouched by the logic for levels < 9\n    # Specifically, index 0 is empty in 'details' array based on the kernel logic \n    # (loop stops when num_threads=1, writing to index 1).\n    # We should mask index 0 if it's 0 in both or irrelevant.\n    # In this specific kernel logic, index 0 of od[] is never written to.\n    \n    # Check excluding index 0 (which is unused in the detail buffer)\n    if size > 1:\n        valid_diff = diff[1:]\n    else:\n        valid_diff = diff\n        \n    return np.all(valid_diff < tolerance)\n\nif __name__ == \"__main__\":\n    SIGNAL_LENGTH = 2048\n    \n    # Check Details\n    # print(\"Checking Details...\")\n    d_out = \"data/details_out.bin\"\n    d_ref = \"data/details_ref.bin\"\n    d_pass = compare_outputs(d_out, d_ref, SIGNAL_LENGTH)\n    \n    # Check Final Approx\n    # print(\"Checking Approximation...\")\n    a_out = \"data/approx_out.bin\"\n    a_ref = \"data/approx_ref.bin\"\n    a_pass = compare_outputs(a_out, a_ref, 1)\n\n    if d_pass and a_pass:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the DWT_Haar kernel to compute a 1D Discrete Wavelet Transform using the Haar wavelet. The input is a 2048-element float32 signal tensor. The outputs are: a 2048-element float32 details_out tensor storing wavelet detail coefficients, and a single-element float32 approx_out tensor for the final approximation coefficient. Constraints: The input length must be a power of two (2048=2^11), requiring 11 recursive decomposition levels. Each level computes pairwise differences (details) and averages (approximations) scaled by 1/√2, with results stored in specific output positions. Bank conflicts must be avoided in shared memory using padding.", "level2_prompt": "Perform a Haar wavelet decomposition on a 1D signal. For each decomposition level: pairwise adjacent elements are processed to compute detail coefficients (difference scaled by 1/√2) and approximation coefficients (sum scaled by 1/√2). Approximation coefficients from each level become the input for the next level. Details are stored in the output array at level-specific offsets, while the final approximation is stored separately.", "level3_prompt": "Compute the DWT_Haar kernel on GPU using CUDA."}
{"id": 478, "task_name": "DWT_Haar", "task_description": "Compute the DWT_Haar kernel on GPU using CUDA.", "inputs": [{"name": "signal", "dtype": "float32", "shape": "(4096,)"}], "outputs": [{"name": "details_out", "dtype": "float32", "shape": "(4096,)"}, {"name": "approx_out", "dtype": "float32", "shape": "(4,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n#include <string>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants\n// ----------------------------------------------------------------------------\n#define INV_SQRT_2 0.70710678118654752440f\n#define LOG_NUM_BANKS 4 \n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void dwtHaar1D(float *id, float *od, float *approx_final,\n                          const unsigned int dlevels,\n                          const unsigned int slength_step_half,\n                          const int bdim) {\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ float shared[];\n\n    const int tid = threadIdx.x;\n    // 使用全局索引，支持多 Block\n    const int tid_global = blockIdx.x * blockDim.x + tid;\n    // 每一个 Block 处理 2 * blockDim.x 个输入数据\n    unsigned int idata = blockIdx.x * (2 * blockDim.x) + tid;\n\n    // 1. 读取数据到共享内存\n    shared[tid] = id[idata];\n    shared[tid + blockDim.x] = id[idata + blockDim.x];\n    cg::sync(cta);\n\n    // 2. 第一层分解 (Level 1)\n    float data0 = shared[2 * tid];\n    float data1 = shared[(2 * tid) + 1];\n    cg::sync(cta);\n\n    // 写入第一层细节系数到全局内存的对应位置\n    od[tid_global + slength_step_half] = (data0 - data1) * INV_SQRT_2;\n\n    // 3. 计算本 Block 内部的后续层级 (Block-level recursion)\n    unsigned int atid = tid + (tid >> LOG_NUM_BANKS);\n    shared[atid] = (data0 + data1) * INV_SQRT_2;\n    cg::sync(cta);\n\n    // 块内递归 (注意：这里的 dlevels 只能处理到 Block 内部消失为止)\n    // 假设每个 Block 256 线程，它可以内部处理 log2(512) = 9 层\n    unsigned int block_levels = (unsigned int)log2f((float)blockDim.x) + 1;\n    unsigned int actual_levels = (dlevels < block_levels) ? dlevels : block_levels;\n\n    if (actual_levels > 1) {\n        unsigned int offset_neighbor = 1;\n        unsigned int num_threads = blockDim.x >> 1;\n        unsigned int idata0 = tid * 2;\n\n        for (unsigned int i = 1; i < actual_levels; ++i) {\n            if (tid < num_threads) {\n                unsigned int idata1 = idata0 + offset_neighbor;\n                // 计算全局写入位置\n                unsigned int g_wpos = (num_threads * gridDim.x) + (blockIdx.x * num_threads) + tid;\n\n                unsigned int c_idata0 = idata0 + (idata0 >> LOG_NUM_BANKS);\n                unsigned int c_idata1 = idata1 + (idata1 >> LOG_NUM_BANKS);\n\n                od[g_wpos] = (shared[c_idata0] - shared[c_idata1]) * INV_SQRT_2;\n                shared[c_idata0] = (shared[c_idata0] + shared[c_idata1]) * INV_SQRT_2;\n\n                num_threads >>= 1;\n                offset_neighbor <<= 1;\n                idata0 <<= 1;\n            }\n            cg::sync(cta);\n        }\n\n        if (tid == 0) {\n            approx_final[blockIdx.x] = shared[0];\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    // Configuration\n    // We process a signal of length 1024 using 1 block of 256 threads.\n    // The kernel processes 2 elements per thread initially.\n    const int SIGNAL_LENGTH = 4096;\n    const int BLOCK_DIM = 512; \n    const int NUM_LEVELS = (int)log2(2 * BLOCK_DIM);\n    const int GRID_DIM = SIGNAL_LENGTH / (2 * BLOCK_DIM);\n\n    size_t signal_bytes = SIGNAL_LENGTH * sizeof(float);\n    size_t approx_bytes = GRID_DIM * sizeof(float);\n\n    // Alloc Host\n    float* h_in = new float[SIGNAL_LENGTH];\n    float* h_out = new float[SIGNAL_LENGTH]; // Output details buffer\n    float* h_approx = new float[GRID_DIM];\n\n    // Read Input\n    read_binary(\"data/signal.bin\", h_in, SIGNAL_LENGTH);\n\n    // Alloc Device\n    float *d_in, *d_out, *d_approx;\n    cudaMalloc(&d_in, signal_bytes);\n    cudaMalloc(&d_out, signal_bytes); // Output details\n    cudaMalloc(&d_approx, approx_bytes);\n\n    cudaMemcpy(d_in, h_in, signal_bytes, cudaMemcpyHostToDevice);\n\n    // Launch Kernel\n    // Shared memory size calculation:\n    // We need enough space for the padded shared memory array.\n    // Max index is roughly 2 * BLOCK_DIM. \n    // With padding (>> 4), size approx: 512 + 32 = 544 floats.\n    // Safe margin: 1024 floats * 4 bytes\n    // size_t shared_mem_size = 2048 * sizeof(float); \n    // size_t shared_mem_size = (SIGNAL_LENGTH + (SIGNAL_LENGTH >> LOG_NUM_BANKS)) * sizeof(float);\n    size_t shared_mem_size = (BLOCK_DIM * 2 + (BLOCK_DIM * 2 >> LOG_NUM_BANKS)) * sizeof(float);\n\n    // slength_step_half is the offset for the first level details in the global array.\n    // For a single block processing 0..511, L1 details correspond to high freq, usually at 256..511.\n    unsigned int slength_step_half = SIGNAL_LENGTH / 2;\n\n    dwtHaar1D<<<GRID_DIM, BLOCK_DIM, shared_mem_size>>>(\n        d_in, \n        d_out, \n        d_approx, \n        NUM_LEVELS, \n        slength_step_half, \n        BLOCK_DIM\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read Back\n    cudaMemcpy(h_out, d_out, signal_bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_approx, d_approx, approx_bytes, cudaMemcpyDeviceToHost);\n\n    // Write Outputs\n    write_binary(\"data/details_out.bin\", h_out, SIGNAL_LENGTH);\n    write_binary(\"data/approx_out.bin\", h_approx, GRID_DIM);\n\n    // Cleanup\n    cudaFree(d_in); cudaFree(d_out); cudaFree(d_approx);\n    delete[] h_in; delete[] h_out; delete[] h_approx;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\nSIGNAL_LENGTH = 4096\nTHREADS_PER_BLOCK = 512\nNUM_BLOCKS = SIGNAL_LENGTH // (2 * THREADS_PER_BLOCK)\nINV_SQRT_2 = 0.7071067811865475\n\ndef gen_multi_block_haar():\n    signal = np.random.randn(SIGNAL_LENGTH).astype(np.float32)\n    details_out = np.zeros(SIGNAL_LENGTH, dtype=np.float32)\n    block_approx = np.zeros(NUM_BLOCKS, dtype=np.float32)\n\n    for b in range(NUM_BLOCKS):\n        # 提取当前 Block 的数据 (每个 Block 处理 1024 个元素)\n        block_data = signal[b*1024 : (b+1)*1024]\n        \n        # Level 1\n        b_half = 512\n        current_approx = np.zeros(b_half)\n        for t in range(b_half):\n            d0, d1 = block_data[2*t], block_data[2*t+1]\n            # 写入全局 od: tid_global + slength_step_half\n            details_out[(b * b_half + t) + SIGNAL_LENGTH//2] = (d0 - d1) * INV_SQRT_2\n            current_approx[t] = (d0 + d1) * INV_SQRT_2\n        \n        # Block 内部后续层级\n        num_threads = b_half // 2\n        while num_threads >= 1:\n            next_approx = np.zeros(num_threads)\n            for t in range(num_threads):\n                d0, d1 = current_approx[2*t], current_approx[2*t+1]\n                # 对应内核中的 g_wpos 计算\n                g_wpos = (num_threads * NUM_BLOCKS) + (b * num_threads) + t\n                details_out[g_wpos] = (d0 - d1) * INV_SQRT_2\n                next_approx[t] = (d0 + d1) * INV_SQRT_2\n            current_approx = next_approx\n            num_threads //= 2\n        \n        block_approx[b] = current_approx[0]\n\n    return signal, details_out, block_approx\n\n# 执行并保存\nsig, det, approx = gen_multi_block_haar()\nos.makedirs(\"data\", exist_ok=True)\nsig.tofile(\"data/signal.bin\")\ndet.tofile(\"data/details_ref.bin\")\napprox.tofile(\"data/approx_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\nif __name__ == \"__main__\":\n    # 验证 Details\n    output_det = np.fromfile(\"data/details_out.bin\", dtype=np.float32)\n    ref_det = np.fromfile(\"data/details_ref.bin\", dtype=np.float32)\n    \n    # 过滤掉不被写入的 index 0\n    diff_det = np.abs(output_det[1:] - ref_det[1:])\n    # print(f\"Max Detail Diff: {np.max(diff_det)}\")\n    \n    # 验证 Block Approximations\n    output_approx = np.fromfile(\"data/approx_out.bin\", dtype=np.float32)\n    ref_approx = np.fromfile(\"data/approx_ref.bin\", dtype=np.float32)\n    diff_approx = np.abs(output_approx - ref_approx)\n    # print(f\"Max Approx Diff: {np.max(diff_approx)}\")\n    \n    if np.max(diff_det) < 1e-3 and np.max(diff_approx) < 1e-3:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the DWT_Haar kernel for a 1D signal of length 4096. The kernel must compute multi-level Haar wavelet decomposition using multiple GPU blocks. Each block processes 1024 consecutive elements. For the first decomposition level, compute detail coefficients as (x[2i] - x[2i+1]) * √2/2 and approximation coefficients as (x[2i] + x[2i+1]) * √2/2. Recursively apply the same decomposition to approximation coefficients within each block until reaching a single final approximation value per block. Output must include: (1) A 4096-length details_out tensor storing all detail coefficients (first-level details in indices 2048-4095, subsequent levels in lower indices), and (2) A 4-length approx_out tensor containing the final approximation coefficient from each block.", "level2_prompt": "Perform multi-level Haar wavelet decomposition on a 4096-element 1D signal. Divide processing across 4 blocks, each handling 1024 elements. At each decomposition level, transform element pairs: detail = (a-b) * √2/2, approximation = (a+b) * √2/2. Store first-level details in the second half of the output array. Recursively decompose approximations within blocks until obtaining a single approximation value per block. Output includes all detail coefficients and per-block final approximations.", "level3_prompt": "Compute the Haar wavelet transform for a 4096-element signal."}
{"id": 479, "task_name": "DWT_Haar", "task_description": "Compute the DWT_Haar kernel on GPU using CUDA.", "inputs": [{"name": "signal", "dtype": "float32", "shape": "(8192,)"}], "outputs": [{"name": "details_out", "dtype": "float32", "shape": "(8192,)"}, {"name": "approx_out", "dtype": "float32", "shape": "(8,)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n#include <string>\n\nnamespace cg = cooperative_groups;\n\n// ----------------------------------------------------------------------------\n// Constants\n// ----------------------------------------------------------------------------\n#define INV_SQRT_2 0.70710678118654752440f\n#define LOG_NUM_BANKS 4 \n\n// ----------------------------------------------------------------------------\n// Kernel\n// ----------------------------------------------------------------------------\n__global__ void dwtHaar1D(float *id, float *od, float *approx_final,\n                          const unsigned int dlevels,\n                          const unsigned int slength_step_half,\n                          const int bdim) {\n    cg::thread_block cta = cg::this_thread_block();\n    extern __shared__ float shared[];\n\n    const int tid = threadIdx.x;\n    // 使用全局索引，支持多 Block\n    const int tid_global = blockIdx.x * blockDim.x + tid;\n    // 每一个 Block 处理 2 * blockDim.x 个输入数据\n    unsigned int idata = blockIdx.x * (2 * blockDim.x) + tid;\n\n    // 1. 读取数据到共享内存\n    shared[tid] = id[idata];\n    shared[tid + blockDim.x] = id[idata + blockDim.x];\n    cg::sync(cta);\n\n    // 2. 第一层分解 (Level 1)\n    float data0 = shared[2 * tid];\n    float data1 = shared[(2 * tid) + 1];\n    cg::sync(cta);\n\n    // 写入第一层细节系数到全局内存的对应位置\n    od[tid_global + slength_step_half] = (data0 - data1) * INV_SQRT_2;\n\n    // 3. 计算本 Block 内部的后续层级 (Block-level recursion)\n    unsigned int atid = tid + (tid >> LOG_NUM_BANKS);\n    shared[atid] = (data0 + data1) * INV_SQRT_2;\n    cg::sync(cta);\n\n    // 块内递归 (注意：这里的 dlevels 只能处理到 Block 内部消失为止)\n    // 假设每个 Block 256 线程，它可以内部处理 log2(512) = 9 层\n    unsigned int block_levels = (unsigned int)log2f((float)blockDim.x) + 1;\n    unsigned int actual_levels = (dlevels < block_levels) ? dlevels : block_levels;\n\n    if (actual_levels > 1) {\n        unsigned int offset_neighbor = 1;\n        unsigned int num_threads = blockDim.x >> 1;\n        unsigned int idata0 = tid * 2;\n\n        for (unsigned int i = 1; i < actual_levels; ++i) {\n            if (tid < num_threads) {\n                unsigned int idata1 = idata0 + offset_neighbor;\n                // 计算全局写入位置\n                unsigned int g_wpos = (num_threads * gridDim.x) + (blockIdx.x * num_threads) + tid;\n\n                unsigned int c_idata0 = idata0 + (idata0 >> LOG_NUM_BANKS);\n                unsigned int c_idata1 = idata1 + (idata1 >> LOG_NUM_BANKS);\n\n                od[g_wpos] = (shared[c_idata0] - shared[c_idata1]) * INV_SQRT_2;\n                shared[c_idata0] = (shared[c_idata0] + shared[c_idata1]) * INV_SQRT_2;\n\n                num_threads >>= 1;\n                offset_neighbor <<= 1;\n                idata0 <<= 1;\n            }\n            cg::sync(cta);\n        }\n\n        if (tid == 0) {\n            approx_final[blockIdx.x] = shared[0];\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Helpers\n// ----------------------------------------------------------------------------\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) { std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) { std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\n// ----------------------------------------------------------------------------\n// Main\n// ----------------------------------------------------------------------------\nint main() {\n    // Configuration\n    // We process a signal of length 1024 using 1 block of 256 threads.\n    // The kernel processes 2 elements per thread initially.\n    const int SIGNAL_LENGTH = 8192;\n    const int BLOCK_DIM = 512; \n    const int NUM_LEVELS = (int)log2(2 * BLOCK_DIM);\n    const int GRID_DIM = SIGNAL_LENGTH / (2 * BLOCK_DIM);\n\n    size_t signal_bytes = SIGNAL_LENGTH * sizeof(float);\n    size_t approx_bytes = GRID_DIM * sizeof(float);\n\n    // Alloc Host\n    float* h_in = new float[SIGNAL_LENGTH];\n    float* h_out = new float[SIGNAL_LENGTH]; // Output details buffer\n    float* h_approx = new float[GRID_DIM];\n\n    // Read Input\n    read_binary(\"data/signal.bin\", h_in, SIGNAL_LENGTH);\n\n    // Alloc Device\n    float *d_in, *d_out, *d_approx;\n    cudaMalloc(&d_in, signal_bytes);\n    cudaMalloc(&d_out, signal_bytes); // Output details\n    cudaMalloc(&d_approx, approx_bytes);\n\n    cudaMemcpy(d_in, h_in, signal_bytes, cudaMemcpyHostToDevice);\n\n    // Launch Kernel\n    // Shared memory size calculation:\n    // We need enough space for the padded shared memory array.\n    // Max index is roughly 2 * BLOCK_DIM. \n    // With padding (>> 4), size approx: 512 + 32 = 544 floats.\n    // Safe margin: 1024 floats * 4 bytes\n    // size_t shared_mem_size = 2048 * sizeof(float); \n    // size_t shared_mem_size = (SIGNAL_LENGTH + (SIGNAL_LENGTH >> LOG_NUM_BANKS)) * sizeof(float);\n    size_t shared_mem_size = (BLOCK_DIM * 2 + (BLOCK_DIM * 2 >> LOG_NUM_BANKS)) * sizeof(float);\n\n    // slength_step_half is the offset for the first level details in the global array.\n    // For a single block processing 0..511, L1 details correspond to high freq, usually at 256..511.\n    unsigned int slength_step_half = SIGNAL_LENGTH / 2;\n\n    dwtHaar1D<<<GRID_DIM, BLOCK_DIM, shared_mem_size>>>(\n        d_in, \n        d_out, \n        d_approx, \n        NUM_LEVELS, \n        slength_step_half, \n        BLOCK_DIM\n    );\n\n    cudaDeviceSynchronize();\n\n    // Read Back\n    cudaMemcpy(h_out, d_out, signal_bytes, cudaMemcpyDeviceToHost);\n    cudaMemcpy(h_approx, d_approx, approx_bytes, cudaMemcpyDeviceToHost);\n\n    // Write Outputs\n    write_binary(\"data/details_out.bin\", h_out, SIGNAL_LENGTH);\n    write_binary(\"data/approx_out.bin\", h_approx, GRID_DIM);\n\n    // Cleanup\n    cudaFree(d_in); cudaFree(d_out); cudaFree(d_approx);\n    delete[] h_in; delete[] h_out; delete[] h_approx;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\nimport math\n\nSIGNAL_LENGTH = 8192\nTHREADS_PER_BLOCK = 512\nNUM_BLOCKS = SIGNAL_LENGTH // (2 * THREADS_PER_BLOCK)\nINV_SQRT_2 = 0.7071067811865475\n\ndef gen_multi_block_haar():\n    signal = np.random.randn(SIGNAL_LENGTH).astype(np.float32)\n    details_out = np.zeros(SIGNAL_LENGTH, dtype=np.float32)\n    block_approx = np.zeros(NUM_BLOCKS, dtype=np.float32)\n\n    for b in range(NUM_BLOCKS):\n        # 提取当前 Block 的数据 (每个 Block 处理 1024 个元素)\n        block_data = signal[b*1024 : (b+1)*1024]\n        \n        # Level 1\n        b_half = 512\n        current_approx = np.zeros(b_half)\n        for t in range(b_half):\n            d0, d1 = block_data[2*t], block_data[2*t+1]\n            # 写入全局 od: tid_global + slength_step_half\n            details_out[(b * b_half + t) + SIGNAL_LENGTH//2] = (d0 - d1) * INV_SQRT_2\n            current_approx[t] = (d0 + d1) * INV_SQRT_2\n        \n        # Block 内部后续层级\n        num_threads = b_half // 2\n        while num_threads >= 1:\n            next_approx = np.zeros(num_threads)\n            for t in range(num_threads):\n                d0, d1 = current_approx[2*t], current_approx[2*t+1]\n                # 对应内核中的 g_wpos 计算\n                g_wpos = (num_threads * NUM_BLOCKS) + (b * num_threads) + t\n                details_out[g_wpos] = (d0 - d1) * INV_SQRT_2\n                next_approx[t] = (d0 + d1) * INV_SQRT_2\n            current_approx = next_approx\n            num_threads //= 2\n        \n        block_approx[b] = current_approx[0]\n\n    return signal, details_out, block_approx\n\n# 执行并保存\nsig, det, approx = gen_multi_block_haar()\nos.makedirs(\"data\", exist_ok=True)\nsig.tofile(\"data/signal.bin\")\ndet.tofile(\"data/details_ref.bin\")\napprox.tofile(\"data/approx_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\nif __name__ == \"__main__\":\n    # 验证 Details\n    output_det = np.fromfile(\"data/details_out.bin\", dtype=np.float32)\n    ref_det = np.fromfile(\"data/details_ref.bin\", dtype=np.float32)\n    \n    # 过滤掉不被写入的 index 0\n    diff_det = np.abs(output_det[1:] - ref_det[1:])\n    # print(f\"Max Detail Diff: {np.max(diff_det)}\")\n    \n    # 验证 Block Approximations\n    output_approx = np.fromfile(\"data/approx_out.bin\", dtype=np.float32)\n    ref_approx = np.fromfile(\"data/approx_ref.bin\", dtype=np.float32)\n    diff_approx = np.abs(output_approx - ref_approx)\n    # print(f\"Max Approx Diff: {np.max(diff_approx)}\")\n    \n    if np.max(diff_det) < 1e-3 and np.max(diff_approx) < 1e-3:\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel for the Haar wavelet transform (DWT_Haar). The input is a signal tensor of 8192 float32 values. The kernel must recursively decompose the signal into detail and approximation coefficients. Each thread block processes 1024 elements using 512 threads. The computation involves pairwise operations: detail coefficients are calculated as (x - y) * 1/sqrt(2) and approximation coefficients as (x + y) * 1/sqrt(2). Detail coefficients from all decomposition levels must be stored in the 8192-length output tensor, with level-1 details placed in the second half. The final approximation coefficient per block must be stored in an 8-length output tensor. Constraints: fixed input size (8192), 8 blocks, and 512 threads per block.", "level2_prompt": "Compute a Haar wavelet transform on an 8192-element signal. Divide the signal into 8 blocks. For each block, recursively apply pairwise operations: details = (x - y)/√2 and approximations = (x + y)/√2. Store all detail coefficients in an 8192-output array (level-1 details in indices 4096-8191). Store the final approximation per block in an 8-element array.", "level3_prompt": "Compute the Haar wavelet transform for an 8192-element signal, generating detail coefficients and block-wise approximations."}
{"id": 480, "task_name": "FDTD_3D", "task_description": "Compute the FDTD_3D kernel on GPU using CUDA.", "inputs": [{"name": "fdtd_input", "dtype": "float32", "shape": "(72, 72, 72)"}, {"name": "fdtd_stencil", "dtype": "float32", "shape": "(5,)"}], "outputs": [{"name": "fdtd_output", "dtype": "float32", "shape": "(72, 72, 72)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n#define RADIUS 4\n#define k_blockDimX 32\n#define k_blockDimMaxY 16\n\n// Stencil coefficients in constant memory\n__constant__ float stencil[RADIUS + 1];\n\n// Constants for the host\nconst int DIMX = 64;\nconst int DIMY = 64;\nconst int DIMZ = 64;\n\n// The provided kernel code\n__global__ void\nFiniteDifferencesKernel(float *output, const float *input, const int dimx, const int dimy, const int dimz)\n{\n    bool      validr = true;\n    bool      validw = true;\n    const int gtidx  = blockIdx.x * blockDim.x + threadIdx.x;\n    const int gtidy  = blockIdx.y * blockDim.y + threadIdx.y;\n    const int ltidx  = threadIdx.x;\n    const int ltidy  = threadIdx.y;\n    const int workx  = blockDim.x;\n    const int worky  = blockDim.y;\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    __shared__ float tile[k_blockDimMaxY + 2 * RADIUS][k_blockDimX + 2 * RADIUS];\n\n    const int stride_y = dimx + 2 * RADIUS;\n    const int stride_z = stride_y * (dimy + 2 * RADIUS);\n\n    int inputIndex  = 0;\n    int outputIndex = 0;\n\n    // Advance inputIndex to start of inner volume\n    inputIndex += RADIUS * stride_y + RADIUS;\n\n    // Advance inputIndex to target element\n    inputIndex += gtidy * stride_y + gtidx;\n\n    float infront[RADIUS];\n    float behind[RADIUS];\n    float current;\n\n    const int tx = ltidx + RADIUS;\n    const int ty = ltidy + RADIUS;\n\n    // Check in bounds\n    if ((gtidx >= dimx + RADIUS) || (gtidy >= dimy + RADIUS))\n        validr = false;\n\n    if ((gtidx >= dimx) || (gtidy >= dimy))\n        validw = false;\n\n    // Preload the \"infront\" and \"behind\" data\n    for (int i = RADIUS - 2; i >= 0; i--) {\n        if (validr)\n            behind[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n    if (validr)\n        current = input[inputIndex];\n\n    outputIndex = inputIndex;\n    inputIndex += stride_z;\n\n    for (int i = 0; i < RADIUS; i++) {\n        if (validr)\n            infront[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n// Step through the xy-planes\n#pragma unroll 9\n\n    for (int iz = 0; iz < dimz; iz++) {\n        // Advance the slice (move the thread-front)\n        for (int i = RADIUS - 1; i > 0; i--)\n            behind[i] = behind[i - 1];\n\n        behind[0] = current;\n        current    = infront[0];\n#pragma unroll 4\n\n        for (int i = 0; i < RADIUS - 1; i++)\n            infront[i] = infront[i + 1];\n\n        if (validr)\n            infront[RADIUS - 1] = input[inputIndex];\n\n        inputIndex += stride_z;\n        outputIndex += stride_z;\n        cg::sync(cta);\n\n        // Note that for the work items on the boundary of the problem, the\n        // supplied index when reading the halo (below) may wrap to the\n        // previous/next row or even the previous/next xy-plane. This is\n        // acceptable since a) we disable the output write for these work\n        // items and b) there is at least one xy-plane before/after the\n        // current plane, so the access will be within bounds.\n\n        // Update the data slice in the local tile\n        // Halo above & below\n        if (ltidy < RADIUS) {\n            tile[ltidy][tx]                  = input[outputIndex - RADIUS * stride_y];\n            tile[ltidy + worky + RADIUS][tx] = input[outputIndex + worky * stride_y];\n        }\n\n        // Halo left & right\n        if (ltidx < RADIUS) {\n            tile[ty][ltidx]                  = input[outputIndex - RADIUS];\n            tile[ty][ltidx + workx + RADIUS] = input[outputIndex + workx];\n        }\n\n        tile[ty][tx] = current;\n        cg::sync(cta);\n\n        // Compute the output value\n        float value = stencil[0] * current;\n#pragma unroll 4\n\n        for (int i = 1; i <= RADIUS; i++) {\n            value += stencil[i]\n                   * (infront[i - 1] + behind[i - 1] + tile[ty - i][tx] + tile[ty + i][tx] + tile[ty][tx - i]\n                      + tile[ty][tx + i]);\n        }\n\n        // Store the output value\n        if (validw)\n            output[outputIndex] = value;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Total size including padding/radius\n    const int outer_dimx = DIMX + 2 * RADIUS;\n    const int outer_dimy = DIMY + 2 * RADIUS;\n    const int outer_dimz = DIMZ + 2 * RADIUS;\n    const size_t volume_size = outer_dimx * outer_dimy * outer_dimz;\n    const size_t bytes = volume_size * sizeof(float);\n    const size_t stencil_bytes = (RADIUS + 1) * sizeof(float);\n\n    float* h_input = new float[volume_size];\n    float* h_output = new float[volume_size];\n    float* h_stencil = new float[RADIUS + 1];\n\n    // Read input data and stencil\n    read_binary(\"./data/fdtd_input.bin\", h_input, volume_size);\n    read_binary(\"./data/fdtd_stencil.bin\", h_stencil, RADIUS + 1);\n\n    // Initialize output with input (or zeros, but typically FDTD updates in place or ping-pong)\n    // Here we just zero it out to ensure kernel writes correct values\n    memset(h_output, 0, bytes);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_output, h_output, bytes, cudaMemcpyHostToDevice); // Copy initial state if needed\n    cudaMemcpyToSymbol(stencil, h_stencil, stencil_bytes);\n\n    dim3 dimBlock(k_blockDimX, k_blockDimMaxY);\n    dim3 dimGrid((DIMX + dimBlock.x - 1) / dimBlock.x, (DIMY + dimBlock.y - 1) / dimBlock.y);\n\n    FiniteDifferencesKernel<<<dimGrid, dimBlock>>>(d_output, d_input, DIMX, DIMY, DIMZ);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/fdtd_output.bin\", h_output, volume_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n    delete[] h_stencil;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 64\nDIMY = 64\nDIMZ = 64\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\nseed = 42\nnp.random.seed(seed)\n\n# Generate random input volume (with padding/halos)\ninput_vol = np.random.randn(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX).astype(np.float32)\n\n# Generate random stencil coefficients\nstencil = np.random.randn(RADIUS + 1).astype(np.float32)\n\n# Compute reference output using the star-stencil\n# We only need to compute valid inner region\noutput_vol = np.zeros_like(input_vol)\n\n# Vectorized computation for efficiency\n# Extract valid inner regions for shifts\nz_start, z_end = RADIUS, OUTER_DIMZ - RADIUS\ny_start, y_end = RADIUS, OUTER_DIMY - RADIUS\nx_start, x_end = RADIUS, OUTER_DIMX - RADIUS\n\n# Center contribution\noutput_vol[z_start:z_end, y_start:y_end, x_start:x_end] = \\\n    stencil[0] * input_vol[z_start:z_end, y_start:y_end, x_start:x_end]\n\n# Neighbor contributions\nfor i in range(1, RADIUS + 1):\n    # Z neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start-i:z_end-i, y_start:y_end, x_start:x_end] + \n                      input_vol[z_start+i:z_end+i, y_start:y_end, x_start:x_end])\n    # Y neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start-i:y_end-i, x_start:x_end] + \n                      input_vol[z_start:z_end, y_start+i:y_end+i, x_start:x_end])\n    # X neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start:y_end, x_start-i:x_end-i] + \n                      input_vol[z_start:z_end, y_start:y_end, x_start+i:x_end+i])\n\n# Save files\nos.makedirs(\"data\", exist_ok=True)\ninput_vol.tofile(\"data/fdtd_input.bin\")\nstencil.tofile(\"data/fdtd_stencil.bin\")\noutput_vol.tofile(\"data/fdtd_output_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 64\nDIMY = 64\nDIMZ = 64\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, total_elements, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Files not found\")\n        return False\n    \n    # Read full volumes\n    output = read_binary(output_file, total_elements)\n    reference = read_binary(ref_file, total_elements)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n\n    # Reshape to 3D to strip padding\n    output = output.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n    reference = reference.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n\n    # The kernel only writes to the inner volume defined by DIMX, DIMY, DIMZ\n    # We must ignore the padding region in comparison because the CUDA kernel \n    # leaves garbage/zeros there while the CPU gen might have zeros.\n    \n    valid_output = output[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n    valid_ref = reference[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n\n    diff = np.abs(valid_output - valid_ref)\n    max_diff = np.max(diff)\n    \n    # print(f\"Max difference: {max_diff}\")\n    \n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    total_elements = OUTER_DIMX * OUTER_DIMY * OUTER_DIMZ\n    out_file = \"./data/fdtd_output.bin\"\n    ref_file = \"./data/fdtd_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_elements):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task name: FDTD_3D. This kernel performs a 3D finite-difference time-domain stencil computation on a padded input grid. The input is a 72×72×72 float32 tensor with a 4-element halo on all sides, where the inner 64×64×64 region contains valid data. A 5-element float32 stencil array provides coefficients. The output is a 72×72×72 float32 tensor where only the inner 64×64×64 region is modified. For each inner grid point, compute a weighted sum of its center value and all neighbors within Euclidean distance 4 along the X/Y/Z axes, using stencil coefficients where index 0 corresponds to the center and indices 1-4 correspond to radial offsets 1-4 respectively. The halo regions must remain unchanged.", "level2_prompt": "FDTD_3D: Compute a 3D star-shaped stencil operation over a padded grid. For each point in the inner 64×64×64 domain of a 72×72×72 grid, calculate the output as a weighted sum of its value and all neighbors within Manhattan distance 4 along cardinal axes, using weights from a 5-element stencil array where weight[0] applies to the center and weights[1-4] apply to offsets 1-4.", "level3_prompt": "Compute the FDTD_3D kernel on GPU using CUDA."}
{"id": 481, "task_name": "FDTD_3D", "task_description": "Compute the FDTD_3D kernel on GPU using CUDA.", "inputs": [{"name": "fdtd_input", "dtype": "float32", "shape": "(136, 136, 136)"}, {"name": "fdtd_stencil", "dtype": "float32", "shape": "(5,)"}], "outputs": [{"name": "fdtd_output", "dtype": "float32", "shape": "(136, 136, 136)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n#define RADIUS 4\n#define k_blockDimX 32\n#define k_blockDimMaxY 16\n\n// Stencil coefficients in constant memory\n__constant__ float stencil[RADIUS + 1];\n\n// Constants for the host\nconst int DIMX = 128;\nconst int DIMY = 128;\nconst int DIMZ = 128;\n\n// The provided kernel code\n__global__ void\nFiniteDifferencesKernel(float *output, const float *input, const int dimx, const int dimy, const int dimz)\n{\n    bool      validr = true;\n    bool      validw = true;\n    const int gtidx  = blockIdx.x * blockDim.x + threadIdx.x;\n    const int gtidy  = blockIdx.y * blockDim.y + threadIdx.y;\n    const int ltidx  = threadIdx.x;\n    const int ltidy  = threadIdx.y;\n    const int workx  = blockDim.x;\n    const int worky  = blockDim.y;\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    __shared__ float tile[k_blockDimMaxY + 2 * RADIUS][k_blockDimX + 2 * RADIUS];\n\n    const int stride_y = dimx + 2 * RADIUS;\n    const int stride_z = stride_y * (dimy + 2 * RADIUS);\n\n    int inputIndex  = 0;\n    int outputIndex = 0;\n\n    // Advance inputIndex to start of inner volume\n    inputIndex += RADIUS * stride_y + RADIUS;\n\n    // Advance inputIndex to target element\n    inputIndex += gtidy * stride_y + gtidx;\n\n    float infront[RADIUS];\n    float behind[RADIUS];\n    float current;\n\n    const int tx = ltidx + RADIUS;\n    const int ty = ltidy + RADIUS;\n\n    // Check in bounds\n    if ((gtidx >= dimx + RADIUS) || (gtidy >= dimy + RADIUS))\n        validr = false;\n\n    if ((gtidx >= dimx) || (gtidy >= dimy))\n        validw = false;\n\n    // Preload the \"infront\" and \"behind\" data\n    for (int i = RADIUS - 2; i >= 0; i--) {\n        if (validr)\n            behind[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n    if (validr)\n        current = input[inputIndex];\n\n    outputIndex = inputIndex;\n    inputIndex += stride_z;\n\n    for (int i = 0; i < RADIUS; i++) {\n        if (validr)\n            infront[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n// Step through the xy-planes\n#pragma unroll 9\n\n    for (int iz = 0; iz < dimz; iz++) {\n        // Advance the slice (move the thread-front)\n        for (int i = RADIUS - 1; i > 0; i--)\n            behind[i] = behind[i - 1];\n\n        behind[0] = current;\n        current    = infront[0];\n#pragma unroll 4\n\n        for (int i = 0; i < RADIUS - 1; i++)\n            infront[i] = infront[i + 1];\n\n        if (validr)\n            infront[RADIUS - 1] = input[inputIndex];\n\n        inputIndex += stride_z;\n        outputIndex += stride_z;\n        cg::sync(cta);\n\n        // Note that for the work items on the boundary of the problem, the\n        // supplied index when reading the halo (below) may wrap to the\n        // previous/next row or even the previous/next xy-plane. This is\n        // acceptable since a) we disable the output write for these work\n        // items and b) there is at least one xy-plane before/after the\n        // current plane, so the access will be within bounds.\n\n        // Update the data slice in the local tile\n        // Halo above & below\n        if (ltidy < RADIUS) {\n            tile[ltidy][tx]                  = input[outputIndex - RADIUS * stride_y];\n            tile[ltidy + worky + RADIUS][tx] = input[outputIndex + worky * stride_y];\n        }\n\n        // Halo left & right\n        if (ltidx < RADIUS) {\n            tile[ty][ltidx]                  = input[outputIndex - RADIUS];\n            tile[ty][ltidx + workx + RADIUS] = input[outputIndex + workx];\n        }\n\n        tile[ty][tx] = current;\n        cg::sync(cta);\n\n        // Compute the output value\n        float value = stencil[0] * current;\n#pragma unroll 4\n\n        for (int i = 1; i <= RADIUS; i++) {\n            value += stencil[i]\n                   * (infront[i - 1] + behind[i - 1] + tile[ty - i][tx] + tile[ty + i][tx] + tile[ty][tx - i]\n                      + tile[ty][tx + i]);\n        }\n\n        // Store the output value\n        if (validw)\n            output[outputIndex] = value;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Total size including padding/radius\n    const int outer_dimx = DIMX + 2 * RADIUS;\n    const int outer_dimy = DIMY + 2 * RADIUS;\n    const int outer_dimz = DIMZ + 2 * RADIUS;\n    const size_t volume_size = outer_dimx * outer_dimy * outer_dimz;\n    const size_t bytes = volume_size * sizeof(float);\n    const size_t stencil_bytes = (RADIUS + 1) * sizeof(float);\n\n    float* h_input = new float[volume_size];\n    float* h_output = new float[volume_size];\n    float* h_stencil = new float[RADIUS + 1];\n\n    // Read input data and stencil\n    read_binary(\"./data/fdtd_input.bin\", h_input, volume_size);\n    read_binary(\"./data/fdtd_stencil.bin\", h_stencil, RADIUS + 1);\n\n    // Initialize output with input (or zeros, but typically FDTD updates in place or ping-pong)\n    // Here we just zero it out to ensure kernel writes correct values\n    memset(h_output, 0, bytes);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_output, h_output, bytes, cudaMemcpyHostToDevice); // Copy initial state if needed\n    cudaMemcpyToSymbol(stencil, h_stencil, stencil_bytes);\n\n    dim3 dimBlock(k_blockDimX, k_blockDimMaxY);\n    dim3 dimGrid((DIMX + dimBlock.x - 1) / dimBlock.x, (DIMY + dimBlock.y - 1) / dimBlock.y);\n\n    FiniteDifferencesKernel<<<dimGrid, dimBlock>>>(d_output, d_input, DIMX, DIMY, DIMZ);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/fdtd_output.bin\", h_output, volume_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n    delete[] h_stencil;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 128\nDIMY = 128\nDIMZ = 128\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\nseed = 42\nnp.random.seed(seed)\n\n# Generate random input volume (with padding/halos)\ninput_vol = np.random.randn(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX).astype(np.float32)\n\n# Generate random stencil coefficients\nstencil = np.random.randn(RADIUS + 1).astype(np.float32)\n\n# Compute reference output using the star-stencil\n# We only need to compute valid inner region\noutput_vol = np.zeros_like(input_vol)\n\n# Vectorized computation for efficiency\n# Extract valid inner regions for shifts\nz_start, z_end = RADIUS, OUTER_DIMZ - RADIUS\ny_start, y_end = RADIUS, OUTER_DIMY - RADIUS\nx_start, x_end = RADIUS, OUTER_DIMX - RADIUS\n\n# Center contribution\noutput_vol[z_start:z_end, y_start:y_end, x_start:x_end] = \\\n    stencil[0] * input_vol[z_start:z_end, y_start:y_end, x_start:x_end]\n\n# Neighbor contributions\nfor i in range(1, RADIUS + 1):\n    # Z neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start-i:z_end-i, y_start:y_end, x_start:x_end] + \n                      input_vol[z_start+i:z_end+i, y_start:y_end, x_start:x_end])\n    # Y neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start-i:y_end-i, x_start:x_end] + \n                      input_vol[z_start:z_end, y_start+i:y_end+i, x_start:x_end])\n    # X neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start:y_end, x_start-i:x_end-i] + \n                      input_vol[z_start:z_end, y_start:y_end, x_start+i:x_end+i])\n\n# Save files\nos.makedirs(\"data\", exist_ok=True)\ninput_vol.tofile(\"data/fdtd_input.bin\")\nstencil.tofile(\"data/fdtd_stencil.bin\")\noutput_vol.tofile(\"data/fdtd_output_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 128\nDIMY = 128\nDIMZ = 128\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, total_elements, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Files not found\")\n        return False\n    \n    # Read full volumes\n    output = read_binary(output_file, total_elements)\n    reference = read_binary(ref_file, total_elements)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n\n    # Reshape to 3D to strip padding\n    output = output.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n    reference = reference.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n\n    # The kernel only writes to the inner volume defined by DIMX, DIMY, DIMZ\n    # We must ignore the padding region in comparison because the CUDA kernel \n    # leaves garbage/zeros there while the CPU gen might have zeros.\n    \n    valid_output = output[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n    valid_ref = reference[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n\n    diff = np.abs(valid_output - valid_ref)\n    max_diff = np.max(diff)\n    \n    # print(f\"Max difference: {max_diff}\")\n    \n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    total_elements = OUTER_DIMX * OUTER_DIMY * OUTER_DIMZ\n    out_file = \"./data/fdtd_output.bin\"\n    ref_file = \"./data/fdtd_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_elements):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: FDTD_3D. Apply a 3D finite-difference stencil with a radius of 4 to update the inner region of a padded volume. The input is a 136x136x136 float32 tensor representing the volume with padding, and a 5-element float32 tensor for stencil coefficients. The kernel must update only the inner 128x128x128 region by computing a weighted sum of each point and its neighbors in all three dimensions at distances 1 to 4. The output is a 136x136x136 float32 tensor where padding regions remain unchanged.", "level2_prompt": "Task: FDTD_3D. For each point (z,y,x) in the inner 128x128x128 region of a 136x136x136 volume, compute the output value as: stencil[0] × center_value + ∑_{d=1}^4 stencil[d] × (sum of neighbors at ±d steps along x, y, and z axes). The stencil is a 5-element array where index 0 is the center coefficient and indices 1-4 are neighbor coefficients.", "level3_prompt": "Apply a 3D finite-difference stencil update with radius 4 to a padded volume."}
{"id": 482, "task_name": "FDTD_3D", "task_description": "Compute the FDTD_3D kernel on GPU using CUDA.", "inputs": [{"name": "fdtd_input", "dtype": "float32", "shape": "(264, 264, 264)"}, {"name": "fdtd_stencil", "dtype": "float32", "shape": "(5,)"}], "outputs": [{"name": "fdtd_output", "dtype": "float32", "shape": "(264, 264, 264)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n#define RADIUS 4\n#define k_blockDimX 32\n#define k_blockDimMaxY 16\n\n// Stencil coefficients in constant memory\n__constant__ float stencil[RADIUS + 1];\n\n// Constants for the host\nconst int DIMX = 256;\nconst int DIMY = 256;\nconst int DIMZ = 256;\n\n// The provided kernel code\n__global__ void\nFiniteDifferencesKernel(float *output, const float *input, const int dimx, const int dimy, const int dimz)\n{\n    bool      validr = true;\n    bool      validw = true;\n    const int gtidx  = blockIdx.x * blockDim.x + threadIdx.x;\n    const int gtidy  = blockIdx.y * blockDim.y + threadIdx.y;\n    const int ltidx  = threadIdx.x;\n    const int ltidy  = threadIdx.y;\n    const int workx  = blockDim.x;\n    const int worky  = blockDim.y;\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    __shared__ float tile[k_blockDimMaxY + 2 * RADIUS][k_blockDimX + 2 * RADIUS];\n\n    const int stride_y = dimx + 2 * RADIUS;\n    const int stride_z = stride_y * (dimy + 2 * RADIUS);\n\n    int inputIndex  = 0;\n    int outputIndex = 0;\n\n    // Advance inputIndex to start of inner volume\n    inputIndex += RADIUS * stride_y + RADIUS;\n\n    // Advance inputIndex to target element\n    inputIndex += gtidy * stride_y + gtidx;\n\n    float infront[RADIUS];\n    float behind[RADIUS];\n    float current;\n\n    const int tx = ltidx + RADIUS;\n    const int ty = ltidy + RADIUS;\n\n    // Check in bounds\n    if ((gtidx >= dimx + RADIUS) || (gtidy >= dimy + RADIUS))\n        validr = false;\n\n    if ((gtidx >= dimx) || (gtidy >= dimy))\n        validw = false;\n\n    // Preload the \"infront\" and \"behind\" data\n    for (int i = RADIUS - 2; i >= 0; i--) {\n        if (validr)\n            behind[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n    if (validr)\n        current = input[inputIndex];\n\n    outputIndex = inputIndex;\n    inputIndex += stride_z;\n\n    for (int i = 0; i < RADIUS; i++) {\n        if (validr)\n            infront[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n// Step through the xy-planes\n#pragma unroll 9\n\n    for (int iz = 0; iz < dimz; iz++) {\n        // Advance the slice (move the thread-front)\n        for (int i = RADIUS - 1; i > 0; i--)\n            behind[i] = behind[i - 1];\n\n        behind[0] = current;\n        current    = infront[0];\n#pragma unroll 4\n\n        for (int i = 0; i < RADIUS - 1; i++)\n            infront[i] = infront[i + 1];\n\n        if (validr)\n            infront[RADIUS - 1] = input[inputIndex];\n\n        inputIndex += stride_z;\n        outputIndex += stride_z;\n        cg::sync(cta);\n\n        // Note that for the work items on the boundary of the problem, the\n        // supplied index when reading the halo (below) may wrap to the\n        // previous/next row or even the previous/next xy-plane. This is\n        // acceptable since a) we disable the output write for these work\n        // items and b) there is at least one xy-plane before/after the\n        // current plane, so the access will be within bounds.\n\n        // Update the data slice in the local tile\n        // Halo above & below\n        if (ltidy < RADIUS) {\n            tile[ltidy][tx]                  = input[outputIndex - RADIUS * stride_y];\n            tile[ltidy + worky + RADIUS][tx] = input[outputIndex + worky * stride_y];\n        }\n\n        // Halo left & right\n        if (ltidx < RADIUS) {\n            tile[ty][ltidx]                  = input[outputIndex - RADIUS];\n            tile[ty][ltidx + workx + RADIUS] = input[outputIndex + workx];\n        }\n\n        tile[ty][tx] = current;\n        cg::sync(cta);\n\n        // Compute the output value\n        float value = stencil[0] * current;\n#pragma unroll 4\n\n        for (int i = 1; i <= RADIUS; i++) {\n            value += stencil[i]\n                   * (infront[i - 1] + behind[i - 1] + tile[ty - i][tx] + tile[ty + i][tx] + tile[ty][tx - i]\n                      + tile[ty][tx + i]);\n        }\n\n        // Store the output value\n        if (validw)\n            output[outputIndex] = value;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Total size including padding/radius\n    const int outer_dimx = DIMX + 2 * RADIUS;\n    const int outer_dimy = DIMY + 2 * RADIUS;\n    const int outer_dimz = DIMZ + 2 * RADIUS;\n    const size_t volume_size = outer_dimx * outer_dimy * outer_dimz;\n    const size_t bytes = volume_size * sizeof(float);\n    const size_t stencil_bytes = (RADIUS + 1) * sizeof(float);\n\n    float* h_input = new float[volume_size];\n    float* h_output = new float[volume_size];\n    float* h_stencil = new float[RADIUS + 1];\n\n    // Read input data and stencil\n    read_binary(\"./data/fdtd_input.bin\", h_input, volume_size);\n    read_binary(\"./data/fdtd_stencil.bin\", h_stencil, RADIUS + 1);\n\n    // Initialize output with input (or zeros, but typically FDTD updates in place or ping-pong)\n    // Here we just zero it out to ensure kernel writes correct values\n    memset(h_output, 0, bytes);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_output, h_output, bytes, cudaMemcpyHostToDevice); // Copy initial state if needed\n    cudaMemcpyToSymbol(stencil, h_stencil, stencil_bytes);\n\n    dim3 dimBlock(k_blockDimX, k_blockDimMaxY);\n    dim3 dimGrid((DIMX + dimBlock.x - 1) / dimBlock.x, (DIMY + dimBlock.y - 1) / dimBlock.y);\n\n    FiniteDifferencesKernel<<<dimGrid, dimBlock>>>(d_output, d_input, DIMX, DIMY, DIMZ);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/fdtd_output.bin\", h_output, volume_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n    delete[] h_stencil;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 256\nDIMY = 256\nDIMZ = 256\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\nseed = 42\nnp.random.seed(seed)\n\n# Generate random input volume (with padding/halos)\ninput_vol = np.random.randn(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX).astype(np.float32)\n\n# Generate random stencil coefficients\nstencil = np.random.randn(RADIUS + 1).astype(np.float32)\n\n# Compute reference output using the star-stencil\n# We only need to compute valid inner region\noutput_vol = np.zeros_like(input_vol)\n\n# Vectorized computation for efficiency\n# Extract valid inner regions for shifts\nz_start, z_end = RADIUS, OUTER_DIMZ - RADIUS\ny_start, y_end = RADIUS, OUTER_DIMY - RADIUS\nx_start, x_end = RADIUS, OUTER_DIMX - RADIUS\n\n# Center contribution\noutput_vol[z_start:z_end, y_start:y_end, x_start:x_end] = \\\n    stencil[0] * input_vol[z_start:z_end, y_start:y_end, x_start:x_end]\n\n# Neighbor contributions\nfor i in range(1, RADIUS + 1):\n    # Z neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start-i:z_end-i, y_start:y_end, x_start:x_end] + \n                      input_vol[z_start+i:z_end+i, y_start:y_end, x_start:x_end])\n    # Y neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start-i:y_end-i, x_start:x_end] + \n                      input_vol[z_start:z_end, y_start+i:y_end+i, x_start:x_end])\n    # X neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start:y_end, x_start-i:x_end-i] + \n                      input_vol[z_start:z_end, y_start:y_end, x_start+i:x_end+i])\n\n# Save files\nos.makedirs(\"data\", exist_ok=True)\ninput_vol.tofile(\"data/fdtd_input.bin\")\nstencil.tofile(\"data/fdtd_stencil.bin\")\noutput_vol.tofile(\"data/fdtd_output_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 256\nDIMY = 256\nDIMZ = 256\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, total_elements, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Files not found\")\n        return False\n    \n    # Read full volumes\n    output = read_binary(output_file, total_elements)\n    reference = read_binary(ref_file, total_elements)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n\n    # Reshape to 3D to strip padding\n    output = output.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n    reference = reference.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n\n    # The kernel only writes to the inner volume defined by DIMX, DIMY, DIMZ\n    # We must ignore the padding region in comparison because the CUDA kernel \n    # leaves garbage/zeros there while the CPU gen might have zeros.\n    \n    valid_output = output[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n    valid_ref = reference[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n\n    diff = np.abs(valid_output - valid_ref)\n    max_diff = np.max(diff)\n    \n    # print(f\"Max difference: {max_diff}\")\n    \n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    total_elements = OUTER_DIMX * OUTER_DIMY * OUTER_DIMZ\n    out_file = \"./data/fdtd_output.bin\"\n    ref_file = \"./data/fdtd_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_elements):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: FDTD_3D. Implement a CUDA kernel for a 3D finite-difference time-domain stencil operation. The input is a 3D tensor named 'fdtd_input' of shape (264, 264, 264) with float32 data type, which includes a padding of 4 in each dimension. The stencil coefficients are provided as a 1D tensor named 'fdtd_stencil' of shape (5,) with float32 data type. The kernel must compute the output for each point in the inner grid of dimensions (256,256,256) and write to the corresponding inner region of the output tensor 'fdtd_output', which has the same shape (264,264,264) and float32 data type. The computation for each inner point (x,y,z) is: output[z][y][x] = stencil[0] * input[z][y][x] + sum_{i=1}^{4} stencil[i] * (input[z-i][y][x] + input[z+i][y][x] + input[z][y-i][x] + input[z][y+i][x] + input[z][y][x-i] + input[z][y][x+i]). The kernel must not write to the padding region. The kernel should use shared memory to optimize data reuse for the xy-plane and iterate over the z-dimension.", "level2_prompt": "Task: FDTD_3D. For each point (x, y, z) in the inner grid of dimensions 256x256x256 (located at the center of a 264x264x264 grid), compute the output as a weighted sum of the input point and its neighbors in the x, y, and z directions at distances from 1 to 4. The weights are given by a stencil of 5 coefficients. Specifically, the output at (x,y,z) is: center weight multiplied by the input at (x,y,z) plus, for each distance i from 1 to 4, the stencil weight at index i multiplied by the sum of the six neighbors at that distance (two in each of the x, y, and z directions).", "level3_prompt": "Compute the FDTD_3D kernel on GPU using CUDA."}
{"id": 483, "task_name": "FDTD_3D", "task_description": "Compute the FDTD_3D kernel on GPU using CUDA.", "inputs": [{"name": "fdtd_input", "dtype": "float32", "shape": "(520, 520, 520)"}, {"name": "fdtd_stencil", "dtype": "float32", "shape": "(5,)"}], "outputs": [{"name": "fdtd_output", "dtype": "float32", "shape": "(520, 520, 520)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n#define RADIUS 4\n#define k_blockDimX 32\n#define k_blockDimMaxY 16\n\n// Stencil coefficients in constant memory\n__constant__ float stencil[RADIUS + 1];\n\n// Constants for the host\nconst int DIMX = 512;\nconst int DIMY = 512;\nconst int DIMZ = 512;\n\n// The provided kernel code\n__global__ void\nFiniteDifferencesKernel(float *output, const float *input, const int dimx, const int dimy, const int dimz)\n{\n    bool      validr = true;\n    bool      validw = true;\n    const int gtidx  = blockIdx.x * blockDim.x + threadIdx.x;\n    const int gtidy  = blockIdx.y * blockDim.y + threadIdx.y;\n    const int ltidx  = threadIdx.x;\n    const int ltidy  = threadIdx.y;\n    const int workx  = blockDim.x;\n    const int worky  = blockDim.y;\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    __shared__ float tile[k_blockDimMaxY + 2 * RADIUS][k_blockDimX + 2 * RADIUS];\n\n    const int stride_y = dimx + 2 * RADIUS;\n    const int stride_z = stride_y * (dimy + 2 * RADIUS);\n\n    int inputIndex  = 0;\n    int outputIndex = 0;\n\n    // Advance inputIndex to start of inner volume\n    inputIndex += RADIUS * stride_y + RADIUS;\n\n    // Advance inputIndex to target element\n    inputIndex += gtidy * stride_y + gtidx;\n\n    float infront[RADIUS];\n    float behind[RADIUS];\n    float current;\n\n    const int tx = ltidx + RADIUS;\n    const int ty = ltidy + RADIUS;\n\n    // Check in bounds\n    if ((gtidx >= dimx + RADIUS) || (gtidy >= dimy + RADIUS))\n        validr = false;\n\n    if ((gtidx >= dimx) || (gtidy >= dimy))\n        validw = false;\n\n    // Preload the \"infront\" and \"behind\" data\n    for (int i = RADIUS - 2; i >= 0; i--) {\n        if (validr)\n            behind[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n    if (validr)\n        current = input[inputIndex];\n\n    outputIndex = inputIndex;\n    inputIndex += stride_z;\n\n    for (int i = 0; i < RADIUS; i++) {\n        if (validr)\n            infront[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n// Step through the xy-planes\n#pragma unroll 9\n\n    for (int iz = 0; iz < dimz; iz++) {\n        // Advance the slice (move the thread-front)\n        for (int i = RADIUS - 1; i > 0; i--)\n            behind[i] = behind[i - 1];\n\n        behind[0] = current;\n        current    = infront[0];\n#pragma unroll 4\n\n        for (int i = 0; i < RADIUS - 1; i++)\n            infront[i] = infront[i + 1];\n\n        if (validr)\n            infront[RADIUS - 1] = input[inputIndex];\n\n        inputIndex += stride_z;\n        outputIndex += stride_z;\n        cg::sync(cta);\n\n        // Note that for the work items on the boundary of the problem, the\n        // supplied index when reading the halo (below) may wrap to the\n        // previous/next row or even the previous/next xy-plane. This is\n        // acceptable since a) we disable the output write for these work\n        // items and b) there is at least one xy-plane before/after the\n        // current plane, so the access will be within bounds.\n\n        // Update the data slice in the local tile\n        // Halo above & below\n        if (ltidy < RADIUS) {\n            tile[ltidy][tx]                  = input[outputIndex - RADIUS * stride_y];\n            tile[ltidy + worky + RADIUS][tx] = input[outputIndex + worky * stride_y];\n        }\n\n        // Halo left & right\n        if (ltidx < RADIUS) {\n            tile[ty][ltidx]                  = input[outputIndex - RADIUS];\n            tile[ty][ltidx + workx + RADIUS] = input[outputIndex + workx];\n        }\n\n        tile[ty][tx] = current;\n        cg::sync(cta);\n\n        // Compute the output value\n        float value = stencil[0] * current;\n#pragma unroll 4\n\n        for (int i = 1; i <= RADIUS; i++) {\n            value += stencil[i]\n                   * (infront[i - 1] + behind[i - 1] + tile[ty - i][tx] + tile[ty + i][tx] + tile[ty][tx - i]\n                      + tile[ty][tx + i]);\n        }\n\n        // Store the output value\n        if (validw)\n            output[outputIndex] = value;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Total size including padding/radius\n    const int outer_dimx = DIMX + 2 * RADIUS;\n    const int outer_dimy = DIMY + 2 * RADIUS;\n    const int outer_dimz = DIMZ + 2 * RADIUS;\n    const size_t volume_size = outer_dimx * outer_dimy * outer_dimz;\n    const size_t bytes = volume_size * sizeof(float);\n    const size_t stencil_bytes = (RADIUS + 1) * sizeof(float);\n\n    float* h_input = new float[volume_size];\n    float* h_output = new float[volume_size];\n    float* h_stencil = new float[RADIUS + 1];\n\n    // Read input data and stencil\n    read_binary(\"./data/fdtd_input.bin\", h_input, volume_size);\n    read_binary(\"./data/fdtd_stencil.bin\", h_stencil, RADIUS + 1);\n\n    // Initialize output with input (or zeros, but typically FDTD updates in place or ping-pong)\n    // Here we just zero it out to ensure kernel writes correct values\n    memset(h_output, 0, bytes);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_output, h_output, bytes, cudaMemcpyHostToDevice); // Copy initial state if needed\n    cudaMemcpyToSymbol(stencil, h_stencil, stencil_bytes);\n\n    dim3 dimBlock(k_blockDimX, k_blockDimMaxY);\n    dim3 dimGrid((DIMX + dimBlock.x - 1) / dimBlock.x, (DIMY + dimBlock.y - 1) / dimBlock.y);\n\n    FiniteDifferencesKernel<<<dimGrid, dimBlock>>>(d_output, d_input, DIMX, DIMY, DIMZ);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/fdtd_output.bin\", h_output, volume_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n    delete[] h_stencil;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 512\nDIMY = 512\nDIMZ = 512\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\nseed = 42\nnp.random.seed(seed)\n\n# Generate random input volume (with padding/halos)\ninput_vol = np.random.randn(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX).astype(np.float32)\n\n# Generate random stencil coefficients\nstencil = np.random.randn(RADIUS + 1).astype(np.float32)\n\n# Compute reference output using the star-stencil\n# We only need to compute valid inner region\noutput_vol = np.zeros_like(input_vol)\n\n# Vectorized computation for efficiency\n# Extract valid inner regions for shifts\nz_start, z_end = RADIUS, OUTER_DIMZ - RADIUS\ny_start, y_end = RADIUS, OUTER_DIMY - RADIUS\nx_start, x_end = RADIUS, OUTER_DIMX - RADIUS\n\n# Center contribution\noutput_vol[z_start:z_end, y_start:y_end, x_start:x_end] = \\\n    stencil[0] * input_vol[z_start:z_end, y_start:y_end, x_start:x_end]\n\n# Neighbor contributions\nfor i in range(1, RADIUS + 1):\n    # Z neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start-i:z_end-i, y_start:y_end, x_start:x_end] + \n                      input_vol[z_start+i:z_end+i, y_start:y_end, x_start:x_end])\n    # Y neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start-i:y_end-i, x_start:x_end] + \n                      input_vol[z_start:z_end, y_start+i:y_end+i, x_start:x_end])\n    # X neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start:y_end, x_start-i:x_end-i] + \n                      input_vol[z_start:z_end, y_start:y_end, x_start+i:x_end+i])\n\n# Save files\nos.makedirs(\"data\", exist_ok=True)\ninput_vol.tofile(\"data/fdtd_input.bin\")\nstencil.tofile(\"data/fdtd_stencil.bin\")\noutput_vol.tofile(\"data/fdtd_output_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 512\nDIMY = 512\nDIMZ = 512\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, total_elements, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Files not found\")\n        return False\n    \n    # Read full volumes\n    output = read_binary(output_file, total_elements)\n    reference = read_binary(ref_file, total_elements)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n\n    # Reshape to 3D to strip padding\n    output = output.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n    reference = reference.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n\n    # The kernel only writes to the inner volume defined by DIMX, DIMY, DIMZ\n    # We must ignore the padding region in comparison because the CUDA kernel \n    # leaves garbage/zeros there while the CPU gen might have zeros.\n    \n    valid_output = output[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n    valid_ref = reference[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n\n    diff = np.abs(valid_output - valid_ref)\n    max_diff = np.max(diff)\n    \n    # print(f\"Max difference: {max_diff}\")\n    \n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    total_elements = OUTER_DIMX * OUTER_DIMY * OUTER_DIMZ\n    out_file = \"./data/fdtd_output.bin\"\n    ref_file = \"./data/fdtd_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_elements):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the FDTD_3D kernel to perform a 3D finite-difference time-domain computation. The kernel takes two inputs: a 520×520×520 float32 tensor representing a padded 3D grid and a 5-element float32 tensor containing stencil coefficients. It outputs a 520×520×520 float32 tensor. The computation must apply a star-shaped stencil with a radius of 4 to each point in the inner 512×512×512 region of the input grid, while leaving the outer padding unchanged. The stencil uses the center point and neighbors along all three axes at offsets ±1 to ±4. Only the inner region must be updated; the padding should remain unmodified.", "level2_prompt": "FDTD_3D kernel: For each point (x,y,z) in the inner 512×512×512 grid, compute the weighted sum of the center point and its 24 neighbors (±1 to ±4 offsets along x, y, z axes). Weights are defined by a 5-element stencil array where index 0 is the center weight and indices 1-4 are weights for neighbors at distances 1-4. The input grid includes a 4-unit padding on all sides, which must not be modified in the output.", "level3_prompt": "Compute the FDTD_3D kernel on GPU using CUDA."}
{"id": 484, "task_name": "FDTD_3D", "task_description": "Compute the FDTD_3D kernel on GPU using CUDA.", "inputs": [{"name": "fdtd_input", "dtype": "float32", "shape": "(1032, 1032, 1032)"}, {"name": "fdtd_stencil", "dtype": "float32", "shape": "(5,)"}], "outputs": [{"name": "fdtd_output", "dtype": "float32", "shape": "(1032, 1032, 1032)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <cooperative_groups.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\nnamespace cg = cooperative_groups;\n\n#define RADIUS 4\n#define k_blockDimX 32\n#define k_blockDimMaxY 16\n\n// Stencil coefficients in constant memory\n__constant__ float stencil[RADIUS + 1];\n\n// Constants for the host\nconst int DIMX = 1024;\nconst int DIMY = 1024;\nconst int DIMZ = 1024;\n\n// The provided kernel code\n__global__ void\nFiniteDifferencesKernel(float *output, const float *input, const int dimx, const int dimy, const int dimz)\n{\n    bool      validr = true;\n    bool      validw = true;\n    const int gtidx  = blockIdx.x * blockDim.x + threadIdx.x;\n    const int gtidy  = blockIdx.y * blockDim.y + threadIdx.y;\n    const int ltidx  = threadIdx.x;\n    const int ltidy  = threadIdx.y;\n    const int workx  = blockDim.x;\n    const int worky  = blockDim.y;\n    // Handle to thread block group\n    cg::thread_block cta = cg::this_thread_block();\n    __shared__ float tile[k_blockDimMaxY + 2 * RADIUS][k_blockDimX + 2 * RADIUS];\n\n    const int stride_y = dimx + 2 * RADIUS;\n    const int stride_z = stride_y * (dimy + 2 * RADIUS);\n\n    int inputIndex  = 0;\n    int outputIndex = 0;\n\n    // Advance inputIndex to start of inner volume\n    inputIndex += RADIUS * stride_y + RADIUS;\n\n    // Advance inputIndex to target element\n    inputIndex += gtidy * stride_y + gtidx;\n\n    float infront[RADIUS];\n    float behind[RADIUS];\n    float current;\n\n    const int tx = ltidx + RADIUS;\n    const int ty = ltidy + RADIUS;\n\n    // Check in bounds\n    if ((gtidx >= dimx + RADIUS) || (gtidy >= dimy + RADIUS))\n        validr = false;\n\n    if ((gtidx >= dimx) || (gtidy >= dimy))\n        validw = false;\n\n    // Preload the \"infront\" and \"behind\" data\n    for (int i = RADIUS - 2; i >= 0; i--) {\n        if (validr)\n            behind[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n    if (validr)\n        current = input[inputIndex];\n\n    outputIndex = inputIndex;\n    inputIndex += stride_z;\n\n    for (int i = 0; i < RADIUS; i++) {\n        if (validr)\n            infront[i] = input[inputIndex];\n\n        inputIndex += stride_z;\n    }\n\n// Step through the xy-planes\n#pragma unroll 9\n\n    for (int iz = 0; iz < dimz; iz++) {\n        // Advance the slice (move the thread-front)\n        for (int i = RADIUS - 1; i > 0; i--)\n            behind[i] = behind[i - 1];\n\n        behind[0] = current;\n        current    = infront[0];\n#pragma unroll 4\n\n        for (int i = 0; i < RADIUS - 1; i++)\n            infront[i] = infront[i + 1];\n\n        if (validr)\n            infront[RADIUS - 1] = input[inputIndex];\n\n        inputIndex += stride_z;\n        outputIndex += stride_z;\n        cg::sync(cta);\n\n        // Note that for the work items on the boundary of the problem, the\n        // supplied index when reading the halo (below) may wrap to the\n        // previous/next row or even the previous/next xy-plane. This is\n        // acceptable since a) we disable the output write for these work\n        // items and b) there is at least one xy-plane before/after the\n        // current plane, so the access will be within bounds.\n\n        // Update the data slice in the local tile\n        // Halo above & below\n        if (ltidy < RADIUS) {\n            tile[ltidy][tx]                  = input[outputIndex - RADIUS * stride_y];\n            tile[ltidy + worky + RADIUS][tx] = input[outputIndex + worky * stride_y];\n        }\n\n        // Halo left & right\n        if (ltidx < RADIUS) {\n            tile[ty][ltidx]                  = input[outputIndex - RADIUS];\n            tile[ty][ltidx + workx + RADIUS] = input[outputIndex + workx];\n        }\n\n        tile[ty][tx] = current;\n        cg::sync(cta);\n\n        // Compute the output value\n        float value = stencil[0] * current;\n#pragma unroll 4\n\n        for (int i = 1; i <= RADIUS; i++) {\n            value += stencil[i]\n                   * (infront[i - 1] + behind[i - 1] + tile[ty - i][tx] + tile[ty + i][tx] + tile[ty][tx - i]\n                      + tile[ty][tx + i]);\n        }\n\n        // Store the output value\n        if (validw)\n            output[outputIndex] = value;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    // Total size including padding/radius\n    const int outer_dimx = DIMX + 2 * RADIUS;\n    const int outer_dimy = DIMY + 2 * RADIUS;\n    const int outer_dimz = DIMZ + 2 * RADIUS;\n    const size_t volume_size = outer_dimx * outer_dimy * outer_dimz;\n    const size_t bytes = volume_size * sizeof(float);\n    const size_t stencil_bytes = (RADIUS + 1) * sizeof(float);\n\n    float* h_input = new float[volume_size];\n    float* h_output = new float[volume_size];\n    float* h_stencil = new float[RADIUS + 1];\n\n    // Read input data and stencil\n    read_binary(\"./data/fdtd_input.bin\", h_input, volume_size);\n    read_binary(\"./data/fdtd_stencil.bin\", h_stencil, RADIUS + 1);\n\n    // Initialize output with input (or zeros, but typically FDTD updates in place or ping-pong)\n    // Here we just zero it out to ensure kernel writes correct values\n    memset(h_output, 0, bytes);\n\n    float *d_input, *d_output;\n    cudaMalloc(&d_input, bytes);\n    cudaMalloc(&d_output, bytes);\n\n    cudaMemcpy(d_input, h_input, bytes, cudaMemcpyHostToDevice);\n    cudaMemcpy(d_output, h_output, bytes, cudaMemcpyHostToDevice); // Copy initial state if needed\n    cudaMemcpyToSymbol(stencil, h_stencil, stencil_bytes);\n\n    dim3 dimBlock(k_blockDimX, k_blockDimMaxY);\n    dim3 dimGrid((DIMX + dimBlock.x - 1) / dimBlock.x, (DIMY + dimBlock.y - 1) / dimBlock.y);\n\n    FiniteDifferencesKernel<<<dimGrid, dimBlock>>>(d_output, d_input, DIMX, DIMY, DIMZ);\n\n    cudaMemcpy(h_output, d_output, bytes, cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/fdtd_output.bin\", h_output, volume_size);\n\n    cudaFree(d_input);\n    cudaFree(d_output);\n    delete[] h_input;\n    delete[] h_output;\n    delete[] h_stencil;\n\n    return 0;\n}", "gen.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 1024\nDIMY = 1024\nDIMZ = 1024\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\nseed = 42\nnp.random.seed(seed)\n\n# Generate random input volume (with padding/halos)\ninput_vol = np.random.randn(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX).astype(np.float32)\n\n# Generate random stencil coefficients\nstencil = np.random.randn(RADIUS + 1).astype(np.float32)\n\n# Compute reference output using the star-stencil\n# We only need to compute valid inner region\noutput_vol = np.zeros_like(input_vol)\n\n# Vectorized computation for efficiency\n# Extract valid inner regions for shifts\nz_start, z_end = RADIUS, OUTER_DIMZ - RADIUS\ny_start, y_end = RADIUS, OUTER_DIMY - RADIUS\nx_start, x_end = RADIUS, OUTER_DIMX - RADIUS\n\n# Center contribution\noutput_vol[z_start:z_end, y_start:y_end, x_start:x_end] = \\\n    stencil[0] * input_vol[z_start:z_end, y_start:y_end, x_start:x_end]\n\n# Neighbor contributions\nfor i in range(1, RADIUS + 1):\n    # Z neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start-i:z_end-i, y_start:y_end, x_start:x_end] + \n                      input_vol[z_start+i:z_end+i, y_start:y_end, x_start:x_end])\n    # Y neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start-i:y_end-i, x_start:x_end] + \n                      input_vol[z_start:z_end, y_start+i:y_end+i, x_start:x_end])\n    # X neighbors\n    output_vol[z_start:z_end, y_start:y_end, x_start:x_end] += \\\n        stencil[i] * (input_vol[z_start:z_end, y_start:y_end, x_start-i:x_end-i] + \n                      input_vol[z_start:z_end, y_start:y_end, x_start+i:x_end+i])\n\n# Save files\nos.makedirs(\"data\", exist_ok=True)\ninput_vol.tofile(\"data/fdtd_input.bin\")\nstencil.tofile(\"data/fdtd_stencil.bin\")\noutput_vol.tofile(\"data/fdtd_output_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\n# Constants\nDIMX = 1024\nDIMY = 1024\nDIMZ = 1024\nRADIUS = 4\nOUTER_DIMX = DIMX + 2 * RADIUS\nOUTER_DIMY = DIMY + 2 * RADIUS\nOUTER_DIMZ = DIMZ + 2 * RADIUS\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, total_elements, tolerance=1e-4):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Files not found\")\n        return False\n    \n    # Read full volumes\n    output = read_binary(output_file, total_elements)\n    reference = read_binary(ref_file, total_elements)\n    \n    if output.shape != reference.shape:\n        print(\"Shape mismatch\")\n        return False\n\n    # Reshape to 3D to strip padding\n    output = output.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n    reference = reference.reshape(OUTER_DIMZ, OUTER_DIMY, OUTER_DIMX)\n\n    # The kernel only writes to the inner volume defined by DIMX, DIMY, DIMZ\n    # We must ignore the padding region in comparison because the CUDA kernel \n    # leaves garbage/zeros there while the CPU gen might have zeros.\n    \n    valid_output = output[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n    valid_ref = reference[RADIUS:-RADIUS, RADIUS:-RADIUS, RADIUS:-RADIUS]\n\n    diff = np.abs(valid_output - valid_ref)\n    max_diff = np.max(diff)\n    \n    # print(f\"Max difference: {max_diff}\")\n    \n    return np.all(diff < tolerance)\n\nif __name__ == \"__main__\":\n    total_elements = OUTER_DIMX * OUTER_DIMY * OUTER_DIMZ\n    out_file = \"./data/fdtd_output.bin\"\n    ref_file = \"./data/fdtd_output_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, total_elements):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: FDTD_3D. The kernel must compute a 3D finite-difference time-domain (FDTD) stencil operation with a radius of 4. Inputs include a float32 tensor of shape (1032, 1032, 1032) representing a padded 3D grid and a float32 tensor of shape (5,) containing stencil coefficients. The output is a float32 tensor of shape (1032, 1032, 1032). The computation applies the stencil to each point in the inner grid (1024x1024x1024) by summing weighted contributions from the center point and its neighbors at distances 1 to 4 along the x, y, and z axes. The padded regions in the output remain unchanged.", "level2_prompt": "Task: FDTD_3D. For each point (x, y, z) in the inner 1024x1024x1024 grid, compute the output value as: output[x,y,z] = stencil[0] * input[x,y,z] + Σ_{i=1}^{4} stencil[i] * (input[x±i,y,z] + input[x,y±i,z] + input[x,y,z±i]), where input and output tensors include padding of 4 units.", "level3_prompt": "Compute the FDTD_3D stencil operation."}
{"id": 485, "task_name": "Lennard_Jones", "task_description": "Compute the Lennard_Jones kernel on GPU using CUDA.", "inputs": [{"name": "pos", "dtype": "float32", "shape": "(1024, 4)"}], "outputs": [{"name": "force_out", "dtype": "float32", "shape": "(1024, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\n#define NUM_ATOMS 1024\n#define BLOCK_SIZE 256\n\n__global__ void compute_lj_force_kernel(\n    float4* pos, \n    float3* force, \n    int num_atoms,\n    float cutsq, \n    float epsilon, \n    float sigma6) {\n\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= num_atoms) return;\n\n    float3 f_i = {0.0f, 0.0f, 0.0f};\n    float4 pos_i = pos[i];\n\n    for (int j = 0; j < num_atoms; j++) {\n        if (i == j) continue;\n        float4 pos_j = pos[j];\n        float dx = pos_i.x - pos_j.x;\n        float dy = pos_i.y - pos_j.y;\n        float dz = pos_i.z - pos_j.z;\n        float rsq = dx*dx + dy*dy + dz*dz;\n\n        if (rsq < cutsq) {\n            float r2inv = 1.0f / rsq;\n            float r6inv = r2inv * r2inv * r2inv;\n            // Standard LJ Force: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1.0) * r2inv\n            float f_factor = 24.0f * epsilon * r6inv * (2.0f * sigma6 * r6inv - 1.0f) * r2inv;\n            \n            f_i.x += dx * f_factor;\n            f_i.y += dy * f_factor;\n            f_i.z += dz * f_factor;\n        }\n    }\n    force[i] = f_i;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int num_atoms = NUM_ATOMS;\n    float cutsq = 100.0f; \n    float epsilon = 1.0f;\n    float sigma6 = 1.0f; // sigma^6\n\n    size_t size_pos = num_atoms * 4;\n    size_t size_force = num_atoms * 3;\n\n    float *h_pos = new float[size_pos];\n    float *h_force = new float[size_force];\n\n    read_binary(\"./data/pos.bin\", h_pos, size_pos);\n\n    float4 *d_pos;\n    float3 *d_force;\n    cudaMalloc(&d_pos, num_atoms * sizeof(float4));\n    cudaMalloc(&d_force, num_atoms * sizeof(float3));\n\n    cudaMemcpy(d_pos, h_pos, num_atoms * sizeof(float4), cudaMemcpyHostToDevice);\n\n    int blocks = (num_atoms + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    compute_lj_force_kernel<<<blocks, BLOCK_SIZE>>>(d_pos, d_force, num_atoms, cutsq, epsilon, sigma6);\n\n    cudaMemcpy(h_force, d_force, num_atoms * sizeof(float3), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/force_out.bin\", h_force, size_force);\n\n    cudaFree(d_pos);\n    cudaFree(d_force);\n    delete[] h_pos;\n    delete[] h_force;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport numpy as np\nimport math\n\nnum_atoms = 1024\ncutsq = 100.0\nepsilon = 1.0\nsigma6 = 1.0\nbox_size = 64.0\n\nseed = 42\ntorch.manual_seed(seed)\n\ngrid_dim = int(math.ceil(num_atoms**(1/3)))\nspacing = box_size / grid_dim\n\nx = torch.linspace(0, box_size - spacing, grid_dim)\ny = torch.linspace(0, box_size - spacing, grid_dim)\nz = torch.linspace(0, box_size - spacing, grid_dim)\n\ngrid_x, grid_y, grid_z = torch.meshgrid(x, y, z, indexing='ij')\ngrid_pos = torch.stack([grid_x, grid_y, grid_z], dim=-1).reshape(-1, 3)\n\npos_xyz = grid_pos[:num_atoms]\n\nnoise = (torch.rand(num_atoms, 3) - 0.5) * (spacing * 0.2)\npos_xyz += noise\n\npos_w = torch.zeros(num_atoms, 1)\npos = torch.cat([pos_xyz, pos_w], dim=1).float()\n\nforce = torch.zeros(num_atoms, 3, dtype=torch.float32)\n\nchunk_size = 128\nall_pos_d = pos[:, :3].double()\n\nfor i in range(0, num_atoms, chunk_size):\n    end = min(i + chunk_size, num_atoms)\n    # [Chunk, 3]\n    pos_chunk = all_pos_d[i:end]\n    \n    # [Chunk, 1, 3] - [1, N, 3] -> [Chunk, N, 3]\n    diff = pos_chunk.unsqueeze(1) - all_pos_d.unsqueeze(0)\n    \n    rsq = torch.sum(diff**2, dim=2) # [Chunk, N]\n    \n    # Mask\n    mask = (rsq < cutsq) & (rsq > 1e-6)\n    \n    f_chunk = torch.zeros(end-i, 3, dtype=torch.double)\n    \n    if mask.any():\n        safe_rsq = torch.where(mask, rsq, torch.tensor(1.0, dtype=torch.double))\n        \n        r2inv = 1.0 / safe_rsq\n        r6inv = r2inv * r2inv * r2inv\n        f_factor = 24.0 * epsilon * r6inv * (2.0 * sigma6 * r6inv - 1.0) * r2inv\n        \n        forces = diff * f_factor.unsqueeze(2)\n        \n        forces = torch.where(mask.unsqueeze(2), forces, torch.tensor(0.0, dtype=torch.double))\n        \n        f_chunk = torch.sum(forces, dim=1)\n        \n    force[i:end] = f_chunk.float()\n\nmax_f_mag = torch.max(torch.norm(force, dim=1))\n# print(f\"Max Force Magnitude: {max_f_mag:.2f} (Should be < 10000)\")\n\nos.makedirs(\"data\", exist_ok=True)\npos.numpy().tofile(\"data/pos.bin\")\nforce.numpy().tofile(\"data/force_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\nNUM_ATOMS = 1024\n\ndef compare_outputs(output_file, ref_file, num_atoms, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Missing files.\")\n        return False\n    \n    # float3 * num_atoms = 3 * 4 bytes * num_atoms\n    expected_size = num_atoms * 3\n    \n    output = np.fromfile(output_file, dtype=np.float32)\n    reference = np.fromfile(ref_file, dtype=np.float32)\n    \n    if output.size != expected_size or reference.size != expected_size:\n        print(f\"Size mismatch! Expected {expected_size}, got {output.size} and {reference.size}\")\n        return False\n    \n    output = output.reshape(-1, 3)\n    reference = reference.reshape(-1, 3)\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    mean_diff = np.mean(diff)\n    \n    # print(f\"Max Diff: {max_diff:.6f}\")\n    # print(f\"Mean Diff: {mean_diff:.6f}\")\n    \n    if max_diff > tolerance:\n        idx = np.unravel_index(np.argmax(diff), diff.shape)[0]\n        # print(f\"Worst atom index: {idx}\")\n        # print(f\"CUDA: {output[idx]}\")\n        # print(f\"Ref : {reference[idx]}\")\n    \n    return max_diff < tolerance\n\nif __name__ == \"__main__\":\n    out_file = \"./data/force_out.bin\"\n    ref_file = \"./data/force_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, NUM_ATOMS, tolerance=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Lennard_Jones task: Compute the Lennard-Jones forces for each atom in a system of 1024 atoms. The input is a float32 tensor 'pos' with shape (1024, 4), where each row represents an atom's position (x, y, z) and an unused fourth component. The output is a float32 tensor 'force_out' with shape (1024, 3), representing the force vector (x, y, z) on each atom. For each atom i, calculate the force by summing contributions from all other atoms j where the squared distance between them is less than a cutoff (cutsq = 100.0). Skip self-interactions (i=j). The force calculation uses the Lennard-Jones potential formula: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1) * r2inv, where r2inv = 1/rsq, r6inv = r2inv^3, and rsq is the squared distance between atoms. Constants epsilon = 1.0 and sigma6 = 1.0 are fixed.", "level2_prompt": "Lennard_Jones task: For each atom i in a system of 1024 atoms, compute the net force vector by summing pairwise interactions with all other atoms j. Interactions occur only when the squared distance between i and j is below a cutoff threshold. The force magnitude is calculated using the Lennard-Jones potential formula, which depends on the inverse sixth power of the distance. The direction of each pairwise force is along the vector connecting atom i to atom j.", "level3_prompt": "Compute the Lennard-Jones kernel on GPU for 1024 atoms."}
{"id": 486, "task_name": "Lennard_Jones", "task_description": "Compute the Lennard_Jones kernel on GPU using CUDA.", "inputs": [{"name": "pos", "dtype": "float32", "shape": "(2048, 4)"}], "outputs": [{"name": "force_out", "dtype": "float32", "shape": "(2048, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\n#define NUM_ATOMS 2048\n#define BLOCK_SIZE 256\n\n__global__ void compute_lj_force_kernel(\n    float4* pos, \n    float3* force, \n    int num_atoms,\n    float cutsq, \n    float epsilon, \n    float sigma6) {\n\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= num_atoms) return;\n\n    float3 f_i = {0.0f, 0.0f, 0.0f};\n    float4 pos_i = pos[i];\n\n    for (int j = 0; j < num_atoms; j++) {\n        if (i == j) continue;\n        float4 pos_j = pos[j];\n        float dx = pos_i.x - pos_j.x;\n        float dy = pos_i.y - pos_j.y;\n        float dz = pos_i.z - pos_j.z;\n        float rsq = dx*dx + dy*dy + dz*dz;\n\n        if (rsq < cutsq) {\n            float r2inv = 1.0f / rsq;\n            float r6inv = r2inv * r2inv * r2inv;\n            // Standard LJ Force: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1.0) * r2inv\n            float f_factor = 24.0f * epsilon * r6inv * (2.0f * sigma6 * r6inv - 1.0f) * r2inv;\n            \n            f_i.x += dx * f_factor;\n            f_i.y += dy * f_factor;\n            f_i.z += dz * f_factor;\n        }\n    }\n    force[i] = f_i;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int num_atoms = NUM_ATOMS;\n    float cutsq = 100.0f; \n    float epsilon = 1.0f;\n    float sigma6 = 1.0f; // sigma^6\n\n    size_t size_pos = num_atoms * 4;\n    size_t size_force = num_atoms * 3;\n\n    float *h_pos = new float[size_pos];\n    float *h_force = new float[size_force];\n\n    read_binary(\"./data/pos.bin\", h_pos, size_pos);\n\n    float4 *d_pos;\n    float3 *d_force;\n    cudaMalloc(&d_pos, num_atoms * sizeof(float4));\n    cudaMalloc(&d_force, num_atoms * sizeof(float3));\n\n    cudaMemcpy(d_pos, h_pos, num_atoms * sizeof(float4), cudaMemcpyHostToDevice);\n\n    int blocks = (num_atoms + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    compute_lj_force_kernel<<<blocks, BLOCK_SIZE>>>(d_pos, d_force, num_atoms, cutsq, epsilon, sigma6);\n\n    cudaMemcpy(h_force, d_force, num_atoms * sizeof(float3), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/force_out.bin\", h_force, size_force);\n\n    cudaFree(d_pos);\n    cudaFree(d_force);\n    delete[] h_pos;\n    delete[] h_force;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport numpy as np\nimport math\n\nnum_atoms = 2048\ncutsq = 100.0\nepsilon = 1.0\nsigma6 = 1.0\nbox_size = 64.0\n\nseed = 42\ntorch.manual_seed(seed)\n\ngrid_dim = int(math.ceil(num_atoms**(1/3)))\nspacing = box_size / grid_dim\n\nx = torch.linspace(0, box_size - spacing, grid_dim)\ny = torch.linspace(0, box_size - spacing, grid_dim)\nz = torch.linspace(0, box_size - spacing, grid_dim)\n\ngrid_x, grid_y, grid_z = torch.meshgrid(x, y, z, indexing='ij')\ngrid_pos = torch.stack([grid_x, grid_y, grid_z], dim=-1).reshape(-1, 3)\n\npos_xyz = grid_pos[:num_atoms]\n\nnoise = (torch.rand(num_atoms, 3) - 0.5) * (spacing * 0.2)\npos_xyz += noise\n\npos_w = torch.zeros(num_atoms, 1)\npos = torch.cat([pos_xyz, pos_w], dim=1).float()\n\nforce = torch.zeros(num_atoms, 3, dtype=torch.float32)\n\nchunk_size = 128\nall_pos_d = pos[:, :3].double()\n\nfor i in range(0, num_atoms, chunk_size):\n    end = min(i + chunk_size, num_atoms)\n    # [Chunk, 3]\n    pos_chunk = all_pos_d[i:end]\n    \n    # [Chunk, 1, 3] - [1, N, 3] -> [Chunk, N, 3]\n    diff = pos_chunk.unsqueeze(1) - all_pos_d.unsqueeze(0)\n    \n    rsq = torch.sum(diff**2, dim=2) # [Chunk, N]\n    \n    # Mask\n    mask = (rsq < cutsq) & (rsq > 1e-6)\n    \n    f_chunk = torch.zeros(end-i, 3, dtype=torch.double)\n    \n    if mask.any():\n        safe_rsq = torch.where(mask, rsq, torch.tensor(1.0, dtype=torch.double))\n        \n        r2inv = 1.0 / safe_rsq\n        r6inv = r2inv * r2inv * r2inv\n        f_factor = 24.0 * epsilon * r6inv * (2.0 * sigma6 * r6inv - 1.0) * r2inv\n        \n        forces = diff * f_factor.unsqueeze(2)\n        \n        forces = torch.where(mask.unsqueeze(2), forces, torch.tensor(0.0, dtype=torch.double))\n        \n        f_chunk = torch.sum(forces, dim=1)\n        \n    force[i:end] = f_chunk.float()\n\nmax_f_mag = torch.max(torch.norm(force, dim=1))\n# print(f\"Max Force Magnitude: {max_f_mag:.2f} (Should be < 10000)\")\n\nos.makedirs(\"data\", exist_ok=True)\npos.numpy().tofile(\"data/pos.bin\")\nforce.numpy().tofile(\"data/force_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\nNUM_ATOMS = 2048\n\ndef compare_outputs(output_file, ref_file, num_atoms, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Missing files.\")\n        return False\n    \n    expected_size = num_atoms * 3\n    \n    output = np.fromfile(output_file, dtype=np.float32)\n    reference = np.fromfile(ref_file, dtype=np.float32)\n    \n    if output.size != expected_size or reference.size != expected_size:\n        print(f\"Size mismatch! Expected {expected_size}, got {output.size} and {reference.size}\")\n        return False\n    \n    output = output.reshape(-1, 3)\n    reference = reference.reshape(-1, 3)\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    mean_diff = np.mean(diff)\n    \n    # print(f\"Max Diff: {max_diff:.6f}\")\n    # print(f\"Mean Diff: {mean_diff:.6f}\")\n    \n    if max_diff > tolerance:\n        idx = np.unravel_index(np.argmax(diff), diff.shape)[0]\n        # print(f\"Worst atom index: {idx}\")\n        # print(f\"CUDA: {output[idx]}\")\n        # print(f\"Ref : {reference[idx]}\")\n    \n    return max_diff < tolerance\n\nif __name__ == \"__main__\":\n    out_file = \"./data/force_out.bin\"\n    ref_file = \"./data/force_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, NUM_ATOMS, tolerance=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement a CUDA kernel named 'Lennard_Jones' that calculates atomic forces using the Lennard-Jones potential. The input is a 2048×4 float32 tensor 'pos' where each row contains atomic coordinates (x,y,z) and an unused fourth value. The output must be a 2048×3 float32 tensor 'force_out' containing force vectors (fx,fy,fz) for each atom. The kernel must exclude self-interactions (i≠j), only compute interactions when squared distance is below 100.0, and use fixed parameters epsilon=1.0 and sigma6=1.0. Forces are accumulated through pairwise interactions where force contribution is calculated as 24ε·r6inv·(2σ6·r6inv - 1)·r2inv·(dx,dy,dz).", "level2_prompt": "Compute Lennard-Jones forces for 2048 atoms. For each atom i, calculate force contributions from all other atoms j where squared distance rij² < 100.0. Force contribution per pair: f = 24ε·(1/rij⁶)·[2σ⁶·(1/rij⁶) - 1]·(1/rij²)·Δr. Accumulate force vectors for each i by summing contributions from all valid j pairs. Exclude i=j interactions.", "level3_prompt": "Compute the Lennard-Jones kernel on GPU using CUDA."}
{"id": 487, "task_name": "Lennard_Jones", "task_description": "Compute the Lennard_Jones kernel on GPU using CUDA.", "inputs": [{"name": "pos", "dtype": "float32", "shape": "(4096, 4)"}], "outputs": [{"name": "force_out", "dtype": "float32", "shape": "(4096, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\n#define NUM_ATOMS 4096\n#define BLOCK_SIZE 256\n\n__global__ void compute_lj_force_kernel(\n    float4* pos, \n    float3* force, \n    int num_atoms,\n    float cutsq, \n    float epsilon, \n    float sigma6) {\n\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= num_atoms) return;\n\n    float3 f_i = {0.0f, 0.0f, 0.0f};\n    float4 pos_i = pos[i];\n\n    for (int j = 0; j < num_atoms; j++) {\n        if (i == j) continue;\n        float4 pos_j = pos[j];\n        float dx = pos_i.x - pos_j.x;\n        float dy = pos_i.y - pos_j.y;\n        float dz = pos_i.z - pos_j.z;\n        float rsq = dx*dx + dy*dy + dz*dz;\n\n        if (rsq < cutsq) {\n            float r2inv = 1.0f / rsq;\n            float r6inv = r2inv * r2inv * r2inv;\n            // Standard LJ Force: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1.0) * r2inv\n            float f_factor = 24.0f * epsilon * r6inv * (2.0f * sigma6 * r6inv - 1.0f) * r2inv;\n            \n            f_i.x += dx * f_factor;\n            f_i.y += dy * f_factor;\n            f_i.z += dz * f_factor;\n        }\n    }\n    force[i] = f_i;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int num_atoms = NUM_ATOMS;\n    float cutsq = 100.0f; \n    float epsilon = 1.0f;\n    float sigma6 = 1.0f; // sigma^6\n\n    size_t size_pos = num_atoms * 4;\n    size_t size_force = num_atoms * 3;\n\n    float *h_pos = new float[size_pos];\n    float *h_force = new float[size_force];\n\n    read_binary(\"./data/pos.bin\", h_pos, size_pos);\n\n    float4 *d_pos;\n    float3 *d_force;\n    cudaMalloc(&d_pos, num_atoms * sizeof(float4));\n    cudaMalloc(&d_force, num_atoms * sizeof(float3));\n\n    cudaMemcpy(d_pos, h_pos, num_atoms * sizeof(float4), cudaMemcpyHostToDevice);\n\n    int blocks = (num_atoms + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    compute_lj_force_kernel<<<blocks, BLOCK_SIZE>>>(d_pos, d_force, num_atoms, cutsq, epsilon, sigma6);\n\n    cudaMemcpy(h_force, d_force, num_atoms * sizeof(float3), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/force_out.bin\", h_force, size_force);\n\n    cudaFree(d_pos);\n    cudaFree(d_force);\n    delete[] h_pos;\n    delete[] h_force;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport numpy as np\nimport math\n\nnum_atoms = 4096\ncutsq = 100.0\nepsilon = 1.0\nsigma6 = 1.0\nbox_size = 64.0\n\nseed = 42\ntorch.manual_seed(seed)\n\ngrid_dim = int(math.ceil(num_atoms**(1/3)))\nspacing = box_size / grid_dim\n\nx = torch.linspace(0, box_size - spacing, grid_dim)\ny = torch.linspace(0, box_size - spacing, grid_dim)\nz = torch.linspace(0, box_size - spacing, grid_dim)\n\ngrid_x, grid_y, grid_z = torch.meshgrid(x, y, z, indexing='ij')\ngrid_pos = torch.stack([grid_x, grid_y, grid_z], dim=-1).reshape(-1, 3)\n\npos_xyz = grid_pos[:num_atoms]\n\nnoise = (torch.rand(num_atoms, 3) - 0.5) * (spacing * 0.2)\npos_xyz += noise\n\npos_w = torch.zeros(num_atoms, 1)\npos = torch.cat([pos_xyz, pos_w], dim=1).float()\n\nforce = torch.zeros(num_atoms, 3, dtype=torch.float32)\n\nchunk_size = 128\nall_pos_d = pos[:, :3].double()\n\nfor i in range(0, num_atoms, chunk_size):\n    end = min(i + chunk_size, num_atoms)\n    # [Chunk, 3]\n    pos_chunk = all_pos_d[i:end]\n    \n    # [Chunk, 1, 3] - [1, N, 3] -> [Chunk, N, 3]\n    diff = pos_chunk.unsqueeze(1) - all_pos_d.unsqueeze(0)\n    \n    rsq = torch.sum(diff**2, dim=2) # [Chunk, N]\n    \n    # Mask\n    mask = (rsq < cutsq) & (rsq > 1e-6)\n    \n    f_chunk = torch.zeros(end-i, 3, dtype=torch.double)\n    \n    if mask.any():\n        safe_rsq = torch.where(mask, rsq, torch.tensor(1.0, dtype=torch.double))\n        \n        r2inv = 1.0 / safe_rsq\n        r6inv = r2inv * r2inv * r2inv\n        f_factor = 24.0 * epsilon * r6inv * (2.0 * sigma6 * r6inv - 1.0) * r2inv\n        \n        forces = diff * f_factor.unsqueeze(2)\n        \n        forces = torch.where(mask.unsqueeze(2), forces, torch.tensor(0.0, dtype=torch.double))\n        \n        f_chunk = torch.sum(forces, dim=1)\n        \n    force[i:end] = f_chunk.float()\n\nmax_f_mag = torch.max(torch.norm(force, dim=1))\n# print(f\"Max Force Magnitude: {max_f_mag:.2f} (Should be < 10000)\")\n\nos.makedirs(\"data\", exist_ok=True)\npos.numpy().tofile(\"data/pos.bin\")\nforce.numpy().tofile(\"data/force_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\nNUM_ATOMS = 4096\n\ndef compare_outputs(output_file, ref_file, num_atoms, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Missing files.\")\n        return False\n    \n    # float3 * num_atoms = 3 * 4 bytes * num_atoms\n    expected_size = num_atoms * 3\n    \n    output = np.fromfile(output_file, dtype=np.float32)\n    reference = np.fromfile(ref_file, dtype=np.float32)\n    \n    if output.size != expected_size or reference.size != expected_size:\n        print(f\"Size mismatch! Expected {expected_size}, got {output.size} and {reference.size}\")\n        return False\n    \n    output = output.reshape(-1, 3)\n    reference = reference.reshape(-1, 3)\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    mean_diff = np.mean(diff)\n    \n    # print(f\"Max Diff: {max_diff:.6f}\")\n    # print(f\"Mean Diff: {mean_diff:.6f}\")\n    \n    if max_diff > tolerance:\n        idx = np.unravel_index(np.argmax(diff), diff.shape)[0]\n        # print(f\"Worst atom index: {idx}\")\n        # print(f\"CUDA: {output[idx]}\")\n        # print(f\"Ref : {reference[idx]}\")\n    \n    return max_diff < tolerance\n\nif __name__ == \"__main__\":\n    out_file = \"./data/force_out.bin\"\n    ref_file = \"./data/force_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, NUM_ATOMS, tolerance=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Implement the Lennard-Jones force computation kernel. The kernel should calculate the 3D force vectors for 4096 atoms based on pairwise interactions using the Lennard-Jones potential. Input is a float32 tensor of shape (4096, 4) where each row contains an atom's x, y, z coordinates and an unused fourth value. Output should be a float32 tensor of shape (4096, 3) containing the force vectors in x, y, z directions. Constraints: avoid self-interactions (i != j), only consider atom pairs within squared cutoff distance (cutsq = 100), and use Lennard-Jones parameters epsilon=1.0 and sigma6=1.0.", "level2_prompt": "Compute Lennard-Jones forces for 4096 atoms. For each atom i, calculate its force by summing contributions from all other atoms j (j ≠ i) within a squared cutoff distance. The force between i and j is proportional to (dx, dy, dz) × [24εr⁻⁶(2σ⁶r⁻⁶ - 1)r⁻²], where ε and σ⁶ are constants, r is distance between atoms, and (dx, dy, dz) is their displacement vector.", "level3_prompt": "Compute the Lennard-Jones kernel on GPU using CUDA."}
{"id": 488, "task_name": "Lennard_Jones", "task_description": "Compute the Lennard_Jones kernel on GPU using CUDA.", "inputs": [{"name": "pos", "dtype": "float32", "shape": "(8192, 4)"}], "outputs": [{"name": "force_out", "dtype": "float32", "shape": "(8192, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\n#define NUM_ATOMS 8192\n#define BLOCK_SIZE 256\n\n__global__ void compute_lj_force_kernel(\n    float4* pos, \n    float3* force, \n    int num_atoms,\n    float cutsq, \n    float epsilon, \n    float sigma6) {\n\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= num_atoms) return;\n\n    float3 f_i = {0.0f, 0.0f, 0.0f};\n    float4 pos_i = pos[i];\n\n    for (int j = 0; j < num_atoms; j++) {\n        if (i == j) continue;\n        float4 pos_j = pos[j];\n        float dx = pos_i.x - pos_j.x;\n        float dy = pos_i.y - pos_j.y;\n        float dz = pos_i.z - pos_j.z;\n        float rsq = dx*dx + dy*dy + dz*dz;\n\n        if (rsq < cutsq) {\n            float r2inv = 1.0f / rsq;\n            float r6inv = r2inv * r2inv * r2inv;\n            // Standard LJ Force: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1.0) * r2inv\n            float f_factor = 24.0f * epsilon * r6inv * (2.0f * sigma6 * r6inv - 1.0f) * r2inv;\n            \n            f_i.x += dx * f_factor;\n            f_i.y += dy * f_factor;\n            f_i.z += dz * f_factor;\n        }\n    }\n    force[i] = f_i;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int num_atoms = NUM_ATOMS;\n    float cutsq = 100.0f; \n    float epsilon = 1.0f;\n    float sigma6 = 1.0f; // sigma^6\n\n    size_t size_pos = num_atoms * 4;\n    size_t size_force = num_atoms * 3;\n\n    float *h_pos = new float[size_pos];\n    float *h_force = new float[size_force];\n\n    read_binary(\"./data/pos.bin\", h_pos, size_pos);\n\n    float4 *d_pos;\n    float3 *d_force;\n    cudaMalloc(&d_pos, num_atoms * sizeof(float4));\n    cudaMalloc(&d_force, num_atoms * sizeof(float3));\n\n    cudaMemcpy(d_pos, h_pos, num_atoms * sizeof(float4), cudaMemcpyHostToDevice);\n\n    int blocks = (num_atoms + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    compute_lj_force_kernel<<<blocks, BLOCK_SIZE>>>(d_pos, d_force, num_atoms, cutsq, epsilon, sigma6);\n\n    cudaMemcpy(h_force, d_force, num_atoms * sizeof(float3), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/force_out.bin\", h_force, size_force);\n\n    cudaFree(d_pos);\n    cudaFree(d_force);\n    delete[] h_pos;\n    delete[] h_force;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport numpy as np\nimport math\n\nnum_atoms = 8192\ncutsq = 100.0\nepsilon = 1.0\nsigma6 = 1.0\nbox_size = 64.0\n\nseed = 42\ntorch.manual_seed(seed)\n\ngrid_dim = int(math.ceil(num_atoms**(1/3)))\nspacing = box_size / grid_dim\n\nx = torch.linspace(0, box_size - spacing, grid_dim)\ny = torch.linspace(0, box_size - spacing, grid_dim)\nz = torch.linspace(0, box_size - spacing, grid_dim)\n\ngrid_x, grid_y, grid_z = torch.meshgrid(x, y, z, indexing='ij')\ngrid_pos = torch.stack([grid_x, grid_y, grid_z], dim=-1).reshape(-1, 3)\n\npos_xyz = grid_pos[:num_atoms]\n\nnoise = (torch.rand(num_atoms, 3) - 0.5) * (spacing * 0.2)\npos_xyz += noise\n\npos_w = torch.zeros(num_atoms, 1)\npos = torch.cat([pos_xyz, pos_w], dim=1).float()\n\nforce = torch.zeros(num_atoms, 3, dtype=torch.float32)\n\nchunk_size = 128\nall_pos_d = pos[:, :3].double()\n\nfor i in range(0, num_atoms, chunk_size):\n    end = min(i + chunk_size, num_atoms)\n    # [Chunk, 3]\n    pos_chunk = all_pos_d[i:end]\n    \n    # [Chunk, 1, 3] - [1, N, 3] -> [Chunk, N, 3]\n    diff = pos_chunk.unsqueeze(1) - all_pos_d.unsqueeze(0)\n    \n    rsq = torch.sum(diff**2, dim=2) # [Chunk, N]\n    \n    # Mask\n    mask = (rsq < cutsq) & (rsq > 1e-6)\n    \n    f_chunk = torch.zeros(end-i, 3, dtype=torch.double)\n    \n    if mask.any():\n        safe_rsq = torch.where(mask, rsq, torch.tensor(1.0, dtype=torch.double))\n        \n        r2inv = 1.0 / safe_rsq\n        r6inv = r2inv * r2inv * r2inv\n        f_factor = 24.0 * epsilon * r6inv * (2.0 * sigma6 * r6inv - 1.0) * r2inv\n        \n        forces = diff * f_factor.unsqueeze(2)\n        \n        forces = torch.where(mask.unsqueeze(2), forces, torch.tensor(0.0, dtype=torch.double))\n        \n        f_chunk = torch.sum(forces, dim=1)\n        \n    force[i:end] = f_chunk.float()\n\nmax_f_mag = torch.max(torch.norm(force, dim=1))\n# print(f\"Max Force Magnitude: {max_f_mag:.2f} (Should be < 10000)\")\n\nos.makedirs(\"data\", exist_ok=True)\npos.numpy().tofile(\"data/pos.bin\")\nforce.numpy().tofile(\"data/force_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\nNUM_ATOMS = 8192\n\ndef compare_outputs(output_file, ref_file, num_atoms, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Missing files.\")\n        return False\n    \n    # float3 * num_atoms = 3 * 4 bytes * num_atoms\n    expected_size = num_atoms * 3\n    \n    output = np.fromfile(output_file, dtype=np.float32)\n    reference = np.fromfile(ref_file, dtype=np.float32)\n    \n    if output.size != expected_size or reference.size != expected_size:\n        print(f\"Size mismatch! Expected {expected_size}, got {output.size} and {reference.size}\")\n        return False\n    \n    output = output.reshape(-1, 3)\n    reference = reference.reshape(-1, 3)\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    mean_diff = np.mean(diff)\n    \n    # print(f\"Max Diff: {max_diff:.6f}\")\n    # print(f\"Mean Diff: {mean_diff:.6f}\")\n    \n    if max_diff > tolerance:\n        idx = np.unravel_index(np.argmax(diff), diff.shape)[0]\n        # print(f\"Worst atom index: {idx}\")\n        # print(f\"CUDA: {output[idx]}\")\n        # print(f\"Ref : {reference[idx]}\")\n    \n    return max_diff < tolerance\n\nif __name__ == \"__main__\":\n    out_file = \"./data/force_out.bin\"\n    ref_file = \"./data/force_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, NUM_ATOMS, tolerance=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Compute the Lennard-Jones kernel for atomic force calculation. Given an input tensor 'pos' of shape (8192, 4) with float32 data type representing atom positions (x,y,z,w), calculate the net force vector on each atom. The output tensor 'force_out' must have shape (8192, 3) with float32 data type. For each atom i, sum forces from all other atoms j where squared distance is below cutoff. Force calculation uses the Lennard-Jones potential formula: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1) * r2inv, where r6inv = (1/rsq)^3 and rsq is squared distance between atoms. Exclude self-interactions (i=j) and interactions beyond cutoff distance.", "level2_prompt": "Implement Lennard-Jones force computation. For each atom i in a system of 8192 atoms, calculate net force by summing contributions from all other atoms j. The force contribution between atoms i and j is computed only when their squared distance is below a cutoff. The force magnitude follows the Lennard-Jones potential derivative: 24εr⁻⁶(2σ⁶r⁻⁶ - 1)r⁻², where r is the interatomic distance. Vector forces are accumulated in x, y, z components for each atom i.", "level3_prompt": "Compute the Lennard-Jones kernel on GPU using CUDA."}
{"id": 489, "task_name": "Lennard_Jones", "task_description": "Compute the Lennard_Jones kernel on GPU using CUDA.", "inputs": [{"name": "pos", "dtype": "float32", "shape": "(16384, 4)"}], "outputs": [{"name": "force_out", "dtype": "float32", "shape": "(16384, 3)"}], "gpu": "unknown", "bench.cu": "#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n\n#define NUM_ATOMS 16384\n#define BLOCK_SIZE 256\n\n__global__ void compute_lj_force_kernel(\n    float4* pos, \n    float3* force, \n    int num_atoms,\n    float cutsq, \n    float epsilon, \n    float sigma6) {\n\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    if (i >= num_atoms) return;\n\n    float3 f_i = {0.0f, 0.0f, 0.0f};\n    float4 pos_i = pos[i];\n\n    for (int j = 0; j < num_atoms; j++) {\n        if (i == j) continue;\n        float4 pos_j = pos[j];\n        float dx = pos_i.x - pos_j.x;\n        float dy = pos_i.y - pos_j.y;\n        float dz = pos_i.z - pos_j.z;\n        float rsq = dx*dx + dy*dy + dz*dz;\n\n        if (rsq < cutsq) {\n            float r2inv = 1.0f / rsq;\n            float r6inv = r2inv * r2inv * r2inv;\n            // Standard LJ Force: 24 * epsilon * r6inv * (2 * sigma6 * r6inv - 1.0) * r2inv\n            float f_factor = 24.0f * epsilon * r6inv * (2.0f * sigma6 * r6inv - 1.0f) * r2inv;\n            \n            f_i.x += dx * f_factor;\n            f_i.y += dy * f_factor;\n            f_i.z += dz * f_factor;\n        }\n    }\n    force[i] = f_i;\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    int num_atoms = NUM_ATOMS;\n    float cutsq = 100.0f; \n    float epsilon = 1.0f;\n    float sigma6 = 1.0f; // sigma^6\n\n    size_t size_pos = num_atoms * 4;\n    size_t size_force = num_atoms * 3;\n\n    float *h_pos = new float[size_pos];\n    float *h_force = new float[size_force];\n\n    read_binary(\"./data/pos.bin\", h_pos, size_pos);\n\n    float4 *d_pos;\n    float3 *d_force;\n    cudaMalloc(&d_pos, num_atoms * sizeof(float4));\n    cudaMalloc(&d_force, num_atoms * sizeof(float3));\n\n    cudaMemcpy(d_pos, h_pos, num_atoms * sizeof(float4), cudaMemcpyHostToDevice);\n\n    int blocks = (num_atoms + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    compute_lj_force_kernel<<<blocks, BLOCK_SIZE>>>(d_pos, d_force, num_atoms, cutsq, epsilon, sigma6);\n\n    cudaMemcpy(h_force, d_force, num_atoms * sizeof(float3), cudaMemcpyDeviceToHost);\n\n    write_binary(\"./data/force_out.bin\", h_force, size_force);\n\n    cudaFree(d_pos);\n    cudaFree(d_force);\n    delete[] h_pos;\n    delete[] h_force;\n\n    return 0;\n}", "gen.py": "import torch\nimport os\nimport numpy as np\nimport math\n\nnum_atoms = 16384\ncutsq = 100.0\nepsilon = 1.0\nsigma6 = 1.0\nbox_size = 64.0\n\nseed = 42\ntorch.manual_seed(seed)\n\ngrid_dim = int(math.ceil(num_atoms**(1/3)))\nspacing = box_size / grid_dim\n\nx = torch.linspace(0, box_size - spacing, grid_dim)\ny = torch.linspace(0, box_size - spacing, grid_dim)\nz = torch.linspace(0, box_size - spacing, grid_dim)\n\ngrid_x, grid_y, grid_z = torch.meshgrid(x, y, z, indexing='ij')\ngrid_pos = torch.stack([grid_x, grid_y, grid_z], dim=-1).reshape(-1, 3)\n\npos_xyz = grid_pos[:num_atoms]\n\nnoise = (torch.rand(num_atoms, 3) - 0.5) * (spacing * 0.2)\npos_xyz += noise\n\npos_w = torch.zeros(num_atoms, 1)\npos = torch.cat([pos_xyz, pos_w], dim=1).float()\n\nforce = torch.zeros(num_atoms, 3, dtype=torch.float32)\n\nchunk_size = 128\nall_pos_d = pos[:, :3].double()\n\nfor i in range(0, num_atoms, chunk_size):\n    end = min(i + chunk_size, num_atoms)\n    # [Chunk, 3]\n    pos_chunk = all_pos_d[i:end]\n    \n    # [Chunk, 1, 3] - [1, N, 3] -> [Chunk, N, 3]\n    diff = pos_chunk.unsqueeze(1) - all_pos_d.unsqueeze(0)\n    \n    rsq = torch.sum(diff**2, dim=2) # [Chunk, N]\n    \n    # Mask\n    mask = (rsq < cutsq) & (rsq > 1e-6)\n    \n    f_chunk = torch.zeros(end-i, 3, dtype=torch.double)\n    \n    if mask.any():\n        safe_rsq = torch.where(mask, rsq, torch.tensor(1.0, dtype=torch.double))\n        \n        r2inv = 1.0 / safe_rsq\n        r6inv = r2inv * r2inv * r2inv\n        f_factor = 24.0 * epsilon * r6inv * (2.0 * sigma6 * r6inv - 1.0) * r2inv\n        \n        forces = diff * f_factor.unsqueeze(2)\n        \n        forces = torch.where(mask.unsqueeze(2), forces, torch.tensor(0.0, dtype=torch.double))\n        \n        f_chunk = torch.sum(forces, dim=1)\n        \n    force[i:end] = f_chunk.float()\n\nmax_f_mag = torch.max(torch.norm(force, dim=1))\n# print(f\"Max Force Magnitude: {max_f_mag:.2f} (Should be < 10000)\")\n\nos.makedirs(\"data\", exist_ok=True)\npos.numpy().tofile(\"data/pos.bin\")\nforce.numpy().tofile(\"data/force_ref.bin\")", "compare.py": "import numpy as np\nimport os\n\nNUM_ATOMS = 16384\n\ndef compare_outputs(output_file, ref_file, num_atoms, tolerance=1e-2):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        print(\"Missing files.\")\n        return False\n    \n    # float3 * num_atoms = 3 * 4 bytes * num_atoms\n    expected_size = num_atoms * 3\n    \n    output = np.fromfile(output_file, dtype=np.float32)\n    reference = np.fromfile(ref_file, dtype=np.float32)\n    \n    if output.size != expected_size or reference.size != expected_size:\n        print(f\"Size mismatch! Expected {expected_size}, got {output.size} and {reference.size}\")\n        return False\n    \n    output = output.reshape(-1, 3)\n    reference = reference.reshape(-1, 3)\n    \n    diff = np.abs(output - reference)\n    max_diff = np.max(diff)\n    mean_diff = np.mean(diff)\n    \n    # print(f\"Max Diff: {max_diff:.6f}\")\n    # print(f\"Mean Diff: {mean_diff:.6f}\")\n    \n    if max_diff > tolerance:\n        idx = np.unravel_index(np.argmax(diff), diff.shape)[0]\n        # print(f\"Worst atom index: {idx}\")\n        # print(f\"CUDA: {output[idx]}\")\n        # print(f\"Ref : {reference[idx]}\")\n    \n    return max_diff < tolerance\n\nif __name__ == \"__main__\":\n    out_file = \"./data/force_out.bin\"\n    ref_file = \"./data/force_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, NUM_ATOMS, tolerance=1e-2):\n        print(\"T\")\n    else:\n        print(\"F\")", "level1_prompt": "Task: Lennard_Jones. Compute the total force on each atom in a system of 16384 atoms using the Lennard-Jones potential. The input is a tensor 'pos' of shape (16384, 4) and dtype float32, where the first three elements of each row are x, y, z coordinates and the fourth element is unused. The output is a tensor 'force_out' of shape (16384, 3) and dtype float32, representing the force vector (x, y, z components) on each atom. Constraints: Force is computed only for atom pairs with squared distance less than 100.0. The force calculation uses parameters epsilon=1.0 and sigma6=1.0 (sigma^6). Each atom's force is the vector sum of contributions from all other atoms within the cutoff distance.", "level2_prompt": "Task: Lennard_Jones. For each atom i, initialize a force vector to zero. For every other atom j, compute the squared distance between i and j. If the squared distance is below 100.0, calculate the Lennard-Jones force contribution: 24 * epsilon * (r6inv) * (2 * sigma6 * r6inv - 1) * (r2inv) * (r_vec), where r_vec is the distance vector between atoms, r2inv is 1/squared_distance, and r6inv is (r2inv)^3. Accumulate these force contributions for each atom i.", "level3_prompt": "Compute the Lennard_Jones kernel on GPU using CUDA."}
{"id": 490, "task_name": "Reverse_Array", "task_description": "Compute the Reverse_Array kernel on GPU using CUDA.", "inputs": [{"name": "reverse_input", "dtype": "float32", "shape": "(1048576,)"}], "outputs": [{"name": "reverse_out", "dtype": "float32", "shape": "(1048576,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 20;\n\n__global__ void reverse_array_kernel(float* data, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int opp_idx = n - 1 - idx;\n    if (idx < n / 2) {\n        float tmp = data[idx];\n        data[idx] = data[opp_idx];\n        data[opp_idx] = tmp;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    std::string input_file = \"data/reverse_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N / 2 + threads - 1) / threads;\n    reverse_array_kernel<<<blocks, threads>>>(d_data, N);\n\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/reverse_out.bin\";\n    write_binary(out_file, h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 20\n\nx = (np.random.rand(N) * 100 - 50).astype(np.float32)\ny = x[::-1].copy()\n\nx.tofile(\"data/reverse_input.bin\")\ny.tofile(\"data/reverse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 20\n    out_file = \"data/reverse_out.bin\"\n    ref_file = \"data/reverse_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement a CUDA kernel named 'Reverse_Array' that reverses the order of elements in a one-dimensional array. The input is a single tensor called 'reverse_input' of dtype float32 with shape (1048576,). The output must be a tensor called 'reverse_out' of dtype float32 with the same shape (1048576,). The kernel must produce an output where each element at position i is the element from the input at position (n-1-i), where n is the array length. The kernel must efficiently handle the entire array length without data loss or corruption.", "level2_prompt": "Create a CUDA kernel to reverse a one-dimensional array. For an input array of length n, the output array should have its first element equal to the last element of the input, its second element equal to the second-to-last element of the input, and so forth, such that output[i] = input[n-1-i] for all valid indices i.", "level3_prompt": "Compute the Reverse_Array kernel on GPU using CUDA."}
{"id": 491, "task_name": "Reverse_Array", "task_description": "Compute the Reverse_Array kernel on GPU using CUDA.", "inputs": [{"name": "reverse_input", "dtype": "float32", "shape": "(4194304,)"}], "outputs": [{"name": "reverse_out", "dtype": "float32", "shape": "(4194304,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 22;\n\n__global__ void reverse_array_kernel(float* data, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int opp_idx = n - 1 - idx;\n    if (idx < n / 2) {\n        float tmp = data[idx];\n        data[idx] = data[opp_idx];\n        data[opp_idx] = tmp;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    std::string input_file = \"data/reverse_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N / 2 + threads - 1) / threads;\n    reverse_array_kernel<<<blocks, threads>>>(d_data, N);\n\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/reverse_out.bin\";\n    write_binary(out_file, h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 22\n\nx = (np.random.rand(N) * 100 - 50).astype(np.float32)\ny = x[::-1].copy()\n\nx.tofile(\"data/reverse_input.bin\")\ny.tofile(\"data/reverse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 22\n    out_file = \"data/reverse_out.bin\"\n    ref_file = \"data/reverse_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Implement the Reverse_Array kernel to reverse the order of elements in a 1D array. The input is a tensor named 'reverse_input' with shape (4194304,) and dtype float32. The output should be a tensor named 'reverse_out' with identical shape and dtype, containing elements in reversed order. The kernel must only swap elements symmetrically around the midpoint without modifying indices beyond the first half of the array.", "level2_prompt": "Reverse the elements of a float32 array with length 4194304. For each index i in the first half of the array, swap the element at position i with the element at position (n-1-i), where n is the array length.", "level3_prompt": "Compute the reverse of an input array."}
{"id": 492, "task_name": "Reverse_Array", "task_description": "Compute the Reverse_Array kernel on GPU using CUDA.", "inputs": [{"name": "reverse_input", "dtype": "float32", "shape": "(16777216,)"}], "outputs": [{"name": "reverse_out", "dtype": "float32", "shape": "(16777216,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 24;\n\n__global__ void reverse_array_kernel(float* data, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int opp_idx = n - 1 - idx;\n    if (idx < n / 2) {\n        float tmp = data[idx];\n        data[idx] = data[opp_idx];\n        data[opp_idx] = tmp;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    std::string input_file = \"data/reverse_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N / 2 + threads - 1) / threads;\n    reverse_array_kernel<<<blocks, threads>>>(d_data, N);\n\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/reverse_out.bin\";\n    write_binary(out_file, h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 24\n\nx = (np.random.rand(N) * 100 - 50).astype(np.float32)\ny = x[::-1].copy()\n\nx.tofile(\"data/reverse_input.bin\")\ny.tofile(\"data/reverse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 24\n    out_file = \"data/reverse_out.bin\"\n    ref_file = \"data/reverse_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reverse_Array. Reverse the order of elements in a one-dimensional array of 16777216 floating-point numbers (float32). The kernel must swap each element at index i with the element at index N-1-i for all i in the range [0, N/2), where N is the array length. Since N is even, the entire array is reversed without leaving any middle element. The output must be an array of the same shape and data type as the input.", "level2_prompt": "Task: Reverse_Array. For an array of N elements, reverse the order by swapping each element at position i (where 0 ≤ i < N/2) with the element at position N-1-i.", "level3_prompt": "Reverse an array of floating-point numbers."}
{"id": 493, "task_name": "Reverse_Array", "task_description": "Compute the Reverse_Array kernel on GPU using CUDA.", "inputs": [{"name": "reverse_input", "dtype": "float32", "shape": "(67108864,)"}], "outputs": [{"name": "reverse_out", "dtype": "float32", "shape": "(67108864,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 26;\n\n__global__ void reverse_array_kernel(float* data, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int opp_idx = n - 1 - idx;\n    if (idx < n / 2) {\n        float tmp = data[idx];\n        data[idx] = data[opp_idx];\n        data[opp_idx] = tmp;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    std::string input_file = \"data/reverse_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N / 2 + threads - 1) / threads;\n    reverse_array_kernel<<<blocks, threads>>>(d_data, N);\n\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/reverse_out.bin\";\n    write_binary(out_file, h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 26\n\nx = (np.random.rand(N) * 100 - 50).astype(np.float32)\ny = x[::-1].copy()\n\nx.tofile(\"data/reverse_input.bin\")\ny.tofile(\"data/reverse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 26\n    out_file = \"data/reverse_out.bin\"\n    ref_file = \"data/reverse_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reverse_Array. Reverse the order of elements in a one-dimensional float32 array of size 67108864. The input array 'reverse_input' contains 67108864 float32 values. The output array 'reverse_out' must have the same shape and data type, where each element at position i is the element from the input array at position (67108863 - i). The kernel must correctly reverse the entire array, ensuring the output exactly matches the reversed input without modifying the original input array.", "level2_prompt": "Task: Reverse_Array. For an input array of n float32 elements, produce an output array where the element at index i is the element from the input at index (n - 1 - i). The array size n is fixed at 67108864.", "level3_prompt": "Reverse an array of float32 values."}
{"id": 494, "task_name": "Reverse_Array", "task_description": "Compute the Reverse_Array kernel on GPU using CUDA.", "inputs": [{"name": "reverse_input", "dtype": "float32", "shape": "(268435456,)"}], "outputs": [{"name": "reverse_out", "dtype": "float32", "shape": "(268435456,)"}], "gpu": "unknown", "bench.cu": "#include <iostream>\n#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include <fstream>\n#include <string>\n\nconst size_t N = 1 << 28;\n\n__global__ void reverse_array_kernel(float* data, int n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int opp_idx = n - 1 - idx;\n    if (idx < n / 2) {\n        float tmp = data[idx];\n        data[idx] = data[opp_idx];\n        data[opp_idx] = tmp;\n    }\n}\n\nvoid read_binary(const std::string& filename, float* data, size_t size) {\n    std::ifstream in(filename, std::ios::binary);\n    if (!in) {\n        std::cerr << \"Can not open: \" << filename << std::endl;\n        exit(1);\n    }\n    in.read(reinterpret_cast<char*>(data), size * sizeof(float));\n    in.close();\n}\n\nvoid write_binary(const std::string& filename, const float* data, size_t size) {\n    std::ofstream out(filename, std::ios::binary);\n    if (!out) {\n        std::cerr << \"Can not write: \" << filename << std::endl;\n        exit(1);\n    }\n    out.write(reinterpret_cast<const char*>(data), size * sizeof(float));\n    out.close();\n}\n\nint main() {\n    size_t bytes = N * sizeof(float);\n\n    float* h_input = (float*)malloc(bytes);\n\n    std::string input_file = \"data/reverse_input.bin\";\n    read_binary(input_file, h_input, N);\n\n    float* d_data;\n    cudaMalloc(&d_data, bytes);\n    cudaMemcpy(d_data, h_input, bytes, cudaMemcpyHostToDevice);\n\n    int threads = 256;\n    int blocks = (N / 2 + threads - 1) / threads;\n    reverse_array_kernel<<<blocks, threads>>>(d_data, N);\n\n    cudaMemcpy(h_input, d_data, bytes, cudaMemcpyDeviceToHost);\n\n    std::string out_file = \"data/reverse_out.bin\";\n    write_binary(out_file, h_input, N);\n\n    cudaFree(d_data);\n    free(h_input);\n\n    return 0;\n}\n", "gen.py": "import numpy as np\nimport os\n\nos.makedirs(\"data\", exist_ok=True)\nnp.random.seed(42)\n\nN = 1 << 28\n\nx = (np.random.rand(N) * 100 - 50).astype(np.float32)\ny = x[::-1].copy()\n\nx.tofile(\"data/reverse_input.bin\")\ny.tofile(\"data/reverse_ref.bin\")\n", "compare.py": "import numpy as np\nimport os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef compare_outputs(output_file, ref_file, size, tolerance=1e-5):\n    if not os.path.exists(output_file) or not os.path.exists(ref_file):\n        return False\n    output = read_binary(output_file, size)\n    reference = read_binary(ref_file, size)\n    if output.shape != reference.shape:\n        return False\n    return np.allclose(output, reference, atol=tolerance)\n\nif __name__ == \"__main__\":\n    N = 1 << 28\n    out_file = \"data/reverse_out.bin\"\n    ref_file = \"data/reverse_ref.bin\"\n\n    if compare_outputs(out_file, ref_file, N):\n        print(\"T\")\n    else:\n        print(\"F\")\n", "level1_prompt": "Task: Reverse_Array. Reverse the input array of 268435456 float32 values by swapping each element at index i with the element at index (n-1-i) for all i from 0 to n/2 - 1, where n is the array length. The input is a one-dimensional tensor of float32 values, and the output must be a one-dimensional tensor of the same shape and type containing the reversed elements. The kernel must only perform swaps in the first half of the array to avoid redundant operations and ensure correctness for even lengths.", "level2_prompt": "Task: Reverse_Array. For an array of length n, produce an output array where each element at position i is swapped with the element at position n-1-i for i ranging from 0 to floor((n-1)/2). This results in a completely reversed array.", "level3_prompt": "Reverse the input array."}
{"id": 495, "task_name": "Max_Pooling_2D", "task_description": "Compute the Max_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "maxpool2d_X", "dtype": "float32", "shape": "(16, 64, 128, 128)"}], "outputs": [{"name": "maxpool2d_Y_out", "dtype": "float32", "shape": "(16, 64, 64, 64)"}], "gpu": "unknown", "bench.cu": "\n#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <float.h>\n#define N 16\n#define C 64\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n\n__global__ void maxpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float m = -FLT_MAX;\n    #pragma unroll\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        float v = xptr[h*W + w];\n        m = v > m ? v : m;\n    }\n    Y[idx] = m;\n}\n\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\n\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\n\nint main()\n{\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/maxpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    maxpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/maxpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\n\ntorch.manual_seed(4001)\n\nN,C,H,W=16,64,128,128\n\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.max_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/maxpool2d_X.bin\")\nY.numpy().tofile(\"./data/maxpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\n\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\n\ndef main():\n    size = 16*64*64*64\n    if not (os.path.exists(\"./data/maxpool2d_Y_out.bin\") and os.path.exists(\"./data/maxpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/maxpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/maxpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\n\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task: Max_Pooling_2D. Implement a CUDA kernel for 2D max pooling. Input is a 4D tensor 'maxpool2d_X' with shape (16, 64, 128, 128) and float32 dtype. Output is a 4D tensor 'maxpool2d_Y_out' with shape (16, 64, 64, 64) and float32 dtype. Use a 2x2 pooling window with stride 2, no padding, and floor-based output dimension calculation. Compute maximum values within each non-overlapping window across height and width dimensions.", "level2_prompt": "Task: Max_Pooling_2D. Perform 2D max pooling on a 4D input tensor of shape (16, 64, 128, 128). Reduce each 2x2 window with stride 2 to its maximum value, producing an output tensor of shape (16, 64, 64, 64). The pooling operation slides over height and width dimensions without overlapping or padding.", "level3_prompt": "Compute the Max_Pooling_2D kernel on GPU using CUDA."}
{"id": 496, "task_name": "Max_Pooling_2D", "task_description": "Compute the Max_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "maxpool2d_X", "dtype": "float32", "shape": "(16, 96, 128, 128)"}], "outputs": [{"name": "maxpool2d_Y_out", "dtype": "float32", "shape": "(16, 96, 64, 64)"}], "gpu": "unknown", "bench.cu": "\n#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <float.h>\n#define N 16\n#define C 96\n#define H 128\n#define W 128\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n__global__ void maxpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float m = -FLT_MAX;\n    #pragma unroll\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        float v = xptr[h*W + w];\n        m = v > m ? v : m;\n    }\n    Y[idx] = m;\n}\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/maxpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    maxpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/maxpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\ntorch.manual_seed(4002)\nN,C,H,W=16,96,128,128\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.max_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/maxpool2d_X.bin\")\nY.numpy().tofile(\"./data/maxpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\ndef main():\n    size = 16*96*64*64\n    if not (os.path.exists(\"./data/maxpool2d_Y_out.bin\") and os.path.exists(\"./data/maxpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/maxpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/maxpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Max_Pooling_2D task: Implement a CUDA kernel that performs 2D max pooling on a 4D input tensor with shape (16, 96, 128, 128) and dtype float32. The kernel must slide a 2x2 window over the input tensor with stride 2, computing the maximum value in each window without padding. The output tensor must have shape (16, 96, 64, 64) and dtype float32. The kernel must preserve batch and channel dimensions while reducing spatial dimensions by half.", "level2_prompt": "Max_Pooling_2D task: For each non-overlapping 2x2 window in the spatial dimensions of a 4D input tensor, compute the maximum value across all elements in the window. The operation should maintain the batch and channel dimensions while halving both spatial dimensions through strided window traversal.", "level3_prompt": "Compute the Max_Pooling_2D kernel on GPU using CUDA."}
{"id": 497, "task_name": "Max_Pooling_2D", "task_description": "Compute the Max_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "maxpool2d_X", "dtype": "float32", "shape": "(32, 64, 192, 192)"}], "outputs": [{"name": "maxpool2d_Y_out", "dtype": "float32", "shape": "(32, 64, 96, 96)"}], "gpu": "unknown", "bench.cu": "\n#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <float.h>\n#define N 32\n#define C 64\n#define H 192\n#define W 192\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n__global__ void maxpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float m = -FLT_MAX;\n    #pragma unroll\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        float v = xptr[h*W + w];\n        m = v > m ? v : m;\n    }\n    Y[idx] = m;\n}\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/maxpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    maxpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/maxpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\ntorch.manual_seed(4003)\nN,C,H,W=32,64,192,192\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.max_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/maxpool2d_X.bin\")\nY.numpy().tofile(\"./data/maxpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\ndef main():\n    size = 32*64*96*96\n    if not (os.path.exists(\"./data/maxpool2d_Y_out.bin\") and os.path.exists(\"./data/maxpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/maxpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/maxpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task: Max_Pooling_2D. Implement a CUDA kernel that performs 2D max pooling on a 4D input tensor of shape (32, 64, 192, 192) with float32 values. The kernel must use a 2x2 pooling window with stride 2, no padding, and no ceil mode. The output tensor should have shape (32, 64, 96, 96) and dtype float32. For each output position, compute the maximum value within the corresponding 2x2 input window. The kernel must handle batch and channel dimensions correctly.", "level2_prompt": "Task: Max_Pooling_2D. Implement a CUDA kernel that reduces spatial dimensions of a 4D float32 tensor from (192, 192) to (96, 96) using max pooling. For each 2x2 non-overlapping window in the input (stride 2), output the maximum value while preserving batch and channel dimensions.", "level3_prompt": "Compute the Max_Pooling_2D kernel on GPU using CUDA."}
{"id": 498, "task_name": "Max_Pooling_2D", "task_description": "Compute the Max_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "maxpool2d_X", "dtype": "float32", "shape": "(32, 96, 192, 192)"}], "outputs": [{"name": "maxpool2d_Y_out", "dtype": "float32", "shape": "(32, 96, 96, 96)"}], "gpu": "unknown", "bench.cu": "\n#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <float.h>\n#define N 32\n#define C 96\n#define H 192\n#define W 192\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n__global__ void maxpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float m = -FLT_MAX;\n    #pragma unroll\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        float v = xptr[h*W + w];\n        m = v > m ? v : m;\n    }\n    Y[idx] = m;\n}\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/maxpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    maxpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/maxpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\ntorch.manual_seed(4004)\nN,C,H,W=32,96,192,192\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.max_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/maxpool2d_X.bin\")\nY.numpy().tofile(\"./data/maxpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\ndef main():\n    size = 32*96*96*96\n    if not (os.path.exists(\"./data/maxpool2d_Y_out.bin\") and os.path.exists(\"./data/maxpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/maxpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/maxpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task: Max_Pooling_2D. Implement a CUDA kernel that performs 2D max pooling. The input tensor 'maxpool2d_X' has shape (32, 96, 192, 192) and dtype float32. The output tensor 'maxpool2d_Y_out' must have shape (32, 96, 96, 96) and dtype float32. Use a pooling window of size 2x2 with stride 2 and no padding. Each thread should compute one output element by finding the maximum value in the corresponding 2x2 input region. The input tensor is arranged in batch, channel, height, width order.", "level2_prompt": "Task: Max_Pooling_2D. Perform 2D max pooling using a 2x2 window and stride 2. For each output element, compute the maximum value from the corresponding 2x2 region in the input tensor. The input has dimensions [batch, channels, height, width], and the output maintains batch and channel dimensions while reducing spatial dimensions by half.", "level3_prompt": "Compute the Max_Pooling_2D kernel on GPU using CUDA."}
{"id": 499, "task_name": "Max_Pooling_2D", "task_description": "Compute the Max_Pooling_2D kernel on GPU using CUDA.", "inputs": [{"name": "maxpool2d_X", "dtype": "float32", "shape": "(32, 128, 256, 256)"}], "outputs": [{"name": "maxpool2d_Y_out", "dtype": "float32", "shape": "(32, 128, 128, 128)"}], "gpu": "unknown", "bench.cu": "\n#include <cuda_runtime.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <float.h>\n#define N 32\n#define C 128\n#define H 256\n#define W 256\n#define K 2\n#define S 2\n#define HO ((H - K)/S + 1)\n#define WO ((W - K)/S + 1)\n__global__ void maxpool2d_kernel(const float* X, float* Y){\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int total = N*C*HO*WO; if(idx >= total) return;\n    int wo = idx % WO;\n    int ho = (idx / WO) % HO;\n    int c  = (idx / (WO*HO)) % C;\n    int n  = (idx / (WO*HO*C));\n    int hstart = ho * S, wstart = wo * S;\n    const float* xptr = X + ((n*C + c)*H)*W;\n    float m = -FLT_MAX;\n    #pragma unroll\n    for(int kh=0; kh<K; ++kh) for(int kw=0; kw<K; ++kw){\n        int h = hstart + kh; int w = wstart + kw;\n        float v = xptr[h*W + w];\n        m = v > m ? v : m;\n    }\n    Y[idx] = m;\n}\nstatic void read_binary(const std::string& filename, float* data, size_t size){\n    std::ifstream in(filename, std::ios::binary);\n    if(!in){ std::cerr << \"Can not open: \" << filename << std::endl; exit(1); }\n    in.read(reinterpret_cast<char*>(data), size*sizeof(float));\n}\nstatic void write_binary(const std::string& filename, const float* data, size_t size){\n    std::ofstream out(filename, std::ios::binary);\n    if(!out){ std::cerr << \"Can not write: \" << filename << std::endl; exit(1); }\n    out.write(reinterpret_cast<const char*>(data), size*sizeof(float));\n}\nint main(){\n    const size_t size_in=(size_t)N*C*H*W;\n    const size_t size_out=(size_t)N*C*HO*WO;\n    float *hX=new float[size_in], *hY=new float[size_out];\n    read_binary(\"./data/maxpool2d_X.bin\", hX, size_in);\n    float *dX,*dY; cudaMalloc(&dX,size_in*sizeof(float)); cudaMalloc(&dY,size_out*sizeof(float));\n    cudaMemcpy(dX,hX,size_in*sizeof(float),cudaMemcpyHostToDevice);\n    int threads=256, blocks=(int)((size_out+threads-1)/threads);\n    maxpool2d_kernel<<<blocks,threads>>>(dX,dY);\n    cudaMemcpy(hY,dY,size_out*sizeof(float),cudaMemcpyDeviceToHost);\n    write_binary(\"./data/maxpool2d_Y_out.bin\", hY, size_out);\n    cudaFree(dX); cudaFree(dY); delete[] hX; delete[] hY; return 0;\n}\n", "gen.py": "import torch, os\ntorch.manual_seed(4005)\nN,C,H,W=32,128,256,256\nX=torch.randn(N,C,H,W,dtype=torch.float32)\nY=torch.nn.functional.max_pool2d(X,kernel_size=2,stride=2,padding=0,ceil_mode=False)\nos.makedirs(\"./data\",exist_ok=True)\nX.numpy().tofile(\"./data/maxpool2d_X.bin\")\nY.numpy().tofile(\"./data/maxpool2d_Y_ref.bin\")\n", "compare.py": "import numpy as np, os\ndef read_binary(filename, size):\n    return np.fromfile(filename, dtype=np.float32, count=size)\ndef main():\n    size = 32*128*128*128\n    if not (os.path.exists(\"./data/maxpool2d_Y_out.bin\") and os.path.exists(\"./data/maxpool2d_Y_ref.bin\")):\n        print(\"F\"); return\n    out = read_binary(\"./data/maxpool2d_Y_out.bin\", size)\n    ref = read_binary(\"./data/maxpool2d_Y_ref.bin\", size)\n    print(\"T\" if np.allclose(out, ref, atol=1e-5) else \"F\")\nif __name__ == \"__main__\":\n    main()\n", "level1_prompt": "Task: Max_Pooling_2D. Compute a 2D max pooling operation on a 4D input tensor of shape (32, 128, 256, 256) with float32 data type. Apply a 2x2 kernel with stride 2 and no padding. For each 2x2 window, select the maximum value. The output tensor must be of shape (32, 128, 128, 128) with float32 data type. The operation must independently process each batch and channel without overlapping windows.", "level2_prompt": "Task: Max_Pooling_2D. Perform max pooling on a 4D tensor (batch, channels, height, width). Slide a 2x2 window across height and width dimensions with stride 2, selecting the maximum value in each window. The spatial dimensions reduce from 256x256 to 128x128 while preserving batch and channel counts.", "level3_prompt": "Compute the Max_Pooling_2D kernel on GPU using CUDA."}
